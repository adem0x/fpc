unit pic32mx430f064h;
interface
{$goto on}
{$modeswitch advancedrecords}
{$INLINE ON}
{$OPTIMIZATION STACKFRAME}
{$L startup.o}
{$PACKRECORDS 2}
type
  TBits_1 = 0..1;
  TBits_2 = 0..3;
  TBits_3 = 0..7;
  TBits_4 = 0..15;
  TBits_5 = 0..31;
  TBits_6 = 0..63;
  TBits_7 = 0..127;
  TBits_8 = 0..255;
  TBits_9 = 0..511;
  TBits_10 = 0..1023;
  TBits_11 = 0..2047;
  TBits_12 = 0..4095;
  TBits_13 = 0..8191;
  TBits_14 = 0..16383;
  TBits_15 = 0..32767;
  TBits_16 = 0..65535;
  TBits_17 = 0..131071;
  TBits_18 = 0..262143;
  TBits_19 = 0..524287;
  TBits_20 = 0..1048575;
  TBits_21 = 0..2097151;
  TBits_22 = 0..4194303;
  TBits_23 = 0..8388607;
  TBits_24 = 0..16777215;
  TBits_25 = 0..33554431;
  TBits_26 = 0..67108863;
  TBits_27 = 0..134217727;
  TBits_28 = 0..268435455;
  TBits_29 = 0..536870911;
  TBits_30 = 0..1073741823;
  TBits_31 = 0..2147483647;
  TBits_32 = 0..4294967295;
  TWDT_WDTCON = record
  private
    function  getON : TBits_1; inline;
    function  getSWDTPS : TBits_5; inline;
    function  getSWDTPS0 : TBits_1; inline;
    function  getSWDTPS1 : TBits_1; inline;
    function  getSWDTPS2 : TBits_1; inline;
    function  getSWDTPS3 : TBits_1; inline;
    function  getSWDTPS4 : TBits_1; inline;
    function  getWDTCLR : TBits_1; inline;
    function  getWDTPS : TBits_5; inline;
    function  getWDTPSTA : TBits_5; inline;
    function  getWDTWINEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSWDTPS(thebits : TBits_5); inline;
    procedure setSWDTPS0(thebits : TBits_1); inline;
    procedure setSWDTPS1(thebits : TBits_1); inline;
    procedure setSWDTPS2(thebits : TBits_1); inline;
    procedure setSWDTPS3(thebits : TBits_1); inline;
    procedure setSWDTPS4(thebits : TBits_1); inline;
    procedure setWDTCLR(thebits : TBits_1); inline;
    procedure setWDTPS(thebits : TBits_5); inline;
    procedure setWDTPSTA(thebits : TBits_5); inline;
    procedure setWDTWINEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSWDTPS0; inline;
    procedure clearSWDTPS1; inline;
    procedure clearSWDTPS2; inline;
    procedure clearSWDTPS3; inline;
    procedure clearSWDTPS4; inline;
    procedure clearWDTCLR; inline;
    procedure clearWDTWINEN; inline;
    procedure setON; inline;
    procedure setSWDTPS0; inline;
    procedure setSWDTPS1; inline;
    procedure setSWDTPS2; inline;
    procedure setSWDTPS3; inline;
    procedure setSWDTPS4; inline;
    procedure setWDTCLR; inline;
    procedure setWDTWINEN; inline;
    property ON : TBits_1 read getON write setON;
    property SWDTPS : TBits_5 read getSWDTPS write setSWDTPS;
    property SWDTPS0 : TBits_1 read getSWDTPS0 write setSWDTPS0;
    property SWDTPS1 : TBits_1 read getSWDTPS1 write setSWDTPS1;
    property SWDTPS2 : TBits_1 read getSWDTPS2 write setSWDTPS2;
    property SWDTPS3 : TBits_1 read getSWDTPS3 write setSWDTPS3;
    property SWDTPS4 : TBits_1 read getSWDTPS4 write setSWDTPS4;
    property WDTCLR : TBits_1 read getWDTCLR write setWDTCLR;
    property WDTPS : TBits_5 read getWDTPS write setWDTPS;
    property WDTPSTA : TBits_5 read getWDTPSTA write setWDTPSTA;
    property WDTWINEN : TBits_1 read getWDTWINEN write setWDTWINEN;
    property w : TBits_32 read getw write setw;
  end;
type
  TWDTRegisters = record
    WDTCONbits : TWDT_WDTCON;
    WDTCON : longWord;
    WDTCONCLR : longWord;
    WDTCONSET : longWord;
    WDTCONINV : longWord;
  end;
  TRTCC_RTCCON = record
  private
    function  getCAL : TBits_10; inline;
    function  getHALFSEC : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getRTCCLKON : TBits_1; inline;
    function  getRTCOE : TBits_1; inline;
    function  getRTCSYNC : TBits_1; inline;
    function  getRTCWREN : TBits_1; inline;
    function  getRTSECSEL : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCAL(thebits : TBits_10); inline;
    procedure setHALFSEC(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setRTCCLKON(thebits : TBits_1); inline;
    procedure setRTCOE(thebits : TBits_1); inline;
    procedure setRTCSYNC(thebits : TBits_1); inline;
    procedure setRTCWREN(thebits : TBits_1); inline;
    procedure setRTSECSEL(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearHALFSEC; inline;
    procedure clearON; inline;
    procedure clearRTCCLKON; inline;
    procedure clearRTCOE; inline;
    procedure clearRTCSYNC; inline;
    procedure clearRTCWREN; inline;
    procedure clearRTSECSEL; inline;
    procedure clearSIDL; inline;
    procedure setHALFSEC; inline;
    procedure setON; inline;
    procedure setRTCCLKON; inline;
    procedure setRTCOE; inline;
    procedure setRTCSYNC; inline;
    procedure setRTCWREN; inline;
    procedure setRTSECSEL; inline;
    procedure setSIDL; inline;
    property CAL : TBits_10 read getCAL write setCAL;
    property HALFSEC : TBits_1 read getHALFSEC write setHALFSEC;
    property ON : TBits_1 read getON write setON;
    property RTCCLKON : TBits_1 read getRTCCLKON write setRTCCLKON;
    property RTCOE : TBits_1 read getRTCOE write setRTCOE;
    property RTCSYNC : TBits_1 read getRTCSYNC write setRTCSYNC;
    property RTCWREN : TBits_1 read getRTCWREN write setRTCWREN;
    property RTSECSEL : TBits_1 read getRTSECSEL write setRTSECSEL;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_RTCALRM = record
  private
    function  getALRMEN : TBits_1; inline;
    function  getALRMSYNC : TBits_1; inline;
    function  getAMASK : TBits_4; inline;
    function  getARPT : TBits_8; inline;
    function  getCHIME : TBits_1; inline;
    function  getPIV : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setALRMEN(thebits : TBits_1); inline;
    procedure setALRMSYNC(thebits : TBits_1); inline;
    procedure setAMASK(thebits : TBits_4); inline;
    procedure setARPT(thebits : TBits_8); inline;
    procedure setCHIME(thebits : TBits_1); inline;
    procedure setPIV(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearALRMEN; inline;
    procedure clearALRMSYNC; inline;
    procedure clearCHIME; inline;
    procedure clearPIV; inline;
    procedure setALRMEN; inline;
    procedure setALRMSYNC; inline;
    procedure setCHIME; inline;
    procedure setPIV; inline;
    property ALRMEN : TBits_1 read getALRMEN write setALRMEN;
    property ALRMSYNC : TBits_1 read getALRMSYNC write setALRMSYNC;
    property AMASK : TBits_4 read getAMASK write setAMASK;
    property ARPT : TBits_8 read getARPT write setARPT;
    property CHIME : TBits_1 read getCHIME write setCHIME;
    property PIV : TBits_1 read getPIV write setPIV;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_RTCTIME = record
  private
    function  getHR01 : TBits_4; inline;
    function  getHR10 : TBits_4; inline;
    function  getMIN01 : TBits_4; inline;
    function  getMIN10 : TBits_4; inline;
    function  getSEC01 : TBits_4; inline;
    function  getSEC10 : TBits_4; inline;
    function  getw : TBits_32; inline;
    procedure setHR01(thebits : TBits_4); inline;
    procedure setHR10(thebits : TBits_4); inline;
    procedure setMIN01(thebits : TBits_4); inline;
    procedure setMIN10(thebits : TBits_4); inline;
    procedure setSEC01(thebits : TBits_4); inline;
    procedure setSEC10(thebits : TBits_4); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property HR01 : TBits_4 read getHR01 write setHR01;
    property HR10 : TBits_4 read getHR10 write setHR10;
    property MIN01 : TBits_4 read getMIN01 write setMIN01;
    property MIN10 : TBits_4 read getMIN10 write setMIN10;
    property SEC01 : TBits_4 read getSEC01 write setSEC01;
    property SEC10 : TBits_4 read getSEC10 write setSEC10;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_RTCDATE = record
  private
    function  getDAY01 : TBits_4; inline;
    function  getDAY10 : TBits_4; inline;
    function  getMONTH01 : TBits_4; inline;
    function  getMONTH10 : TBits_4; inline;
    function  getWDAY01 : TBits_4; inline;
    function  getYEAR01 : TBits_4; inline;
    function  getYEAR10 : TBits_4; inline;
    function  getw : TBits_32; inline;
    procedure setDAY01(thebits : TBits_4); inline;
    procedure setDAY10(thebits : TBits_4); inline;
    procedure setMONTH01(thebits : TBits_4); inline;
    procedure setMONTH10(thebits : TBits_4); inline;
    procedure setWDAY01(thebits : TBits_4); inline;
    procedure setYEAR01(thebits : TBits_4); inline;
    procedure setYEAR10(thebits : TBits_4); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DAY01 : TBits_4 read getDAY01 write setDAY01;
    property DAY10 : TBits_4 read getDAY10 write setDAY10;
    property MONTH01 : TBits_4 read getMONTH01 write setMONTH01;
    property MONTH10 : TBits_4 read getMONTH10 write setMONTH10;
    property WDAY01 : TBits_4 read getWDAY01 write setWDAY01;
    property YEAR01 : TBits_4 read getYEAR01 write setYEAR01;
    property YEAR10 : TBits_4 read getYEAR10 write setYEAR10;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_ALRMTIME = record
  private
    function  getHR01 : TBits_4; inline;
    function  getHR10 : TBits_4; inline;
    function  getMIN01 : TBits_4; inline;
    function  getMIN10 : TBits_4; inline;
    function  getSEC01 : TBits_4; inline;
    function  getSEC10 : TBits_4; inline;
    function  getw : TBits_32; inline;
    procedure setHR01(thebits : TBits_4); inline;
    procedure setHR10(thebits : TBits_4); inline;
    procedure setMIN01(thebits : TBits_4); inline;
    procedure setMIN10(thebits : TBits_4); inline;
    procedure setSEC01(thebits : TBits_4); inline;
    procedure setSEC10(thebits : TBits_4); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property HR01 : TBits_4 read getHR01 write setHR01;
    property HR10 : TBits_4 read getHR10 write setHR10;
    property MIN01 : TBits_4 read getMIN01 write setMIN01;
    property MIN10 : TBits_4 read getMIN10 write setMIN10;
    property SEC01 : TBits_4 read getSEC01 write setSEC01;
    property SEC10 : TBits_4 read getSEC10 write setSEC10;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_ALRMDATE = record
  private
    function  getDAY01 : TBits_4; inline;
    function  getDAY10 : TBits_4; inline;
    function  getMONTH01 : TBits_4; inline;
    function  getMONTH10 : TBits_4; inline;
    function  getWDAY01 : TBits_4; inline;
    function  getw : TBits_32; inline;
    procedure setDAY01(thebits : TBits_4); inline;
    procedure setDAY10(thebits : TBits_4); inline;
    procedure setMONTH01(thebits : TBits_4); inline;
    procedure setMONTH10(thebits : TBits_4); inline;
    procedure setWDAY01(thebits : TBits_4); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DAY01 : TBits_4 read getDAY01 write setDAY01;
    property DAY10 : TBits_4 read getDAY10 write setDAY10;
    property MONTH01 : TBits_4 read getMONTH01 write setMONTH01;
    property MONTH10 : TBits_4 read getMONTH10 write setMONTH10;
    property WDAY01 : TBits_4 read getWDAY01 write setWDAY01;
    property w : TBits_32 read getw write setw;
  end;
type
  TRTCCRegisters = record
    RTCCONbits : TRTCC_RTCCON;
    RTCCON : longWord;
    RTCCONCLR : longWord;
    RTCCONSET : longWord;
    RTCCONINV : longWord;
    RTCALRMbits : TRTCC_RTCALRM;
    RTCALRM : longWord;
    RTCALRMCLR : longWord;
    RTCALRMSET : longWord;
    RTCALRMINV : longWord;
    RTCTIMEbits : TRTCC_RTCTIME;
    RTCTIME : longWord;
    RTCTIMECLR : longWord;
    RTCTIMESET : longWord;
    RTCTIMEINV : longWord;
    RTCDATEbits : TRTCC_RTCDATE;
    RTCDATE : longWord;
    RTCDATECLR : longWord;
    RTCDATESET : longWord;
    RTCDATEINV : longWord;
    ALRMTIMEbits : TRTCC_ALRMTIME;
    ALRMTIME : longWord;
    ALRMTIMECLR : longWord;
    ALRMTIMESET : longWord;
    ALRMTIMEINV : longWord;
    ALRMDATEbits : TRTCC_ALRMDATE;
    ALRMDATE : longWord;
    ALRMDATECLR : longWord;
    ALRMDATESET : longWord;
    ALRMDATEINV : longWord;
  end;
  TTMR1_T1CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getTCKPS : TBits_2; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCS : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getTSYNC : TBits_1; inline;
    function  getTWDIS : TBits_1; inline;
    function  getTWIP : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_2); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCS(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setTSYNC(thebits : TBits_1); inline;
    procedure setTWDIS(thebits : TBits_1); inline;
    procedure setTWIP(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCS; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure clearTSYNC; inline;
    procedure clearTWDIS; inline;
    procedure clearTWIP; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCS; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    procedure setTSYNC; inline;
    procedure setTWDIS; inline;
    procedure setTWIP; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property TCKPS : TBits_2 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCS : TBits_1 read getTCS write setTCS;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property TSYNC : TBits_1 read getTSYNC write setTSYNC;
    property TWDIS : TBits_1 read getTWDIS write setTWDIS;
    property TWIP : TBits_1 read getTWIP write setTWIP;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR1Registers = record
    T1CONbits : TTMR1_T1CON;
    T1CON : longWord;
    T1CONCLR : longWord;
    T1CONSET : longWord;
    T1CONINV : longWord;
    TMR1 : longWord;
    TMR1CLR : longWord;
    TMR1SET : longWord;
    TMR1INV : longWord;
    PR1 : longWord;
    PR1CLR : longWord;
    PR1SET : longWord;
    PR1INV : longWord;
  end;
  TTMR2_T2CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getT32 : TBits_1; inline;
    function  getTCKPS : TBits_3; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCKPS2 : TBits_1; inline;
    function  getTCS : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setT32(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_3); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCKPS2(thebits : TBits_1); inline;
    procedure setTCS(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearT32; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCKPS2; inline;
    procedure clearTCS; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setT32; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCKPS2; inline;
    procedure setTCS; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property T32 : TBits_1 read getT32 write setT32;
    property TCKPS : TBits_3 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCKPS2 : TBits_1 read getTCKPS2 write setTCKPS2;
    property TCS : TBits_1 read getTCS write setTCS;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR2Registers = record
    T2CONbits : TTMR2_T2CON;
    T2CON : longWord;
    T2CONCLR : longWord;
    T2CONSET : longWord;
    T2CONINV : longWord;
    TMR2 : longWord;
    TMR2CLR : longWord;
    TMR2SET : longWord;
    TMR2INV : longWord;
    PR2 : longWord;
    PR2CLR : longWord;
    PR2SET : longWord;
    PR2INV : longWord;
  end;
  TTMR3_T3CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getT32 : TBits_1; inline;
    function  getTCKPS : TBits_3; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCKPS2 : TBits_1; inline;
    function  getTCS : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setT32(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_3); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCKPS2(thebits : TBits_1); inline;
    procedure setTCS(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearT32; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCKPS2; inline;
    procedure clearTCS; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setT32; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCKPS2; inline;
    procedure setTCS; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property T32 : TBits_1 read getT32 write setT32;
    property TCKPS : TBits_3 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCKPS2 : TBits_1 read getTCKPS2 write setTCKPS2;
    property TCS : TBits_1 read getTCS write setTCS;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR3Registers = record
    T3CONbits : TTMR3_T3CON;
    T3CON : longWord;
    T3CONCLR : longWord;
    T3CONSET : longWord;
    T3CONINV : longWord;
    TMR3 : longWord;
    TMR3CLR : longWord;
    TMR3SET : longWord;
    TMR3INV : longWord;
    PR3 : longWord;
    PR3CLR : longWord;
    PR3SET : longWord;
    PR3INV : longWord;
  end;
  TTMR4_T4CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getT32 : TBits_1; inline;
    function  getTCKPS : TBits_3; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCKPS2 : TBits_1; inline;
    function  getTCS : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setT32(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_3); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCKPS2(thebits : TBits_1); inline;
    procedure setTCS(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearT32; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCKPS2; inline;
    procedure clearTCS; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setT32; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCKPS2; inline;
    procedure setTCS; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property T32 : TBits_1 read getT32 write setT32;
    property TCKPS : TBits_3 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCKPS2 : TBits_1 read getTCKPS2 write setTCKPS2;
    property TCS : TBits_1 read getTCS write setTCS;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR4Registers = record
    T4CONbits : TTMR4_T4CON;
    T4CON : longWord;
    T4CONCLR : longWord;
    T4CONSET : longWord;
    T4CONINV : longWord;
    TMR4 : longWord;
    TMR4CLR : longWord;
    TMR4SET : longWord;
    TMR4INV : longWord;
    PR4 : longWord;
    PR4CLR : longWord;
    PR4SET : longWord;
    PR4INV : longWord;
  end;
  TTMR5_T5CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getT32 : TBits_1; inline;
    function  getTCKPS : TBits_3; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCKPS2 : TBits_1; inline;
    function  getTCS : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setT32(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_3); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCKPS2(thebits : TBits_1); inline;
    procedure setTCS(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearT32; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCKPS2; inline;
    procedure clearTCS; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setT32; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCKPS2; inline;
    procedure setTCS; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property T32 : TBits_1 read getT32 write setT32;
    property TCKPS : TBits_3 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCKPS2 : TBits_1 read getTCKPS2 write setTCKPS2;
    property TCS : TBits_1 read getTCS write setTCS;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR5Registers = record
    T5CONbits : TTMR5_T5CON;
    T5CON : longWord;
    T5CONCLR : longWord;
    T5CONSET : longWord;
    T5CONINV : longWord;
    TMR5 : longWord;
    TMR5CLR : longWord;
    TMR5SET : longWord;
    TMR5INV : longWord;
    PR5 : longWord;
    PR5CLR : longWord;
    PR5SET : longWord;
    PR5INV : longWord;
  end;
  TICAP1_IC1CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP1Registers = record
    IC1CONbits : TICAP1_IC1CON;
    IC1CON : longWord;
    IC1CONCLR : longWord;
    IC1CONSET : longWord;
    IC1CONINV : longWord;
    IC1BUF : longWord;
  end;
  TICAP2_IC2CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP2Registers = record
    IC2CONbits : TICAP2_IC2CON;
    IC2CON : longWord;
    IC2CONCLR : longWord;
    IC2CONSET : longWord;
    IC2CONINV : longWord;
    IC2BUF : longWord;
  end;
  TICAP3_IC3CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP3Registers = record
    IC3CONbits : TICAP3_IC3CON;
    IC3CON : longWord;
    IC3CONCLR : longWord;
    IC3CONSET : longWord;
    IC3CONINV : longWord;
    IC3BUF : longWord;
  end;
  TICAP4_IC4CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP4Registers = record
    IC4CONbits : TICAP4_IC4CON;
    IC4CON : longWord;
    IC4CONCLR : longWord;
    IC4CONSET : longWord;
    IC4CONINV : longWord;
    IC4BUF : longWord;
  end;
  TICAP5_IC5CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP5Registers = record
    IC5CONbits : TICAP5_IC5CON;
    IC5CON : longWord;
    IC5CONCLR : longWord;
    IC5CONSET : longWord;
    IC5CONINV : longWord;
    IC5BUF : longWord;
  end;
  TOCMP1_OC1CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP1Registers = record
    OC1CONbits : TOCMP1_OC1CON;
    OC1CON : longWord;
    OC1CONCLR : longWord;
    OC1CONSET : longWord;
    OC1CONINV : longWord;
    OC1R : longWord;
    OC1RCLR : longWord;
    OC1RSET : longWord;
    OC1RINV : longWord;
    OC1RS : longWord;
    OC1RSCLR : longWord;
    OC1RSSET : longWord;
    OC1RSINV : longWord;
  end;
  TOCMP2_OC2CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP2Registers = record
    OC2CONbits : TOCMP2_OC2CON;
    OC2CON : longWord;
    OC2CONCLR : longWord;
    OC2CONSET : longWord;
    OC2CONINV : longWord;
    OC2R : longWord;
    OC2RCLR : longWord;
    OC2RSET : longWord;
    OC2RINV : longWord;
    OC2RS : longWord;
    OC2RSCLR : longWord;
    OC2RSSET : longWord;
    OC2RSINV : longWord;
  end;
  TOCMP3_OC3CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP3Registers = record
    OC3CONbits : TOCMP3_OC3CON;
    OC3CON : longWord;
    OC3CONCLR : longWord;
    OC3CONSET : longWord;
    OC3CONINV : longWord;
    OC3R : longWord;
    OC3RCLR : longWord;
    OC3RSET : longWord;
    OC3RINV : longWord;
    OC3RS : longWord;
    OC3RSCLR : longWord;
    OC3RSSET : longWord;
    OC3RSINV : longWord;
  end;
  TOCMP4_OC4CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP4Registers = record
    OC4CONbits : TOCMP4_OC4CON;
    OC4CON : longWord;
    OC4CONCLR : longWord;
    OC4CONSET : longWord;
    OC4CONINV : longWord;
    OC4R : longWord;
    OC4RCLR : longWord;
    OC4RSET : longWord;
    OC4RINV : longWord;
    OC4RS : longWord;
    OC4RSCLR : longWord;
    OC4RSSET : longWord;
    OC4RSINV : longWord;
  end;
  TOCMP5_OC5CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP5Registers = record
    OC5CONbits : TOCMP5_OC5CON;
    OC5CON : longWord;
    OC5CONCLR : longWord;
    OC5CONSET : longWord;
    OC5CONINV : longWord;
    OC5R : longWord;
    OC5RCLR : longWord;
    OC5RSET : longWord;
    OC5RINV : longWord;
    OC5RS : longWord;
    OC5RSCLR : longWord;
    OC5RSSET : longWord;
    OC5RSINV : longWord;
  end;
  TI2C1_I2C1111CON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C1_I2C1CON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C1_I2C1111STAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C1_I2C1STAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
type
  TI2C1Registers = record
    I2C1111CONbits : TI2C1_I2C1111CON;
    I2C1111CON : longWord;
    I2C1CONbits : TI2C1_I2C1CON;
    I2C1CON : longWord;
    I2C1111CONCLR : longWord;
    I2C1CONCLR : longWord;
    I2C1111CONSET : longWord;
    I2C1CONSET : longWord;
    I2C1111CONINV : longWord;
    I2C1CONINV : longWord;
    I2C1111STATbits : TI2C1_I2C1111STAT;
    I2C1111STAT : longWord;
    I2C1STATbits : TI2C1_I2C1STAT;
    I2C1STAT : longWord;
    I2C1111STATCLR : longWord;
    I2C1STATCLR : longWord;
    I2C1111STATSET : longWord;
    I2C1STATSET : longWord;
    I2C1111STATINV : longWord;
    I2C1STATINV : longWord;
    I2C1111ADD : longWord;
    I2C1ADD : longWord;
    I2C1111ADDCLR : longWord;
    I2C1ADDCLR : longWord;
    I2C1111ADDSET : longWord;
    I2C1ADDSET : longWord;
    I2C1111ADDINV : longWord;
    I2C1ADDINV : longWord;
    I2C1111MSK : longWord;
    I2C1MSK : longWord;
    I2C1111MSKCLR : longWord;
    I2C1MSKCLR : longWord;
    I2C1111MSKSET : longWord;
    I2C1MSKSET : longWord;
    I2C1111MSKINV : longWord;
    I2C1MSKINV : longWord;
    I2C1111BRG : longWord;
    I2C1BRG : longWord;
    I2C1111BRGCLR : longWord;
    I2C1BRGCLR : longWord;
    I2C1111BRGSET : longWord;
    I2C1BRGSET : longWord;
    I2C1111BRGINV : longWord;
    I2C1BRGINV : longWord;
    I2C1111TRN : longWord;
    I2C1TRN : longWord;
    I2C1111TRNCLR : longWord;
    I2C1TRNCLR : longWord;
    I2C1111TRNSET : longWord;
    I2C1TRNSET : longWord;
    I2C1111TRNINV : longWord;
    I2C1TRNINV : longWord;
    I2C1111RCV : longWord;
    I2C1RCV : longWord;
  end;
  TI2C2_I2C2CON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C2_I2CABCON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C2_I2C2STAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C2_I2CABSTAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
type
  TI2C2Registers = record
    I2C2CONbits : TI2C2_I2C2CON;
    I2C2CON : longWord;
    I2CABCONbits : TI2C2_I2CABCON;
    I2CABCON : longWord;
    I2C2CONCLR : longWord;
    I2CABCONCLR : longWord;
    I2C2CONSET : longWord;
    I2CABCONSET : longWord;
    I2C2CONINV : longWord;
    I2CABCONINV : longWord;
    I2C2STATbits : TI2C2_I2C2STAT;
    I2C2STAT : longWord;
    I2CABSTATbits : TI2C2_I2CABSTAT;
    I2CABSTAT : longWord;
    I2C2STATCLR : longWord;
    I2CABSTATCLR : longWord;
    I2C2STATSET : longWord;
    I2CABSTATSET : longWord;
    I2C2STATINV : longWord;
    I2CABSTATINV : longWord;
    I2C2ADD : longWord;
    I2CABADD : longWord;
    I2C2ADDCLR : longWord;
    I2CABADDCLR : longWord;
    I2C2ADDSET : longWord;
    I2CABADDSET : longWord;
    I2C2ADDINV : longWord;
    I2CABADDINV : longWord;
    I2C2MSK : longWord;
    I2CABMSK : longWord;
    I2C2MSKCLR : longWord;
    I2CABMSKCLR : longWord;
    I2C2MSKSET : longWord;
    I2CABMSKSET : longWord;
    I2C2MSKINV : longWord;
    I2CABMSKINV : longWord;
    I2C2BRG : longWord;
    I2CABBRG : longWord;
    I2C2BRGCLR : longWord;
    I2CABBRGCLR : longWord;
    I2C2BRGSET : longWord;
    I2CABBRGSET : longWord;
    I2C2BRGINV : longWord;
    I2CABBRGINV : longWord;
    I2C2TRN : longWord;
    I2CABTRN : longWord;
    I2C2TRNCLR : longWord;
    I2CABTRNCLR : longWord;
    I2C2TRNSET : longWord;
    I2CABTRNSET : longWord;
    I2C2TRNINV : longWord;
    I2CABTRNINV : longWord;
    I2C2RCV : longWord;
    I2CABRCV : longWord;
  end;
  TSPI1_SPI1CON = record
  private
    function  getCKE : TBits_1; inline;
    function  getCKP : TBits_1; inline;
    function  getDISSDI : TBits_1; inline;
    function  getDISSDO : TBits_1; inline;
    function  getENHBUF : TBits_1; inline;
    function  getFRMCNT : TBits_3; inline;
    function  getFRMEN : TBits_1; inline;
    function  getFRMPOL : TBits_1; inline;
    function  getFRMSYNC : TBits_1; inline;
    function  getFRMSYPW : TBits_1; inline;
    function  getMCLKSEL : TBits_1; inline;
    function  getMODE16 : TBits_1; inline;
    function  getMODE32 : TBits_1; inline;
    function  getMSSEN : TBits_1; inline;
    function  getMSTEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMP : TBits_1; inline;
    function  getSPIFE : TBits_1; inline;
    function  getSRXISEL : TBits_2; inline;
    function  getSSEN : TBits_1; inline;
    function  getSTXISEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCKE(thebits : TBits_1); inline;
    procedure setCKP(thebits : TBits_1); inline;
    procedure setDISSDI(thebits : TBits_1); inline;
    procedure setDISSDO(thebits : TBits_1); inline;
    procedure setENHBUF(thebits : TBits_1); inline;
    procedure setFRMCNT(thebits : TBits_3); inline;
    procedure setFRMEN(thebits : TBits_1); inline;
    procedure setFRMPOL(thebits : TBits_1); inline;
    procedure setFRMSYNC(thebits : TBits_1); inline;
    procedure setFRMSYPW(thebits : TBits_1); inline;
    procedure setMCLKSEL(thebits : TBits_1); inline;
    procedure setMODE16(thebits : TBits_1); inline;
    procedure setMODE32(thebits : TBits_1); inline;
    procedure setMSSEN(thebits : TBits_1); inline;
    procedure setMSTEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMP(thebits : TBits_1); inline;
    procedure setSPIFE(thebits : TBits_1); inline;
    procedure setSRXISEL(thebits : TBits_2); inline;
    procedure setSSEN(thebits : TBits_1); inline;
    procedure setSTXISEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCKE; inline;
    procedure clearCKP; inline;
    procedure clearDISSDI; inline;
    procedure clearDISSDO; inline;
    procedure clearENHBUF; inline;
    procedure clearFRMEN; inline;
    procedure clearFRMPOL; inline;
    procedure clearFRMSYNC; inline;
    procedure clearFRMSYPW; inline;
    procedure clearMCLKSEL; inline;
    procedure clearMODE16; inline;
    procedure clearMODE32; inline;
    procedure clearMSSEN; inline;
    procedure clearMSTEN; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearSMP; inline;
    procedure clearSPIFE; inline;
    procedure clearSSEN; inline;
    procedure setCKE; inline;
    procedure setCKP; inline;
    procedure setDISSDI; inline;
    procedure setDISSDO; inline;
    procedure setENHBUF; inline;
    procedure setFRMEN; inline;
    procedure setFRMPOL; inline;
    procedure setFRMSYNC; inline;
    procedure setFRMSYPW; inline;
    procedure setMCLKSEL; inline;
    procedure setMODE16; inline;
    procedure setMODE32; inline;
    procedure setMSSEN; inline;
    procedure setMSTEN; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setSMP; inline;
    procedure setSPIFE; inline;
    procedure setSSEN; inline;
    property CKE : TBits_1 read getCKE write setCKE;
    property CKP : TBits_1 read getCKP write setCKP;
    property DISSDI : TBits_1 read getDISSDI write setDISSDI;
    property DISSDO : TBits_1 read getDISSDO write setDISSDO;
    property ENHBUF : TBits_1 read getENHBUF write setENHBUF;
    property FRMCNT : TBits_3 read getFRMCNT write setFRMCNT;
    property FRMEN : TBits_1 read getFRMEN write setFRMEN;
    property FRMPOL : TBits_1 read getFRMPOL write setFRMPOL;
    property FRMSYNC : TBits_1 read getFRMSYNC write setFRMSYNC;
    property FRMSYPW : TBits_1 read getFRMSYPW write setFRMSYPW;
    property MCLKSEL : TBits_1 read getMCLKSEL write setMCLKSEL;
    property MODE16 : TBits_1 read getMODE16 write setMODE16;
    property MODE32 : TBits_1 read getMODE32 write setMODE32;
    property MSSEN : TBits_1 read getMSSEN write setMSSEN;
    property MSTEN : TBits_1 read getMSTEN write setMSTEN;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMP : TBits_1 read getSMP write setSMP;
    property SPIFE : TBits_1 read getSPIFE write setSPIFE;
    property SRXISEL : TBits_2 read getSRXISEL write setSRXISEL;
    property SSEN : TBits_1 read getSSEN write setSSEN;
    property STXISEL : TBits_2 read getSTXISEL write setSTXISEL;
    property w : TBits_32 read getw write setw;
  end;
  TSPI1_SPI1STAT = record
  private
    function  getFRMERR : TBits_1; inline;
    function  getRXBUFELM : TBits_5; inline;
    function  getSPIBUSY : TBits_1; inline;
    function  getSPIRBE : TBits_1; inline;
    function  getSPIRBF : TBits_1; inline;
    function  getSPIROV : TBits_1; inline;
    function  getSPITBE : TBits_1; inline;
    function  getSPITBF : TBits_1; inline;
    function  getSPITUR : TBits_1; inline;
    function  getSRMT : TBits_1; inline;
    function  getTXBUFELM : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setFRMERR(thebits : TBits_1); inline;
    procedure setRXBUFELM(thebits : TBits_5); inline;
    procedure setSPIBUSY(thebits : TBits_1); inline;
    procedure setSPIRBE(thebits : TBits_1); inline;
    procedure setSPIRBF(thebits : TBits_1); inline;
    procedure setSPIROV(thebits : TBits_1); inline;
    procedure setSPITBE(thebits : TBits_1); inline;
    procedure setSPITBF(thebits : TBits_1); inline;
    procedure setSPITUR(thebits : TBits_1); inline;
    procedure setSRMT(thebits : TBits_1); inline;
    procedure setTXBUFELM(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFRMERR; inline;
    procedure clearSPIBUSY; inline;
    procedure clearSPIRBE; inline;
    procedure clearSPIRBF; inline;
    procedure clearSPIROV; inline;
    procedure clearSPITBE; inline;
    procedure clearSPITBF; inline;
    procedure clearSPITUR; inline;
    procedure clearSRMT; inline;
    procedure setFRMERR; inline;
    procedure setSPIBUSY; inline;
    procedure setSPIRBE; inline;
    procedure setSPIRBF; inline;
    procedure setSPIROV; inline;
    procedure setSPITBE; inline;
    procedure setSPITBF; inline;
    procedure setSPITUR; inline;
    procedure setSRMT; inline;
    property FRMERR : TBits_1 read getFRMERR write setFRMERR;
    property RXBUFELM : TBits_5 read getRXBUFELM write setRXBUFELM;
    property SPIBUSY : TBits_1 read getSPIBUSY write setSPIBUSY;
    property SPIRBE : TBits_1 read getSPIRBE write setSPIRBE;
    property SPIRBF : TBits_1 read getSPIRBF write setSPIRBF;
    property SPIROV : TBits_1 read getSPIROV write setSPIROV;
    property SPITBE : TBits_1 read getSPITBE write setSPITBE;
    property SPITBF : TBits_1 read getSPITBF write setSPITBF;
    property SPITUR : TBits_1 read getSPITUR write setSPITUR;
    property SRMT : TBits_1 read getSRMT write setSRMT;
    property TXBUFELM : TBits_5 read getTXBUFELM write setTXBUFELM;
    property w : TBits_32 read getw write setw;
  end;
  TSPI1_SPI1CON2 = record
  private
    function  getAUDEN : TBits_1; inline;
    function  getAUDMOD : TBits_2; inline;
    function  getAUDMOD0 : TBits_1; inline;
    function  getAUDMOD1 : TBits_1; inline;
    function  getAUDMONO : TBits_1; inline;
    function  getFRMERREN : TBits_1; inline;
    function  getIGNROV : TBits_1; inline;
    function  getIGNTUR : TBits_1; inline;
    function  getSPIROVEN : TBits_1; inline;
    function  getSPISGNEXT : TBits_1; inline;
    function  getSPITUREN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAUDEN(thebits : TBits_1); inline;
    procedure setAUDMOD(thebits : TBits_2); inline;
    procedure setAUDMOD0(thebits : TBits_1); inline;
    procedure setAUDMOD1(thebits : TBits_1); inline;
    procedure setAUDMONO(thebits : TBits_1); inline;
    procedure setFRMERREN(thebits : TBits_1); inline;
    procedure setIGNROV(thebits : TBits_1); inline;
    procedure setIGNTUR(thebits : TBits_1); inline;
    procedure setSPIROVEN(thebits : TBits_1); inline;
    procedure setSPISGNEXT(thebits : TBits_1); inline;
    procedure setSPITUREN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAUDEN; inline;
    procedure clearAUDMOD0; inline;
    procedure clearAUDMOD1; inline;
    procedure clearAUDMONO; inline;
    procedure clearFRMERREN; inline;
    procedure clearIGNROV; inline;
    procedure clearIGNTUR; inline;
    procedure clearSPIROVEN; inline;
    procedure clearSPISGNEXT; inline;
    procedure clearSPITUREN; inline;
    procedure setAUDEN; inline;
    procedure setAUDMOD0; inline;
    procedure setAUDMOD1; inline;
    procedure setAUDMONO; inline;
    procedure setFRMERREN; inline;
    procedure setIGNROV; inline;
    procedure setIGNTUR; inline;
    procedure setSPIROVEN; inline;
    procedure setSPISGNEXT; inline;
    procedure setSPITUREN; inline;
    property AUDEN : TBits_1 read getAUDEN write setAUDEN;
    property AUDMOD : TBits_2 read getAUDMOD write setAUDMOD;
    property AUDMOD0 : TBits_1 read getAUDMOD0 write setAUDMOD0;
    property AUDMOD1 : TBits_1 read getAUDMOD1 write setAUDMOD1;
    property AUDMONO : TBits_1 read getAUDMONO write setAUDMONO;
    property FRMERREN : TBits_1 read getFRMERREN write setFRMERREN;
    property IGNROV : TBits_1 read getIGNROV write setIGNROV;
    property IGNTUR : TBits_1 read getIGNTUR write setIGNTUR;
    property SPIROVEN : TBits_1 read getSPIROVEN write setSPIROVEN;
    property SPISGNEXT : TBits_1 read getSPISGNEXT write setSPISGNEXT;
    property SPITUREN : TBits_1 read getSPITUREN write setSPITUREN;
    property w : TBits_32 read getw write setw;
  end;
type
  TSPI1Registers = record
    SPI1CONbits : TSPI1_SPI1CON;
    SPI1CON : longWord;
    SPI1CONCLR : longWord;
    SPI1CONSET : longWord;
    SPI1CONINV : longWord;
    SPI1STATbits : TSPI1_SPI1STAT;
    SPI1STAT : longWord;
    SPI1STATCLR : longWord;
    SPI1STATSET : longWord;
    SPI1STATINV : longWord;
    SPI1BUF : longWord;
    SPI1BRG : longWord;
    SPI1BRGCLR : longWord;
    SPI1BRGSET : longWord;
    SPI1BRGINV : longWord;
    SPI1CON2bits : TSPI1_SPI1CON2;
    SPI1CON2 : longWord;
    SPI1CON2CLR : longWord;
    SPI1CON2SET : longWord;
    SPI1CON2INV : longWord;
  end;
  TSPI2_SPI2CON = record
  private
    function  getCKE : TBits_1; inline;
    function  getCKP : TBits_1; inline;
    function  getDISSDI : TBits_1; inline;
    function  getDISSDO : TBits_1; inline;
    function  getENHBUF : TBits_1; inline;
    function  getFRMCNT : TBits_3; inline;
    function  getFRMEN : TBits_1; inline;
    function  getFRMPOL : TBits_1; inline;
    function  getFRMSYNC : TBits_1; inline;
    function  getFRMSYPW : TBits_1; inline;
    function  getMCLKSEL : TBits_1; inline;
    function  getMODE16 : TBits_1; inline;
    function  getMODE32 : TBits_1; inline;
    function  getMSSEN : TBits_1; inline;
    function  getMSTEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMP : TBits_1; inline;
    function  getSPIFE : TBits_1; inline;
    function  getSRXISEL : TBits_2; inline;
    function  getSSEN : TBits_1; inline;
    function  getSTXISEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCKE(thebits : TBits_1); inline;
    procedure setCKP(thebits : TBits_1); inline;
    procedure setDISSDI(thebits : TBits_1); inline;
    procedure setDISSDO(thebits : TBits_1); inline;
    procedure setENHBUF(thebits : TBits_1); inline;
    procedure setFRMCNT(thebits : TBits_3); inline;
    procedure setFRMEN(thebits : TBits_1); inline;
    procedure setFRMPOL(thebits : TBits_1); inline;
    procedure setFRMSYNC(thebits : TBits_1); inline;
    procedure setFRMSYPW(thebits : TBits_1); inline;
    procedure setMCLKSEL(thebits : TBits_1); inline;
    procedure setMODE16(thebits : TBits_1); inline;
    procedure setMODE32(thebits : TBits_1); inline;
    procedure setMSSEN(thebits : TBits_1); inline;
    procedure setMSTEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMP(thebits : TBits_1); inline;
    procedure setSPIFE(thebits : TBits_1); inline;
    procedure setSRXISEL(thebits : TBits_2); inline;
    procedure setSSEN(thebits : TBits_1); inline;
    procedure setSTXISEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCKE; inline;
    procedure clearCKP; inline;
    procedure clearDISSDI; inline;
    procedure clearDISSDO; inline;
    procedure clearENHBUF; inline;
    procedure clearFRMEN; inline;
    procedure clearFRMPOL; inline;
    procedure clearFRMSYNC; inline;
    procedure clearFRMSYPW; inline;
    procedure clearMCLKSEL; inline;
    procedure clearMODE16; inline;
    procedure clearMODE32; inline;
    procedure clearMSSEN; inline;
    procedure clearMSTEN; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearSMP; inline;
    procedure clearSPIFE; inline;
    procedure clearSSEN; inline;
    procedure setCKE; inline;
    procedure setCKP; inline;
    procedure setDISSDI; inline;
    procedure setDISSDO; inline;
    procedure setENHBUF; inline;
    procedure setFRMEN; inline;
    procedure setFRMPOL; inline;
    procedure setFRMSYNC; inline;
    procedure setFRMSYPW; inline;
    procedure setMCLKSEL; inline;
    procedure setMODE16; inline;
    procedure setMODE32; inline;
    procedure setMSSEN; inline;
    procedure setMSTEN; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setSMP; inline;
    procedure setSPIFE; inline;
    procedure setSSEN; inline;
    property CKE : TBits_1 read getCKE write setCKE;
    property CKP : TBits_1 read getCKP write setCKP;
    property DISSDI : TBits_1 read getDISSDI write setDISSDI;
    property DISSDO : TBits_1 read getDISSDO write setDISSDO;
    property ENHBUF : TBits_1 read getENHBUF write setENHBUF;
    property FRMCNT : TBits_3 read getFRMCNT write setFRMCNT;
    property FRMEN : TBits_1 read getFRMEN write setFRMEN;
    property FRMPOL : TBits_1 read getFRMPOL write setFRMPOL;
    property FRMSYNC : TBits_1 read getFRMSYNC write setFRMSYNC;
    property FRMSYPW : TBits_1 read getFRMSYPW write setFRMSYPW;
    property MCLKSEL : TBits_1 read getMCLKSEL write setMCLKSEL;
    property MODE16 : TBits_1 read getMODE16 write setMODE16;
    property MODE32 : TBits_1 read getMODE32 write setMODE32;
    property MSSEN : TBits_1 read getMSSEN write setMSSEN;
    property MSTEN : TBits_1 read getMSTEN write setMSTEN;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMP : TBits_1 read getSMP write setSMP;
    property SPIFE : TBits_1 read getSPIFE write setSPIFE;
    property SRXISEL : TBits_2 read getSRXISEL write setSRXISEL;
    property SSEN : TBits_1 read getSSEN write setSSEN;
    property STXISEL : TBits_2 read getSTXISEL write setSTXISEL;
    property w : TBits_32 read getw write setw;
  end;
  TSPI2_SPI2STAT = record
  private
    function  getFRMERR : TBits_1; inline;
    function  getRXBUFELM : TBits_5; inline;
    function  getSPIBUSY : TBits_1; inline;
    function  getSPIRBE : TBits_1; inline;
    function  getSPIRBF : TBits_1; inline;
    function  getSPIROV : TBits_1; inline;
    function  getSPITBE : TBits_1; inline;
    function  getSPITBF : TBits_1; inline;
    function  getSPITUR : TBits_1; inline;
    function  getSRMT : TBits_1; inline;
    function  getTXBUFELM : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setFRMERR(thebits : TBits_1); inline;
    procedure setRXBUFELM(thebits : TBits_5); inline;
    procedure setSPIBUSY(thebits : TBits_1); inline;
    procedure setSPIRBE(thebits : TBits_1); inline;
    procedure setSPIRBF(thebits : TBits_1); inline;
    procedure setSPIROV(thebits : TBits_1); inline;
    procedure setSPITBE(thebits : TBits_1); inline;
    procedure setSPITBF(thebits : TBits_1); inline;
    procedure setSPITUR(thebits : TBits_1); inline;
    procedure setSRMT(thebits : TBits_1); inline;
    procedure setTXBUFELM(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFRMERR; inline;
    procedure clearSPIBUSY; inline;
    procedure clearSPIRBE; inline;
    procedure clearSPIRBF; inline;
    procedure clearSPIROV; inline;
    procedure clearSPITBE; inline;
    procedure clearSPITBF; inline;
    procedure clearSPITUR; inline;
    procedure clearSRMT; inline;
    procedure setFRMERR; inline;
    procedure setSPIBUSY; inline;
    procedure setSPIRBE; inline;
    procedure setSPIRBF; inline;
    procedure setSPIROV; inline;
    procedure setSPITBE; inline;
    procedure setSPITBF; inline;
    procedure setSPITUR; inline;
    procedure setSRMT; inline;
    property FRMERR : TBits_1 read getFRMERR write setFRMERR;
    property RXBUFELM : TBits_5 read getRXBUFELM write setRXBUFELM;
    property SPIBUSY : TBits_1 read getSPIBUSY write setSPIBUSY;
    property SPIRBE : TBits_1 read getSPIRBE write setSPIRBE;
    property SPIRBF : TBits_1 read getSPIRBF write setSPIRBF;
    property SPIROV : TBits_1 read getSPIROV write setSPIROV;
    property SPITBE : TBits_1 read getSPITBE write setSPITBE;
    property SPITBF : TBits_1 read getSPITBF write setSPITBF;
    property SPITUR : TBits_1 read getSPITUR write setSPITUR;
    property SRMT : TBits_1 read getSRMT write setSRMT;
    property TXBUFELM : TBits_5 read getTXBUFELM write setTXBUFELM;
    property w : TBits_32 read getw write setw;
  end;
  TSPI2_SPI2CON2 = record
  private
    function  getAUDEN : TBits_1; inline;
    function  getAUDMOD : TBits_2; inline;
    function  getAUDMOD0 : TBits_1; inline;
    function  getAUDMOD1 : TBits_1; inline;
    function  getAUDMONO : TBits_1; inline;
    function  getFRMERREN : TBits_1; inline;
    function  getIGNROV : TBits_1; inline;
    function  getIGNTUR : TBits_1; inline;
    function  getSPIROVEN : TBits_1; inline;
    function  getSPISGNEXT : TBits_1; inline;
    function  getSPITUREN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAUDEN(thebits : TBits_1); inline;
    procedure setAUDMOD(thebits : TBits_2); inline;
    procedure setAUDMOD0(thebits : TBits_1); inline;
    procedure setAUDMOD1(thebits : TBits_1); inline;
    procedure setAUDMONO(thebits : TBits_1); inline;
    procedure setFRMERREN(thebits : TBits_1); inline;
    procedure setIGNROV(thebits : TBits_1); inline;
    procedure setIGNTUR(thebits : TBits_1); inline;
    procedure setSPIROVEN(thebits : TBits_1); inline;
    procedure setSPISGNEXT(thebits : TBits_1); inline;
    procedure setSPITUREN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAUDEN; inline;
    procedure clearAUDMOD0; inline;
    procedure clearAUDMOD1; inline;
    procedure clearAUDMONO; inline;
    procedure clearFRMERREN; inline;
    procedure clearIGNROV; inline;
    procedure clearIGNTUR; inline;
    procedure clearSPIROVEN; inline;
    procedure clearSPISGNEXT; inline;
    procedure clearSPITUREN; inline;
    procedure setAUDEN; inline;
    procedure setAUDMOD0; inline;
    procedure setAUDMOD1; inline;
    procedure setAUDMONO; inline;
    procedure setFRMERREN; inline;
    procedure setIGNROV; inline;
    procedure setIGNTUR; inline;
    procedure setSPIROVEN; inline;
    procedure setSPISGNEXT; inline;
    procedure setSPITUREN; inline;
    property AUDEN : TBits_1 read getAUDEN write setAUDEN;
    property AUDMOD : TBits_2 read getAUDMOD write setAUDMOD;
    property AUDMOD0 : TBits_1 read getAUDMOD0 write setAUDMOD0;
    property AUDMOD1 : TBits_1 read getAUDMOD1 write setAUDMOD1;
    property AUDMONO : TBits_1 read getAUDMONO write setAUDMONO;
    property FRMERREN : TBits_1 read getFRMERREN write setFRMERREN;
    property IGNROV : TBits_1 read getIGNROV write setIGNROV;
    property IGNTUR : TBits_1 read getIGNTUR write setIGNTUR;
    property SPIROVEN : TBits_1 read getSPIROVEN write setSPIROVEN;
    property SPISGNEXT : TBits_1 read getSPISGNEXT write setSPISGNEXT;
    property SPITUREN : TBits_1 read getSPITUREN write setSPITUREN;
    property w : TBits_32 read getw write setw;
  end;
type
  TSPI2Registers = record
    SPI2CONbits : TSPI2_SPI2CON;
    SPI2CON : longWord;
    SPI2CONCLR : longWord;
    SPI2CONSET : longWord;
    SPI2CONINV : longWord;
    SPI2STATbits : TSPI2_SPI2STAT;
    SPI2STAT : longWord;
    SPI2STATCLR : longWord;
    SPI2STATSET : longWord;
    SPI2STATINV : longWord;
    SPI2BUF : longWord;
    SPI2BRG : longWord;
    SPI2BRGCLR : longWord;
    SPI2BRGSET : longWord;
    SPI2BRGINV : longWord;
    SPI2CON2bits : TSPI2_SPI2CON2;
    SPI2CON2 : longWord;
    SPI2CON2CLR : longWord;
    SPI2CON2SET : longWord;
    SPI2CON2INV : longWord;
  end;
  TUART1_U1MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART1_UDCMODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART1_U1STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
  TUART1_UDCSTA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
type
  TUART1Registers = record
    U1MODEbits : TUART1_U1MODE;
    U1MODE : longWord;
    UDCMODEbits : TUART1_UDCMODE;
    UDCMODE : longWord;
    U1MODECLR : longWord;
    UDCMODECLR : longWord;
    U1MODESET : longWord;
    UDCMODESET : longWord;
    U1MODEINV : longWord;
    UDCMODEINV : longWord;
    U1STAbits : TUART1_U1STA;
    U1STA : longWord;
    UDCSTAbits : TUART1_UDCSTA;
    UDCSTA : longWord;
    U1STACLR : longWord;
    UDCSTACLR : longWord;
    U1STASET : longWord;
    UDCSTASET : longWord;
    U1STAINV : longWord;
    UDCSTAINV : longWord;
    U1TXREG : longWord;
    UDCTXREG : longWord;
    U1RXREG : longWord;
    UDCRXREG : longWord;
    U1BRG : longWord;
    UDCBRG : longWord;
    U1BRGCLR : longWord;
    UDCBRGCLR : longWord;
    U1BRGSET : longWord;
    UDCBRGSET : longWord;
    U1BRGINV : longWord;
    UDCBRGINV : longWord;
  end;
  TUART2_U2MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART2_U8932MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART2_U2STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
  TUART2_U8932STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
type
  TUART2Registers = record
    U2MODEbits : TUART2_U2MODE;
    U2MODE : longWord;
    U8932MODEbits : TUART2_U8932MODE;
    U8932MODE : longWord;
    U2MODECLR : longWord;
    U8932MODECLR : longWord;
    U2MODESET : longWord;
    U8932MODESET : longWord;
    U2MODEINV : longWord;
    U8932MODEINV : longWord;
    U2STAbits : TUART2_U2STA;
    U2STA : longWord;
    U8932STAbits : TUART2_U8932STA;
    U8932STA : longWord;
    U2STACLR : longWord;
    U8932STACLR : longWord;
    U2STASET : longWord;
    U8932STASET : longWord;
    U2STAINV : longWord;
    U8932STAINV : longWord;
    U2TXREG : longWord;
    U8932TXREG : longWord;
    U2RXREG : longWord;
    U8932RXREG : longWord;
    U2BRG : longWord;
    U8932BRG : longWord;
    U2BRGCLR : longWord;
    U8932BRGCLR : longWord;
    U2BRGSET : longWord;
    U8932BRGSET : longWord;
    U2BRGINV : longWord;
    U8932BRGINV : longWord;
  end;
  TUART3_U39MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART3_U3MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART3_U39STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
  TUART3_U3STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
type
  TUART3Registers = record
    U39MODEbits : TUART3_U39MODE;
    U39MODE : longWord;
    U3MODEbits : TUART3_U3MODE;
    U3MODE : longWord;
    U39MODECLR : longWord;
    U3MODECLR : longWord;
    U39MODESET : longWord;
    U3MODESET : longWord;
    U39MODEINV : longWord;
    U3MODEINV : longWord;
    U39STAbits : TUART3_U39STA;
    U39STA : longWord;
    U3STAbits : TUART3_U3STA;
    U3STA : longWord;
    U39STACLR : longWord;
    U3STACLR : longWord;
    U39STASET : longWord;
    U3STASET : longWord;
    U39STAINV : longWord;
    U3STAINV : longWord;
    U39TXREG : longWord;
    U3TXREG : longWord;
    U39RXREG : longWord;
    U3RXREG : longWord;
    U39BRG : longWord;
    U3BRG : longWord;
    U39BRGCLR : longWord;
    U3BRGCLR : longWord;
    U39BRGSET : longWord;
    U3BRGSET : longWord;
    U39BRGINV : longWord;
    U3BRGINV : longWord;
  end;
  TUART4_U4MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART4_UodMODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART4_U4STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
  TUART4_UodSTA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
type
  TUART4Registers = record
    U4MODEbits : TUART4_U4MODE;
    U4MODE : longWord;
    UodMODEbits : TUART4_UodMODE;
    UodMODE : longWord;
    U4MODECLR : longWord;
    UodMODECLR : longWord;
    U4MODESET : longWord;
    UodMODESET : longWord;
    U4MODEINV : longWord;
    UodMODEINV : longWord;
    U4STAbits : TUART4_U4STA;
    U4STA : longWord;
    UodSTAbits : TUART4_UodSTA;
    UodSTA : longWord;
    U4STACLR : longWord;
    UodSTACLR : longWord;
    U4STASET : longWord;
    UodSTASET : longWord;
    U4STAINV : longWord;
    UodSTAINV : longWord;
    U4TXREG : longWord;
    UodTXREG : longWord;
    U4RXREG : longWord;
    UodRXREG : longWord;
    U4BRG : longWord;
    UodBRG : longWord;
    U4BRGCLR : longWord;
    UodBRGCLR : longWord;
    U4BRGSET : longWord;
    UodBRGSET : longWord;
    U4BRGINV : longWord;
    UodBRGINV : longWord;
  end;
  TPMP_PMCON = record
  private
    function  getADRMUX : TBits_2; inline;
    function  getADRMUX0 : TBits_1; inline;
    function  getADRMUX1 : TBits_1; inline;
    function  getALP : TBits_1; inline;
    function  getCS1P : TBits_1; inline;
    function  getCS2P : TBits_1; inline;
    function  getCSF : TBits_2; inline;
    function  getCSF0 : TBits_1; inline;
    function  getCSF1 : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPMPEN : TBits_1; inline;
    function  getPMPTTL : TBits_1; inline;
    function  getPSIDL : TBits_1; inline;
    function  getPTRDEN : TBits_1; inline;
    function  getPTWREN : TBits_1; inline;
    function  getRDSP : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getWRSP : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setADRMUX(thebits : TBits_2); inline;
    procedure setADRMUX0(thebits : TBits_1); inline;
    procedure setADRMUX1(thebits : TBits_1); inline;
    procedure setALP(thebits : TBits_1); inline;
    procedure setCS1P(thebits : TBits_1); inline;
    procedure setCS2P(thebits : TBits_1); inline;
    procedure setCSF(thebits : TBits_2); inline;
    procedure setCSF0(thebits : TBits_1); inline;
    procedure setCSF1(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPMPEN(thebits : TBits_1); inline;
    procedure setPMPTTL(thebits : TBits_1); inline;
    procedure setPSIDL(thebits : TBits_1); inline;
    procedure setPTRDEN(thebits : TBits_1); inline;
    procedure setPTWREN(thebits : TBits_1); inline;
    procedure setRDSP(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setWRSP(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADRMUX0; inline;
    procedure clearADRMUX1; inline;
    procedure clearALP; inline;
    procedure clearCS1P; inline;
    procedure clearCS2P; inline;
    procedure clearCSF0; inline;
    procedure clearCSF1; inline;
    procedure clearON; inline;
    procedure clearPMPEN; inline;
    procedure clearPMPTTL; inline;
    procedure clearPSIDL; inline;
    procedure clearPTRDEN; inline;
    procedure clearPTWREN; inline;
    procedure clearRDSP; inline;
    procedure clearSIDL; inline;
    procedure clearWRSP; inline;
    procedure setADRMUX0; inline;
    procedure setADRMUX1; inline;
    procedure setALP; inline;
    procedure setCS1P; inline;
    procedure setCS2P; inline;
    procedure setCSF0; inline;
    procedure setCSF1; inline;
    procedure setON; inline;
    procedure setPMPEN; inline;
    procedure setPMPTTL; inline;
    procedure setPSIDL; inline;
    procedure setPTRDEN; inline;
    procedure setPTWREN; inline;
    procedure setRDSP; inline;
    procedure setSIDL; inline;
    procedure setWRSP; inline;
    property ADRMUX : TBits_2 read getADRMUX write setADRMUX;
    property ADRMUX0 : TBits_1 read getADRMUX0 write setADRMUX0;
    property ADRMUX1 : TBits_1 read getADRMUX1 write setADRMUX1;
    property ALP : TBits_1 read getALP write setALP;
    property CS1P : TBits_1 read getCS1P write setCS1P;
    property CS2P : TBits_1 read getCS2P write setCS2P;
    property CSF : TBits_2 read getCSF write setCSF;
    property CSF0 : TBits_1 read getCSF0 write setCSF0;
    property CSF1 : TBits_1 read getCSF1 write setCSF1;
    property ON : TBits_1 read getON write setON;
    property PMPEN : TBits_1 read getPMPEN write setPMPEN;
    property PMPTTL : TBits_1 read getPMPTTL write setPMPTTL;
    property PSIDL : TBits_1 read getPSIDL write setPSIDL;
    property PTRDEN : TBits_1 read getPTRDEN write setPTRDEN;
    property PTWREN : TBits_1 read getPTWREN write setPTWREN;
    property RDSP : TBits_1 read getRDSP write setRDSP;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property WRSP : TBits_1 read getWRSP write setWRSP;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMMODE = record
  private
    function  getBUSY : TBits_1; inline;
    function  getINCM : TBits_2; inline;
    function  getINCM0 : TBits_1; inline;
    function  getINCM1 : TBits_1; inline;
    function  getIRQM : TBits_2; inline;
    function  getIRQM0 : TBits_1; inline;
    function  getIRQM1 : TBits_1; inline;
    function  getMODE : TBits_2; inline;
    function  getMODE0 : TBits_1; inline;
    function  getMODE1 : TBits_1; inline;
    function  getMODE16 : TBits_1; inline;
    function  getWAITB : TBits_2; inline;
    function  getWAITB0 : TBits_1; inline;
    function  getWAITB1 : TBits_1; inline;
    function  getWAITE : TBits_2; inline;
    function  getWAITE0 : TBits_1; inline;
    function  getWAITE1 : TBits_1; inline;
    function  getWAITM : TBits_4; inline;
    function  getWAITM0 : TBits_1; inline;
    function  getWAITM1 : TBits_1; inline;
    function  getWAITM2 : TBits_1; inline;
    function  getWAITM3 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBUSY(thebits : TBits_1); inline;
    procedure setINCM(thebits : TBits_2); inline;
    procedure setINCM0(thebits : TBits_1); inline;
    procedure setINCM1(thebits : TBits_1); inline;
    procedure setIRQM(thebits : TBits_2); inline;
    procedure setIRQM0(thebits : TBits_1); inline;
    procedure setIRQM1(thebits : TBits_1); inline;
    procedure setMODE(thebits : TBits_2); inline;
    procedure setMODE0(thebits : TBits_1); inline;
    procedure setMODE1(thebits : TBits_1); inline;
    procedure setMODE16(thebits : TBits_1); inline;
    procedure setWAITB(thebits : TBits_2); inline;
    procedure setWAITB0(thebits : TBits_1); inline;
    procedure setWAITB1(thebits : TBits_1); inline;
    procedure setWAITE(thebits : TBits_2); inline;
    procedure setWAITE0(thebits : TBits_1); inline;
    procedure setWAITE1(thebits : TBits_1); inline;
    procedure setWAITM(thebits : TBits_4); inline;
    procedure setWAITM0(thebits : TBits_1); inline;
    procedure setWAITM1(thebits : TBits_1); inline;
    procedure setWAITM2(thebits : TBits_1); inline;
    procedure setWAITM3(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBUSY; inline;
    procedure clearINCM0; inline;
    procedure clearINCM1; inline;
    procedure clearIRQM0; inline;
    procedure clearIRQM1; inline;
    procedure clearMODE0; inline;
    procedure clearMODE16; inline;
    procedure clearMODE1; inline;
    procedure clearWAITB0; inline;
    procedure clearWAITB1; inline;
    procedure clearWAITE0; inline;
    procedure clearWAITE1; inline;
    procedure clearWAITM0; inline;
    procedure clearWAITM1; inline;
    procedure clearWAITM2; inline;
    procedure clearWAITM3; inline;
    procedure setBUSY; inline;
    procedure setINCM0; inline;
    procedure setINCM1; inline;
    procedure setIRQM0; inline;
    procedure setIRQM1; inline;
    procedure setMODE0; inline;
    procedure setMODE16; inline;
    procedure setMODE1; inline;
    procedure setWAITB0; inline;
    procedure setWAITB1; inline;
    procedure setWAITE0; inline;
    procedure setWAITE1; inline;
    procedure setWAITM0; inline;
    procedure setWAITM1; inline;
    procedure setWAITM2; inline;
    procedure setWAITM3; inline;
    property BUSY : TBits_1 read getBUSY write setBUSY;
    property INCM : TBits_2 read getINCM write setINCM;
    property INCM0 : TBits_1 read getINCM0 write setINCM0;
    property INCM1 : TBits_1 read getINCM1 write setINCM1;
    property IRQM : TBits_2 read getIRQM write setIRQM;
    property IRQM0 : TBits_1 read getIRQM0 write setIRQM0;
    property IRQM1 : TBits_1 read getIRQM1 write setIRQM1;
    property MODE : TBits_2 read getMODE write setMODE;
    property MODE0 : TBits_1 read getMODE0 write setMODE0;
    property MODE1 : TBits_1 read getMODE1 write setMODE1;
    property MODE16 : TBits_1 read getMODE16 write setMODE16;
    property WAITB : TBits_2 read getWAITB write setWAITB;
    property WAITB0 : TBits_1 read getWAITB0 write setWAITB0;
    property WAITB1 : TBits_1 read getWAITB1 write setWAITB1;
    property WAITE : TBits_2 read getWAITE write setWAITE;
    property WAITE0 : TBits_1 read getWAITE0 write setWAITE0;
    property WAITE1 : TBits_1 read getWAITE1 write setWAITE1;
    property WAITM : TBits_4 read getWAITM write setWAITM;
    property WAITM0 : TBits_1 read getWAITM0 write setWAITM0;
    property WAITM1 : TBits_1 read getWAITM1 write setWAITM1;
    property WAITM2 : TBits_1 read getWAITM2 write setWAITM2;
    property WAITM3 : TBits_1 read getWAITM3 write setWAITM3;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMADDR = record
  private
    function  getADDR : TBits_14; inline;
    function  getCS : TBits_2; inline;
    function  getCS1 : TBits_1; inline;
    function  getCS2 : TBits_1; inline;
    function  getPADDR : TBits_14; inline;
    function  getw : TBits_32; inline;
    procedure setADDR(thebits : TBits_14); inline;
    procedure setCS(thebits : TBits_2); inline;
    procedure setCS1(thebits : TBits_1); inline;
    procedure setCS2(thebits : TBits_1); inline;
    procedure setPADDR(thebits : TBits_14); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCS1; inline;
    procedure clearCS2; inline;
    procedure setCS1; inline;
    procedure setCS2; inline;
    property ADDR : TBits_14 read getADDR write setADDR;
    property CS : TBits_2 read getCS write setCS;
    property CS1 : TBits_1 read getCS1 write setCS1;
    property CS2 : TBits_1 read getCS2 write setCS2;
    property PADDR : TBits_14 read getPADDR write setPADDR;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMDOUT = record
  private
    function  getDATAOUT : TBits_32; inline;
    function  getw : TBits_32; inline;
    procedure setDATAOUT(thebits : TBits_32); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DATAOUT : TBits_32 read getDATAOUT write setDATAOUT;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMDIN = record
  private
    function  getDATAIN : TBits_32; inline;
    function  getw : TBits_32; inline;
    procedure setDATAIN(thebits : TBits_32); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DATAIN : TBits_32 read getDATAIN write setDATAIN;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMAEN = record
  private
    function  getPTEN : TBits_16; inline;
    function  getPTEN0 : TBits_1; inline;
    function  getPTEN1 : TBits_1; inline;
    function  getPTEN10 : TBits_1; inline;
    function  getPTEN11 : TBits_1; inline;
    function  getPTEN12 : TBits_1; inline;
    function  getPTEN13 : TBits_1; inline;
    function  getPTEN14 : TBits_1; inline;
    function  getPTEN15 : TBits_1; inline;
    function  getPTEN2 : TBits_1; inline;
    function  getPTEN3 : TBits_1; inline;
    function  getPTEN4 : TBits_1; inline;
    function  getPTEN5 : TBits_1; inline;
    function  getPTEN6 : TBits_1; inline;
    function  getPTEN7 : TBits_1; inline;
    function  getPTEN8 : TBits_1; inline;
    function  getPTEN9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setPTEN(thebits : TBits_16); inline;
    procedure setPTEN0(thebits : TBits_1); inline;
    procedure setPTEN1(thebits : TBits_1); inline;
    procedure setPTEN10(thebits : TBits_1); inline;
    procedure setPTEN11(thebits : TBits_1); inline;
    procedure setPTEN12(thebits : TBits_1); inline;
    procedure setPTEN13(thebits : TBits_1); inline;
    procedure setPTEN14(thebits : TBits_1); inline;
    procedure setPTEN15(thebits : TBits_1); inline;
    procedure setPTEN2(thebits : TBits_1); inline;
    procedure setPTEN3(thebits : TBits_1); inline;
    procedure setPTEN4(thebits : TBits_1); inline;
    procedure setPTEN5(thebits : TBits_1); inline;
    procedure setPTEN6(thebits : TBits_1); inline;
    procedure setPTEN7(thebits : TBits_1); inline;
    procedure setPTEN8(thebits : TBits_1); inline;
    procedure setPTEN9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearPTEN0; inline;
    procedure clearPTEN10; inline;
    procedure clearPTEN11; inline;
    procedure clearPTEN12; inline;
    procedure clearPTEN13; inline;
    procedure clearPTEN14; inline;
    procedure clearPTEN15; inline;
    procedure clearPTEN1; inline;
    procedure clearPTEN2; inline;
    procedure clearPTEN3; inline;
    procedure clearPTEN4; inline;
    procedure clearPTEN5; inline;
    procedure clearPTEN6; inline;
    procedure clearPTEN7; inline;
    procedure clearPTEN8; inline;
    procedure clearPTEN9; inline;
    procedure setPTEN0; inline;
    procedure setPTEN10; inline;
    procedure setPTEN11; inline;
    procedure setPTEN12; inline;
    procedure setPTEN13; inline;
    procedure setPTEN14; inline;
    procedure setPTEN15; inline;
    procedure setPTEN1; inline;
    procedure setPTEN2; inline;
    procedure setPTEN3; inline;
    procedure setPTEN4; inline;
    procedure setPTEN5; inline;
    procedure setPTEN6; inline;
    procedure setPTEN7; inline;
    procedure setPTEN8; inline;
    procedure setPTEN9; inline;
    property PTEN : TBits_16 read getPTEN write setPTEN;
    property PTEN0 : TBits_1 read getPTEN0 write setPTEN0;
    property PTEN1 : TBits_1 read getPTEN1 write setPTEN1;
    property PTEN10 : TBits_1 read getPTEN10 write setPTEN10;
    property PTEN11 : TBits_1 read getPTEN11 write setPTEN11;
    property PTEN12 : TBits_1 read getPTEN12 write setPTEN12;
    property PTEN13 : TBits_1 read getPTEN13 write setPTEN13;
    property PTEN14 : TBits_1 read getPTEN14 write setPTEN14;
    property PTEN15 : TBits_1 read getPTEN15 write setPTEN15;
    property PTEN2 : TBits_1 read getPTEN2 write setPTEN2;
    property PTEN3 : TBits_1 read getPTEN3 write setPTEN3;
    property PTEN4 : TBits_1 read getPTEN4 write setPTEN4;
    property PTEN5 : TBits_1 read getPTEN5 write setPTEN5;
    property PTEN6 : TBits_1 read getPTEN6 write setPTEN6;
    property PTEN7 : TBits_1 read getPTEN7 write setPTEN7;
    property PTEN8 : TBits_1 read getPTEN8 write setPTEN8;
    property PTEN9 : TBits_1 read getPTEN9 write setPTEN9;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMSTAT = record
  private
    function  getIB0F : TBits_1; inline;
    function  getIB1F : TBits_1; inline;
    function  getIB2F : TBits_1; inline;
    function  getIB3F : TBits_1; inline;
    function  getIBF : TBits_1; inline;
    function  getIBOV : TBits_1; inline;
    function  getOB0E : TBits_1; inline;
    function  getOB1E : TBits_1; inline;
    function  getOB2E : TBits_1; inline;
    function  getOB3E : TBits_1; inline;
    function  getOBE : TBits_1; inline;
    function  getOBUF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setIB0F(thebits : TBits_1); inline;
    procedure setIB1F(thebits : TBits_1); inline;
    procedure setIB2F(thebits : TBits_1); inline;
    procedure setIB3F(thebits : TBits_1); inline;
    procedure setIBF(thebits : TBits_1); inline;
    procedure setIBOV(thebits : TBits_1); inline;
    procedure setOB0E(thebits : TBits_1); inline;
    procedure setOB1E(thebits : TBits_1); inline;
    procedure setOB2E(thebits : TBits_1); inline;
    procedure setOB3E(thebits : TBits_1); inline;
    procedure setOBE(thebits : TBits_1); inline;
    procedure setOBUF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearIB0F; inline;
    procedure clearIB1F; inline;
    procedure clearIB2F; inline;
    procedure clearIB3F; inline;
    procedure clearIBF; inline;
    procedure clearIBOV; inline;
    procedure clearOB0E; inline;
    procedure clearOB1E; inline;
    procedure clearOB2E; inline;
    procedure clearOB3E; inline;
    procedure clearOBE; inline;
    procedure clearOBUF; inline;
    procedure setIB0F; inline;
    procedure setIB1F; inline;
    procedure setIB2F; inline;
    procedure setIB3F; inline;
    procedure setIBF; inline;
    procedure setIBOV; inline;
    procedure setOB0E; inline;
    procedure setOB1E; inline;
    procedure setOB2E; inline;
    procedure setOB3E; inline;
    procedure setOBE; inline;
    procedure setOBUF; inline;
    property IB0F : TBits_1 read getIB0F write setIB0F;
    property IB1F : TBits_1 read getIB1F write setIB1F;
    property IB2F : TBits_1 read getIB2F write setIB2F;
    property IB3F : TBits_1 read getIB3F write setIB3F;
    property IBF : TBits_1 read getIBF write setIBF;
    property IBOV : TBits_1 read getIBOV write setIBOV;
    property OB0E : TBits_1 read getOB0E write setOB0E;
    property OB1E : TBits_1 read getOB1E write setOB1E;
    property OB2E : TBits_1 read getOB2E write setOB2E;
    property OB3E : TBits_1 read getOB3E write setOB3E;
    property OBE : TBits_1 read getOBE write setOBE;
    property OBUF : TBits_1 read getOBUF write setOBUF;
    property w : TBits_32 read getw write setw;
  end;
type
  TPMPRegisters = record
    PMCONbits : TPMP_PMCON;
    PMCON : longWord;
    PMCONCLR : longWord;
    PMCONSET : longWord;
    PMCONINV : longWord;
    PMMODEbits : TPMP_PMMODE;
    PMMODE : longWord;
    PMMODECLR : longWord;
    PMMODESET : longWord;
    PMMODEINV : longWord;
    PMADDRbits : TPMP_PMADDR;
    PMADDR : longWord;
    PMADDRCLR : longWord;
    PMADDRSET : longWord;
    PMADDRINV : longWord;
    PMDOUTbits : TPMP_PMDOUT;
    PMDOUT : longWord;
    PMDOUTCLR : longWord;
    PMDOUTSET : longWord;
    PMDOUTINV : longWord;
    PMDINbits : TPMP_PMDIN;
    PMDIN : longWord;
    PMDINCLR : longWord;
    PMDINSET : longWord;
    PMDININV : longWord;
    PMAENbits : TPMP_PMAEN;
    PMAEN : longWord;
    PMAENCLR : longWord;
    PMAENSET : longWord;
    PMAENINV : longWord;
    PMSTATbits : TPMP_PMSTAT;
    PMSTAT : longWord;
    PMSTATCLR : longWord;
    PMSTATSET : longWord;
    PMSTATINV : longWord;
  end;
  TADC10_AD1CON1 = record
  private
    function  getADON : TBits_1; inline;
    function  getADSIDL : TBits_1; inline;
    function  getASAM : TBits_1; inline;
    function  getCLRASAM : TBits_1; inline;
    function  getDONE : TBits_1; inline;
    function  getFORM : TBits_3; inline;
    function  getFORM0 : TBits_1; inline;
    function  getFORM1 : TBits_1; inline;
    function  getFORM2 : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSAMP : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSSRC : TBits_3; inline;
    function  getSSRC0 : TBits_1; inline;
    function  getSSRC1 : TBits_1; inline;
    function  getSSRC2 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setADON(thebits : TBits_1); inline;
    procedure setADSIDL(thebits : TBits_1); inline;
    procedure setASAM(thebits : TBits_1); inline;
    procedure setCLRASAM(thebits : TBits_1); inline;
    procedure setDONE(thebits : TBits_1); inline;
    procedure setFORM(thebits : TBits_3); inline;
    procedure setFORM0(thebits : TBits_1); inline;
    procedure setFORM1(thebits : TBits_1); inline;
    procedure setFORM2(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSAMP(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSSRC(thebits : TBits_3); inline;
    procedure setSSRC0(thebits : TBits_1); inline;
    procedure setSSRC1(thebits : TBits_1); inline;
    procedure setSSRC2(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADON; inline;
    procedure clearADSIDL; inline;
    procedure clearASAM; inline;
    procedure clearCLRASAM; inline;
    procedure clearDONE; inline;
    procedure clearFORM0; inline;
    procedure clearFORM1; inline;
    procedure clearFORM2; inline;
    procedure clearON; inline;
    procedure clearSAMP; inline;
    procedure clearSIDL; inline;
    procedure clearSSRC0; inline;
    procedure clearSSRC1; inline;
    procedure clearSSRC2; inline;
    procedure setADON; inline;
    procedure setADSIDL; inline;
    procedure setASAM; inline;
    procedure setCLRASAM; inline;
    procedure setDONE; inline;
    procedure setFORM0; inline;
    procedure setFORM1; inline;
    procedure setFORM2; inline;
    procedure setON; inline;
    procedure setSAMP; inline;
    procedure setSIDL; inline;
    procedure setSSRC0; inline;
    procedure setSSRC1; inline;
    procedure setSSRC2; inline;
    property ADON : TBits_1 read getADON write setADON;
    property ADSIDL : TBits_1 read getADSIDL write setADSIDL;
    property ASAM : TBits_1 read getASAM write setASAM;
    property CLRASAM : TBits_1 read getCLRASAM write setCLRASAM;
    property DONE : TBits_1 read getDONE write setDONE;
    property FORM : TBits_3 read getFORM write setFORM;
    property FORM0 : TBits_1 read getFORM0 write setFORM0;
    property FORM1 : TBits_1 read getFORM1 write setFORM1;
    property FORM2 : TBits_1 read getFORM2 write setFORM2;
    property ON : TBits_1 read getON write setON;
    property SAMP : TBits_1 read getSAMP write setSAMP;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SSRC : TBits_3 read getSSRC write setSSRC;
    property SSRC0 : TBits_1 read getSSRC0 write setSSRC0;
    property SSRC1 : TBits_1 read getSSRC1 write setSSRC1;
    property SSRC2 : TBits_1 read getSSRC2 write setSSRC2;
    property w : TBits_32 read getw write setw;
  end;
  TADC10_AD1CON2 = record
  private
    function  getALTS : TBits_1; inline;
    function  getBUFM : TBits_1; inline;
    function  getBUFS : TBits_1; inline;
    function  getCSCNA : TBits_1; inline;
    function  getOFFCAL : TBits_1; inline;
    function  getSMPI : TBits_4; inline;
    function  getSMPI0 : TBits_1; inline;
    function  getSMPI1 : TBits_1; inline;
    function  getSMPI2 : TBits_1; inline;
    function  getSMPI3 : TBits_1; inline;
    function  getVCFG : TBits_3; inline;
    function  getVCFG0 : TBits_1; inline;
    function  getVCFG1 : TBits_1; inline;
    function  getVCFG2 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setALTS(thebits : TBits_1); inline;
    procedure setBUFM(thebits : TBits_1); inline;
    procedure setBUFS(thebits : TBits_1); inline;
    procedure setCSCNA(thebits : TBits_1); inline;
    procedure setOFFCAL(thebits : TBits_1); inline;
    procedure setSMPI(thebits : TBits_4); inline;
    procedure setSMPI0(thebits : TBits_1); inline;
    procedure setSMPI1(thebits : TBits_1); inline;
    procedure setSMPI2(thebits : TBits_1); inline;
    procedure setSMPI3(thebits : TBits_1); inline;
    procedure setVCFG(thebits : TBits_3); inline;
    procedure setVCFG0(thebits : TBits_1); inline;
    procedure setVCFG1(thebits : TBits_1); inline;
    procedure setVCFG2(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearALTS; inline;
    procedure clearBUFM; inline;
    procedure clearBUFS; inline;
    procedure clearCSCNA; inline;
    procedure clearOFFCAL; inline;
    procedure clearSMPI0; inline;
    procedure clearSMPI1; inline;
    procedure clearSMPI2; inline;
    procedure clearSMPI3; inline;
    procedure clearVCFG0; inline;
    procedure clearVCFG1; inline;
    procedure clearVCFG2; inline;
    procedure setALTS; inline;
    procedure setBUFM; inline;
    procedure setBUFS; inline;
    procedure setCSCNA; inline;
    procedure setOFFCAL; inline;
    procedure setSMPI0; inline;
    procedure setSMPI1; inline;
    procedure setSMPI2; inline;
    procedure setSMPI3; inline;
    procedure setVCFG0; inline;
    procedure setVCFG1; inline;
    procedure setVCFG2; inline;
    property ALTS : TBits_1 read getALTS write setALTS;
    property BUFM : TBits_1 read getBUFM write setBUFM;
    property BUFS : TBits_1 read getBUFS write setBUFS;
    property CSCNA : TBits_1 read getCSCNA write setCSCNA;
    property OFFCAL : TBits_1 read getOFFCAL write setOFFCAL;
    property SMPI : TBits_4 read getSMPI write setSMPI;
    property SMPI0 : TBits_1 read getSMPI0 write setSMPI0;
    property SMPI1 : TBits_1 read getSMPI1 write setSMPI1;
    property SMPI2 : TBits_1 read getSMPI2 write setSMPI2;
    property SMPI3 : TBits_1 read getSMPI3 write setSMPI3;
    property VCFG : TBits_3 read getVCFG write setVCFG;
    property VCFG0 : TBits_1 read getVCFG0 write setVCFG0;
    property VCFG1 : TBits_1 read getVCFG1 write setVCFG1;
    property VCFG2 : TBits_1 read getVCFG2 write setVCFG2;
    property w : TBits_32 read getw write setw;
  end;
  TADC10_AD1CON3 = record
  private
    function  getADCS : TBits_8; inline;
    function  getADCS0 : TBits_1; inline;
    function  getADCS1 : TBits_1; inline;
    function  getADCS2 : TBits_1; inline;
    function  getADCS3 : TBits_1; inline;
    function  getADCS4 : TBits_1; inline;
    function  getADCS5 : TBits_1; inline;
    function  getADCS6 : TBits_1; inline;
    function  getADCS7 : TBits_1; inline;
    function  getADRC : TBits_1; inline;
    function  getSAMC : TBits_5; inline;
    function  getSAMC0 : TBits_1; inline;
    function  getSAMC1 : TBits_1; inline;
    function  getSAMC2 : TBits_1; inline;
    function  getSAMC3 : TBits_1; inline;
    function  getSAMC4 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setADCS(thebits : TBits_8); inline;
    procedure setADCS0(thebits : TBits_1); inline;
    procedure setADCS1(thebits : TBits_1); inline;
    procedure setADCS2(thebits : TBits_1); inline;
    procedure setADCS3(thebits : TBits_1); inline;
    procedure setADCS4(thebits : TBits_1); inline;
    procedure setADCS5(thebits : TBits_1); inline;
    procedure setADCS6(thebits : TBits_1); inline;
    procedure setADCS7(thebits : TBits_1); inline;
    procedure setADRC(thebits : TBits_1); inline;
    procedure setSAMC(thebits : TBits_5); inline;
    procedure setSAMC0(thebits : TBits_1); inline;
    procedure setSAMC1(thebits : TBits_1); inline;
    procedure setSAMC2(thebits : TBits_1); inline;
    procedure setSAMC3(thebits : TBits_1); inline;
    procedure setSAMC4(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADCS0; inline;
    procedure clearADCS1; inline;
    procedure clearADCS2; inline;
    procedure clearADCS3; inline;
    procedure clearADCS4; inline;
    procedure clearADCS5; inline;
    procedure clearADCS6; inline;
    procedure clearADCS7; inline;
    procedure clearADRC; inline;
    procedure clearSAMC0; inline;
    procedure clearSAMC1; inline;
    procedure clearSAMC2; inline;
    procedure clearSAMC3; inline;
    procedure clearSAMC4; inline;
    procedure setADCS0; inline;
    procedure setADCS1; inline;
    procedure setADCS2; inline;
    procedure setADCS3; inline;
    procedure setADCS4; inline;
    procedure setADCS5; inline;
    procedure setADCS6; inline;
    procedure setADCS7; inline;
    procedure setADRC; inline;
    procedure setSAMC0; inline;
    procedure setSAMC1; inline;
    procedure setSAMC2; inline;
    procedure setSAMC3; inline;
    procedure setSAMC4; inline;
    property ADCS : TBits_8 read getADCS write setADCS;
    property ADCS0 : TBits_1 read getADCS0 write setADCS0;
    property ADCS1 : TBits_1 read getADCS1 write setADCS1;
    property ADCS2 : TBits_1 read getADCS2 write setADCS2;
    property ADCS3 : TBits_1 read getADCS3 write setADCS3;
    property ADCS4 : TBits_1 read getADCS4 write setADCS4;
    property ADCS5 : TBits_1 read getADCS5 write setADCS5;
    property ADCS6 : TBits_1 read getADCS6 write setADCS6;
    property ADCS7 : TBits_1 read getADCS7 write setADCS7;
    property ADRC : TBits_1 read getADRC write setADRC;
    property SAMC : TBits_5 read getSAMC write setSAMC;
    property SAMC0 : TBits_1 read getSAMC0 write setSAMC0;
    property SAMC1 : TBits_1 read getSAMC1 write setSAMC1;
    property SAMC2 : TBits_1 read getSAMC2 write setSAMC2;
    property SAMC3 : TBits_1 read getSAMC3 write setSAMC3;
    property SAMC4 : TBits_1 read getSAMC4 write setSAMC4;
    property w : TBits_32 read getw write setw;
  end;
  TADC10_AD1CHS = record
  private
    function  getCH0NA : TBits_1; inline;
    function  getCH0NB : TBits_1; inline;
    function  getCH0SA : TBits_5; inline;
    function  getCH0SA0 : TBits_1; inline;
    function  getCH0SA1 : TBits_1; inline;
    function  getCH0SA2 : TBits_1; inline;
    function  getCH0SA3 : TBits_1; inline;
    function  getCH0SA4 : TBits_1; inline;
    function  getCH0SB : TBits_5; inline;
    function  getCH0SB0 : TBits_1; inline;
    function  getCH0SB1 : TBits_1; inline;
    function  getCH0SB2 : TBits_1; inline;
    function  getCH0SB3 : TBits_1; inline;
    function  getCH0SB4 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCH0NA(thebits : TBits_1); inline;
    procedure setCH0NB(thebits : TBits_1); inline;
    procedure setCH0SA(thebits : TBits_5); inline;
    procedure setCH0SA0(thebits : TBits_1); inline;
    procedure setCH0SA1(thebits : TBits_1); inline;
    procedure setCH0SA2(thebits : TBits_1); inline;
    procedure setCH0SA3(thebits : TBits_1); inline;
    procedure setCH0SA4(thebits : TBits_1); inline;
    procedure setCH0SB(thebits : TBits_5); inline;
    procedure setCH0SB0(thebits : TBits_1); inline;
    procedure setCH0SB1(thebits : TBits_1); inline;
    procedure setCH0SB2(thebits : TBits_1); inline;
    procedure setCH0SB3(thebits : TBits_1); inline;
    procedure setCH0SB4(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCH0NA; inline;
    procedure clearCH0NB; inline;
    procedure clearCH0SA0; inline;
    procedure clearCH0SA1; inline;
    procedure clearCH0SA2; inline;
    procedure clearCH0SA3; inline;
    procedure clearCH0SA4; inline;
    procedure clearCH0SB0; inline;
    procedure clearCH0SB1; inline;
    procedure clearCH0SB2; inline;
    procedure clearCH0SB3; inline;
    procedure clearCH0SB4; inline;
    procedure setCH0NA; inline;
    procedure setCH0NB; inline;
    procedure setCH0SA0; inline;
    procedure setCH0SA1; inline;
    procedure setCH0SA2; inline;
    procedure setCH0SA3; inline;
    procedure setCH0SA4; inline;
    procedure setCH0SB0; inline;
    procedure setCH0SB1; inline;
    procedure setCH0SB2; inline;
    procedure setCH0SB3; inline;
    procedure setCH0SB4; inline;
    property CH0NA : TBits_1 read getCH0NA write setCH0NA;
    property CH0NB : TBits_1 read getCH0NB write setCH0NB;
    property CH0SA : TBits_5 read getCH0SA write setCH0SA;
    property CH0SA0 : TBits_1 read getCH0SA0 write setCH0SA0;
    property CH0SA1 : TBits_1 read getCH0SA1 write setCH0SA1;
    property CH0SA2 : TBits_1 read getCH0SA2 write setCH0SA2;
    property CH0SA3 : TBits_1 read getCH0SA3 write setCH0SA3;
    property CH0SA4 : TBits_1 read getCH0SA4 write setCH0SA4;
    property CH0SB : TBits_5 read getCH0SB write setCH0SB;
    property CH0SB0 : TBits_1 read getCH0SB0 write setCH0SB0;
    property CH0SB1 : TBits_1 read getCH0SB1 write setCH0SB1;
    property CH0SB2 : TBits_1 read getCH0SB2 write setCH0SB2;
    property CH0SB3 : TBits_1 read getCH0SB3 write setCH0SB3;
    property CH0SB4 : TBits_1 read getCH0SB4 write setCH0SB4;
    property w : TBits_32 read getw write setw;
  end;
  TADC10_AD1CSSL = record
  private
    function  getCSSL : TBits_31; inline;
    function  getCSSL0 : TBits_1; inline;
    function  getCSSL1 : TBits_1; inline;
    function  getCSSL10 : TBits_1; inline;
    function  getCSSL11 : TBits_1; inline;
    function  getCSSL12 : TBits_1; inline;
    function  getCSSL13 : TBits_1; inline;
    function  getCSSL14 : TBits_1; inline;
    function  getCSSL15 : TBits_1; inline;
    function  getCSSL16 : TBits_1; inline;
    function  getCSSL17 : TBits_1; inline;
    function  getCSSL18 : TBits_1; inline;
    function  getCSSL19 : TBits_1; inline;
    function  getCSSL2 : TBits_1; inline;
    function  getCSSL20 : TBits_1; inline;
    function  getCSSL21 : TBits_1; inline;
    function  getCSSL22 : TBits_1; inline;
    function  getCSSL23 : TBits_1; inline;
    function  getCSSL24 : TBits_1; inline;
    function  getCSSL25 : TBits_1; inline;
    function  getCSSL26 : TBits_1; inline;
    function  getCSSL27 : TBits_1; inline;
    function  getCSSL28 : TBits_1; inline;
    function  getCSSL29 : TBits_1; inline;
    function  getCSSL3 : TBits_1; inline;
    function  getCSSL30 : TBits_1; inline;
    function  getCSSL4 : TBits_1; inline;
    function  getCSSL5 : TBits_1; inline;
    function  getCSSL6 : TBits_1; inline;
    function  getCSSL7 : TBits_1; inline;
    function  getCSSL8 : TBits_1; inline;
    function  getCSSL9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCSSL(thebits : TBits_31); inline;
    procedure setCSSL0(thebits : TBits_1); inline;
    procedure setCSSL1(thebits : TBits_1); inline;
    procedure setCSSL10(thebits : TBits_1); inline;
    procedure setCSSL11(thebits : TBits_1); inline;
    procedure setCSSL12(thebits : TBits_1); inline;
    procedure setCSSL13(thebits : TBits_1); inline;
    procedure setCSSL14(thebits : TBits_1); inline;
    procedure setCSSL15(thebits : TBits_1); inline;
    procedure setCSSL16(thebits : TBits_1); inline;
    procedure setCSSL17(thebits : TBits_1); inline;
    procedure setCSSL18(thebits : TBits_1); inline;
    procedure setCSSL19(thebits : TBits_1); inline;
    procedure setCSSL2(thebits : TBits_1); inline;
    procedure setCSSL20(thebits : TBits_1); inline;
    procedure setCSSL21(thebits : TBits_1); inline;
    procedure setCSSL22(thebits : TBits_1); inline;
    procedure setCSSL23(thebits : TBits_1); inline;
    procedure setCSSL24(thebits : TBits_1); inline;
    procedure setCSSL25(thebits : TBits_1); inline;
    procedure setCSSL26(thebits : TBits_1); inline;
    procedure setCSSL27(thebits : TBits_1); inline;
    procedure setCSSL28(thebits : TBits_1); inline;
    procedure setCSSL29(thebits : TBits_1); inline;
    procedure setCSSL3(thebits : TBits_1); inline;
    procedure setCSSL30(thebits : TBits_1); inline;
    procedure setCSSL4(thebits : TBits_1); inline;
    procedure setCSSL5(thebits : TBits_1); inline;
    procedure setCSSL6(thebits : TBits_1); inline;
    procedure setCSSL7(thebits : TBits_1); inline;
    procedure setCSSL8(thebits : TBits_1); inline;
    procedure setCSSL9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCSSL0; inline;
    procedure clearCSSL10; inline;
    procedure clearCSSL11; inline;
    procedure clearCSSL12; inline;
    procedure clearCSSL13; inline;
    procedure clearCSSL14; inline;
    procedure clearCSSL15; inline;
    procedure clearCSSL16; inline;
    procedure clearCSSL17; inline;
    procedure clearCSSL18; inline;
    procedure clearCSSL19; inline;
    procedure clearCSSL1; inline;
    procedure clearCSSL20; inline;
    procedure clearCSSL21; inline;
    procedure clearCSSL22; inline;
    procedure clearCSSL23; inline;
    procedure clearCSSL24; inline;
    procedure clearCSSL25; inline;
    procedure clearCSSL26; inline;
    procedure clearCSSL27; inline;
    procedure clearCSSL28; inline;
    procedure clearCSSL29; inline;
    procedure clearCSSL2; inline;
    procedure clearCSSL30; inline;
    procedure clearCSSL3; inline;
    procedure clearCSSL4; inline;
    procedure clearCSSL5; inline;
    procedure clearCSSL6; inline;
    procedure clearCSSL7; inline;
    procedure clearCSSL8; inline;
    procedure clearCSSL9; inline;
    procedure setCSSL0; inline;
    procedure setCSSL10; inline;
    procedure setCSSL11; inline;
    procedure setCSSL12; inline;
    procedure setCSSL13; inline;
    procedure setCSSL14; inline;
    procedure setCSSL15; inline;
    procedure setCSSL16; inline;
    procedure setCSSL17; inline;
    procedure setCSSL18; inline;
    procedure setCSSL19; inline;
    procedure setCSSL1; inline;
    procedure setCSSL20; inline;
    procedure setCSSL21; inline;
    procedure setCSSL22; inline;
    procedure setCSSL23; inline;
    procedure setCSSL24; inline;
    procedure setCSSL25; inline;
    procedure setCSSL26; inline;
    procedure setCSSL27; inline;
    procedure setCSSL28; inline;
    procedure setCSSL29; inline;
    procedure setCSSL2; inline;
    procedure setCSSL30; inline;
    procedure setCSSL3; inline;
    procedure setCSSL4; inline;
    procedure setCSSL5; inline;
    procedure setCSSL6; inline;
    procedure setCSSL7; inline;
    procedure setCSSL8; inline;
    procedure setCSSL9; inline;
    property CSSL : TBits_31 read getCSSL write setCSSL;
    property CSSL0 : TBits_1 read getCSSL0 write setCSSL0;
    property CSSL1 : TBits_1 read getCSSL1 write setCSSL1;
    property CSSL10 : TBits_1 read getCSSL10 write setCSSL10;
    property CSSL11 : TBits_1 read getCSSL11 write setCSSL11;
    property CSSL12 : TBits_1 read getCSSL12 write setCSSL12;
    property CSSL13 : TBits_1 read getCSSL13 write setCSSL13;
    property CSSL14 : TBits_1 read getCSSL14 write setCSSL14;
    property CSSL15 : TBits_1 read getCSSL15 write setCSSL15;
    property CSSL16 : TBits_1 read getCSSL16 write setCSSL16;
    property CSSL17 : TBits_1 read getCSSL17 write setCSSL17;
    property CSSL18 : TBits_1 read getCSSL18 write setCSSL18;
    property CSSL19 : TBits_1 read getCSSL19 write setCSSL19;
    property CSSL2 : TBits_1 read getCSSL2 write setCSSL2;
    property CSSL20 : TBits_1 read getCSSL20 write setCSSL20;
    property CSSL21 : TBits_1 read getCSSL21 write setCSSL21;
    property CSSL22 : TBits_1 read getCSSL22 write setCSSL22;
    property CSSL23 : TBits_1 read getCSSL23 write setCSSL23;
    property CSSL24 : TBits_1 read getCSSL24 write setCSSL24;
    property CSSL25 : TBits_1 read getCSSL25 write setCSSL25;
    property CSSL26 : TBits_1 read getCSSL26 write setCSSL26;
    property CSSL27 : TBits_1 read getCSSL27 write setCSSL27;
    property CSSL28 : TBits_1 read getCSSL28 write setCSSL28;
    property CSSL29 : TBits_1 read getCSSL29 write setCSSL29;
    property CSSL3 : TBits_1 read getCSSL3 write setCSSL3;
    property CSSL30 : TBits_1 read getCSSL30 write setCSSL30;
    property CSSL4 : TBits_1 read getCSSL4 write setCSSL4;
    property CSSL5 : TBits_1 read getCSSL5 write setCSSL5;
    property CSSL6 : TBits_1 read getCSSL6 write setCSSL6;
    property CSSL7 : TBits_1 read getCSSL7 write setCSSL7;
    property CSSL8 : TBits_1 read getCSSL8 write setCSSL8;
    property CSSL9 : TBits_1 read getCSSL9 write setCSSL9;
    property w : TBits_32 read getw write setw;
  end;
type
  TADC10Registers = record
    AD1CON1bits : TADC10_AD1CON1;
    AD1CON1 : longWord;
    AD1CON1CLR : longWord;
    AD1CON1SET : longWord;
    AD1CON1INV : longWord;
    AD1CON2bits : TADC10_AD1CON2;
    AD1CON2 : longWord;
    AD1CON2CLR : longWord;
    AD1CON2SET : longWord;
    AD1CON2INV : longWord;
    AD1CON3bits : TADC10_AD1CON3;
    AD1CON3 : longWord;
    AD1CON3CLR : longWord;
    AD1CON3SET : longWord;
    AD1CON3INV : longWord;
    AD1CHSbits : TADC10_AD1CHS;
    AD1CHS : longWord;
    AD1CHSCLR : longWord;
    AD1CHSSET : longWord;
    AD1CHSINV : longWord;
    AD1CSSLbits : TADC10_AD1CSSL;
    AD1CSSL : longWord;
    AD1CSSLCLR : longWord;
    AD1CSSLSET : longWord;
    AD1CSSLINV : longWord;
    ADC1BUF0 : longWord;
    ADC1BUF1 : longWord;
    ADC1BUF2 : longWord;
    ADC1BUF3 : longWord;
    ADC1BUF4 : longWord;
    ADC1BUF5 : longWord;
    ADC1BUF6 : longWord;
    ADC1BUF7 : longWord;
    ADC1BUF8 : longWord;
    ADC1BUF9 : longWord;
    ADC1BUFA : longWord;
    ADC1BUFB : longWord;
    ADC1BUFC : longWord;
    ADC1BUFD : longWord;
    ADC1BUFE : longWord;
    ADC1BUFF : longWord;
  end;
  TCVR_CVRCON = record
  private
    function  getCVR : TBits_4; inline;
    function  getCVR0 : TBits_1; inline;
    function  getCVR1 : TBits_1; inline;
    function  getCVR2 : TBits_1; inline;
    function  getCVR3 : TBits_1; inline;
    function  getCVROE : TBits_1; inline;
    function  getCVRR : TBits_1; inline;
    function  getCVRSS : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCVR(thebits : TBits_4); inline;
    procedure setCVR0(thebits : TBits_1); inline;
    procedure setCVR1(thebits : TBits_1); inline;
    procedure setCVR2(thebits : TBits_1); inline;
    procedure setCVR3(thebits : TBits_1); inline;
    procedure setCVROE(thebits : TBits_1); inline;
    procedure setCVRR(thebits : TBits_1); inline;
    procedure setCVRSS(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCVR0; inline;
    procedure clearCVR1; inline;
    procedure clearCVR2; inline;
    procedure clearCVR3; inline;
    procedure clearCVROE; inline;
    procedure clearCVRR; inline;
    procedure clearCVRSS; inline;
    procedure clearON; inline;
    procedure setCVR0; inline;
    procedure setCVR1; inline;
    procedure setCVR2; inline;
    procedure setCVR3; inline;
    procedure setCVROE; inline;
    procedure setCVRR; inline;
    procedure setCVRSS; inline;
    procedure setON; inline;
    property CVR : TBits_4 read getCVR write setCVR;
    property CVR0 : TBits_1 read getCVR0 write setCVR0;
    property CVR1 : TBits_1 read getCVR1 write setCVR1;
    property CVR2 : TBits_1 read getCVR2 write setCVR2;
    property CVR3 : TBits_1 read getCVR3 write setCVR3;
    property CVROE : TBits_1 read getCVROE write setCVROE;
    property CVRR : TBits_1 read getCVRR write setCVRR;
    property CVRSS : TBits_1 read getCVRSS write setCVRSS;
    property ON : TBits_1 read getON write setON;
    property w : TBits_32 read getw write setw;
  end;
type
  TCVRRegisters = record
    CVRCONbits : TCVR_CVRCON;
    CVRCON : longWord;
    CVRCONCLR : longWord;
    CVRCONSET : longWord;
    CVRCONINV : longWord;
  end;
  TCMP_CM1CON = record
  private
    function  getCCH : TBits_2; inline;
    function  getCCH0 : TBits_1; inline;
    function  getCCH1 : TBits_1; inline;
    function  getCOE : TBits_1; inline;
    function  getCOUT : TBits_1; inline;
    function  getCPOL : TBits_1; inline;
    function  getCREF : TBits_1; inline;
    function  getEVPOL : TBits_2; inline;
    function  getEVPOL0 : TBits_1; inline;
    function  getEVPOL1 : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCCH(thebits : TBits_2); inline;
    procedure setCCH0(thebits : TBits_1); inline;
    procedure setCCH1(thebits : TBits_1); inline;
    procedure setCOE(thebits : TBits_1); inline;
    procedure setCOUT(thebits : TBits_1); inline;
    procedure setCPOL(thebits : TBits_1); inline;
    procedure setCREF(thebits : TBits_1); inline;
    procedure setEVPOL(thebits : TBits_2); inline;
    procedure setEVPOL0(thebits : TBits_1); inline;
    procedure setEVPOL1(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCCH0; inline;
    procedure clearCCH1; inline;
    procedure clearCOE; inline;
    procedure clearCOUT; inline;
    procedure clearCPOL; inline;
    procedure clearCREF; inline;
    procedure clearEVPOL0; inline;
    procedure clearEVPOL1; inline;
    procedure clearON; inline;
    procedure setCCH0; inline;
    procedure setCCH1; inline;
    procedure setCOE; inline;
    procedure setCOUT; inline;
    procedure setCPOL; inline;
    procedure setCREF; inline;
    procedure setEVPOL0; inline;
    procedure setEVPOL1; inline;
    procedure setON; inline;
    property CCH : TBits_2 read getCCH write setCCH;
    property CCH0 : TBits_1 read getCCH0 write setCCH0;
    property CCH1 : TBits_1 read getCCH1 write setCCH1;
    property COE : TBits_1 read getCOE write setCOE;
    property COUT : TBits_1 read getCOUT write setCOUT;
    property CPOL : TBits_1 read getCPOL write setCPOL;
    property CREF : TBits_1 read getCREF write setCREF;
    property EVPOL : TBits_2 read getEVPOL write setEVPOL;
    property EVPOL0 : TBits_1 read getEVPOL0 write setEVPOL0;
    property EVPOL1 : TBits_1 read getEVPOL1 write setEVPOL1;
    property ON : TBits_1 read getON write setON;
    property w : TBits_32 read getw write setw;
  end;
  TCMP_CM2CON = record
  private
    function  getCCH : TBits_2; inline;
    function  getCCH0 : TBits_1; inline;
    function  getCCH1 : TBits_1; inline;
    function  getCOE : TBits_1; inline;
    function  getCOUT : TBits_1; inline;
    function  getCPOL : TBits_1; inline;
    function  getCREF : TBits_1; inline;
    function  getEVPOL : TBits_2; inline;
    function  getEVPOL0 : TBits_1; inline;
    function  getEVPOL1 : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCCH(thebits : TBits_2); inline;
    procedure setCCH0(thebits : TBits_1); inline;
    procedure setCCH1(thebits : TBits_1); inline;
    procedure setCOE(thebits : TBits_1); inline;
    procedure setCOUT(thebits : TBits_1); inline;
    procedure setCPOL(thebits : TBits_1); inline;
    procedure setCREF(thebits : TBits_1); inline;
    procedure setEVPOL(thebits : TBits_2); inline;
    procedure setEVPOL0(thebits : TBits_1); inline;
    procedure setEVPOL1(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCCH0; inline;
    procedure clearCCH1; inline;
    procedure clearCOE; inline;
    procedure clearCOUT; inline;
    procedure clearCPOL; inline;
    procedure clearCREF; inline;
    procedure clearEVPOL0; inline;
    procedure clearEVPOL1; inline;
    procedure clearON; inline;
    procedure setCCH0; inline;
    procedure setCCH1; inline;
    procedure setCOE; inline;
    procedure setCOUT; inline;
    procedure setCPOL; inline;
    procedure setCREF; inline;
    procedure setEVPOL0; inline;
    procedure setEVPOL1; inline;
    procedure setON; inline;
    property CCH : TBits_2 read getCCH write setCCH;
    property CCH0 : TBits_1 read getCCH0 write setCCH0;
    property CCH1 : TBits_1 read getCCH1 write setCCH1;
    property COE : TBits_1 read getCOE write setCOE;
    property COUT : TBits_1 read getCOUT write setCOUT;
    property CPOL : TBits_1 read getCPOL write setCPOL;
    property CREF : TBits_1 read getCREF write setCREF;
    property EVPOL : TBits_2 read getEVPOL write setEVPOL;
    property EVPOL0 : TBits_1 read getEVPOL0 write setEVPOL0;
    property EVPOL1 : TBits_1 read getEVPOL1 write setEVPOL1;
    property ON : TBits_1 read getON write setON;
    property w : TBits_32 read getw write setw;
  end;
  TCMP_CMSTAT = record
  private
    function  getC1OUT : TBits_1; inline;
    function  getC2OUT : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC1OUT(thebits : TBits_1); inline;
    procedure setC2OUT(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC1OUT; inline;
    procedure clearC2OUT; inline;
    procedure clearSIDL; inline;
    procedure setC1OUT; inline;
    procedure setC2OUT; inline;
    procedure setSIDL; inline;
    property C1OUT : TBits_1 read getC1OUT write setC1OUT;
    property C2OUT : TBits_1 read getC2OUT write setC2OUT;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TCMP_CTMUCON = record
  private
    function  getCTMUSIDL : TBits_1; inline;
    function  getCTTRIG : TBits_1; inline;
    function  getEDG1MOD : TBits_1; inline;
    function  getEDG1POL : TBits_1; inline;
    function  getEDG1SEL : TBits_4; inline;
    function  getEDG1STAT : TBits_1; inline;
    function  getEDG2MOD : TBits_1; inline;
    function  getEDG2POL : TBits_1; inline;
    function  getEDG2SEL : TBits_4; inline;
    function  getEDG2STAT : TBits_1; inline;
    function  getEDGEN : TBits_1; inline;
    function  getEDGSEQEN : TBits_1; inline;
    function  getIDISSEN : TBits_1; inline;
    function  getIRNG : TBits_2; inline;
    function  getITRIM : TBits_6; inline;
    function  getON : TBits_1; inline;
    function  getTGEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCTMUSIDL(thebits : TBits_1); inline;
    procedure setCTTRIG(thebits : TBits_1); inline;
    procedure setEDG1MOD(thebits : TBits_1); inline;
    procedure setEDG1POL(thebits : TBits_1); inline;
    procedure setEDG1SEL(thebits : TBits_4); inline;
    procedure setEDG1STAT(thebits : TBits_1); inline;
    procedure setEDG2MOD(thebits : TBits_1); inline;
    procedure setEDG2POL(thebits : TBits_1); inline;
    procedure setEDG2SEL(thebits : TBits_4); inline;
    procedure setEDG2STAT(thebits : TBits_1); inline;
    procedure setEDGEN(thebits : TBits_1); inline;
    procedure setEDGSEQEN(thebits : TBits_1); inline;
    procedure setIDISSEN(thebits : TBits_1); inline;
    procedure setIRNG(thebits : TBits_2); inline;
    procedure setITRIM(thebits : TBits_6); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setTGEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCTMUSIDL; inline;
    procedure clearCTTRIG; inline;
    procedure clearEDG1MOD; inline;
    procedure clearEDG1POL; inline;
    procedure clearEDG1STAT; inline;
    procedure clearEDG2MOD; inline;
    procedure clearEDG2POL; inline;
    procedure clearEDG2STAT; inline;
    procedure clearEDGEN; inline;
    procedure clearEDGSEQEN; inline;
    procedure clearIDISSEN; inline;
    procedure clearON; inline;
    procedure clearTGEN; inline;
    procedure setCTMUSIDL; inline;
    procedure setCTTRIG; inline;
    procedure setEDG1MOD; inline;
    procedure setEDG1POL; inline;
    procedure setEDG1STAT; inline;
    procedure setEDG2MOD; inline;
    procedure setEDG2POL; inline;
    procedure setEDG2STAT; inline;
    procedure setEDGEN; inline;
    procedure setEDGSEQEN; inline;
    procedure setIDISSEN; inline;
    procedure setON; inline;
    procedure setTGEN; inline;
    property CTMUSIDL : TBits_1 read getCTMUSIDL write setCTMUSIDL;
    property CTTRIG : TBits_1 read getCTTRIG write setCTTRIG;
    property EDG1MOD : TBits_1 read getEDG1MOD write setEDG1MOD;
    property EDG1POL : TBits_1 read getEDG1POL write setEDG1POL;
    property EDG1SEL : TBits_4 read getEDG1SEL write setEDG1SEL;
    property EDG1STAT : TBits_1 read getEDG1STAT write setEDG1STAT;
    property EDG2MOD : TBits_1 read getEDG2MOD write setEDG2MOD;
    property EDG2POL : TBits_1 read getEDG2POL write setEDG2POL;
    property EDG2SEL : TBits_4 read getEDG2SEL write setEDG2SEL;
    property EDG2STAT : TBits_1 read getEDG2STAT write setEDG2STAT;
    property EDGEN : TBits_1 read getEDGEN write setEDGEN;
    property EDGSEQEN : TBits_1 read getEDGSEQEN write setEDGSEQEN;
    property IDISSEN : TBits_1 read getIDISSEN write setIDISSEN;
    property IRNG : TBits_2 read getIRNG write setIRNG;
    property ITRIM : TBits_6 read getITRIM write setITRIM;
    property ON : TBits_1 read getON write setON;
    property TGEN : TBits_1 read getTGEN write setTGEN;
    property w : TBits_32 read getw write setw;
  end;
type
  TCMPRegisters = record
    CM1CONbits : TCMP_CM1CON;
    CM1CON : longWord;
    CM1CONCLR : longWord;
    CM1CONSET : longWord;
    CM1CONINV : longWord;
    CM2CONbits : TCMP_CM2CON;
    CM2CON : longWord;
    CM2CONCLR : longWord;
    CM2CONSET : longWord;
    CM2CONINV : longWord;
    CMSTATbits : TCMP_CMSTAT;
    CMSTAT : longWord;
    CMSTATCLR : longWord;
    CMSTATSET : longWord;
    CMSTATINV : longWord;
    CTMUCONbits : TCMP_CTMUCON;
    CTMUCON : longWord;
    CTMUCONCLR : longWord;
    CTMUCONSET : longWord;
    CTMUCONINV : longWord;
  end;
  TOSC_OSCCON = record
  private
    function  getCF : TBits_1; inline;
    function  getCLKLOCK : TBits_1; inline;
    function  getCOSC : TBits_3; inline;
    function  getCOSC0 : TBits_1; inline;
    function  getCOSC1 : TBits_1; inline;
    function  getCOSC2 : TBits_1; inline;
    function  getFRCDIV : TBits_3; inline;
    function  getFRCDIV0 : TBits_1; inline;
    function  getFRCDIV1 : TBits_1; inline;
    function  getFRCDIV2 : TBits_1; inline;
    function  getNOSC : TBits_3; inline;
    function  getNOSC0 : TBits_1; inline;
    function  getNOSC1 : TBits_1; inline;
    function  getNOSC2 : TBits_1; inline;
    function  getOSWEN : TBits_1; inline;
    function  getPBDIV : TBits_2; inline;
    function  getPBDIV0 : TBits_1; inline;
    function  getPBDIV1 : TBits_1; inline;
    function  getPBDIVRDY : TBits_1; inline;
    function  getPLLMULT : TBits_3; inline;
    function  getPLLMULT0 : TBits_1; inline;
    function  getPLLMULT1 : TBits_1; inline;
    function  getPLLMULT2 : TBits_1; inline;
    function  getPLLODIV : TBits_3; inline;
    function  getPLLODIV0 : TBits_1; inline;
    function  getPLLODIV1 : TBits_1; inline;
    function  getPLLODIV2 : TBits_1; inline;
    function  getSLOCK : TBits_1; inline;
    function  getSLPEN : TBits_1; inline;
    function  getSOSCEN : TBits_1; inline;
    function  getSOSCRDY : TBits_1; inline;
    function  getUFRCEN : TBits_1; inline;
    function  getULOCK : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCF(thebits : TBits_1); inline;
    procedure setCLKLOCK(thebits : TBits_1); inline;
    procedure setCOSC(thebits : TBits_3); inline;
    procedure setCOSC0(thebits : TBits_1); inline;
    procedure setCOSC1(thebits : TBits_1); inline;
    procedure setCOSC2(thebits : TBits_1); inline;
    procedure setFRCDIV(thebits : TBits_3); inline;
    procedure setFRCDIV0(thebits : TBits_1); inline;
    procedure setFRCDIV1(thebits : TBits_1); inline;
    procedure setFRCDIV2(thebits : TBits_1); inline;
    procedure setNOSC(thebits : TBits_3); inline;
    procedure setNOSC0(thebits : TBits_1); inline;
    procedure setNOSC1(thebits : TBits_1); inline;
    procedure setNOSC2(thebits : TBits_1); inline;
    procedure setOSWEN(thebits : TBits_1); inline;
    procedure setPBDIV(thebits : TBits_2); inline;
    procedure setPBDIV0(thebits : TBits_1); inline;
    procedure setPBDIV1(thebits : TBits_1); inline;
    procedure setPBDIVRDY(thebits : TBits_1); inline;
    procedure setPLLMULT(thebits : TBits_3); inline;
    procedure setPLLMULT0(thebits : TBits_1); inline;
    procedure setPLLMULT1(thebits : TBits_1); inline;
    procedure setPLLMULT2(thebits : TBits_1); inline;
    procedure setPLLODIV(thebits : TBits_3); inline;
    procedure setPLLODIV0(thebits : TBits_1); inline;
    procedure setPLLODIV1(thebits : TBits_1); inline;
    procedure setPLLODIV2(thebits : TBits_1); inline;
    procedure setSLOCK(thebits : TBits_1); inline;
    procedure setSLPEN(thebits : TBits_1); inline;
    procedure setSOSCEN(thebits : TBits_1); inline;
    procedure setSOSCRDY(thebits : TBits_1); inline;
    procedure setUFRCEN(thebits : TBits_1); inline;
    procedure setULOCK(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCF; inline;
    procedure clearCLKLOCK; inline;
    procedure clearCOSC0; inline;
    procedure clearCOSC1; inline;
    procedure clearCOSC2; inline;
    procedure clearFRCDIV0; inline;
    procedure clearFRCDIV1; inline;
    procedure clearFRCDIV2; inline;
    procedure clearNOSC0; inline;
    procedure clearNOSC1; inline;
    procedure clearNOSC2; inline;
    procedure clearOSWEN; inline;
    procedure clearPBDIV0; inline;
    procedure clearPBDIV1; inline;
    procedure clearPBDIVRDY; inline;
    procedure clearPLLMULT0; inline;
    procedure clearPLLMULT1; inline;
    procedure clearPLLMULT2; inline;
    procedure clearPLLODIV0; inline;
    procedure clearPLLODIV1; inline;
    procedure clearPLLODIV2; inline;
    procedure clearSLOCK; inline;
    procedure clearSLPEN; inline;
    procedure clearSOSCEN; inline;
    procedure clearSOSCRDY; inline;
    procedure clearUFRCEN; inline;
    procedure clearULOCK; inline;
    procedure setCF; inline;
    procedure setCLKLOCK; inline;
    procedure setCOSC0; inline;
    procedure setCOSC1; inline;
    procedure setCOSC2; inline;
    procedure setFRCDIV0; inline;
    procedure setFRCDIV1; inline;
    procedure setFRCDIV2; inline;
    procedure setNOSC0; inline;
    procedure setNOSC1; inline;
    procedure setNOSC2; inline;
    procedure setOSWEN; inline;
    procedure setPBDIV0; inline;
    procedure setPBDIV1; inline;
    procedure setPBDIVRDY; inline;
    procedure setPLLMULT0; inline;
    procedure setPLLMULT1; inline;
    procedure setPLLMULT2; inline;
    procedure setPLLODIV0; inline;
    procedure setPLLODIV1; inline;
    procedure setPLLODIV2; inline;
    procedure setSLOCK; inline;
    procedure setSLPEN; inline;
    procedure setSOSCEN; inline;
    procedure setSOSCRDY; inline;
    procedure setUFRCEN; inline;
    procedure setULOCK; inline;
    property CF : TBits_1 read getCF write setCF;
    property CLKLOCK : TBits_1 read getCLKLOCK write setCLKLOCK;
    property COSC : TBits_3 read getCOSC write setCOSC;
    property COSC0 : TBits_1 read getCOSC0 write setCOSC0;
    property COSC1 : TBits_1 read getCOSC1 write setCOSC1;
    property COSC2 : TBits_1 read getCOSC2 write setCOSC2;
    property FRCDIV : TBits_3 read getFRCDIV write setFRCDIV;
    property FRCDIV0 : TBits_1 read getFRCDIV0 write setFRCDIV0;
    property FRCDIV1 : TBits_1 read getFRCDIV1 write setFRCDIV1;
    property FRCDIV2 : TBits_1 read getFRCDIV2 write setFRCDIV2;
    property NOSC : TBits_3 read getNOSC write setNOSC;
    property NOSC0 : TBits_1 read getNOSC0 write setNOSC0;
    property NOSC1 : TBits_1 read getNOSC1 write setNOSC1;
    property NOSC2 : TBits_1 read getNOSC2 write setNOSC2;
    property OSWEN : TBits_1 read getOSWEN write setOSWEN;
    property PBDIV : TBits_2 read getPBDIV write setPBDIV;
    property PBDIV0 : TBits_1 read getPBDIV0 write setPBDIV0;
    property PBDIV1 : TBits_1 read getPBDIV1 write setPBDIV1;
    property PBDIVRDY : TBits_1 read getPBDIVRDY write setPBDIVRDY;
    property PLLMULT : TBits_3 read getPLLMULT write setPLLMULT;
    property PLLMULT0 : TBits_1 read getPLLMULT0 write setPLLMULT0;
    property PLLMULT1 : TBits_1 read getPLLMULT1 write setPLLMULT1;
    property PLLMULT2 : TBits_1 read getPLLMULT2 write setPLLMULT2;
    property PLLODIV : TBits_3 read getPLLODIV write setPLLODIV;
    property PLLODIV0 : TBits_1 read getPLLODIV0 write setPLLODIV0;
    property PLLODIV1 : TBits_1 read getPLLODIV1 write setPLLODIV1;
    property PLLODIV2 : TBits_1 read getPLLODIV2 write setPLLODIV2;
    property SLOCK : TBits_1 read getSLOCK write setSLOCK;
    property SLPEN : TBits_1 read getSLPEN write setSLPEN;
    property SOSCEN : TBits_1 read getSOSCEN write setSOSCEN;
    property SOSCRDY : TBits_1 read getSOSCRDY write setSOSCRDY;
    property UFRCEN : TBits_1 read getUFRCEN write setUFRCEN;
    property ULOCK : TBits_1 read getULOCK write setULOCK;
    property w : TBits_32 read getw write setw;
  end;
  TOSC_OSCTUN = record
  private
    function  getTUN : TBits_6; inline;
    function  getTUN0 : TBits_1; inline;
    function  getTUN1 : TBits_1; inline;
    function  getTUN2 : TBits_1; inline;
    function  getTUN3 : TBits_1; inline;
    function  getTUN4 : TBits_1; inline;
    function  getTUN5 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTUN(thebits : TBits_6); inline;
    procedure setTUN0(thebits : TBits_1); inline;
    procedure setTUN1(thebits : TBits_1); inline;
    procedure setTUN2(thebits : TBits_1); inline;
    procedure setTUN3(thebits : TBits_1); inline;
    procedure setTUN4(thebits : TBits_1); inline;
    procedure setTUN5(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTUN0; inline;
    procedure clearTUN1; inline;
    procedure clearTUN2; inline;
    procedure clearTUN3; inline;
    procedure clearTUN4; inline;
    procedure clearTUN5; inline;
    procedure setTUN0; inline;
    procedure setTUN1; inline;
    procedure setTUN2; inline;
    procedure setTUN3; inline;
    procedure setTUN4; inline;
    procedure setTUN5; inline;
    property TUN : TBits_6 read getTUN write setTUN;
    property TUN0 : TBits_1 read getTUN0 write setTUN0;
    property TUN1 : TBits_1 read getTUN1 write setTUN1;
    property TUN2 : TBits_1 read getTUN2 write setTUN2;
    property TUN3 : TBits_1 read getTUN3 write setTUN3;
    property TUN4 : TBits_1 read getTUN4 write setTUN4;
    property TUN5 : TBits_1 read getTUN5 write setTUN5;
    property w : TBits_32 read getw write setw;
  end;
  TOSC_REFOCON = record
  private
    function  getACTIVE : TBits_1; inline;
    function  getDIVSWEN : TBits_1; inline;
    function  getOE : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getRODIV : TBits_15; inline;
    function  getROSEL : TBits_4; inline;
    function  getRSLP : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACTIVE(thebits : TBits_1); inline;
    procedure setDIVSWEN(thebits : TBits_1); inline;
    procedure setOE(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setRODIV(thebits : TBits_15); inline;
    procedure setROSEL(thebits : TBits_4); inline;
    procedure setRSLP(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACTIVE; inline;
    procedure clearDIVSWEN; inline;
    procedure clearOE; inline;
    procedure clearON; inline;
    procedure clearRSLP; inline;
    procedure clearSIDL; inline;
    procedure setACTIVE; inline;
    procedure setDIVSWEN; inline;
    procedure setOE; inline;
    procedure setON; inline;
    procedure setRSLP; inline;
    procedure setSIDL; inline;
    property ACTIVE : TBits_1 read getACTIVE write setACTIVE;
    property DIVSWEN : TBits_1 read getDIVSWEN write setDIVSWEN;
    property OE : TBits_1 read getOE write setOE;
    property ON : TBits_1 read getON write setON;
    property RODIV : TBits_15 read getRODIV write setRODIV;
    property ROSEL : TBits_4 read getROSEL write setROSEL;
    property RSLP : TBits_1 read getRSLP write setRSLP;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TOSC_REFOTRIM = record
  private
    function  getROTRIM : TBits_9; inline;
    function  getw : TBits_32; inline;
    procedure setROTRIM(thebits : TBits_9); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property ROTRIM : TBits_9 read getROTRIM write setROTRIM;
    property w : TBits_32 read getw write setw;
  end;
type
  TOSCRegisters = record
    OSCCONbits : TOSC_OSCCON;
    OSCCON : longWord;
    OSCCONCLR : longWord;
    OSCCONSET : longWord;
    OSCCONINV : longWord;
    OSCTUNbits : TOSC_OSCTUN;
    OSCTUN : longWord;
    OSCTUNCLR : longWord;
    OSCTUNSET : longWord;
    OSCTUNINV : longWord;
    REFOCONbits : TOSC_REFOCON;
    REFOCON : longWord;
    REFOCONCLR : longWord;
    REFOCONSET : longWord;
    REFOCONINV : longWord;
    REFOTRIMbits : TOSC_REFOTRIM;
    REFOTRIM : longWord;
    REFOTRIMCLR : longWord;
    REFOTRIMSET : longWord;
    REFOTRIMINV : longWord;
  end;
type
  TCFGRegisters = record
    CFGCON : longWord;
    DDPCON : longWord;
    DEVID : longWord;
    SYSKEY : longWord;
    SYSKEYCLR : longWord;
    SYSKEYSET : longWord;
    SYSKEYINV : longWord;
    PMD1 : longWord;
    PMD1CLR : longWord;
    PMD1SET : longWord;
    PMD1INV : longWord;
    PMD2 : longWord;
    PMD2CLR : longWord;
    PMD2SET : longWord;
    PMD2INV : longWord;
    PMD3 : longWord;
    PMD3CLR : longWord;
    PMD3SET : longWord;
    PMD3INV : longWord;
    PMD4 : longWord;
    PMD4CLR : longWord;
    PMD4SET : longWord;
    PMD4INV : longWord;
    PMD5 : longWord;
    PMD5CLR : longWord;
    PMD5SET : longWord;
    PMD5INV : longWord;
    PMD6 : longWord;
    PMD6CLR : longWord;
    PMD6SET : longWord;
    PMD6INV : longWord;
  end;
  TNVM_NVMCON = record
  private
    function  getLVDERR : TBits_1; inline;
    function  getLVDSTAT : TBits_1; inline;
    function  getNVMOP : TBits_4; inline;
    function  getNVMOP0 : TBits_1; inline;
    function  getNVMOP1 : TBits_1; inline;
    function  getNVMOP2 : TBits_1; inline;
    function  getNVMOP3 : TBits_1; inline;
    function  getPROGOP : TBits_4; inline;
    function  getPROGOP0 : TBits_1; inline;
    function  getPROGOP1 : TBits_1; inline;
    function  getPROGOP2 : TBits_1; inline;
    function  getPROGOP3 : TBits_1; inline;
    function  getWR : TBits_1; inline;
    function  getWREN : TBits_1; inline;
    function  getWRERR : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLVDERR(thebits : TBits_1); inline;
    procedure setLVDSTAT(thebits : TBits_1); inline;
    procedure setNVMOP(thebits : TBits_4); inline;
    procedure setNVMOP0(thebits : TBits_1); inline;
    procedure setNVMOP1(thebits : TBits_1); inline;
    procedure setNVMOP2(thebits : TBits_1); inline;
    procedure setNVMOP3(thebits : TBits_1); inline;
    procedure setPROGOP(thebits : TBits_4); inline;
    procedure setPROGOP0(thebits : TBits_1); inline;
    procedure setPROGOP1(thebits : TBits_1); inline;
    procedure setPROGOP2(thebits : TBits_1); inline;
    procedure setPROGOP3(thebits : TBits_1); inline;
    procedure setWR(thebits : TBits_1); inline;
    procedure setWREN(thebits : TBits_1); inline;
    procedure setWRERR(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLVDERR; inline;
    procedure clearLVDSTAT; inline;
    procedure clearNVMOP0; inline;
    procedure clearNVMOP1; inline;
    procedure clearNVMOP2; inline;
    procedure clearNVMOP3; inline;
    procedure clearPROGOP0; inline;
    procedure clearPROGOP1; inline;
    procedure clearPROGOP2; inline;
    procedure clearPROGOP3; inline;
    procedure clearWR; inline;
    procedure clearWREN; inline;
    procedure clearWRERR; inline;
    procedure setLVDERR; inline;
    procedure setLVDSTAT; inline;
    procedure setNVMOP0; inline;
    procedure setNVMOP1; inline;
    procedure setNVMOP2; inline;
    procedure setNVMOP3; inline;
    procedure setPROGOP0; inline;
    procedure setPROGOP1; inline;
    procedure setPROGOP2; inline;
    procedure setPROGOP3; inline;
    procedure setWR; inline;
    procedure setWREN; inline;
    procedure setWRERR; inline;
    property LVDERR : TBits_1 read getLVDERR write setLVDERR;
    property LVDSTAT : TBits_1 read getLVDSTAT write setLVDSTAT;
    property NVMOP : TBits_4 read getNVMOP write setNVMOP;
    property NVMOP0 : TBits_1 read getNVMOP0 write setNVMOP0;
    property NVMOP1 : TBits_1 read getNVMOP1 write setNVMOP1;
    property NVMOP2 : TBits_1 read getNVMOP2 write setNVMOP2;
    property NVMOP3 : TBits_1 read getNVMOP3 write setNVMOP3;
    property PROGOP : TBits_4 read getPROGOP write setPROGOP;
    property PROGOP0 : TBits_1 read getPROGOP0 write setPROGOP0;
    property PROGOP1 : TBits_1 read getPROGOP1 write setPROGOP1;
    property PROGOP2 : TBits_1 read getPROGOP2 write setPROGOP2;
    property PROGOP3 : TBits_1 read getPROGOP3 write setPROGOP3;
    property WR : TBits_1 read getWR write setWR;
    property WREN : TBits_1 read getWREN write setWREN;
    property WRERR : TBits_1 read getWRERR write setWRERR;
    property w : TBits_32 read getw write setw;
  end;
type
  TNVMRegisters = record
    NVMCONbits : TNVM_NVMCON;
    NVMCON : longWord;
    NVMCONCLR : longWord;
    NVMCONSET : longWord;
    NVMCONINV : longWord;
    NVMKEY : longWord;
    NVMADDR : longWord;
    NVMADDRCLR : longWord;
    NVMADDRSET : longWord;
    NVMADDRINV : longWord;
    NVMDATA : longWord;
    NVMSRCADDR : longWord;
  end;
  TRCON_RCON = record
  private
    function  getBOR : TBits_1; inline;
    function  getCMR : TBits_1; inline;
    function  getEXTR : TBits_1; inline;
    function  getHVDR : TBits_1; inline;
    function  getIDLE : TBits_1; inline;
    function  getPOR : TBits_1; inline;
    function  getSLEEP : TBits_1; inline;
    function  getSWR : TBits_1; inline;
    function  getVREGS : TBits_1; inline;
    function  getWDTO : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBOR(thebits : TBits_1); inline;
    procedure setCMR(thebits : TBits_1); inline;
    procedure setEXTR(thebits : TBits_1); inline;
    procedure setHVDR(thebits : TBits_1); inline;
    procedure setIDLE(thebits : TBits_1); inline;
    procedure setPOR(thebits : TBits_1); inline;
    procedure setSLEEP(thebits : TBits_1); inline;
    procedure setSWR(thebits : TBits_1); inline;
    procedure setVREGS(thebits : TBits_1); inline;
    procedure setWDTO(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBOR; inline;
    procedure clearCMR; inline;
    procedure clearEXTR; inline;
    procedure clearHVDR; inline;
    procedure clearIDLE; inline;
    procedure clearPOR; inline;
    procedure clearSLEEP; inline;
    procedure clearSWR; inline;
    procedure clearVREGS; inline;
    procedure clearWDTO; inline;
    procedure setBOR; inline;
    procedure setCMR; inline;
    procedure setEXTR; inline;
    procedure setHVDR; inline;
    procedure setIDLE; inline;
    procedure setPOR; inline;
    procedure setSLEEP; inline;
    procedure setSWR; inline;
    procedure setVREGS; inline;
    procedure setWDTO; inline;
    property BOR : TBits_1 read getBOR write setBOR;
    property CMR : TBits_1 read getCMR write setCMR;
    property EXTR : TBits_1 read getEXTR write setEXTR;
    property HVDR : TBits_1 read getHVDR write setHVDR;
    property IDLE : TBits_1 read getIDLE write setIDLE;
    property POR : TBits_1 read getPOR write setPOR;
    property SLEEP : TBits_1 read getSLEEP write setSLEEP;
    property SWR : TBits_1 read getSWR write setSWR;
    property VREGS : TBits_1 read getVREGS write setVREGS;
    property WDTO : TBits_1 read getWDTO write setWDTO;
    property w : TBits_32 read getw write setw;
  end;
  TRCON_RSWRST = record
  private
    function  getSWRST : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setSWRST(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearSWRST; inline;
    procedure setSWRST; inline;
    property SWRST : TBits_1 read getSWRST write setSWRST;
    property w : TBits_32 read getw write setw;
  end;
type
  TRCONRegisters = record
    RCONbits : TRCON_RCON;
    RCON : longWord;
    RCONCLR : longWord;
    RCONSET : longWord;
    RCONINV : longWord;
    RSWRSTbits : TRCON_RSWRST;
    RSWRST : longWord;
    RSWRSTCLR : longWord;
    RSWRSTSET : longWord;
    RSWRSTINV : longWord;
    INT1R : longWord;
    INT2R : longWord;
    INT3R : longWord;
    INT4R : longWord;
    T2CKR : longWord;
    T3CKR : longWord;
    T4CKR : longWord;
    T5CKR : longWord;
    IC1R : longWord;
    IC2R : longWord;
    IC3R : longWord;
    IC4R : longWord;
    IC5R : longWord;
    OCFAR : longWord;
    U1RXR : longWord;
    U1CTSR : longWord;
    U2RXR : longWord;
    U2CTSR : longWord;
    U3RXR : longWord;
    U3CTSR : longWord;
    U4RXR : longWord;
    U4CTSR : longWord;
    U5RXR : longWord;
    U5CTSR : longWord;
    SDI1R : longWord;
    SS1R : longWord;
    SDI2R : longWord;
    SS2R : longWord;
    REFCLKIR : longWord;
    RPB0R : longWord;
    RPB1R : longWord;
    RPB2R : longWord;
    RPB3R : longWord;
    RPB5R : longWord;
    RPB6R : longWord;
    RPB7R : longWord;
    RPB8R : longWord;
    RPB9R : longWord;
    RPB10R : longWord;
    RPB14R : longWord;
    RPB15R : longWord;
    RPC13R : longWord;
    RPC14R : longWord;
    RPD0R : longWord;
    RPD1R : longWord;
    RPD2R : longWord;
    RPD3R : longWord;
    RPD4R : longWord;
    RPD5R : longWord;
    RPD8R : longWord;
    RPD9R : longWord;
    RPD10R : longWord;
    RPD11R : longWord;
    RPE3R : longWord;
    RPE5R : longWord;
    RPF0R : longWord;
    RPF1R : longWord;
    RPF4R : longWord;
    RPF5R : longWord;
    RPG6R : longWord;
    RPG7R : longWord;
    RPG8R : longWord;
    RPG9R : longWord;
  end;
  TINT_INTCON = record
  private
    function  getINT0EP : TBits_1; inline;
    function  getINT1EP : TBits_1; inline;
    function  getINT2EP : TBits_1; inline;
    function  getINT3EP : TBits_1; inline;
    function  getINT4EP : TBits_1; inline;
    function  getMVEC : TBits_1; inline;
    function  getSS0 : TBits_1; inline;
    function  getTPC : TBits_3; inline;
    function  getw : TBits_32; inline;
    procedure setINT0EP(thebits : TBits_1); inline;
    procedure setINT1EP(thebits : TBits_1); inline;
    procedure setINT2EP(thebits : TBits_1); inline;
    procedure setINT3EP(thebits : TBits_1); inline;
    procedure setINT4EP(thebits : TBits_1); inline;
    procedure setMVEC(thebits : TBits_1); inline;
    procedure setSS0(thebits : TBits_1); inline;
    procedure setTPC(thebits : TBits_3); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearINT0EP; inline;
    procedure clearINT1EP; inline;
    procedure clearINT2EP; inline;
    procedure clearINT3EP; inline;
    procedure clearINT4EP; inline;
    procedure clearMVEC; inline;
    procedure clearSS0; inline;
    procedure setINT0EP; inline;
    procedure setINT1EP; inline;
    procedure setINT2EP; inline;
    procedure setINT3EP; inline;
    procedure setINT4EP; inline;
    procedure setMVEC; inline;
    procedure setSS0; inline;
    property INT0EP : TBits_1 read getINT0EP write setINT0EP;
    property INT1EP : TBits_1 read getINT1EP write setINT1EP;
    property INT2EP : TBits_1 read getINT2EP write setINT2EP;
    property INT3EP : TBits_1 read getINT3EP write setINT3EP;
    property INT4EP : TBits_1 read getINT4EP write setINT4EP;
    property MVEC : TBits_1 read getMVEC write setMVEC;
    property SS0 : TBits_1 read getSS0 write setSS0;
    property TPC : TBits_3 read getTPC write setTPC;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IFS0 = record
  private
    function  getAD1IF : TBits_1; inline;
    function  getCS0IF : TBits_1; inline;
    function  getCS1IF : TBits_1; inline;
    function  getCTIF : TBits_1; inline;
    function  getFCEIF : TBits_1; inline;
    function  getFSCMIF : TBits_1; inline;
    function  getIC1EIF : TBits_1; inline;
    function  getIC1IF : TBits_1; inline;
    function  getIC2EIF : TBits_1; inline;
    function  getIC2IF : TBits_1; inline;
    function  getIC3EIF : TBits_1; inline;
    function  getIC3IF : TBits_1; inline;
    function  getIC4EIF : TBits_1; inline;
    function  getIC4IF : TBits_1; inline;
    function  getIC5EIF : TBits_1; inline;
    function  getIC5IF : TBits_1; inline;
    function  getINT0IF : TBits_1; inline;
    function  getINT1IF : TBits_1; inline;
    function  getINT2IF : TBits_1; inline;
    function  getINT3IF : TBits_1; inline;
    function  getINT4IF : TBits_1; inline;
    function  getOC1IF : TBits_1; inline;
    function  getOC2IF : TBits_1; inline;
    function  getOC3IF : TBits_1; inline;
    function  getOC4IF : TBits_1; inline;
    function  getOC5IF : TBits_1; inline;
    function  getRTCCIF : TBits_1; inline;
    function  getT1IF : TBits_1; inline;
    function  getT2IF : TBits_1; inline;
    function  getT3IF : TBits_1; inline;
    function  getT4IF : TBits_1; inline;
    function  getT5IF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAD1IF(thebits : TBits_1); inline;
    procedure setCS0IF(thebits : TBits_1); inline;
    procedure setCS1IF(thebits : TBits_1); inline;
    procedure setCTIF(thebits : TBits_1); inline;
    procedure setFCEIF(thebits : TBits_1); inline;
    procedure setFSCMIF(thebits : TBits_1); inline;
    procedure setIC1EIF(thebits : TBits_1); inline;
    procedure setIC1IF(thebits : TBits_1); inline;
    procedure setIC2EIF(thebits : TBits_1); inline;
    procedure setIC2IF(thebits : TBits_1); inline;
    procedure setIC3EIF(thebits : TBits_1); inline;
    procedure setIC3IF(thebits : TBits_1); inline;
    procedure setIC4EIF(thebits : TBits_1); inline;
    procedure setIC4IF(thebits : TBits_1); inline;
    procedure setIC5EIF(thebits : TBits_1); inline;
    procedure setIC5IF(thebits : TBits_1); inline;
    procedure setINT0IF(thebits : TBits_1); inline;
    procedure setINT1IF(thebits : TBits_1); inline;
    procedure setINT2IF(thebits : TBits_1); inline;
    procedure setINT3IF(thebits : TBits_1); inline;
    procedure setINT4IF(thebits : TBits_1); inline;
    procedure setOC1IF(thebits : TBits_1); inline;
    procedure setOC2IF(thebits : TBits_1); inline;
    procedure setOC3IF(thebits : TBits_1); inline;
    procedure setOC4IF(thebits : TBits_1); inline;
    procedure setOC5IF(thebits : TBits_1); inline;
    procedure setRTCCIF(thebits : TBits_1); inline;
    procedure setT1IF(thebits : TBits_1); inline;
    procedure setT2IF(thebits : TBits_1); inline;
    procedure setT3IF(thebits : TBits_1); inline;
    procedure setT4IF(thebits : TBits_1); inline;
    procedure setT5IF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAD1IF; inline;
    procedure clearCS0IF; inline;
    procedure clearCS1IF; inline;
    procedure clearCTIF; inline;
    procedure clearFCEIF; inline;
    procedure clearFSCMIF; inline;
    procedure clearIC1EIF; inline;
    procedure clearIC1IF; inline;
    procedure clearIC2EIF; inline;
    procedure clearIC2IF; inline;
    procedure clearIC3EIF; inline;
    procedure clearIC3IF; inline;
    procedure clearIC4EIF; inline;
    procedure clearIC4IF; inline;
    procedure clearIC5EIF; inline;
    procedure clearIC5IF; inline;
    procedure clearINT0IF; inline;
    procedure clearINT1IF; inline;
    procedure clearINT2IF; inline;
    procedure clearINT3IF; inline;
    procedure clearINT4IF; inline;
    procedure clearOC1IF; inline;
    procedure clearOC2IF; inline;
    procedure clearOC3IF; inline;
    procedure clearOC4IF; inline;
    procedure clearOC5IF; inline;
    procedure clearRTCCIF; inline;
    procedure clearT1IF; inline;
    procedure clearT2IF; inline;
    procedure clearT3IF; inline;
    procedure clearT4IF; inline;
    procedure clearT5IF; inline;
    procedure setAD1IF; inline;
    procedure setCS0IF; inline;
    procedure setCS1IF; inline;
    procedure setCTIF; inline;
    procedure setFCEIF; inline;
    procedure setFSCMIF; inline;
    procedure setIC1EIF; inline;
    procedure setIC1IF; inline;
    procedure setIC2EIF; inline;
    procedure setIC2IF; inline;
    procedure setIC3EIF; inline;
    procedure setIC3IF; inline;
    procedure setIC4EIF; inline;
    procedure setIC4IF; inline;
    procedure setIC5EIF; inline;
    procedure setIC5IF; inline;
    procedure setINT0IF; inline;
    procedure setINT1IF; inline;
    procedure setINT2IF; inline;
    procedure setINT3IF; inline;
    procedure setINT4IF; inline;
    procedure setOC1IF; inline;
    procedure setOC2IF; inline;
    procedure setOC3IF; inline;
    procedure setOC4IF; inline;
    procedure setOC5IF; inline;
    procedure setRTCCIF; inline;
    procedure setT1IF; inline;
    procedure setT2IF; inline;
    procedure setT3IF; inline;
    procedure setT4IF; inline;
    procedure setT5IF; inline;
    property AD1IF : TBits_1 read getAD1IF write setAD1IF;
    property CS0IF : TBits_1 read getCS0IF write setCS0IF;
    property CS1IF : TBits_1 read getCS1IF write setCS1IF;
    property CTIF : TBits_1 read getCTIF write setCTIF;
    property FCEIF : TBits_1 read getFCEIF write setFCEIF;
    property FSCMIF : TBits_1 read getFSCMIF write setFSCMIF;
    property IC1EIF : TBits_1 read getIC1EIF write setIC1EIF;
    property IC1IF : TBits_1 read getIC1IF write setIC1IF;
    property IC2EIF : TBits_1 read getIC2EIF write setIC2EIF;
    property IC2IF : TBits_1 read getIC2IF write setIC2IF;
    property IC3EIF : TBits_1 read getIC3EIF write setIC3EIF;
    property IC3IF : TBits_1 read getIC3IF write setIC3IF;
    property IC4EIF : TBits_1 read getIC4EIF write setIC4EIF;
    property IC4IF : TBits_1 read getIC4IF write setIC4IF;
    property IC5EIF : TBits_1 read getIC5EIF write setIC5EIF;
    property IC5IF : TBits_1 read getIC5IF write setIC5IF;
    property INT0IF : TBits_1 read getINT0IF write setINT0IF;
    property INT1IF : TBits_1 read getINT1IF write setINT1IF;
    property INT2IF : TBits_1 read getINT2IF write setINT2IF;
    property INT3IF : TBits_1 read getINT3IF write setINT3IF;
    property INT4IF : TBits_1 read getINT4IF write setINT4IF;
    property OC1IF : TBits_1 read getOC1IF write setOC1IF;
    property OC2IF : TBits_1 read getOC2IF write setOC2IF;
    property OC3IF : TBits_1 read getOC3IF write setOC3IF;
    property OC4IF : TBits_1 read getOC4IF write setOC4IF;
    property OC5IF : TBits_1 read getOC5IF write setOC5IF;
    property RTCCIF : TBits_1 read getRTCCIF write setRTCCIF;
    property T1IF : TBits_1 read getT1IF write setT1IF;
    property T2IF : TBits_1 read getT2IF write setT2IF;
    property T3IF : TBits_1 read getT3IF write setT3IF;
    property T4IF : TBits_1 read getT4IF write setT4IF;
    property T5IF : TBits_1 read getT5IF write setT5IF;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IFS1 = record
  private
    function  getCMP1IF : TBits_1; inline;
    function  getCMP2IF : TBits_1; inline;
    function  getCNAIF : TBits_1; inline;
    function  getCNBIF : TBits_1; inline;
    function  getCNCIF : TBits_1; inline;
    function  getCNDIF : TBits_1; inline;
    function  getCNEIF : TBits_1; inline;
    function  getCNFIF : TBits_1; inline;
    function  getCNGIF : TBits_1; inline;
    function  getI2C1BIF : TBits_1; inline;
    function  getI2C1MIF : TBits_1; inline;
    function  getI2C1SIF : TBits_1; inline;
    function  getI2C2BIF : TBits_1; inline;
    function  getI2C2MIF : TBits_1; inline;
    function  getI2C2SIF : TBits_1; inline;
    function  getPMPEIF : TBits_1; inline;
    function  getPMPIF : TBits_1; inline;
    function  getSPI1EIF : TBits_1; inline;
    function  getSPI1RXIF : TBits_1; inline;
    function  getSPI1TXIF : TBits_1; inline;
    function  getSPI2EIF : TBits_1; inline;
    function  getSPI2RXIF : TBits_1; inline;
    function  getSPI2TXIF : TBits_1; inline;
    function  getU1EIF : TBits_1; inline;
    function  getU1RXIF : TBits_1; inline;
    function  getU1TXIF : TBits_1; inline;
    function  getU2EIF : TBits_1; inline;
    function  getU2RXIF : TBits_1; inline;
    function  getU2TXIF : TBits_1; inline;
    function  getU3EIF : TBits_1; inline;
    function  getU3RXIF : TBits_1; inline;
    function  getUSBIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCMP1IF(thebits : TBits_1); inline;
    procedure setCMP2IF(thebits : TBits_1); inline;
    procedure setCNAIF(thebits : TBits_1); inline;
    procedure setCNBIF(thebits : TBits_1); inline;
    procedure setCNCIF(thebits : TBits_1); inline;
    procedure setCNDIF(thebits : TBits_1); inline;
    procedure setCNEIF(thebits : TBits_1); inline;
    procedure setCNFIF(thebits : TBits_1); inline;
    procedure setCNGIF(thebits : TBits_1); inline;
    procedure setI2C1BIF(thebits : TBits_1); inline;
    procedure setI2C1MIF(thebits : TBits_1); inline;
    procedure setI2C1SIF(thebits : TBits_1); inline;
    procedure setI2C2BIF(thebits : TBits_1); inline;
    procedure setI2C2MIF(thebits : TBits_1); inline;
    procedure setI2C2SIF(thebits : TBits_1); inline;
    procedure setPMPEIF(thebits : TBits_1); inline;
    procedure setPMPIF(thebits : TBits_1); inline;
    procedure setSPI1EIF(thebits : TBits_1); inline;
    procedure setSPI1RXIF(thebits : TBits_1); inline;
    procedure setSPI1TXIF(thebits : TBits_1); inline;
    procedure setSPI2EIF(thebits : TBits_1); inline;
    procedure setSPI2RXIF(thebits : TBits_1); inline;
    procedure setSPI2TXIF(thebits : TBits_1); inline;
    procedure setU1EIF(thebits : TBits_1); inline;
    procedure setU1RXIF(thebits : TBits_1); inline;
    procedure setU1TXIF(thebits : TBits_1); inline;
    procedure setU2EIF(thebits : TBits_1); inline;
    procedure setU2RXIF(thebits : TBits_1); inline;
    procedure setU2TXIF(thebits : TBits_1); inline;
    procedure setU3EIF(thebits : TBits_1); inline;
    procedure setU3RXIF(thebits : TBits_1); inline;
    procedure setUSBIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCMP1IF; inline;
    procedure clearCMP2IF; inline;
    procedure clearCNAIF; inline;
    procedure clearCNBIF; inline;
    procedure clearCNCIF; inline;
    procedure clearCNDIF; inline;
    procedure clearCNEIF; inline;
    procedure clearCNFIF; inline;
    procedure clearCNGIF; inline;
    procedure clearI2C1BIF; inline;
    procedure clearI2C1MIF; inline;
    procedure clearI2C1SIF; inline;
    procedure clearI2C2BIF; inline;
    procedure clearI2C2MIF; inline;
    procedure clearI2C2SIF; inline;
    procedure clearPMPEIF; inline;
    procedure clearPMPIF; inline;
    procedure clearSPI1EIF; inline;
    procedure clearSPI1RXIF; inline;
    procedure clearSPI1TXIF; inline;
    procedure clearSPI2EIF; inline;
    procedure clearSPI2RXIF; inline;
    procedure clearSPI2TXIF; inline;
    procedure clearU1EIF; inline;
    procedure clearU1RXIF; inline;
    procedure clearU1TXIF; inline;
    procedure clearU2EIF; inline;
    procedure clearU2RXIF; inline;
    procedure clearU2TXIF; inline;
    procedure clearU3EIF; inline;
    procedure clearU3RXIF; inline;
    procedure clearUSBIF; inline;
    procedure setCMP1IF; inline;
    procedure setCMP2IF; inline;
    procedure setCNAIF; inline;
    procedure setCNBIF; inline;
    procedure setCNCIF; inline;
    procedure setCNDIF; inline;
    procedure setCNEIF; inline;
    procedure setCNFIF; inline;
    procedure setCNGIF; inline;
    procedure setI2C1BIF; inline;
    procedure setI2C1MIF; inline;
    procedure setI2C1SIF; inline;
    procedure setI2C2BIF; inline;
    procedure setI2C2MIF; inline;
    procedure setI2C2SIF; inline;
    procedure setPMPEIF; inline;
    procedure setPMPIF; inline;
    procedure setSPI1EIF; inline;
    procedure setSPI1RXIF; inline;
    procedure setSPI1TXIF; inline;
    procedure setSPI2EIF; inline;
    procedure setSPI2RXIF; inline;
    procedure setSPI2TXIF; inline;
    procedure setU1EIF; inline;
    procedure setU1RXIF; inline;
    procedure setU1TXIF; inline;
    procedure setU2EIF; inline;
    procedure setU2RXIF; inline;
    procedure setU2TXIF; inline;
    procedure setU3EIF; inline;
    procedure setU3RXIF; inline;
    procedure setUSBIF; inline;
    property CMP1IF : TBits_1 read getCMP1IF write setCMP1IF;
    property CMP2IF : TBits_1 read getCMP2IF write setCMP2IF;
    property CNAIF : TBits_1 read getCNAIF write setCNAIF;
    property CNBIF : TBits_1 read getCNBIF write setCNBIF;
    property CNCIF : TBits_1 read getCNCIF write setCNCIF;
    property CNDIF : TBits_1 read getCNDIF write setCNDIF;
    property CNEIF : TBits_1 read getCNEIF write setCNEIF;
    property CNFIF : TBits_1 read getCNFIF write setCNFIF;
    property CNGIF : TBits_1 read getCNGIF write setCNGIF;
    property I2C1BIF : TBits_1 read getI2C1BIF write setI2C1BIF;
    property I2C1MIF : TBits_1 read getI2C1MIF write setI2C1MIF;
    property I2C1SIF : TBits_1 read getI2C1SIF write setI2C1SIF;
    property I2C2BIF : TBits_1 read getI2C2BIF write setI2C2BIF;
    property I2C2MIF : TBits_1 read getI2C2MIF write setI2C2MIF;
    property I2C2SIF : TBits_1 read getI2C2SIF write setI2C2SIF;
    property PMPEIF : TBits_1 read getPMPEIF write setPMPEIF;
    property PMPIF : TBits_1 read getPMPIF write setPMPIF;
    property SPI1EIF : TBits_1 read getSPI1EIF write setSPI1EIF;
    property SPI1RXIF : TBits_1 read getSPI1RXIF write setSPI1RXIF;
    property SPI1TXIF : TBits_1 read getSPI1TXIF write setSPI1TXIF;
    property SPI2EIF : TBits_1 read getSPI2EIF write setSPI2EIF;
    property SPI2RXIF : TBits_1 read getSPI2RXIF write setSPI2RXIF;
    property SPI2TXIF : TBits_1 read getSPI2TXIF write setSPI2TXIF;
    property U1EIF : TBits_1 read getU1EIF write setU1EIF;
    property U1RXIF : TBits_1 read getU1RXIF write setU1RXIF;
    property U1TXIF : TBits_1 read getU1TXIF write setU1TXIF;
    property U2EIF : TBits_1 read getU2EIF write setU2EIF;
    property U2RXIF : TBits_1 read getU2RXIF write setU2RXIF;
    property U2TXIF : TBits_1 read getU2TXIF write setU2TXIF;
    property U3EIF : TBits_1 read getU3EIF write setU3EIF;
    property U3RXIF : TBits_1 read getU3RXIF write setU3RXIF;
    property USBIF : TBits_1 read getUSBIF write setUSBIF;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IEC0 = record
  private
    function  getAD1IE : TBits_1; inline;
    function  getCS0IE : TBits_1; inline;
    function  getCS1IE : TBits_1; inline;
    function  getCTIE : TBits_1; inline;
    function  getFCEIE : TBits_1; inline;
    function  getFSCMIE : TBits_1; inline;
    function  getIC1EIE : TBits_1; inline;
    function  getIC1IE : TBits_1; inline;
    function  getIC2EIE : TBits_1; inline;
    function  getIC2IE : TBits_1; inline;
    function  getIC3EIE : TBits_1; inline;
    function  getIC3IE : TBits_1; inline;
    function  getIC4EIE : TBits_1; inline;
    function  getIC4IE : TBits_1; inline;
    function  getIC5EIE : TBits_1; inline;
    function  getIC5IE : TBits_1; inline;
    function  getINT0IE : TBits_1; inline;
    function  getINT1IE : TBits_1; inline;
    function  getINT2IE : TBits_1; inline;
    function  getINT3IE : TBits_1; inline;
    function  getINT4IE : TBits_1; inline;
    function  getOC1IE : TBits_1; inline;
    function  getOC2IE : TBits_1; inline;
    function  getOC3IE : TBits_1; inline;
    function  getOC4IE : TBits_1; inline;
    function  getOC5IE : TBits_1; inline;
    function  getRTCCIE : TBits_1; inline;
    function  getT1IE : TBits_1; inline;
    function  getT2IE : TBits_1; inline;
    function  getT3IE : TBits_1; inline;
    function  getT4IE : TBits_1; inline;
    function  getT5IE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAD1IE(thebits : TBits_1); inline;
    procedure setCS0IE(thebits : TBits_1); inline;
    procedure setCS1IE(thebits : TBits_1); inline;
    procedure setCTIE(thebits : TBits_1); inline;
    procedure setFCEIE(thebits : TBits_1); inline;
    procedure setFSCMIE(thebits : TBits_1); inline;
    procedure setIC1EIE(thebits : TBits_1); inline;
    procedure setIC1IE(thebits : TBits_1); inline;
    procedure setIC2EIE(thebits : TBits_1); inline;
    procedure setIC2IE(thebits : TBits_1); inline;
    procedure setIC3EIE(thebits : TBits_1); inline;
    procedure setIC3IE(thebits : TBits_1); inline;
    procedure setIC4EIE(thebits : TBits_1); inline;
    procedure setIC4IE(thebits : TBits_1); inline;
    procedure setIC5EIE(thebits : TBits_1); inline;
    procedure setIC5IE(thebits : TBits_1); inline;
    procedure setINT0IE(thebits : TBits_1); inline;
    procedure setINT1IE(thebits : TBits_1); inline;
    procedure setINT2IE(thebits : TBits_1); inline;
    procedure setINT3IE(thebits : TBits_1); inline;
    procedure setINT4IE(thebits : TBits_1); inline;
    procedure setOC1IE(thebits : TBits_1); inline;
    procedure setOC2IE(thebits : TBits_1); inline;
    procedure setOC3IE(thebits : TBits_1); inline;
    procedure setOC4IE(thebits : TBits_1); inline;
    procedure setOC5IE(thebits : TBits_1); inline;
    procedure setRTCCIE(thebits : TBits_1); inline;
    procedure setT1IE(thebits : TBits_1); inline;
    procedure setT2IE(thebits : TBits_1); inline;
    procedure setT3IE(thebits : TBits_1); inline;
    procedure setT4IE(thebits : TBits_1); inline;
    procedure setT5IE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAD1IE; inline;
    procedure clearCS0IE; inline;
    procedure clearCS1IE; inline;
    procedure clearCTIE; inline;
    procedure clearFCEIE; inline;
    procedure clearFSCMIE; inline;
    procedure clearIC1EIE; inline;
    procedure clearIC1IE; inline;
    procedure clearIC2EIE; inline;
    procedure clearIC2IE; inline;
    procedure clearIC3EIE; inline;
    procedure clearIC3IE; inline;
    procedure clearIC4EIE; inline;
    procedure clearIC4IE; inline;
    procedure clearIC5EIE; inline;
    procedure clearIC5IE; inline;
    procedure clearINT0IE; inline;
    procedure clearINT1IE; inline;
    procedure clearINT2IE; inline;
    procedure clearINT3IE; inline;
    procedure clearINT4IE; inline;
    procedure clearOC1IE; inline;
    procedure clearOC2IE; inline;
    procedure clearOC3IE; inline;
    procedure clearOC4IE; inline;
    procedure clearOC5IE; inline;
    procedure clearRTCCIE; inline;
    procedure clearT1IE; inline;
    procedure clearT2IE; inline;
    procedure clearT3IE; inline;
    procedure clearT4IE; inline;
    procedure clearT5IE; inline;
    procedure setAD1IE; inline;
    procedure setCS0IE; inline;
    procedure setCS1IE; inline;
    procedure setCTIE; inline;
    procedure setFCEIE; inline;
    procedure setFSCMIE; inline;
    procedure setIC1EIE; inline;
    procedure setIC1IE; inline;
    procedure setIC2EIE; inline;
    procedure setIC2IE; inline;
    procedure setIC3EIE; inline;
    procedure setIC3IE; inline;
    procedure setIC4EIE; inline;
    procedure setIC4IE; inline;
    procedure setIC5EIE; inline;
    procedure setIC5IE; inline;
    procedure setINT0IE; inline;
    procedure setINT1IE; inline;
    procedure setINT2IE; inline;
    procedure setINT3IE; inline;
    procedure setINT4IE; inline;
    procedure setOC1IE; inline;
    procedure setOC2IE; inline;
    procedure setOC3IE; inline;
    procedure setOC4IE; inline;
    procedure setOC5IE; inline;
    procedure setRTCCIE; inline;
    procedure setT1IE; inline;
    procedure setT2IE; inline;
    procedure setT3IE; inline;
    procedure setT4IE; inline;
    procedure setT5IE; inline;
    property AD1IE : TBits_1 read getAD1IE write setAD1IE;
    property CS0IE : TBits_1 read getCS0IE write setCS0IE;
    property CS1IE : TBits_1 read getCS1IE write setCS1IE;
    property CTIE : TBits_1 read getCTIE write setCTIE;
    property FCEIE : TBits_1 read getFCEIE write setFCEIE;
    property FSCMIE : TBits_1 read getFSCMIE write setFSCMIE;
    property IC1EIE : TBits_1 read getIC1EIE write setIC1EIE;
    property IC1IE : TBits_1 read getIC1IE write setIC1IE;
    property IC2EIE : TBits_1 read getIC2EIE write setIC2EIE;
    property IC2IE : TBits_1 read getIC2IE write setIC2IE;
    property IC3EIE : TBits_1 read getIC3EIE write setIC3EIE;
    property IC3IE : TBits_1 read getIC3IE write setIC3IE;
    property IC4EIE : TBits_1 read getIC4EIE write setIC4EIE;
    property IC4IE : TBits_1 read getIC4IE write setIC4IE;
    property IC5EIE : TBits_1 read getIC5EIE write setIC5EIE;
    property IC5IE : TBits_1 read getIC5IE write setIC5IE;
    property INT0IE : TBits_1 read getINT0IE write setINT0IE;
    property INT1IE : TBits_1 read getINT1IE write setINT1IE;
    property INT2IE : TBits_1 read getINT2IE write setINT2IE;
    property INT3IE : TBits_1 read getINT3IE write setINT3IE;
    property INT4IE : TBits_1 read getINT4IE write setINT4IE;
    property OC1IE : TBits_1 read getOC1IE write setOC1IE;
    property OC2IE : TBits_1 read getOC2IE write setOC2IE;
    property OC3IE : TBits_1 read getOC3IE write setOC3IE;
    property OC4IE : TBits_1 read getOC4IE write setOC4IE;
    property OC5IE : TBits_1 read getOC5IE write setOC5IE;
    property RTCCIE : TBits_1 read getRTCCIE write setRTCCIE;
    property T1IE : TBits_1 read getT1IE write setT1IE;
    property T2IE : TBits_1 read getT2IE write setT2IE;
    property T3IE : TBits_1 read getT3IE write setT3IE;
    property T4IE : TBits_1 read getT4IE write setT4IE;
    property T5IE : TBits_1 read getT5IE write setT5IE;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IEC1 = record
  private
    function  getCMP1IE : TBits_1; inline;
    function  getCMP2IE : TBits_1; inline;
    function  getCNAIE : TBits_1; inline;
    function  getCNBIE : TBits_1; inline;
    function  getCNCIE : TBits_1; inline;
    function  getCNDIE : TBits_1; inline;
    function  getCNEIE : TBits_1; inline;
    function  getCNFIE : TBits_1; inline;
    function  getCNGIE : TBits_1; inline;
    function  getI2C1BIE : TBits_1; inline;
    function  getI2C1MIE : TBits_1; inline;
    function  getI2C1SIE : TBits_1; inline;
    function  getI2C2BIE : TBits_1; inline;
    function  getI2C2MIE : TBits_1; inline;
    function  getI2C2SIE : TBits_1; inline;
    function  getPMPEIE : TBits_1; inline;
    function  getPMPIE : TBits_1; inline;
    function  getSPI1EIE : TBits_1; inline;
    function  getSPI1RXIE : TBits_1; inline;
    function  getSPI1TXIE : TBits_1; inline;
    function  getSPI2EIE : TBits_1; inline;
    function  getSPI2RXIE : TBits_1; inline;
    function  getSPI2TXIE : TBits_1; inline;
    function  getU1EIE : TBits_1; inline;
    function  getU1RXIE : TBits_1; inline;
    function  getU1TXIE : TBits_1; inline;
    function  getU2EIE : TBits_1; inline;
    function  getU2RXIE : TBits_1; inline;
    function  getU2TXIE : TBits_1; inline;
    function  getU3EIE : TBits_1; inline;
    function  getU3RXIE : TBits_1; inline;
    function  getUSBIE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCMP1IE(thebits : TBits_1); inline;
    procedure setCMP2IE(thebits : TBits_1); inline;
    procedure setCNAIE(thebits : TBits_1); inline;
    procedure setCNBIE(thebits : TBits_1); inline;
    procedure setCNCIE(thebits : TBits_1); inline;
    procedure setCNDIE(thebits : TBits_1); inline;
    procedure setCNEIE(thebits : TBits_1); inline;
    procedure setCNFIE(thebits : TBits_1); inline;
    procedure setCNGIE(thebits : TBits_1); inline;
    procedure setI2C1BIE(thebits : TBits_1); inline;
    procedure setI2C1MIE(thebits : TBits_1); inline;
    procedure setI2C1SIE(thebits : TBits_1); inline;
    procedure setI2C2BIE(thebits : TBits_1); inline;
    procedure setI2C2MIE(thebits : TBits_1); inline;
    procedure setI2C2SIE(thebits : TBits_1); inline;
    procedure setPMPEIE(thebits : TBits_1); inline;
    procedure setPMPIE(thebits : TBits_1); inline;
    procedure setSPI1EIE(thebits : TBits_1); inline;
    procedure setSPI1RXIE(thebits : TBits_1); inline;
    procedure setSPI1TXIE(thebits : TBits_1); inline;
    procedure setSPI2EIE(thebits : TBits_1); inline;
    procedure setSPI2RXIE(thebits : TBits_1); inline;
    procedure setSPI2TXIE(thebits : TBits_1); inline;
    procedure setU1EIE(thebits : TBits_1); inline;
    procedure setU1RXIE(thebits : TBits_1); inline;
    procedure setU1TXIE(thebits : TBits_1); inline;
    procedure setU2EIE(thebits : TBits_1); inline;
    procedure setU2RXIE(thebits : TBits_1); inline;
    procedure setU2TXIE(thebits : TBits_1); inline;
    procedure setU3EIE(thebits : TBits_1); inline;
    procedure setU3RXIE(thebits : TBits_1); inline;
    procedure setUSBIE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCMP1IE; inline;
    procedure clearCMP2IE; inline;
    procedure clearCNAIE; inline;
    procedure clearCNBIE; inline;
    procedure clearCNCIE; inline;
    procedure clearCNDIE; inline;
    procedure clearCNEIE; inline;
    procedure clearCNFIE; inline;
    procedure clearCNGIE; inline;
    procedure clearI2C1BIE; inline;
    procedure clearI2C1MIE; inline;
    procedure clearI2C1SIE; inline;
    procedure clearI2C2BIE; inline;
    procedure clearI2C2MIE; inline;
    procedure clearI2C2SIE; inline;
    procedure clearPMPEIE; inline;
    procedure clearPMPIE; inline;
    procedure clearSPI1EIE; inline;
    procedure clearSPI1RXIE; inline;
    procedure clearSPI1TXIE; inline;
    procedure clearSPI2EIE; inline;
    procedure clearSPI2RXIE; inline;
    procedure clearSPI2TXIE; inline;
    procedure clearU1EIE; inline;
    procedure clearU1RXIE; inline;
    procedure clearU1TXIE; inline;
    procedure clearU2EIE; inline;
    procedure clearU2RXIE; inline;
    procedure clearU2TXIE; inline;
    procedure clearU3EIE; inline;
    procedure clearU3RXIE; inline;
    procedure clearUSBIE; inline;
    procedure setCMP1IE; inline;
    procedure setCMP2IE; inline;
    procedure setCNAIE; inline;
    procedure setCNBIE; inline;
    procedure setCNCIE; inline;
    procedure setCNDIE; inline;
    procedure setCNEIE; inline;
    procedure setCNFIE; inline;
    procedure setCNGIE; inline;
    procedure setI2C1BIE; inline;
    procedure setI2C1MIE; inline;
    procedure setI2C1SIE; inline;
    procedure setI2C2BIE; inline;
    procedure setI2C2MIE; inline;
    procedure setI2C2SIE; inline;
    procedure setPMPEIE; inline;
    procedure setPMPIE; inline;
    procedure setSPI1EIE; inline;
    procedure setSPI1RXIE; inline;
    procedure setSPI1TXIE; inline;
    procedure setSPI2EIE; inline;
    procedure setSPI2RXIE; inline;
    procedure setSPI2TXIE; inline;
    procedure setU1EIE; inline;
    procedure setU1RXIE; inline;
    procedure setU1TXIE; inline;
    procedure setU2EIE; inline;
    procedure setU2RXIE; inline;
    procedure setU2TXIE; inline;
    procedure setU3EIE; inline;
    procedure setU3RXIE; inline;
    procedure setUSBIE; inline;
    property CMP1IE : TBits_1 read getCMP1IE write setCMP1IE;
    property CMP2IE : TBits_1 read getCMP2IE write setCMP2IE;
    property CNAIE : TBits_1 read getCNAIE write setCNAIE;
    property CNBIE : TBits_1 read getCNBIE write setCNBIE;
    property CNCIE : TBits_1 read getCNCIE write setCNCIE;
    property CNDIE : TBits_1 read getCNDIE write setCNDIE;
    property CNEIE : TBits_1 read getCNEIE write setCNEIE;
    property CNFIE : TBits_1 read getCNFIE write setCNFIE;
    property CNGIE : TBits_1 read getCNGIE write setCNGIE;
    property I2C1BIE : TBits_1 read getI2C1BIE write setI2C1BIE;
    property I2C1MIE : TBits_1 read getI2C1MIE write setI2C1MIE;
    property I2C1SIE : TBits_1 read getI2C1SIE write setI2C1SIE;
    property I2C2BIE : TBits_1 read getI2C2BIE write setI2C2BIE;
    property I2C2MIE : TBits_1 read getI2C2MIE write setI2C2MIE;
    property I2C2SIE : TBits_1 read getI2C2SIE write setI2C2SIE;
    property PMPEIE : TBits_1 read getPMPEIE write setPMPEIE;
    property PMPIE : TBits_1 read getPMPIE write setPMPIE;
    property SPI1EIE : TBits_1 read getSPI1EIE write setSPI1EIE;
    property SPI1RXIE : TBits_1 read getSPI1RXIE write setSPI1RXIE;
    property SPI1TXIE : TBits_1 read getSPI1TXIE write setSPI1TXIE;
    property SPI2EIE : TBits_1 read getSPI2EIE write setSPI2EIE;
    property SPI2RXIE : TBits_1 read getSPI2RXIE write setSPI2RXIE;
    property SPI2TXIE : TBits_1 read getSPI2TXIE write setSPI2TXIE;
    property U1EIE : TBits_1 read getU1EIE write setU1EIE;
    property U1RXIE : TBits_1 read getU1RXIE write setU1RXIE;
    property U1TXIE : TBits_1 read getU1TXIE write setU1TXIE;
    property U2EIE : TBits_1 read getU2EIE write setU2EIE;
    property U2RXIE : TBits_1 read getU2RXIE write setU2RXIE;
    property U2TXIE : TBits_1 read getU2TXIE write setU2TXIE;
    property U3EIE : TBits_1 read getU3EIE write setU3EIE;
    property U3RXIE : TBits_1 read getU3RXIE write setU3RXIE;
    property USBIE : TBits_1 read getUSBIE write setUSBIE;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC0 = record
  private
    function  getCS0IP : TBits_3; inline;
    function  getCS0IS : TBits_2; inline;
    function  getCS1IP : TBits_3; inline;
    function  getCS1IS : TBits_2; inline;
    function  getCTIP : TBits_3; inline;
    function  getCTIS : TBits_2; inline;
    function  getINT0IP : TBits_3; inline;
    function  getINT0IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCS0IP(thebits : TBits_3); inline;
    procedure setCS0IS(thebits : TBits_2); inline;
    procedure setCS1IP(thebits : TBits_3); inline;
    procedure setCS1IS(thebits : TBits_2); inline;
    procedure setCTIP(thebits : TBits_3); inline;
    procedure setCTIS(thebits : TBits_2); inline;
    procedure setINT0IP(thebits : TBits_3); inline;
    procedure setINT0IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CS0IP : TBits_3 read getCS0IP write setCS0IP;
    property CS0IS : TBits_2 read getCS0IS write setCS0IS;
    property CS1IP : TBits_3 read getCS1IP write setCS1IP;
    property CS1IS : TBits_2 read getCS1IS write setCS1IS;
    property CTIP : TBits_3 read getCTIP write setCTIP;
    property CTIS : TBits_2 read getCTIS write setCTIS;
    property INT0IP : TBits_3 read getINT0IP write setINT0IP;
    property INT0IS : TBits_2 read getINT0IS write setINT0IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC1 = record
  private
    function  getIC1IP : TBits_3; inline;
    function  getIC1IS : TBits_2; inline;
    function  getINT1IP : TBits_3; inline;
    function  getINT1IS : TBits_2; inline;
    function  getOC1IP : TBits_3; inline;
    function  getOC1IS : TBits_2; inline;
    function  getT1IP : TBits_3; inline;
    function  getT1IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setIC1IP(thebits : TBits_3); inline;
    procedure setIC1IS(thebits : TBits_2); inline;
    procedure setINT1IP(thebits : TBits_3); inline;
    procedure setINT1IS(thebits : TBits_2); inline;
    procedure setOC1IP(thebits : TBits_3); inline;
    procedure setOC1IS(thebits : TBits_2); inline;
    procedure setT1IP(thebits : TBits_3); inline;
    procedure setT1IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property IC1IP : TBits_3 read getIC1IP write setIC1IP;
    property IC1IS : TBits_2 read getIC1IS write setIC1IS;
    property INT1IP : TBits_3 read getINT1IP write setINT1IP;
    property INT1IS : TBits_2 read getINT1IS write setINT1IS;
    property OC1IP : TBits_3 read getOC1IP write setOC1IP;
    property OC1IS : TBits_2 read getOC1IS write setOC1IS;
    property T1IP : TBits_3 read getT1IP write setT1IP;
    property T1IS : TBits_2 read getT1IS write setT1IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC2 = record
  private
    function  getIC2IP : TBits_3; inline;
    function  getIC2IS : TBits_2; inline;
    function  getINT2IP : TBits_3; inline;
    function  getINT2IS : TBits_2; inline;
    function  getOC2IP : TBits_3; inline;
    function  getOC2IS : TBits_2; inline;
    function  getT2IP : TBits_3; inline;
    function  getT2IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setIC2IP(thebits : TBits_3); inline;
    procedure setIC2IS(thebits : TBits_2); inline;
    procedure setINT2IP(thebits : TBits_3); inline;
    procedure setINT2IS(thebits : TBits_2); inline;
    procedure setOC2IP(thebits : TBits_3); inline;
    procedure setOC2IS(thebits : TBits_2); inline;
    procedure setT2IP(thebits : TBits_3); inline;
    procedure setT2IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property IC2IP : TBits_3 read getIC2IP write setIC2IP;
    property IC2IS : TBits_2 read getIC2IS write setIC2IS;
    property INT2IP : TBits_3 read getINT2IP write setINT2IP;
    property INT2IS : TBits_2 read getINT2IS write setINT2IS;
    property OC2IP : TBits_3 read getOC2IP write setOC2IP;
    property OC2IS : TBits_2 read getOC2IS write setOC2IS;
    property T2IP : TBits_3 read getT2IP write setT2IP;
    property T2IS : TBits_2 read getT2IS write setT2IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC3 = record
  private
    function  getIC3IP : TBits_3; inline;
    function  getIC3IS : TBits_2; inline;
    function  getINT3IP : TBits_3; inline;
    function  getINT3IS : TBits_2; inline;
    function  getOC3IP : TBits_3; inline;
    function  getOC3IS : TBits_2; inline;
    function  getT3IP : TBits_3; inline;
    function  getT3IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setIC3IP(thebits : TBits_3); inline;
    procedure setIC3IS(thebits : TBits_2); inline;
    procedure setINT3IP(thebits : TBits_3); inline;
    procedure setINT3IS(thebits : TBits_2); inline;
    procedure setOC3IP(thebits : TBits_3); inline;
    procedure setOC3IS(thebits : TBits_2); inline;
    procedure setT3IP(thebits : TBits_3); inline;
    procedure setT3IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property IC3IP : TBits_3 read getIC3IP write setIC3IP;
    property IC3IS : TBits_2 read getIC3IS write setIC3IS;
    property INT3IP : TBits_3 read getINT3IP write setINT3IP;
    property INT3IS : TBits_2 read getINT3IS write setINT3IS;
    property OC3IP : TBits_3 read getOC3IP write setOC3IP;
    property OC3IS : TBits_2 read getOC3IS write setOC3IS;
    property T3IP : TBits_3 read getT3IP write setT3IP;
    property T3IS : TBits_2 read getT3IS write setT3IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC4 = record
  private
    function  getIC4IP : TBits_3; inline;
    function  getIC4IS : TBits_2; inline;
    function  getINT4IP : TBits_3; inline;
    function  getINT4IS : TBits_2; inline;
    function  getOC4IP : TBits_3; inline;
    function  getOC4IS : TBits_2; inline;
    function  getT4IP : TBits_3; inline;
    function  getT4IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setIC4IP(thebits : TBits_3); inline;
    procedure setIC4IS(thebits : TBits_2); inline;
    procedure setINT4IP(thebits : TBits_3); inline;
    procedure setINT4IS(thebits : TBits_2); inline;
    procedure setOC4IP(thebits : TBits_3); inline;
    procedure setOC4IS(thebits : TBits_2); inline;
    procedure setT4IP(thebits : TBits_3); inline;
    procedure setT4IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property IC4IP : TBits_3 read getIC4IP write setIC4IP;
    property IC4IS : TBits_2 read getIC4IS write setIC4IS;
    property INT4IP : TBits_3 read getINT4IP write setINT4IP;
    property INT4IS : TBits_2 read getINT4IS write setINT4IS;
    property OC4IP : TBits_3 read getOC4IP write setOC4IP;
    property OC4IS : TBits_2 read getOC4IS write setOC4IS;
    property T4IP : TBits_3 read getT4IP write setT4IP;
    property T4IS : TBits_2 read getT4IS write setT4IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC5 = record
  private
    function  getAD1IP : TBits_3; inline;
    function  getAD1IS : TBits_2; inline;
    function  getIC5IP : TBits_3; inline;
    function  getIC5IS : TBits_2; inline;
    function  getOC5IP : TBits_3; inline;
    function  getOC5IS : TBits_2; inline;
    function  getT5IP : TBits_3; inline;
    function  getT5IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setAD1IP(thebits : TBits_3); inline;
    procedure setAD1IS(thebits : TBits_2); inline;
    procedure setIC5IP(thebits : TBits_3); inline;
    procedure setIC5IS(thebits : TBits_2); inline;
    procedure setOC5IP(thebits : TBits_3); inline;
    procedure setOC5IS(thebits : TBits_2); inline;
    procedure setT5IP(thebits : TBits_3); inline;
    procedure setT5IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property AD1IP : TBits_3 read getAD1IP write setAD1IP;
    property AD1IS : TBits_2 read getAD1IS write setAD1IS;
    property IC5IP : TBits_3 read getIC5IP write setIC5IP;
    property IC5IS : TBits_2 read getIC5IS write setIC5IS;
    property OC5IP : TBits_3 read getOC5IP write setOC5IP;
    property OC5IS : TBits_2 read getOC5IS write setOC5IS;
    property T5IP : TBits_3 read getT5IP write setT5IP;
    property T5IS : TBits_2 read getT5IS write setT5IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC6 = record
  private
    function  getCMP1IP : TBits_3; inline;
    function  getCMP1IS : TBits_2; inline;
    function  getFCEIP : TBits_3; inline;
    function  getFCEIS : TBits_2; inline;
    function  getFSCMIP : TBits_3; inline;
    function  getFSCMIS : TBits_2; inline;
    function  getRTCCIP : TBits_3; inline;
    function  getRTCCIS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCMP1IP(thebits : TBits_3); inline;
    procedure setCMP1IS(thebits : TBits_2); inline;
    procedure setFCEIP(thebits : TBits_3); inline;
    procedure setFCEIS(thebits : TBits_2); inline;
    procedure setFSCMIP(thebits : TBits_3); inline;
    procedure setFSCMIS(thebits : TBits_2); inline;
    procedure setRTCCIP(thebits : TBits_3); inline;
    procedure setRTCCIS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CMP1IP : TBits_3 read getCMP1IP write setCMP1IP;
    property CMP1IS : TBits_2 read getCMP1IS write setCMP1IS;
    property FCEIP : TBits_3 read getFCEIP write setFCEIP;
    property FCEIS : TBits_2 read getFCEIS write setFCEIS;
    property FSCMIP : TBits_3 read getFSCMIP write setFSCMIP;
    property FSCMIS : TBits_2 read getFSCMIS write setFSCMIS;
    property RTCCIP : TBits_3 read getRTCCIP write setRTCCIP;
    property RTCCIS : TBits_2 read getRTCCIS write setRTCCIS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC7 = record
  private
    function  getCMP2IP : TBits_3; inline;
    function  getCMP2IS : TBits_2; inline;
    function  getSPI1IP : TBits_3; inline;
    function  getSPI1IS : TBits_2; inline;
    function  getU1IP : TBits_3; inline;
    function  getU1IS : TBits_2; inline;
    function  getUSBIP : TBits_3; inline;
    function  getUSBIS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCMP2IP(thebits : TBits_3); inline;
    procedure setCMP2IS(thebits : TBits_2); inline;
    procedure setSPI1IP(thebits : TBits_3); inline;
    procedure setSPI1IS(thebits : TBits_2); inline;
    procedure setU1IP(thebits : TBits_3); inline;
    procedure setU1IS(thebits : TBits_2); inline;
    procedure setUSBIP(thebits : TBits_3); inline;
    procedure setUSBIS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CMP2IP : TBits_3 read getCMP2IP write setCMP2IP;
    property CMP2IS : TBits_2 read getCMP2IS write setCMP2IS;
    property SPI1IP : TBits_3 read getSPI1IP write setSPI1IP;
    property SPI1IS : TBits_2 read getSPI1IS write setSPI1IS;
    property U1IP : TBits_3 read getU1IP write setU1IP;
    property U1IS : TBits_2 read getU1IS write setU1IS;
    property USBIP : TBits_3 read getUSBIP write setUSBIP;
    property USBIS : TBits_2 read getUSBIS write setUSBIS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC8 = record
  private
    function  getCNIP : TBits_3; inline;
    function  getCNIS : TBits_2; inline;
    function  getI2C1IP : TBits_3; inline;
    function  getI2C1IS : TBits_2; inline;
    function  getPMPIP : TBits_3; inline;
    function  getPMPIS : TBits_2; inline;
    function  getSPI2IP : TBits_3; inline;
    function  getSPI2IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCNIP(thebits : TBits_3); inline;
    procedure setCNIS(thebits : TBits_2); inline;
    procedure setI2C1IP(thebits : TBits_3); inline;
    procedure setI2C1IS(thebits : TBits_2); inline;
    procedure setPMPIP(thebits : TBits_3); inline;
    procedure setPMPIS(thebits : TBits_2); inline;
    procedure setSPI2IP(thebits : TBits_3); inline;
    procedure setSPI2IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CNIP : TBits_3 read getCNIP write setCNIP;
    property CNIS : TBits_2 read getCNIS write setCNIS;
    property I2C1IP : TBits_3 read getI2C1IP write setI2C1IP;
    property I2C1IS : TBits_2 read getI2C1IS write setI2C1IS;
    property PMPIP : TBits_3 read getPMPIP write setPMPIP;
    property PMPIS : TBits_2 read getPMPIS write setPMPIS;
    property SPI2IP : TBits_3 read getSPI2IP write setSPI2IP;
    property SPI2IS : TBits_2 read getSPI2IS write setSPI2IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC9 = record
  private
    function  getI2C2IP : TBits_3; inline;
    function  getI2C2IS : TBits_2; inline;
    function  getU2IP : TBits_3; inline;
    function  getU2IS : TBits_2; inline;
    function  getU3IP : TBits_3; inline;
    function  getU3IS : TBits_2; inline;
    function  getU4IP : TBits_3; inline;
    function  getU4IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setI2C2IP(thebits : TBits_3); inline;
    procedure setI2C2IS(thebits : TBits_2); inline;
    procedure setU2IP(thebits : TBits_3); inline;
    procedure setU2IS(thebits : TBits_2); inline;
    procedure setU3IP(thebits : TBits_3); inline;
    procedure setU3IS(thebits : TBits_2); inline;
    procedure setU4IP(thebits : TBits_3); inline;
    procedure setU4IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property I2C2IP : TBits_3 read getI2C2IP write setI2C2IP;
    property I2C2IS : TBits_2 read getI2C2IS write setI2C2IS;
    property U2IP : TBits_3 read getU2IP write setU2IP;
    property U2IS : TBits_2 read getU2IS write setU2IS;
    property U3IP : TBits_3 read getU3IP write setU3IP;
    property U3IS : TBits_2 read getU3IS write setU3IS;
    property U4IP : TBits_3 read getU4IP write setU4IP;
    property U4IS : TBits_2 read getU4IS write setU4IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC10 = record
  private
    function  getCTMUIP : TBits_2; inline;
    function  getCTMUIS : TBits_3; inline;
    function  getDMA0IP : TBits_3; inline;
    function  getDMA0IS : TBits_2; inline;
    function  getDMA1IP : TBits_3; inline;
    function  getDMA1IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCTMUIP(thebits : TBits_2); inline;
    procedure setCTMUIS(thebits : TBits_3); inline;
    procedure setDMA0IP(thebits : TBits_3); inline;
    procedure setDMA0IS(thebits : TBits_2); inline;
    procedure setDMA1IP(thebits : TBits_3); inline;
    procedure setDMA1IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CTMUIP : TBits_2 read getCTMUIP write setCTMUIP;
    property CTMUIS : TBits_3 read getCTMUIS write setCTMUIS;
    property DMA0IP : TBits_3 read getDMA0IP write setDMA0IP;
    property DMA0IS : TBits_2 read getDMA0IS write setDMA0IS;
    property DMA1IP : TBits_3 read getDMA1IP write setDMA1IP;
    property DMA1IS : TBits_2 read getDMA1IS write setDMA1IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC11 = record
  private
    function  getDMA2IP : TBits_3; inline;
    function  getDMA2IS : TBits_2; inline;
    function  getDMA3IP : TBits_3; inline;
    function  getDMA3IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setDMA2IP(thebits : TBits_3); inline;
    procedure setDMA2IS(thebits : TBits_2); inline;
    procedure setDMA3IP(thebits : TBits_3); inline;
    procedure setDMA3IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DMA2IP : TBits_3 read getDMA2IP write setDMA2IP;
    property DMA2IS : TBits_2 read getDMA2IS write setDMA2IS;
    property DMA3IP : TBits_3 read getDMA3IP write setDMA3IP;
    property DMA3IS : TBits_2 read getDMA3IS write setDMA3IS;
    property w : TBits_32 read getw write setw;
  end;
type
  TINTRegisters = record
    INTCONbits : TINT_INTCON;
    INTCON : longWord;
    INTCONCLR : longWord;
    INTCONSET : longWord;
    INTCONINV : longWord;
    INTSTAT : longWord;
    IPTMR : longWord;
    IPTMRCLR : longWord;
    IPTMRSET : longWord;
    IPTMRINV : longWord;
    IFS0bits : TINT_IFS0;
    IFS0 : longWord;
    IFS0CLR : longWord;
    IFS0SET : longWord;
    IFS0INV : longWord;
    IFS1bits : TINT_IFS1;
    IFS1 : longWord;
    IFS1CLR : longWord;
    IFS1SET : longWord;
    IFS1INV : longWord;
    IFS2 : longWord;
    IFS2CLR : longWord;
    IFS2SET : longWord;
    IFS2INV : longWord;
    IEC0bits : TINT_IEC0;
    IEC0 : longWord;
    IEC0CLR : longWord;
    IEC0SET : longWord;
    IEC0INV : longWord;
    IEC1bits : TINT_IEC1;
    IEC1 : longWord;
    IEC1CLR : longWord;
    IEC1SET : longWord;
    IEC1INV : longWord;
    IEC2 : longWord;
    IEC2CLR : longWord;
    IEC2SET : longWord;
    IEC2INV : longWord;
    IPC0bits : TINT_IPC0;
    IPC0 : longWord;
    IPC0CLR : longWord;
    IPC0SET : longWord;
    IPC0INV : longWord;
    IPC1bits : TINT_IPC1;
    IPC1 : longWord;
    IPC1CLR : longWord;
    IPC1SET : longWord;
    IPC1INV : longWord;
    IPC2bits : TINT_IPC2;
    IPC2 : longWord;
    IPC2CLR : longWord;
    IPC2SET : longWord;
    IPC2INV : longWord;
    IPC3bits : TINT_IPC3;
    IPC3 : longWord;
    IPC3CLR : longWord;
    IPC3SET : longWord;
    IPC3INV : longWord;
    IPC4bits : TINT_IPC4;
    IPC4 : longWord;
    IPC4CLR : longWord;
    IPC4SET : longWord;
    IPC4INV : longWord;
    IPC5bits : TINT_IPC5;
    IPC5 : longWord;
    IPC5CLR : longWord;
    IPC5SET : longWord;
    IPC5INV : longWord;
    IPC6bits : TINT_IPC6;
    IPC6 : longWord;
    IPC6CLR : longWord;
    IPC6SET : longWord;
    IPC6INV : longWord;
    IPC7bits : TINT_IPC7;
    IPC7 : longWord;
    IPC7CLR : longWord;
    IPC7SET : longWord;
    IPC7INV : longWord;
    IPC8bits : TINT_IPC8;
    IPC8 : longWord;
    IPC8CLR : longWord;
    IPC8SET : longWord;
    IPC8INV : longWord;
    IPC9bits : TINT_IPC9;
    IPC9 : longWord;
    IPC9CLR : longWord;
    IPC9SET : longWord;
    IPC9INV : longWord;
    IPC10bits : TINT_IPC10;
    IPC10 : longWord;
    IPC10CLR : longWord;
    IPC10SET : longWord;
    IPC10INV : longWord;
    IPC11bits : TINT_IPC11;
    IPC11 : longWord;
    IPC11CLR : longWord;
    IPC11SET : longWord;
    IPC11INV : longWord;
  end;
  TBMX_BMXCON = record
  private
    function  getBMXARB : TBits_3; inline;
    function  getBMXCHEDMA : TBits_1; inline;
    function  getBMXERRDMA : TBits_1; inline;
    function  getBMXERRDS : TBits_1; inline;
    function  getBMXERRICD : TBits_1; inline;
    function  getBMXERRIS : TBits_1; inline;
    function  getBMXERRIXI : TBits_1; inline;
    function  getBMXWSDRM : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBMXARB(thebits : TBits_3); inline;
    procedure setBMXCHEDMA(thebits : TBits_1); inline;
    procedure setBMXERRDMA(thebits : TBits_1); inline;
    procedure setBMXERRDS(thebits : TBits_1); inline;
    procedure setBMXERRICD(thebits : TBits_1); inline;
    procedure setBMXERRIS(thebits : TBits_1); inline;
    procedure setBMXERRIXI(thebits : TBits_1); inline;
    procedure setBMXWSDRM(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBMXCHEDMA; inline;
    procedure clearBMXERRDMA; inline;
    procedure clearBMXERRDS; inline;
    procedure clearBMXERRICD; inline;
    procedure clearBMXERRIS; inline;
    procedure clearBMXERRIXI; inline;
    procedure clearBMXWSDRM; inline;
    procedure setBMXCHEDMA; inline;
    procedure setBMXERRDMA; inline;
    procedure setBMXERRDS; inline;
    procedure setBMXERRICD; inline;
    procedure setBMXERRIS; inline;
    procedure setBMXERRIXI; inline;
    procedure setBMXWSDRM; inline;
    property BMXARB : TBits_3 read getBMXARB write setBMXARB;
    property BMXCHEDMA : TBits_1 read getBMXCHEDMA write setBMXCHEDMA;
    property BMXERRDMA : TBits_1 read getBMXERRDMA write setBMXERRDMA;
    property BMXERRDS : TBits_1 read getBMXERRDS write setBMXERRDS;
    property BMXERRICD : TBits_1 read getBMXERRICD write setBMXERRICD;
    property BMXERRIS : TBits_1 read getBMXERRIS write setBMXERRIS;
    property BMXERRIXI : TBits_1 read getBMXERRIXI write setBMXERRIXI;
    property BMXWSDRM : TBits_1 read getBMXWSDRM write setBMXWSDRM;
    property w : TBits_32 read getw write setw;
  end;
type
  TBMXRegisters = record
    BMXCONbits : TBMX_BMXCON;
    BMXCON : longWord;
    BMXCONCLR : longWord;
    BMXCONSET : longWord;
    BMXCONINV : longWord;
    BMXDKPBA : longWord;
    BMXDKPBACLR : longWord;
    BMXDKPBASET : longWord;
    BMXDKPBAINV : longWord;
    BMXDUDBA : longWord;
    BMXDUDBACLR : longWord;
    BMXDUDBASET : longWord;
    BMXDUDBAINV : longWord;
    BMXDUPBA : longWord;
    BMXDUPBACLR : longWord;
    BMXDUPBASET : longWord;
    BMXDUPBAINV : longWord;
    BMXDRMSZ : longWord;
    BMXPUPBA : longWord;
    BMXPUPBACLR : longWord;
    BMXPUPBASET : longWord;
    BMXPUPBAINV : longWord;
    BMXPFMSZ : longWord;
    BMXBOOTSZ : longWord;
  end;
  TDMAC_DMACON = record
  private
    function  getDMABUSY : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSUSPEND : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDMABUSY(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSUSPEND(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDMABUSY; inline;
    procedure clearON; inline;
    procedure clearSUSPEND; inline;
    procedure setDMABUSY; inline;
    procedure setON; inline;
    procedure setSUSPEND; inline;
    property DMABUSY : TBits_1 read getDMABUSY write setDMABUSY;
    property ON : TBits_1 read getON write setON;
    property SUSPEND : TBits_1 read getSUSPEND write setSUSPEND;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC_DMASTAT = record
  private
    function  getDMACH : TBits_3; inline;
    function  getRDWR : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDMACH(thebits : TBits_3); inline;
    procedure setRDWR(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRDWR; inline;
    procedure setRDWR; inline;
    property DMACH : TBits_3 read getDMACH write setDMACH;
    property RDWR : TBits_1 read getRDWR write setRDWR;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC_DCRCCON = record
  private
    function  getBITO : TBits_1; inline;
    function  getBYTO : TBits_2; inline;
    function  getCRCAPP : TBits_1; inline;
    function  getCRCCH : TBits_3; inline;
    function  getCRCEN : TBits_1; inline;
    function  getCRCTYP : TBits_1; inline;
    function  getPLEN : TBits_5; inline;
    function  getWBO : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBITO(thebits : TBits_1); inline;
    procedure setBYTO(thebits : TBits_2); inline;
    procedure setCRCAPP(thebits : TBits_1); inline;
    procedure setCRCCH(thebits : TBits_3); inline;
    procedure setCRCEN(thebits : TBits_1); inline;
    procedure setCRCTYP(thebits : TBits_1); inline;
    procedure setPLEN(thebits : TBits_5); inline;
    procedure setWBO(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBITO; inline;
    procedure clearCRCAPP; inline;
    procedure clearCRCEN; inline;
    procedure clearCRCTYP; inline;
    procedure clearWBO; inline;
    procedure setBITO; inline;
    procedure setCRCAPP; inline;
    procedure setCRCEN; inline;
    procedure setCRCTYP; inline;
    procedure setWBO; inline;
    property BITO : TBits_1 read getBITO write setBITO;
    property BYTO : TBits_2 read getBYTO write setBYTO;
    property CRCAPP : TBits_1 read getCRCAPP write setCRCAPP;
    property CRCCH : TBits_3 read getCRCCH write setCRCCH;
    property CRCEN : TBits_1 read getCRCEN write setCRCEN;
    property CRCTYP : TBits_1 read getCRCTYP write setCRCTYP;
    property PLEN : TBits_5 read getPLEN write setPLEN;
    property WBO : TBits_1 read getWBO write setWBO;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMACRegisters = record
    DMACONbits : TDMAC_DMACON;
    DMACON : longWord;
    DMACONCLR : longWord;
    DMACONSET : longWord;
    DMACONINV : longWord;
    DMASTATbits : TDMAC_DMASTAT;
    DMASTAT : longWord;
    DMASTATCLR : longWord;
    DMASTATSET : longWord;
    DMASTATINV : longWord;
    DMAADDR : longWord;
    DMAADDRCLR : longWord;
    DMAADDRSET : longWord;
    DMAADDRINV : longWord;
    DCRCCONbits : TDMAC_DCRCCON;
    DCRCCON : longWord;
    DCRCCONCLR : longWord;
    DCRCCONSET : longWord;
    DCRCCONINV : longWord;
    DCRCDATA : longWord;
    DCRCDATACLR : longWord;
    DCRCDATASET : longWord;
    DCRCDATAINV : longWord;
    DCRCXOR : longWord;
    DCRCXORCLR : longWord;
    DCRCXORSET : longWord;
    DCRCXORINV : longWord;
  end;
  TDMAC0_DCH0CON = record
  private
    function  getCHAED : TBits_1; inline;
    function  getCHAEN : TBits_1; inline;
    function  getCHBUSY : TBits_1; inline;
    function  getCHCHN : TBits_1; inline;
    function  getCHCHNS : TBits_1; inline;
    function  getCHEDET : TBits_1; inline;
    function  getCHEN : TBits_1; inline;
    function  getCHPRI : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHAED(thebits : TBits_1); inline;
    procedure setCHAEN(thebits : TBits_1); inline;
    procedure setCHBUSY(thebits : TBits_1); inline;
    procedure setCHCHN(thebits : TBits_1); inline;
    procedure setCHCHNS(thebits : TBits_1); inline;
    procedure setCHEDET(thebits : TBits_1); inline;
    procedure setCHEN(thebits : TBits_1); inline;
    procedure setCHPRI(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHAED; inline;
    procedure clearCHAEN; inline;
    procedure clearCHBUSY; inline;
    procedure clearCHCHN; inline;
    procedure clearCHCHNS; inline;
    procedure clearCHEDET; inline;
    procedure clearCHEN; inline;
    procedure setCHAED; inline;
    procedure setCHAEN; inline;
    procedure setCHBUSY; inline;
    procedure setCHCHN; inline;
    procedure setCHCHNS; inline;
    procedure setCHEDET; inline;
    procedure setCHEN; inline;
    property CHAED : TBits_1 read getCHAED write setCHAED;
    property CHAEN : TBits_1 read getCHAEN write setCHAEN;
    property CHBUSY : TBits_1 read getCHBUSY write setCHBUSY;
    property CHCHN : TBits_1 read getCHCHN write setCHCHN;
    property CHCHNS : TBits_1 read getCHCHNS write setCHCHNS;
    property CHEDET : TBits_1 read getCHEDET write setCHEDET;
    property CHEN : TBits_1 read getCHEN write setCHEN;
    property CHPRI : TBits_2 read getCHPRI write setCHPRI;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC0_DCH0ECON = record
  private
    function  getAIRQEN : TBits_1; inline;
    function  getCABORT : TBits_1; inline;
    function  getCFORCE : TBits_1; inline;
    function  getCHAIRQ : TBits_8; inline;
    function  getCHSIRQ : TBits_8; inline;
    function  getPATEN : TBits_1; inline;
    function  getSIRQEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAIRQEN(thebits : TBits_1); inline;
    procedure setCABORT(thebits : TBits_1); inline;
    procedure setCFORCE(thebits : TBits_1); inline;
    procedure setCHAIRQ(thebits : TBits_8); inline;
    procedure setCHSIRQ(thebits : TBits_8); inline;
    procedure setPATEN(thebits : TBits_1); inline;
    procedure setSIRQEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAIRQEN; inline;
    procedure clearCABORT; inline;
    procedure clearCFORCE; inline;
    procedure clearPATEN; inline;
    procedure clearSIRQEN; inline;
    procedure setAIRQEN; inline;
    procedure setCABORT; inline;
    procedure setCFORCE; inline;
    procedure setPATEN; inline;
    procedure setSIRQEN; inline;
    property AIRQEN : TBits_1 read getAIRQEN write setAIRQEN;
    property CABORT : TBits_1 read getCABORT write setCABORT;
    property CFORCE : TBits_1 read getCFORCE write setCFORCE;
    property CHAIRQ : TBits_8 read getCHAIRQ write setCHAIRQ;
    property CHSIRQ : TBits_8 read getCHSIRQ write setCHSIRQ;
    property PATEN : TBits_1 read getPATEN write setPATEN;
    property SIRQEN : TBits_1 read getSIRQEN write setSIRQEN;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC0_DCH0INT = record
  private
    function  getCHBCIE : TBits_1; inline;
    function  getCHBCIF : TBits_1; inline;
    function  getCHCCIE : TBits_1; inline;
    function  getCHCCIF : TBits_1; inline;
    function  getCHDDIE : TBits_1; inline;
    function  getCHDDIF : TBits_1; inline;
    function  getCHDHIE : TBits_1; inline;
    function  getCHDHIF : TBits_1; inline;
    function  getCHERIE : TBits_1; inline;
    function  getCHERIF : TBits_1; inline;
    function  getCHSDIE : TBits_1; inline;
    function  getCHSDIF : TBits_1; inline;
    function  getCHSHIE : TBits_1; inline;
    function  getCHSHIF : TBits_1; inline;
    function  getCHTAIE : TBits_1; inline;
    function  getCHTAIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCHBCIE(thebits : TBits_1); inline;
    procedure setCHBCIF(thebits : TBits_1); inline;
    procedure setCHCCIE(thebits : TBits_1); inline;
    procedure setCHCCIF(thebits : TBits_1); inline;
    procedure setCHDDIE(thebits : TBits_1); inline;
    procedure setCHDDIF(thebits : TBits_1); inline;
    procedure setCHDHIE(thebits : TBits_1); inline;
    procedure setCHDHIF(thebits : TBits_1); inline;
    procedure setCHERIE(thebits : TBits_1); inline;
    procedure setCHERIF(thebits : TBits_1); inline;
    procedure setCHSDIE(thebits : TBits_1); inline;
    procedure setCHSDIF(thebits : TBits_1); inline;
    procedure setCHSHIE(thebits : TBits_1); inline;
    procedure setCHSHIF(thebits : TBits_1); inline;
    procedure setCHTAIE(thebits : TBits_1); inline;
    procedure setCHTAIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHBCIE; inline;
    procedure clearCHBCIF; inline;
    procedure clearCHCCIE; inline;
    procedure clearCHCCIF; inline;
    procedure clearCHDDIE; inline;
    procedure clearCHDDIF; inline;
    procedure clearCHDHIE; inline;
    procedure clearCHDHIF; inline;
    procedure clearCHERIE; inline;
    procedure clearCHERIF; inline;
    procedure clearCHSDIE; inline;
    procedure clearCHSDIF; inline;
    procedure clearCHSHIE; inline;
    procedure clearCHSHIF; inline;
    procedure clearCHTAIE; inline;
    procedure clearCHTAIF; inline;
    procedure setCHBCIE; inline;
    procedure setCHBCIF; inline;
    procedure setCHCCIE; inline;
    procedure setCHCCIF; inline;
    procedure setCHDDIE; inline;
    procedure setCHDDIF; inline;
    procedure setCHDHIE; inline;
    procedure setCHDHIF; inline;
    procedure setCHERIE; inline;
    procedure setCHERIF; inline;
    procedure setCHSDIE; inline;
    procedure setCHSDIF; inline;
    procedure setCHSHIE; inline;
    procedure setCHSHIF; inline;
    procedure setCHTAIE; inline;
    procedure setCHTAIF; inline;
    property CHBCIE : TBits_1 read getCHBCIE write setCHBCIE;
    property CHBCIF : TBits_1 read getCHBCIF write setCHBCIF;
    property CHCCIE : TBits_1 read getCHCCIE write setCHCCIE;
    property CHCCIF : TBits_1 read getCHCCIF write setCHCCIF;
    property CHDDIE : TBits_1 read getCHDDIE write setCHDDIE;
    property CHDDIF : TBits_1 read getCHDDIF write setCHDDIF;
    property CHDHIE : TBits_1 read getCHDHIE write setCHDHIE;
    property CHDHIF : TBits_1 read getCHDHIF write setCHDHIF;
    property CHERIE : TBits_1 read getCHERIE write setCHERIE;
    property CHERIF : TBits_1 read getCHERIF write setCHERIF;
    property CHSDIE : TBits_1 read getCHSDIE write setCHSDIE;
    property CHSDIF : TBits_1 read getCHSDIF write setCHSDIF;
    property CHSHIE : TBits_1 read getCHSHIE write setCHSHIE;
    property CHSHIF : TBits_1 read getCHSHIF write setCHSHIF;
    property CHTAIE : TBits_1 read getCHTAIE write setCHTAIE;
    property CHTAIF : TBits_1 read getCHTAIF write setCHTAIF;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMAC0Registers = record
    DCH0CONbits : TDMAC0_DCH0CON;
    DCH0CON : longWord;
    DCH0CONCLR : longWord;
    DCH0CONSET : longWord;
    DCH0CONINV : longWord;
    DCH0ECONbits : TDMAC0_DCH0ECON;
    DCH0ECON : longWord;
    DCH0ECONCLR : longWord;
    DCH0ECONSET : longWord;
    DCH0ECONINV : longWord;
    DCH0INTbits : TDMAC0_DCH0INT;
    DCH0INT : longWord;
    DCH0INTCLR : longWord;
    DCH0INTSET : longWord;
    DCH0INTINV : longWord;
    DCH0SSA : longWord;
    DCH0SSACLR : longWord;
    DCH0SSASET : longWord;
    DCH0SSAINV : longWord;
    DCH0DSA : longWord;
    DCH0DSACLR : longWord;
    DCH0DSASET : longWord;
    DCH0DSAINV : longWord;
    DCH0SSIZ : longWord;
    DCH0SSIZCLR : longWord;
    DCH0SSIZSET : longWord;
    DCH0SSIZINV : longWord;
    DCH0DSIZ : longWord;
    DCH0DSIZCLR : longWord;
    DCH0DSIZSET : longWord;
    DCH0DSIZINV : longWord;
    DCH0SPTR : longWord;
    DCH0SPTRCLR : longWord;
    DCH0SPTRSET : longWord;
    DCH0SPTRINV : longWord;
    DCH0DPTR : longWord;
    DCH0DPTRCLR : longWord;
    DCH0DPTRSET : longWord;
    DCH0DPTRINV : longWord;
    DCH0CSIZ : longWord;
    DCH0CSIZCLR : longWord;
    DCH0CSIZSET : longWord;
    DCH0CSIZINV : longWord;
    DCH0CPTR : longWord;
    DCH0CPTRCLR : longWord;
    DCH0CPTRSET : longWord;
    DCH0CPTRINV : longWord;
    DCH0DAT : longWord;
    DCH0DATCLR : longWord;
    DCH0DATSET : longWord;
    DCH0DATINV : longWord;
  end;
  TDMAC1_DCH1CON = record
  private
    function  getCHAED : TBits_1; inline;
    function  getCHAEN : TBits_1; inline;
    function  getCHBUSY : TBits_1; inline;
    function  getCHCHN : TBits_1; inline;
    function  getCHCHNS : TBits_1; inline;
    function  getCHEDET : TBits_1; inline;
    function  getCHEN : TBits_1; inline;
    function  getCHPRI : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHAED(thebits : TBits_1); inline;
    procedure setCHAEN(thebits : TBits_1); inline;
    procedure setCHBUSY(thebits : TBits_1); inline;
    procedure setCHCHN(thebits : TBits_1); inline;
    procedure setCHCHNS(thebits : TBits_1); inline;
    procedure setCHEDET(thebits : TBits_1); inline;
    procedure setCHEN(thebits : TBits_1); inline;
    procedure setCHPRI(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHAED; inline;
    procedure clearCHAEN; inline;
    procedure clearCHBUSY; inline;
    procedure clearCHCHN; inline;
    procedure clearCHCHNS; inline;
    procedure clearCHEDET; inline;
    procedure clearCHEN; inline;
    procedure setCHAED; inline;
    procedure setCHAEN; inline;
    procedure setCHBUSY; inline;
    procedure setCHCHN; inline;
    procedure setCHCHNS; inline;
    procedure setCHEDET; inline;
    procedure setCHEN; inline;
    property CHAED : TBits_1 read getCHAED write setCHAED;
    property CHAEN : TBits_1 read getCHAEN write setCHAEN;
    property CHBUSY : TBits_1 read getCHBUSY write setCHBUSY;
    property CHCHN : TBits_1 read getCHCHN write setCHCHN;
    property CHCHNS : TBits_1 read getCHCHNS write setCHCHNS;
    property CHEDET : TBits_1 read getCHEDET write setCHEDET;
    property CHEN : TBits_1 read getCHEN write setCHEN;
    property CHPRI : TBits_2 read getCHPRI write setCHPRI;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC1_DCH1ECON = record
  private
    function  getAIRQEN : TBits_1; inline;
    function  getCABORT : TBits_1; inline;
    function  getCFORCE : TBits_1; inline;
    function  getCHAIRQ : TBits_8; inline;
    function  getCHSIRQ : TBits_8; inline;
    function  getPATEN : TBits_1; inline;
    function  getSIRQEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAIRQEN(thebits : TBits_1); inline;
    procedure setCABORT(thebits : TBits_1); inline;
    procedure setCFORCE(thebits : TBits_1); inline;
    procedure setCHAIRQ(thebits : TBits_8); inline;
    procedure setCHSIRQ(thebits : TBits_8); inline;
    procedure setPATEN(thebits : TBits_1); inline;
    procedure setSIRQEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAIRQEN; inline;
    procedure clearCABORT; inline;
    procedure clearCFORCE; inline;
    procedure clearPATEN; inline;
    procedure clearSIRQEN; inline;
    procedure setAIRQEN; inline;
    procedure setCABORT; inline;
    procedure setCFORCE; inline;
    procedure setPATEN; inline;
    procedure setSIRQEN; inline;
    property AIRQEN : TBits_1 read getAIRQEN write setAIRQEN;
    property CABORT : TBits_1 read getCABORT write setCABORT;
    property CFORCE : TBits_1 read getCFORCE write setCFORCE;
    property CHAIRQ : TBits_8 read getCHAIRQ write setCHAIRQ;
    property CHSIRQ : TBits_8 read getCHSIRQ write setCHSIRQ;
    property PATEN : TBits_1 read getPATEN write setPATEN;
    property SIRQEN : TBits_1 read getSIRQEN write setSIRQEN;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC1_DCH1INT = record
  private
    function  getCHBCIE : TBits_1; inline;
    function  getCHBCIF : TBits_1; inline;
    function  getCHCCIE : TBits_1; inline;
    function  getCHCCIF : TBits_1; inline;
    function  getCHDDIE : TBits_1; inline;
    function  getCHDDIF : TBits_1; inline;
    function  getCHDHIE : TBits_1; inline;
    function  getCHDHIF : TBits_1; inline;
    function  getCHERIE : TBits_1; inline;
    function  getCHERIF : TBits_1; inline;
    function  getCHSDIE : TBits_1; inline;
    function  getCHSDIF : TBits_1; inline;
    function  getCHSHIE : TBits_1; inline;
    function  getCHSHIF : TBits_1; inline;
    function  getCHTAIE : TBits_1; inline;
    function  getCHTAIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCHBCIE(thebits : TBits_1); inline;
    procedure setCHBCIF(thebits : TBits_1); inline;
    procedure setCHCCIE(thebits : TBits_1); inline;
    procedure setCHCCIF(thebits : TBits_1); inline;
    procedure setCHDDIE(thebits : TBits_1); inline;
    procedure setCHDDIF(thebits : TBits_1); inline;
    procedure setCHDHIE(thebits : TBits_1); inline;
    procedure setCHDHIF(thebits : TBits_1); inline;
    procedure setCHERIE(thebits : TBits_1); inline;
    procedure setCHERIF(thebits : TBits_1); inline;
    procedure setCHSDIE(thebits : TBits_1); inline;
    procedure setCHSDIF(thebits : TBits_1); inline;
    procedure setCHSHIE(thebits : TBits_1); inline;
    procedure setCHSHIF(thebits : TBits_1); inline;
    procedure setCHTAIE(thebits : TBits_1); inline;
    procedure setCHTAIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHBCIE; inline;
    procedure clearCHBCIF; inline;
    procedure clearCHCCIE; inline;
    procedure clearCHCCIF; inline;
    procedure clearCHDDIE; inline;
    procedure clearCHDDIF; inline;
    procedure clearCHDHIE; inline;
    procedure clearCHDHIF; inline;
    procedure clearCHERIE; inline;
    procedure clearCHERIF; inline;
    procedure clearCHSDIE; inline;
    procedure clearCHSDIF; inline;
    procedure clearCHSHIE; inline;
    procedure clearCHSHIF; inline;
    procedure clearCHTAIE; inline;
    procedure clearCHTAIF; inline;
    procedure setCHBCIE; inline;
    procedure setCHBCIF; inline;
    procedure setCHCCIE; inline;
    procedure setCHCCIF; inline;
    procedure setCHDDIE; inline;
    procedure setCHDDIF; inline;
    procedure setCHDHIE; inline;
    procedure setCHDHIF; inline;
    procedure setCHERIE; inline;
    procedure setCHERIF; inline;
    procedure setCHSDIE; inline;
    procedure setCHSDIF; inline;
    procedure setCHSHIE; inline;
    procedure setCHSHIF; inline;
    procedure setCHTAIE; inline;
    procedure setCHTAIF; inline;
    property CHBCIE : TBits_1 read getCHBCIE write setCHBCIE;
    property CHBCIF : TBits_1 read getCHBCIF write setCHBCIF;
    property CHCCIE : TBits_1 read getCHCCIE write setCHCCIE;
    property CHCCIF : TBits_1 read getCHCCIF write setCHCCIF;
    property CHDDIE : TBits_1 read getCHDDIE write setCHDDIE;
    property CHDDIF : TBits_1 read getCHDDIF write setCHDDIF;
    property CHDHIE : TBits_1 read getCHDHIE write setCHDHIE;
    property CHDHIF : TBits_1 read getCHDHIF write setCHDHIF;
    property CHERIE : TBits_1 read getCHERIE write setCHERIE;
    property CHERIF : TBits_1 read getCHERIF write setCHERIF;
    property CHSDIE : TBits_1 read getCHSDIE write setCHSDIE;
    property CHSDIF : TBits_1 read getCHSDIF write setCHSDIF;
    property CHSHIE : TBits_1 read getCHSHIE write setCHSHIE;
    property CHSHIF : TBits_1 read getCHSHIF write setCHSHIF;
    property CHTAIE : TBits_1 read getCHTAIE write setCHTAIE;
    property CHTAIF : TBits_1 read getCHTAIF write setCHTAIF;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMAC1Registers = record
    DCH1CONbits : TDMAC1_DCH1CON;
    DCH1CON : longWord;
    DCH1CONCLR : longWord;
    DCH1CONSET : longWord;
    DCH1CONINV : longWord;
    DCH1ECONbits : TDMAC1_DCH1ECON;
    DCH1ECON : longWord;
    DCH1ECONCLR : longWord;
    DCH1ECONSET : longWord;
    DCH1ECONINV : longWord;
    DCH1INTbits : TDMAC1_DCH1INT;
    DCH1INT : longWord;
    DCH1INTCLR : longWord;
    DCH1INTSET : longWord;
    DCH1INTINV : longWord;
    DCH1SSA : longWord;
    DCH1SSACLR : longWord;
    DCH1SSASET : longWord;
    DCH1SSAINV : longWord;
    DCH1DSA : longWord;
    DCH1DSACLR : longWord;
    DCH1DSASET : longWord;
    DCH1DSAINV : longWord;
    DCH1SSIZ : longWord;
    DCH1SSIZCLR : longWord;
    DCH1SSIZSET : longWord;
    DCH1SSIZINV : longWord;
    DCH1DSIZ : longWord;
    DCH1DSIZCLR : longWord;
    DCH1DSIZSET : longWord;
    DCH1DSIZINV : longWord;
    DCH1SPTR : longWord;
    DCH1SPTRCLR : longWord;
    DCH1SPTRSET : longWord;
    DCH1SPTRINV : longWord;
    DCH1DPTR : longWord;
    DCH1DPTRCLR : longWord;
    DCH1DPTRSET : longWord;
    DCH1DPTRINV : longWord;
    DCH1CSIZ : longWord;
    DCH1CSIZCLR : longWord;
    DCH1CSIZSET : longWord;
    DCH1CSIZINV : longWord;
    DCH1CPTR : longWord;
    DCH1CPTRCLR : longWord;
    DCH1CPTRSET : longWord;
    DCH1CPTRINV : longWord;
    DCH1DAT : longWord;
    DCH1DATCLR : longWord;
    DCH1DATSET : longWord;
    DCH1DATINV : longWord;
  end;
  TDMAC2_DCH2CON = record
  private
    function  getCHAED : TBits_1; inline;
    function  getCHAEN : TBits_1; inline;
    function  getCHBUSY : TBits_1; inline;
    function  getCHCHN : TBits_1; inline;
    function  getCHCHNS : TBits_1; inline;
    function  getCHEDET : TBits_1; inline;
    function  getCHEN : TBits_1; inline;
    function  getCHPRI : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHAED(thebits : TBits_1); inline;
    procedure setCHAEN(thebits : TBits_1); inline;
    procedure setCHBUSY(thebits : TBits_1); inline;
    procedure setCHCHN(thebits : TBits_1); inline;
    procedure setCHCHNS(thebits : TBits_1); inline;
    procedure setCHEDET(thebits : TBits_1); inline;
    procedure setCHEN(thebits : TBits_1); inline;
    procedure setCHPRI(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHAED; inline;
    procedure clearCHAEN; inline;
    procedure clearCHBUSY; inline;
    procedure clearCHCHN; inline;
    procedure clearCHCHNS; inline;
    procedure clearCHEDET; inline;
    procedure clearCHEN; inline;
    procedure setCHAED; inline;
    procedure setCHAEN; inline;
    procedure setCHBUSY; inline;
    procedure setCHCHN; inline;
    procedure setCHCHNS; inline;
    procedure setCHEDET; inline;
    procedure setCHEN; inline;
    property CHAED : TBits_1 read getCHAED write setCHAED;
    property CHAEN : TBits_1 read getCHAEN write setCHAEN;
    property CHBUSY : TBits_1 read getCHBUSY write setCHBUSY;
    property CHCHN : TBits_1 read getCHCHN write setCHCHN;
    property CHCHNS : TBits_1 read getCHCHNS write setCHCHNS;
    property CHEDET : TBits_1 read getCHEDET write setCHEDET;
    property CHEN : TBits_1 read getCHEN write setCHEN;
    property CHPRI : TBits_2 read getCHPRI write setCHPRI;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC2_DCH2ECON = record
  private
    function  getAIRQEN : TBits_1; inline;
    function  getCABORT : TBits_1; inline;
    function  getCFORCE : TBits_1; inline;
    function  getCHAIRQ : TBits_8; inline;
    function  getCHSIRQ : TBits_8; inline;
    function  getPATEN : TBits_1; inline;
    function  getSIRQEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAIRQEN(thebits : TBits_1); inline;
    procedure setCABORT(thebits : TBits_1); inline;
    procedure setCFORCE(thebits : TBits_1); inline;
    procedure setCHAIRQ(thebits : TBits_8); inline;
    procedure setCHSIRQ(thebits : TBits_8); inline;
    procedure setPATEN(thebits : TBits_1); inline;
    procedure setSIRQEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAIRQEN; inline;
    procedure clearCABORT; inline;
    procedure clearCFORCE; inline;
    procedure clearPATEN; inline;
    procedure clearSIRQEN; inline;
    procedure setAIRQEN; inline;
    procedure setCABORT; inline;
    procedure setCFORCE; inline;
    procedure setPATEN; inline;
    procedure setSIRQEN; inline;
    property AIRQEN : TBits_1 read getAIRQEN write setAIRQEN;
    property CABORT : TBits_1 read getCABORT write setCABORT;
    property CFORCE : TBits_1 read getCFORCE write setCFORCE;
    property CHAIRQ : TBits_8 read getCHAIRQ write setCHAIRQ;
    property CHSIRQ : TBits_8 read getCHSIRQ write setCHSIRQ;
    property PATEN : TBits_1 read getPATEN write setPATEN;
    property SIRQEN : TBits_1 read getSIRQEN write setSIRQEN;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC2_DCH2INT = record
  private
    function  getCHBCIE : TBits_1; inline;
    function  getCHBCIF : TBits_1; inline;
    function  getCHCCIE : TBits_1; inline;
    function  getCHCCIF : TBits_1; inline;
    function  getCHDDIE : TBits_1; inline;
    function  getCHDDIF : TBits_1; inline;
    function  getCHDHIE : TBits_1; inline;
    function  getCHDHIF : TBits_1; inline;
    function  getCHERIE : TBits_1; inline;
    function  getCHERIF : TBits_1; inline;
    function  getCHSDIE : TBits_1; inline;
    function  getCHSDIF : TBits_1; inline;
    function  getCHSHIE : TBits_1; inline;
    function  getCHSHIF : TBits_1; inline;
    function  getCHTAIE : TBits_1; inline;
    function  getCHTAIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCHBCIE(thebits : TBits_1); inline;
    procedure setCHBCIF(thebits : TBits_1); inline;
    procedure setCHCCIE(thebits : TBits_1); inline;
    procedure setCHCCIF(thebits : TBits_1); inline;
    procedure setCHDDIE(thebits : TBits_1); inline;
    procedure setCHDDIF(thebits : TBits_1); inline;
    procedure setCHDHIE(thebits : TBits_1); inline;
    procedure setCHDHIF(thebits : TBits_1); inline;
    procedure setCHERIE(thebits : TBits_1); inline;
    procedure setCHERIF(thebits : TBits_1); inline;
    procedure setCHSDIE(thebits : TBits_1); inline;
    procedure setCHSDIF(thebits : TBits_1); inline;
    procedure setCHSHIE(thebits : TBits_1); inline;
    procedure setCHSHIF(thebits : TBits_1); inline;
    procedure setCHTAIE(thebits : TBits_1); inline;
    procedure setCHTAIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHBCIE; inline;
    procedure clearCHBCIF; inline;
    procedure clearCHCCIE; inline;
    procedure clearCHCCIF; inline;
    procedure clearCHDDIE; inline;
    procedure clearCHDDIF; inline;
    procedure clearCHDHIE; inline;
    procedure clearCHDHIF; inline;
    procedure clearCHERIE; inline;
    procedure clearCHERIF; inline;
    procedure clearCHSDIE; inline;
    procedure clearCHSDIF; inline;
    procedure clearCHSHIE; inline;
    procedure clearCHSHIF; inline;
    procedure clearCHTAIE; inline;
    procedure clearCHTAIF; inline;
    procedure setCHBCIE; inline;
    procedure setCHBCIF; inline;
    procedure setCHCCIE; inline;
    procedure setCHCCIF; inline;
    procedure setCHDDIE; inline;
    procedure setCHDDIF; inline;
    procedure setCHDHIE; inline;
    procedure setCHDHIF; inline;
    procedure setCHERIE; inline;
    procedure setCHERIF; inline;
    procedure setCHSDIE; inline;
    procedure setCHSDIF; inline;
    procedure setCHSHIE; inline;
    procedure setCHSHIF; inline;
    procedure setCHTAIE; inline;
    procedure setCHTAIF; inline;
    property CHBCIE : TBits_1 read getCHBCIE write setCHBCIE;
    property CHBCIF : TBits_1 read getCHBCIF write setCHBCIF;
    property CHCCIE : TBits_1 read getCHCCIE write setCHCCIE;
    property CHCCIF : TBits_1 read getCHCCIF write setCHCCIF;
    property CHDDIE : TBits_1 read getCHDDIE write setCHDDIE;
    property CHDDIF : TBits_1 read getCHDDIF write setCHDDIF;
    property CHDHIE : TBits_1 read getCHDHIE write setCHDHIE;
    property CHDHIF : TBits_1 read getCHDHIF write setCHDHIF;
    property CHERIE : TBits_1 read getCHERIE write setCHERIE;
    property CHERIF : TBits_1 read getCHERIF write setCHERIF;
    property CHSDIE : TBits_1 read getCHSDIE write setCHSDIE;
    property CHSDIF : TBits_1 read getCHSDIF write setCHSDIF;
    property CHSHIE : TBits_1 read getCHSHIE write setCHSHIE;
    property CHSHIF : TBits_1 read getCHSHIF write setCHSHIF;
    property CHTAIE : TBits_1 read getCHTAIE write setCHTAIE;
    property CHTAIF : TBits_1 read getCHTAIF write setCHTAIF;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMAC2Registers = record
    DCH2CONbits : TDMAC2_DCH2CON;
    DCH2CON : longWord;
    DCH2CONCLR : longWord;
    DCH2CONSET : longWord;
    DCH2CONINV : longWord;
    DCH2ECONbits : TDMAC2_DCH2ECON;
    DCH2ECON : longWord;
    DCH2ECONCLR : longWord;
    DCH2ECONSET : longWord;
    DCH2ECONINV : longWord;
    DCH2INTbits : TDMAC2_DCH2INT;
    DCH2INT : longWord;
    DCH2INTCLR : longWord;
    DCH2INTSET : longWord;
    DCH2INTINV : longWord;
    DCH2SSA : longWord;
    DCH2SSACLR : longWord;
    DCH2SSASET : longWord;
    DCH2SSAINV : longWord;
    DCH2DSA : longWord;
    DCH2DSACLR : longWord;
    DCH2DSASET : longWord;
    DCH2DSAINV : longWord;
    DCH2SSIZ : longWord;
    DCH2SSIZCLR : longWord;
    DCH2SSIZSET : longWord;
    DCH2SSIZINV : longWord;
    DCH2DSIZ : longWord;
    DCH2DSIZCLR : longWord;
    DCH2DSIZSET : longWord;
    DCH2DSIZINV : longWord;
    DCH2SPTR : longWord;
    DCH2SPTRCLR : longWord;
    DCH2SPTRSET : longWord;
    DCH2SPTRINV : longWord;
    DCH2DPTR : longWord;
    DCH2DPTRCLR : longWord;
    DCH2DPTRSET : longWord;
    DCH2DPTRINV : longWord;
    DCH2CSIZ : longWord;
    DCH2CSIZCLR : longWord;
    DCH2CSIZSET : longWord;
    DCH2CSIZINV : longWord;
    DCH2CPTR : longWord;
    DCH2CPTRCLR : longWord;
    DCH2CPTRSET : longWord;
    DCH2CPTRINV : longWord;
    DCH2DAT : longWord;
    DCH2DATCLR : longWord;
    DCH2DATSET : longWord;
    DCH2DATINV : longWord;
  end;
  TDMAC3_DCH3CON = record
  private
    function  getCHAED : TBits_1; inline;
    function  getCHAEN : TBits_1; inline;
    function  getCHBUSY : TBits_1; inline;
    function  getCHCHN : TBits_1; inline;
    function  getCHCHNS : TBits_1; inline;
    function  getCHEDET : TBits_1; inline;
    function  getCHEN : TBits_1; inline;
    function  getCHPRI : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHAED(thebits : TBits_1); inline;
    procedure setCHAEN(thebits : TBits_1); inline;
    procedure setCHBUSY(thebits : TBits_1); inline;
    procedure setCHCHN(thebits : TBits_1); inline;
    procedure setCHCHNS(thebits : TBits_1); inline;
    procedure setCHEDET(thebits : TBits_1); inline;
    procedure setCHEN(thebits : TBits_1); inline;
    procedure setCHPRI(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHAED; inline;
    procedure clearCHAEN; inline;
    procedure clearCHBUSY; inline;
    procedure clearCHCHN; inline;
    procedure clearCHCHNS; inline;
    procedure clearCHEDET; inline;
    procedure clearCHEN; inline;
    procedure setCHAED; inline;
    procedure setCHAEN; inline;
    procedure setCHBUSY; inline;
    procedure setCHCHN; inline;
    procedure setCHCHNS; inline;
    procedure setCHEDET; inline;
    procedure setCHEN; inline;
    property CHAED : TBits_1 read getCHAED write setCHAED;
    property CHAEN : TBits_1 read getCHAEN write setCHAEN;
    property CHBUSY : TBits_1 read getCHBUSY write setCHBUSY;
    property CHCHN : TBits_1 read getCHCHN write setCHCHN;
    property CHCHNS : TBits_1 read getCHCHNS write setCHCHNS;
    property CHEDET : TBits_1 read getCHEDET write setCHEDET;
    property CHEN : TBits_1 read getCHEN write setCHEN;
    property CHPRI : TBits_2 read getCHPRI write setCHPRI;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC3_DCH3ECON = record
  private
    function  getAIRQEN : TBits_1; inline;
    function  getCABORT : TBits_1; inline;
    function  getCFORCE : TBits_1; inline;
    function  getCHAIRQ : TBits_8; inline;
    function  getCHSIRQ : TBits_8; inline;
    function  getPATEN : TBits_1; inline;
    function  getSIRQEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAIRQEN(thebits : TBits_1); inline;
    procedure setCABORT(thebits : TBits_1); inline;
    procedure setCFORCE(thebits : TBits_1); inline;
    procedure setCHAIRQ(thebits : TBits_8); inline;
    procedure setCHSIRQ(thebits : TBits_8); inline;
    procedure setPATEN(thebits : TBits_1); inline;
    procedure setSIRQEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAIRQEN; inline;
    procedure clearCABORT; inline;
    procedure clearCFORCE; inline;
    procedure clearPATEN; inline;
    procedure clearSIRQEN; inline;
    procedure setAIRQEN; inline;
    procedure setCABORT; inline;
    procedure setCFORCE; inline;
    procedure setPATEN; inline;
    procedure setSIRQEN; inline;
    property AIRQEN : TBits_1 read getAIRQEN write setAIRQEN;
    property CABORT : TBits_1 read getCABORT write setCABORT;
    property CFORCE : TBits_1 read getCFORCE write setCFORCE;
    property CHAIRQ : TBits_8 read getCHAIRQ write setCHAIRQ;
    property CHSIRQ : TBits_8 read getCHSIRQ write setCHSIRQ;
    property PATEN : TBits_1 read getPATEN write setPATEN;
    property SIRQEN : TBits_1 read getSIRQEN write setSIRQEN;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC3_DCH3INT = record
  private
    function  getCHBCIE : TBits_1; inline;
    function  getCHBCIF : TBits_1; inline;
    function  getCHCCIE : TBits_1; inline;
    function  getCHCCIF : TBits_1; inline;
    function  getCHDDIE : TBits_1; inline;
    function  getCHDDIF : TBits_1; inline;
    function  getCHDHIE : TBits_1; inline;
    function  getCHDHIF : TBits_1; inline;
    function  getCHERIE : TBits_1; inline;
    function  getCHERIF : TBits_1; inline;
    function  getCHSDIE : TBits_1; inline;
    function  getCHSDIF : TBits_1; inline;
    function  getCHSHIE : TBits_1; inline;
    function  getCHSHIF : TBits_1; inline;
    function  getCHTAIE : TBits_1; inline;
    function  getCHTAIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCHBCIE(thebits : TBits_1); inline;
    procedure setCHBCIF(thebits : TBits_1); inline;
    procedure setCHCCIE(thebits : TBits_1); inline;
    procedure setCHCCIF(thebits : TBits_1); inline;
    procedure setCHDDIE(thebits : TBits_1); inline;
    procedure setCHDDIF(thebits : TBits_1); inline;
    procedure setCHDHIE(thebits : TBits_1); inline;
    procedure setCHDHIF(thebits : TBits_1); inline;
    procedure setCHERIE(thebits : TBits_1); inline;
    procedure setCHERIF(thebits : TBits_1); inline;
    procedure setCHSDIE(thebits : TBits_1); inline;
    procedure setCHSDIF(thebits : TBits_1); inline;
    procedure setCHSHIE(thebits : TBits_1); inline;
    procedure setCHSHIF(thebits : TBits_1); inline;
    procedure setCHTAIE(thebits : TBits_1); inline;
    procedure setCHTAIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHBCIE; inline;
    procedure clearCHBCIF; inline;
    procedure clearCHCCIE; inline;
    procedure clearCHCCIF; inline;
    procedure clearCHDDIE; inline;
    procedure clearCHDDIF; inline;
    procedure clearCHDHIE; inline;
    procedure clearCHDHIF; inline;
    procedure clearCHERIE; inline;
    procedure clearCHERIF; inline;
    procedure clearCHSDIE; inline;
    procedure clearCHSDIF; inline;
    procedure clearCHSHIE; inline;
    procedure clearCHSHIF; inline;
    procedure clearCHTAIE; inline;
    procedure clearCHTAIF; inline;
    procedure setCHBCIE; inline;
    procedure setCHBCIF; inline;
    procedure setCHCCIE; inline;
    procedure setCHCCIF; inline;
    procedure setCHDDIE; inline;
    procedure setCHDDIF; inline;
    procedure setCHDHIE; inline;
    procedure setCHDHIF; inline;
    procedure setCHERIE; inline;
    procedure setCHERIF; inline;
    procedure setCHSDIE; inline;
    procedure setCHSDIF; inline;
    procedure setCHSHIE; inline;
    procedure setCHSHIF; inline;
    procedure setCHTAIE; inline;
    procedure setCHTAIF; inline;
    property CHBCIE : TBits_1 read getCHBCIE write setCHBCIE;
    property CHBCIF : TBits_1 read getCHBCIF write setCHBCIF;
    property CHCCIE : TBits_1 read getCHCCIE write setCHCCIE;
    property CHCCIF : TBits_1 read getCHCCIF write setCHCCIF;
    property CHDDIE : TBits_1 read getCHDDIE write setCHDDIE;
    property CHDDIF : TBits_1 read getCHDDIF write setCHDDIF;
    property CHDHIE : TBits_1 read getCHDHIE write setCHDHIE;
    property CHDHIF : TBits_1 read getCHDHIF write setCHDHIF;
    property CHERIE : TBits_1 read getCHERIE write setCHERIE;
    property CHERIF : TBits_1 read getCHERIF write setCHERIF;
    property CHSDIE : TBits_1 read getCHSDIE write setCHSDIE;
    property CHSDIF : TBits_1 read getCHSDIF write setCHSDIF;
    property CHSHIE : TBits_1 read getCHSHIE write setCHSHIE;
    property CHSHIF : TBits_1 read getCHSHIF write setCHSHIF;
    property CHTAIE : TBits_1 read getCHTAIE write setCHTAIE;
    property CHTAIF : TBits_1 read getCHTAIF write setCHTAIF;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMAC3Registers = record
    DCH3CONbits : TDMAC3_DCH3CON;
    DCH3CON : longWord;
    DCH3CONCLR : longWord;
    DCH3CONSET : longWord;
    DCH3CONINV : longWord;
    DCH3ECONbits : TDMAC3_DCH3ECON;
    DCH3ECON : longWord;
    DCH3ECONCLR : longWord;
    DCH3ECONSET : longWord;
    DCH3ECONINV : longWord;
    DCH3INTbits : TDMAC3_DCH3INT;
    DCH3INT : longWord;
    DCH3INTCLR : longWord;
    DCH3INTSET : longWord;
    DCH3INTINV : longWord;
    DCH3SSA : longWord;
    DCH3SSACLR : longWord;
    DCH3SSASET : longWord;
    DCH3SSAINV : longWord;
    DCH3DSA : longWord;
    DCH3DSACLR : longWord;
    DCH3DSASET : longWord;
    DCH3DSAINV : longWord;
    DCH3SSIZ : longWord;
    DCH3SSIZCLR : longWord;
    DCH3SSIZSET : longWord;
    DCH3SSIZINV : longWord;
    DCH3DSIZ : longWord;
    DCH3DSIZCLR : longWord;
    DCH3DSIZSET : longWord;
    DCH3DSIZINV : longWord;
    DCH3SPTR : longWord;
    DCH3SPTRCLR : longWord;
    DCH3SPTRSET : longWord;
    DCH3SPTRINV : longWord;
    DCH3DPTR : longWord;
    DCH3DPTRCLR : longWord;
    DCH3DPTRSET : longWord;
    DCH3DPTRINV : longWord;
    DCH3CSIZ : longWord;
    DCH3CSIZCLR : longWord;
    DCH3CSIZSET : longWord;
    DCH3CSIZINV : longWord;
    DCH3CPTR : longWord;
    DCH3CPTRCLR : longWord;
    DCH3CPTRSET : longWord;
    DCH3CPTRINV : longWord;
    DCH3DAT : longWord;
    DCH3DATCLR : longWord;
    DCH3DATSET : longWord;
    DCH3DATINV : longWord;
  end;
  TPCACHE_CHECON = record
  private
    function  getCHECOH : TBits_1; inline;
    function  getDCSZ : TBits_2; inline;
    function  getPFMWS : TBits_3; inline;
    function  getPREFEN : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHECOH(thebits : TBits_1); inline;
    procedure setDCSZ(thebits : TBits_2); inline;
    procedure setPFMWS(thebits : TBits_3); inline;
    procedure setPREFEN(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHECOH; inline;
    procedure setCHECOH; inline;
    property CHECOH : TBits_1 read getCHECOH write setCHECOH;
    property DCSZ : TBits_2 read getDCSZ write setDCSZ;
    property PFMWS : TBits_3 read getPFMWS write setPFMWS;
    property PREFEN : TBits_2 read getPREFEN write setPREFEN;
    property w : TBits_32 read getw write setw;
  end;
  TPCACHE_CHETAG = record
  private
    function  getLLOCK : TBits_1; inline;
    function  getLTAG : TBits_20; inline;
    function  getLTAGBOOT : TBits_1; inline;
    function  getLTYPE : TBits_1; inline;
    function  getLVALID : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLLOCK(thebits : TBits_1); inline;
    procedure setLTAG(thebits : TBits_20); inline;
    procedure setLTAGBOOT(thebits : TBits_1); inline;
    procedure setLTYPE(thebits : TBits_1); inline;
    procedure setLVALID(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLLOCK; inline;
    procedure clearLTAGBOOT; inline;
    procedure clearLTYPE; inline;
    procedure clearLVALID; inline;
    procedure setLLOCK; inline;
    procedure setLTAGBOOT; inline;
    procedure setLTYPE; inline;
    procedure setLVALID; inline;
    property LLOCK : TBits_1 read getLLOCK write setLLOCK;
    property LTAG : TBits_20 read getLTAG write setLTAG;
    property LTAGBOOT : TBits_1 read getLTAGBOOT write setLTAGBOOT;
    property LTYPE : TBits_1 read getLTYPE write setLTYPE;
    property LVALID : TBits_1 read getLVALID write setLVALID;
    property w : TBits_32 read getw write setw;
  end;
type
  TPCACHERegisters = record
    CHECONbits : TPCACHE_CHECON;
    CHECON : longWord;
    CHECONCLR : longWord;
    CHECONSET : longWord;
    CHECONINV : longWord;
    CHEACC : longWord;
    CHEACCCLR : longWord;
    CHEACCSET : longWord;
    CHEACCINV : longWord;
    CHETAGbits : TPCACHE_CHETAG;
    CHETAG : longWord;
    CHETAGCLR : longWord;
    CHETAGSET : longWord;
    CHETAGINV : longWord;
    CHEMSK : longWord;
    CHEMSKCLR : longWord;
    CHEMSKSET : longWord;
    CHEMSKINV : longWord;
    CHEW0 : longWord;
    CHEW1 : longWord;
    CHEW2 : longWord;
    CHEW3 : longWord;
    CHELRU : longWord;
    CHEHIT : longWord;
    CHEMIS : longWord;
    RESERVED1 : longWord;
    CHEPFABT : longWord;
  end;
  TUSB_U1IR = record
  private
    function  getATTACHIF : TBits_1; inline;
    function  getDETACHIF : TBits_1; inline;
    function  getIDLEIF : TBits_1; inline;
    function  getRESUMEIF : TBits_1; inline;
    function  getSOFIF : TBits_1; inline;
    function  getSTALLIF : TBits_1; inline;
    function  getTRNIF : TBits_1; inline;
    function  getUERRIF : TBits_1; inline;
    function  getURSTIF : TBits_1; inline;
    function  getURSTIF_DETACHIF : TBits_1; inline;
    procedure setATTACHIF(thebits : TBits_1); inline;
    procedure setDETACHIF(thebits : TBits_1); inline;
    procedure setIDLEIF(thebits : TBits_1); inline;
    procedure setRESUMEIF(thebits : TBits_1); inline;
    procedure setSOFIF(thebits : TBits_1); inline;
    procedure setSTALLIF(thebits : TBits_1); inline;
    procedure setTRNIF(thebits : TBits_1); inline;
    procedure setUERRIF(thebits : TBits_1); inline;
    procedure setURSTIF(thebits : TBits_1); inline;
    procedure setURSTIF_DETACHIF(thebits : TBits_1); inline;
  public
    procedure clearATTACHIF; inline;
    procedure clearDETACHIF; inline;
    procedure clearIDLEIF; inline;
    procedure clearRESUMEIF; inline;
    procedure clearSOFIF; inline;
    procedure clearSTALLIF; inline;
    procedure clearTRNIF; inline;
    procedure clearUERRIF; inline;
    procedure clearURSTIF; inline;
    procedure clearURSTIF_DETACHIF; inline;
    procedure setATTACHIF; inline;
    procedure setDETACHIF; inline;
    procedure setIDLEIF; inline;
    procedure setRESUMEIF; inline;
    procedure setSOFIF; inline;
    procedure setSTALLIF; inline;
    procedure setTRNIF; inline;
    procedure setUERRIF; inline;
    procedure setURSTIF; inline;
    procedure setURSTIF_DETACHIF; inline;
    property ATTACHIF : TBits_1 read getATTACHIF write setATTACHIF;
    property DETACHIF : TBits_1 read getDETACHIF write setDETACHIF;
    property IDLEIF : TBits_1 read getIDLEIF write setIDLEIF;
    property RESUMEIF : TBits_1 read getRESUMEIF write setRESUMEIF;
    property SOFIF : TBits_1 read getSOFIF write setSOFIF;
    property STALLIF : TBits_1 read getSTALLIF write setSTALLIF;
    property TRNIF : TBits_1 read getTRNIF write setTRNIF;
    property UERRIF : TBits_1 read getUERRIF write setUERRIF;
    property URSTIF : TBits_1 read getURSTIF write setURSTIF;
    property URSTIF_DETACHIF : TBits_1 read getURSTIF_DETACHIF write setURSTIF_DETACHIF;
  end;
  TUSB_U1IE = record
  private
    function  getATTACHIE : TBits_1; inline;
    function  getDETACHIE : TBits_1; inline;
    function  getIDLEIE : TBits_1; inline;
    function  getRESUMEIE : TBits_1; inline;
    function  getSOFIE : TBits_1; inline;
    function  getSTALLIE : TBits_1; inline;
    function  getTRNIE : TBits_1; inline;
    function  getUERRIE : TBits_1; inline;
    function  getURSTIE : TBits_1; inline;
    function  getURSTIE_DETACHIE : TBits_1; inline;
    procedure setATTACHIE(thebits : TBits_1); inline;
    procedure setDETACHIE(thebits : TBits_1); inline;
    procedure setIDLEIE(thebits : TBits_1); inline;
    procedure setRESUMEIE(thebits : TBits_1); inline;
    procedure setSOFIE(thebits : TBits_1); inline;
    procedure setSTALLIE(thebits : TBits_1); inline;
    procedure setTRNIE(thebits : TBits_1); inline;
    procedure setUERRIE(thebits : TBits_1); inline;
    procedure setURSTIE(thebits : TBits_1); inline;
    procedure setURSTIE_DETACHIE(thebits : TBits_1); inline;
  public
    procedure clearATTACHIE; inline;
    procedure clearDETACHIE; inline;
    procedure clearIDLEIE; inline;
    procedure clearRESUMEIE; inline;
    procedure clearSOFIE; inline;
    procedure clearSTALLIE; inline;
    procedure clearTRNIE; inline;
    procedure clearUERRIE; inline;
    procedure clearURSTIE; inline;
    procedure clearURSTIE_DETACHIE; inline;
    procedure setATTACHIE; inline;
    procedure setDETACHIE; inline;
    procedure setIDLEIE; inline;
    procedure setRESUMEIE; inline;
    procedure setSOFIE; inline;
    procedure setSTALLIE; inline;
    procedure setTRNIE; inline;
    procedure setUERRIE; inline;
    procedure setURSTIE; inline;
    procedure setURSTIE_DETACHIE; inline;
    property ATTACHIE : TBits_1 read getATTACHIE write setATTACHIE;
    property DETACHIE : TBits_1 read getDETACHIE write setDETACHIE;
    property IDLEIE : TBits_1 read getIDLEIE write setIDLEIE;
    property RESUMEIE : TBits_1 read getRESUMEIE write setRESUMEIE;
    property SOFIE : TBits_1 read getSOFIE write setSOFIE;
    property STALLIE : TBits_1 read getSTALLIE write setSTALLIE;
    property TRNIE : TBits_1 read getTRNIE write setTRNIE;
    property UERRIE : TBits_1 read getUERRIE write setUERRIE;
    property URSTIE : TBits_1 read getURSTIE write setURSTIE;
    property URSTIE_DETACHIE : TBits_1 read getURSTIE_DETACHIE write setURSTIE_DETACHIE;
  end;
  TUSB_U1EIR = record
  private
    function  getBMXEF : TBits_1; inline;
    function  getBTOEF : TBits_1; inline;
    function  getBTSEF : TBits_1; inline;
    function  getCRC16EF : TBits_1; inline;
    function  getCRC5EF : TBits_1; inline;
    function  getCRC5EF_EOFEF : TBits_1; inline;
    function  getDFN8EF : TBits_1; inline;
    function  getDMAEF : TBits_1; inline;
    function  getEOFEF : TBits_1; inline;
    function  getPIDEF : TBits_1; inline;
    procedure setBMXEF(thebits : TBits_1); inline;
    procedure setBTOEF(thebits : TBits_1); inline;
    procedure setBTSEF(thebits : TBits_1); inline;
    procedure setCRC16EF(thebits : TBits_1); inline;
    procedure setCRC5EF(thebits : TBits_1); inline;
    procedure setCRC5EF_EOFEF(thebits : TBits_1); inline;
    procedure setDFN8EF(thebits : TBits_1); inline;
    procedure setDMAEF(thebits : TBits_1); inline;
    procedure setEOFEF(thebits : TBits_1); inline;
    procedure setPIDEF(thebits : TBits_1); inline;
  public
    procedure clearBMXEF; inline;
    procedure clearBTOEF; inline;
    procedure clearBTSEF; inline;
    procedure clearCRC16EF; inline;
    procedure clearCRC5EF; inline;
    procedure clearCRC5EF_EOFEF; inline;
    procedure clearDFN8EF; inline;
    procedure clearDMAEF; inline;
    procedure clearEOFEF; inline;
    procedure clearPIDEF; inline;
    procedure setBMXEF; inline;
    procedure setBTOEF; inline;
    procedure setBTSEF; inline;
    procedure setCRC16EF; inline;
    procedure setCRC5EF; inline;
    procedure setCRC5EF_EOFEF; inline;
    procedure setDFN8EF; inline;
    procedure setDMAEF; inline;
    procedure setEOFEF; inline;
    procedure setPIDEF; inline;
    property BMXEF : TBits_1 read getBMXEF write setBMXEF;
    property BTOEF : TBits_1 read getBTOEF write setBTOEF;
    property BTSEF : TBits_1 read getBTSEF write setBTSEF;
    property CRC16EF : TBits_1 read getCRC16EF write setCRC16EF;
    property CRC5EF : TBits_1 read getCRC5EF write setCRC5EF;
    property CRC5EF_EOFEF : TBits_1 read getCRC5EF_EOFEF write setCRC5EF_EOFEF;
    property DFN8EF : TBits_1 read getDFN8EF write setDFN8EF;
    property DMAEF : TBits_1 read getDMAEF write setDMAEF;
    property EOFEF : TBits_1 read getEOFEF write setEOFEF;
    property PIDEF : TBits_1 read getPIDEF write setPIDEF;
  end;
  TUSB_U1EIE = record
  private
    function  getBMXEE : TBits_1; inline;
    function  getBTOEE : TBits_1; inline;
    function  getBTSEE : TBits_1; inline;
    function  getCRC16EE : TBits_1; inline;
    function  getCRC5EE : TBits_1; inline;
    function  getCRC5EE_EOFEE : TBits_1; inline;
    function  getDFN8EE : TBits_1; inline;
    function  getDMAEE : TBits_1; inline;
    function  getEOFEE : TBits_1; inline;
    function  getPIDEE : TBits_1; inline;
    procedure setBMXEE(thebits : TBits_1); inline;
    procedure setBTOEE(thebits : TBits_1); inline;
    procedure setBTSEE(thebits : TBits_1); inline;
    procedure setCRC16EE(thebits : TBits_1); inline;
    procedure setCRC5EE(thebits : TBits_1); inline;
    procedure setCRC5EE_EOFEE(thebits : TBits_1); inline;
    procedure setDFN8EE(thebits : TBits_1); inline;
    procedure setDMAEE(thebits : TBits_1); inline;
    procedure setEOFEE(thebits : TBits_1); inline;
    procedure setPIDEE(thebits : TBits_1); inline;
  public
    procedure clearBMXEE; inline;
    procedure clearBTOEE; inline;
    procedure clearBTSEE; inline;
    procedure clearCRC16EE; inline;
    procedure clearCRC5EE; inline;
    procedure clearCRC5EE_EOFEE; inline;
    procedure clearDFN8EE; inline;
    procedure clearDMAEE; inline;
    procedure clearEOFEE; inline;
    procedure clearPIDEE; inline;
    procedure setBMXEE; inline;
    procedure setBTOEE; inline;
    procedure setBTSEE; inline;
    procedure setCRC16EE; inline;
    procedure setCRC5EE; inline;
    procedure setCRC5EE_EOFEE; inline;
    procedure setDFN8EE; inline;
    procedure setDMAEE; inline;
    procedure setEOFEE; inline;
    procedure setPIDEE; inline;
    property BMXEE : TBits_1 read getBMXEE write setBMXEE;
    property BTOEE : TBits_1 read getBTOEE write setBTOEE;
    property BTSEE : TBits_1 read getBTSEE write setBTSEE;
    property CRC16EE : TBits_1 read getCRC16EE write setCRC16EE;
    property CRC5EE : TBits_1 read getCRC5EE write setCRC5EE;
    property CRC5EE_EOFEE : TBits_1 read getCRC5EE_EOFEE write setCRC5EE_EOFEE;
    property DFN8EE : TBits_1 read getDFN8EE write setDFN8EE;
    property DMAEE : TBits_1 read getDMAEE write setDMAEE;
    property EOFEE : TBits_1 read getEOFEE write setEOFEE;
    property PIDEE : TBits_1 read getPIDEE write setPIDEE;
  end;
  TUSB_U1STAT = record
  private
    function  getDIR : TBits_1; inline;
    function  getENDPT : TBits_4; inline;
    function  getENDPT0 : TBits_1; inline;
    function  getENDPT1 : TBits_1; inline;
    function  getENDPT2 : TBits_1; inline;
    function  getENDPT3 : TBits_1; inline;
    function  getPPBI : TBits_1; inline;
    procedure setDIR(thebits : TBits_1); inline;
    procedure setENDPT(thebits : TBits_4); inline;
    procedure setENDPT0(thebits : TBits_1); inline;
    procedure setENDPT1(thebits : TBits_1); inline;
    procedure setENDPT2(thebits : TBits_1); inline;
    procedure setENDPT3(thebits : TBits_1); inline;
    procedure setPPBI(thebits : TBits_1); inline;
  public
    procedure clearDIR; inline;
    procedure clearENDPT0; inline;
    procedure clearENDPT1; inline;
    procedure clearENDPT2; inline;
    procedure clearENDPT3; inline;
    procedure clearPPBI; inline;
    procedure setDIR; inline;
    procedure setENDPT0; inline;
    procedure setENDPT1; inline;
    procedure setENDPT2; inline;
    procedure setENDPT3; inline;
    procedure setPPBI; inline;
    property DIR : TBits_1 read getDIR write setDIR;
    property ENDPT : TBits_4 read getENDPT write setENDPT;
    property ENDPT0 : TBits_1 read getENDPT0 write setENDPT0;
    property ENDPT1 : TBits_1 read getENDPT1 write setENDPT1;
    property ENDPT2 : TBits_1 read getENDPT2 write setENDPT2;
    property ENDPT3 : TBits_1 read getENDPT3 write setENDPT3;
    property PPBI : TBits_1 read getPPBI write setPPBI;
  end;
  TUSB_U1CON = record
  private
    function  getHOSTEN : TBits_1; inline;
    function  getJSTATE : TBits_1; inline;
    function  getPKTDIS : TBits_1; inline;
    function  getPKTDIS_TOKBUSY : TBits_1; inline;
    function  getPPBRST : TBits_1; inline;
    function  getRESUME : TBits_1; inline;
    function  getSE0 : TBits_1; inline;
    function  getSOFEN : TBits_1; inline;
    function  getTOKBUSY : TBits_1; inline;
    function  getUSBEN : TBits_1; inline;
    function  getUSBEN_SOFEN : TBits_1; inline;
    function  getUSBRST : TBits_1; inline;
    procedure setHOSTEN(thebits : TBits_1); inline;
    procedure setJSTATE(thebits : TBits_1); inline;
    procedure setPKTDIS(thebits : TBits_1); inline;
    procedure setPKTDIS_TOKBUSY(thebits : TBits_1); inline;
    procedure setPPBRST(thebits : TBits_1); inline;
    procedure setRESUME(thebits : TBits_1); inline;
    procedure setSE0(thebits : TBits_1); inline;
    procedure setSOFEN(thebits : TBits_1); inline;
    procedure setTOKBUSY(thebits : TBits_1); inline;
    procedure setUSBEN(thebits : TBits_1); inline;
    procedure setUSBEN_SOFEN(thebits : TBits_1); inline;
    procedure setUSBRST(thebits : TBits_1); inline;
  public
    procedure clearHOSTEN; inline;
    procedure clearJSTATE; inline;
    procedure clearPKTDIS; inline;
    procedure clearPKTDIS_TOKBUSY; inline;
    procedure clearPPBRST; inline;
    procedure clearRESUME; inline;
    procedure clearSE0; inline;
    procedure clearSOFEN; inline;
    procedure clearTOKBUSY; inline;
    procedure clearUSBEN; inline;
    procedure clearUSBEN_SOFEN; inline;
    procedure clearUSBRST; inline;
    procedure setHOSTEN; inline;
    procedure setJSTATE; inline;
    procedure setPKTDIS; inline;
    procedure setPKTDIS_TOKBUSY; inline;
    procedure setPPBRST; inline;
    procedure setRESUME; inline;
    procedure setSE0; inline;
    procedure setSOFEN; inline;
    procedure setTOKBUSY; inline;
    procedure setUSBEN; inline;
    procedure setUSBEN_SOFEN; inline;
    procedure setUSBRST; inline;
    property HOSTEN : TBits_1 read getHOSTEN write setHOSTEN;
    property JSTATE : TBits_1 read getJSTATE write setJSTATE;
    property PKTDIS : TBits_1 read getPKTDIS write setPKTDIS;
    property PKTDIS_TOKBUSY : TBits_1 read getPKTDIS_TOKBUSY write setPKTDIS_TOKBUSY;
    property PPBRST : TBits_1 read getPPBRST write setPPBRST;
    property RESUME : TBits_1 read getRESUME write setRESUME;
    property SE0 : TBits_1 read getSE0 write setSE0;
    property SOFEN : TBits_1 read getSOFEN write setSOFEN;
    property TOKBUSY : TBits_1 read getTOKBUSY write setTOKBUSY;
    property USBEN : TBits_1 read getUSBEN write setUSBEN;
    property USBEN_SOFEN : TBits_1 read getUSBEN_SOFEN write setUSBEN_SOFEN;
    property USBRST : TBits_1 read getUSBRST write setUSBRST;
  end;
  TUSB_U1ADDR = record
  private
    function  getDEVADDR : TBits_7; inline;
    function  getDEVADDR0 : TBits_1; inline;
    function  getDEVADDR1 : TBits_1; inline;
    function  getDEVADDR2 : TBits_1; inline;
    function  getDEVADDR3 : TBits_1; inline;
    function  getDEVADDR4 : TBits_1; inline;
    function  getDEVADDR5 : TBits_1; inline;
    function  getDEVADDR6 : TBits_1; inline;
    function  getLSPDEN : TBits_1; inline;
    procedure setDEVADDR(thebits : TBits_7); inline;
    procedure setDEVADDR0(thebits : TBits_1); inline;
    procedure setDEVADDR1(thebits : TBits_1); inline;
    procedure setDEVADDR2(thebits : TBits_1); inline;
    procedure setDEVADDR3(thebits : TBits_1); inline;
    procedure setDEVADDR4(thebits : TBits_1); inline;
    procedure setDEVADDR5(thebits : TBits_1); inline;
    procedure setDEVADDR6(thebits : TBits_1); inline;
    procedure setLSPDEN(thebits : TBits_1); inline;
  public
    procedure clearDEVADDR0; inline;
    procedure clearDEVADDR1; inline;
    procedure clearDEVADDR2; inline;
    procedure clearDEVADDR3; inline;
    procedure clearDEVADDR4; inline;
    procedure clearDEVADDR5; inline;
    procedure clearDEVADDR6; inline;
    procedure clearLSPDEN; inline;
    procedure setDEVADDR0; inline;
    procedure setDEVADDR1; inline;
    procedure setDEVADDR2; inline;
    procedure setDEVADDR3; inline;
    procedure setDEVADDR4; inline;
    procedure setDEVADDR5; inline;
    procedure setDEVADDR6; inline;
    procedure setLSPDEN; inline;
    property DEVADDR : TBits_7 read getDEVADDR write setDEVADDR;
    property DEVADDR0 : TBits_1 read getDEVADDR0 write setDEVADDR0;
    property DEVADDR1 : TBits_1 read getDEVADDR1 write setDEVADDR1;
    property DEVADDR2 : TBits_1 read getDEVADDR2 write setDEVADDR2;
    property DEVADDR3 : TBits_1 read getDEVADDR3 write setDEVADDR3;
    property DEVADDR4 : TBits_1 read getDEVADDR4 write setDEVADDR4;
    property DEVADDR5 : TBits_1 read getDEVADDR5 write setDEVADDR5;
    property DEVADDR6 : TBits_1 read getDEVADDR6 write setDEVADDR6;
    property LSPDEN : TBits_1 read getLSPDEN write setLSPDEN;
  end;
  TUSB_U1FRML = record
  private
    function  getFRM0 : TBits_1; inline;
    function  getFRM1 : TBits_1; inline;
    function  getFRM2 : TBits_1; inline;
    function  getFRM3 : TBits_1; inline;
    function  getFRM4 : TBits_1; inline;
    function  getFRM5 : TBits_1; inline;
    function  getFRM6 : TBits_1; inline;
    function  getFRM7 : TBits_1; inline;
    function  getFRML : TBits_8; inline;
    procedure setFRM0(thebits : TBits_1); inline;
    procedure setFRM1(thebits : TBits_1); inline;
    procedure setFRM2(thebits : TBits_1); inline;
    procedure setFRM3(thebits : TBits_1); inline;
    procedure setFRM4(thebits : TBits_1); inline;
    procedure setFRM5(thebits : TBits_1); inline;
    procedure setFRM6(thebits : TBits_1); inline;
    procedure setFRM7(thebits : TBits_1); inline;
    procedure setFRML(thebits : TBits_8); inline;
  public
    procedure clearFRM0; inline;
    procedure clearFRM1; inline;
    procedure clearFRM2; inline;
    procedure clearFRM3; inline;
    procedure clearFRM4; inline;
    procedure clearFRM5; inline;
    procedure clearFRM6; inline;
    procedure clearFRM7; inline;
    procedure setFRM0; inline;
    procedure setFRM1; inline;
    procedure setFRM2; inline;
    procedure setFRM3; inline;
    procedure setFRM4; inline;
    procedure setFRM5; inline;
    procedure setFRM6; inline;
    procedure setFRM7; inline;
    property FRM0 : TBits_1 read getFRM0 write setFRM0;
    property FRM1 : TBits_1 read getFRM1 write setFRM1;
    property FRM2 : TBits_1 read getFRM2 write setFRM2;
    property FRM3 : TBits_1 read getFRM3 write setFRM3;
    property FRM4 : TBits_1 read getFRM4 write setFRM4;
    property FRM5 : TBits_1 read getFRM5 write setFRM5;
    property FRM6 : TBits_1 read getFRM6 write setFRM6;
    property FRM7 : TBits_1 read getFRM7 write setFRM7;
    property FRML : TBits_8 read getFRML write setFRML;
  end;
  TUSB_U1FRMH = record
  private
    function  getFRM10 : TBits_1; inline;
    function  getFRM8 : TBits_1; inline;
    function  getFRM9 : TBits_1; inline;
    function  getFRMH : TBits_3; inline;
    procedure setFRM10(thebits : TBits_1); inline;
    procedure setFRM8(thebits : TBits_1); inline;
    procedure setFRM9(thebits : TBits_1); inline;
    procedure setFRMH(thebits : TBits_3); inline;
  public
    procedure clearFRM10; inline;
    procedure clearFRM8; inline;
    procedure clearFRM9; inline;
    procedure setFRM10; inline;
    procedure setFRM8; inline;
    procedure setFRM9; inline;
    property FRM10 : TBits_1 read getFRM10 write setFRM10;
    property FRM8 : TBits_1 read getFRM8 write setFRM8;
    property FRM9 : TBits_1 read getFRM9 write setFRM9;
    property FRMH : TBits_3 read getFRMH write setFRMH;
  end;
  TUSB_U1TOK = record
  private
    function  getEP : TBits_4; inline;
    function  getEP0 : TBits_1; inline;
    function  getEP1 : TBits_1; inline;
    function  getEP2 : TBits_1; inline;
    function  getEP3 : TBits_1; inline;
    function  getPID : TBits_4; inline;
    function  getPID0 : TBits_1; inline;
    function  getPID1 : TBits_1; inline;
    function  getPID2 : TBits_1; inline;
    function  getPID3 : TBits_1; inline;
    procedure setEP(thebits : TBits_4); inline;
    procedure setEP0(thebits : TBits_1); inline;
    procedure setEP1(thebits : TBits_1); inline;
    procedure setEP2(thebits : TBits_1); inline;
    procedure setEP3(thebits : TBits_1); inline;
    procedure setPID(thebits : TBits_4); inline;
    procedure setPID0(thebits : TBits_1); inline;
    procedure setPID1(thebits : TBits_1); inline;
    procedure setPID2(thebits : TBits_1); inline;
    procedure setPID3(thebits : TBits_1); inline;
  public
    procedure clearEP0; inline;
    procedure clearEP1; inline;
    procedure clearEP2; inline;
    procedure clearEP3; inline;
    procedure clearPID0; inline;
    procedure clearPID1; inline;
    procedure clearPID2; inline;
    procedure clearPID3; inline;
    procedure setEP0; inline;
    procedure setEP1; inline;
    procedure setEP2; inline;
    procedure setEP3; inline;
    procedure setPID0; inline;
    procedure setPID1; inline;
    procedure setPID2; inline;
    procedure setPID3; inline;
    property EP : TBits_4 read getEP write setEP;
    property EP0 : TBits_1 read getEP0 write setEP0;
    property EP1 : TBits_1 read getEP1 write setEP1;
    property EP2 : TBits_1 read getEP2 write setEP2;
    property EP3 : TBits_1 read getEP3 write setEP3;
    property PID : TBits_4 read getPID write setPID;
    property PID0 : TBits_1 read getPID0 write setPID0;
    property PID1 : TBits_1 read getPID1 write setPID1;
    property PID2 : TBits_1 read getPID2 write setPID2;
    property PID3 : TBits_1 read getPID3 write setPID3;
  end;
  TUSB_ANSELB = record
  private
    function  getANSB0 : TBits_1; inline;
    function  getANSB1 : TBits_1; inline;
    function  getANSB10 : TBits_1; inline;
    function  getANSB11 : TBits_1; inline;
    function  getANSB12 : TBits_1; inline;
    function  getANSB13 : TBits_1; inline;
    function  getANSB14 : TBits_1; inline;
    function  getANSB15 : TBits_1; inline;
    function  getANSB2 : TBits_1; inline;
    function  getANSB3 : TBits_1; inline;
    function  getANSB4 : TBits_1; inline;
    function  getANSB5 : TBits_1; inline;
    function  getANSB6 : TBits_1; inline;
    function  getANSB7 : TBits_1; inline;
    function  getANSB8 : TBits_1; inline;
    function  getANSB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setANSB0(thebits : TBits_1); inline;
    procedure setANSB1(thebits : TBits_1); inline;
    procedure setANSB10(thebits : TBits_1); inline;
    procedure setANSB11(thebits : TBits_1); inline;
    procedure setANSB12(thebits : TBits_1); inline;
    procedure setANSB13(thebits : TBits_1); inline;
    procedure setANSB14(thebits : TBits_1); inline;
    procedure setANSB15(thebits : TBits_1); inline;
    procedure setANSB2(thebits : TBits_1); inline;
    procedure setANSB3(thebits : TBits_1); inline;
    procedure setANSB4(thebits : TBits_1); inline;
    procedure setANSB5(thebits : TBits_1); inline;
    procedure setANSB6(thebits : TBits_1); inline;
    procedure setANSB7(thebits : TBits_1); inline;
    procedure setANSB8(thebits : TBits_1); inline;
    procedure setANSB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearANSB0; inline;
    procedure clearANSB10; inline;
    procedure clearANSB11; inline;
    procedure clearANSB12; inline;
    procedure clearANSB13; inline;
    procedure clearANSB14; inline;
    procedure clearANSB15; inline;
    procedure clearANSB1; inline;
    procedure clearANSB2; inline;
    procedure clearANSB3; inline;
    procedure clearANSB4; inline;
    procedure clearANSB5; inline;
    procedure clearANSB6; inline;
    procedure clearANSB7; inline;
    procedure clearANSB8; inline;
    procedure clearANSB9; inline;
    procedure setANSB0; inline;
    procedure setANSB10; inline;
    procedure setANSB11; inline;
    procedure setANSB12; inline;
    procedure setANSB13; inline;
    procedure setANSB14; inline;
    procedure setANSB15; inline;
    procedure setANSB1; inline;
    procedure setANSB2; inline;
    procedure setANSB3; inline;
    procedure setANSB4; inline;
    procedure setANSB5; inline;
    procedure setANSB6; inline;
    procedure setANSB7; inline;
    procedure setANSB8; inline;
    procedure setANSB9; inline;
    property ANSB0 : TBits_1 read getANSB0 write setANSB0;
    property ANSB1 : TBits_1 read getANSB1 write setANSB1;
    property ANSB10 : TBits_1 read getANSB10 write setANSB10;
    property ANSB11 : TBits_1 read getANSB11 write setANSB11;
    property ANSB12 : TBits_1 read getANSB12 write setANSB12;
    property ANSB13 : TBits_1 read getANSB13 write setANSB13;
    property ANSB14 : TBits_1 read getANSB14 write setANSB14;
    property ANSB15 : TBits_1 read getANSB15 write setANSB15;
    property ANSB2 : TBits_1 read getANSB2 write setANSB2;
    property ANSB3 : TBits_1 read getANSB3 write setANSB3;
    property ANSB4 : TBits_1 read getANSB4 write setANSB4;
    property ANSB5 : TBits_1 read getANSB5 write setANSB5;
    property ANSB6 : TBits_1 read getANSB6 write setANSB6;
    property ANSB7 : TBits_1 read getANSB7 write setANSB7;
    property ANSB8 : TBits_1 read getANSB8 write setANSB8;
    property ANSB9 : TBits_1 read getANSB9 write setANSB9;
    property w : TBits_32 read getw write setw;
  end;
  TUSB_TRISB = record
  private
    function  getTRISB0 : TBits_1; inline;
    function  getTRISB1 : TBits_1; inline;
    function  getTRISB10 : TBits_1; inline;
    function  getTRISB11 : TBits_1; inline;
    function  getTRISB12 : TBits_1; inline;
    function  getTRISB13 : TBits_1; inline;
    function  getTRISB14 : TBits_1; inline;
    function  getTRISB15 : TBits_1; inline;
    function  getTRISB2 : TBits_1; inline;
    function  getTRISB3 : TBits_1; inline;
    function  getTRISB4 : TBits_1; inline;
    function  getTRISB5 : TBits_1; inline;
    function  getTRISB6 : TBits_1; inline;
    function  getTRISB7 : TBits_1; inline;
    function  getTRISB8 : TBits_1; inline;
    function  getTRISB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISB0(thebits : TBits_1); inline;
    procedure setTRISB1(thebits : TBits_1); inline;
    procedure setTRISB10(thebits : TBits_1); inline;
    procedure setTRISB11(thebits : TBits_1); inline;
    procedure setTRISB12(thebits : TBits_1); inline;
    procedure setTRISB13(thebits : TBits_1); inline;
    procedure setTRISB14(thebits : TBits_1); inline;
    procedure setTRISB15(thebits : TBits_1); inline;
    procedure setTRISB2(thebits : TBits_1); inline;
    procedure setTRISB3(thebits : TBits_1); inline;
    procedure setTRISB4(thebits : TBits_1); inline;
    procedure setTRISB5(thebits : TBits_1); inline;
    procedure setTRISB6(thebits : TBits_1); inline;
    procedure setTRISB7(thebits : TBits_1); inline;
    procedure setTRISB8(thebits : TBits_1); inline;
    procedure setTRISB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISB0; inline;
    procedure clearTRISB10; inline;
    procedure clearTRISB11; inline;
    procedure clearTRISB12; inline;
    procedure clearTRISB13; inline;
    procedure clearTRISB14; inline;
    procedure clearTRISB15; inline;
    procedure clearTRISB1; inline;
    procedure clearTRISB2; inline;
    procedure clearTRISB3; inline;
    procedure clearTRISB4; inline;
    procedure clearTRISB5; inline;
    procedure clearTRISB6; inline;
    procedure clearTRISB7; inline;
    procedure clearTRISB8; inline;
    procedure clearTRISB9; inline;
    procedure setTRISB0; inline;
    procedure setTRISB10; inline;
    procedure setTRISB11; inline;
    procedure setTRISB12; inline;
    procedure setTRISB13; inline;
    procedure setTRISB14; inline;
    procedure setTRISB15; inline;
    procedure setTRISB1; inline;
    procedure setTRISB2; inline;
    procedure setTRISB3; inline;
    procedure setTRISB4; inline;
    procedure setTRISB5; inline;
    procedure setTRISB6; inline;
    procedure setTRISB7; inline;
    procedure setTRISB8; inline;
    procedure setTRISB9; inline;
    property TRISB0 : TBits_1 read getTRISB0 write setTRISB0;
    property TRISB1 : TBits_1 read getTRISB1 write setTRISB1;
    property TRISB10 : TBits_1 read getTRISB10 write setTRISB10;
    property TRISB11 : TBits_1 read getTRISB11 write setTRISB11;
    property TRISB12 : TBits_1 read getTRISB12 write setTRISB12;
    property TRISB13 : TBits_1 read getTRISB13 write setTRISB13;
    property TRISB14 : TBits_1 read getTRISB14 write setTRISB14;
    property TRISB15 : TBits_1 read getTRISB15 write setTRISB15;
    property TRISB2 : TBits_1 read getTRISB2 write setTRISB2;
    property TRISB3 : TBits_1 read getTRISB3 write setTRISB3;
    property TRISB4 : TBits_1 read getTRISB4 write setTRISB4;
    property TRISB5 : TBits_1 read getTRISB5 write setTRISB5;
    property TRISB6 : TBits_1 read getTRISB6 write setTRISB6;
    property TRISB7 : TBits_1 read getTRISB7 write setTRISB7;
    property TRISB8 : TBits_1 read getTRISB8 write setTRISB8;
    property TRISB9 : TBits_1 read getTRISB9 write setTRISB9;
    property w : TBits_32 read getw write setw;
  end;
type
  TUSBRegisters = record
    U1OTGIR : longWord;
    U1OTGIRCLR : longWord;
    U1OTGIE : longWord;
    U1OTGIECLR : longWord;
    U1OTGIESET : longWord;
    U1OTGIEINV : longWord;
    U1OTGSTAT : longWord;
    U1OTGCON : longWord;
    U1OTGCONCLR : longWord;
    U1OTGCONSET : longWord;
    U1OTGCONINV : longWord;
    U1PWRC : longWord;
    U1PWRCCLR : longWord;
    U1PWRCSET : longWord;
    U1PWRCINV : longWord;
    U1IRbits : TUSB_U1IR;
    U1IR : longWord;
    U1IRCLR : longWord;
    U1IEbits : TUSB_U1IE;
    U1IE : longWord;
    U1IECLR : longWord;
    U1IESET : longWord;
    U1IEINV : longWord;
    U1EIRbits : TUSB_U1EIR;
    U1EIR : longWord;
    U1EIRCLR : longWord;
    U1EIEbits : TUSB_U1EIE;
    U1EIE : longWord;
    U1EIECLR : longWord;
    U1EIESET : longWord;
    U1EIEINV : longWord;
    U1STATbits : TUSB_U1STAT;
    U1STAT : longWord;
    U1CONbits : TUSB_U1CON;
    U1CON : longWord;
    U1CONCLR : longWord;
    U1CONSET : longWord;
    U1CONINV : longWord;
    U1ADDRbits : TUSB_U1ADDR;
    U1ADDR : longWord;
    U1ADDRCLR : longWord;
    U1ADDRSET : longWord;
    U1ADDRINV : longWord;
    U1BDTP1 : longWord;
    U1BDTP1CLR : longWord;
    U1BDTP1SET : longWord;
    U1BDTP1INV : longWord;
    U1FRMLbits : TUSB_U1FRML;
    U1FRML : longWord;
    U1FRMHbits : TUSB_U1FRMH;
    U1FRMH : longWord;
    U1TOKbits : TUSB_U1TOK;
    U1TOK : longWord;
    U1TOKCLR : longWord;
    U1TOKSET : longWord;
    U1TOKINV : longWord;
    U1SOF : longWord;
    U1SOFCLR : longWord;
    U1SOFSET : longWord;
    U1SOFINV : longWord;
    U1BDTP2 : longWord;
    U1BDTP2CLR : longWord;
    U1BDTP2SET : longWord;
    U1BDTP2INV : longWord;
    U1BDTP3 : longWord;
    U1BDTP3CLR : longWord;
    U1BDTP3SET : longWord;
    U1BDTP3INV : longWord;
    U1CNFG1 : longWord;
    U1CNFG1CLR : longWord;
    U1CNFG1SET : longWord;
    U1CNFG1INV : longWord;
    U1EP0 : longWord;
    U1EP0CLR : longWord;
    U1EP0SET : longWord;
    U1EP0INV : longWord;
    U1EP1 : longWord;
    U1EP1CLR : longWord;
    U1EP1SET : longWord;
    U1EP1INV : longWord;
    U1EP2 : longWord;
    U1EP2CLR : longWord;
    U1EP2SET : longWord;
    U1EP2INV : longWord;
    U1EP3 : longWord;
    U1EP3CLR : longWord;
    U1EP3SET : longWord;
    U1EP3INV : longWord;
    U1EP4 : longWord;
    U1EP4CLR : longWord;
    U1EP4SET : longWord;
    U1EP4INV : longWord;
    U1EP5 : longWord;
    U1EP5CLR : longWord;
    U1EP5SET : longWord;
    U1EP5INV : longWord;
    U1EP6 : longWord;
    U1EP6CLR : longWord;
    U1EP6SET : longWord;
    U1EP6INV : longWord;
    U1EP7 : longWord;
    U1EP7CLR : longWord;
    U1EP7SET : longWord;
    U1EP7INV : longWord;
    U1EP8 : longWord;
    U1EP8CLR : longWord;
    U1EP8SET : longWord;
    U1EP8INV : longWord;
    U1EP9 : longWord;
    U1EP9CLR : longWord;
    U1EP9SET : longWord;
    U1EP9INV : longWord;
    U1EP10 : longWord;
    U1EP10CLR : longWord;
    U1EP10SET : longWord;
    U1EP10INV : longWord;
    U1EP11 : longWord;
    U1EP11CLR : longWord;
    U1EP11SET : longWord;
    U1EP11INV : longWord;
    U1EP12 : longWord;
    U1EP12CLR : longWord;
    U1EP12SET : longWord;
    U1EP12INV : longWord;
    U1EP13 : longWord;
    U1EP13CLR : longWord;
    U1EP13SET : longWord;
    U1EP13INV : longWord;
    U1EP14 : longWord;
    U1EP14CLR : longWord;
    U1EP14SET : longWord;
    U1EP14INV : longWord;
    U1EP15 : longWord;
    U1EP15CLR : longWord;
    U1EP15SET : longWord;
    U1EP15INV : longWord;
    ANSELBbits : TUSB_ANSELB;
    ANSELB : longWord;
    ANSELBCLR : longWord;
    ANSELBSET : longWord;
    ANSELBINV : longWord;
    TRISBbits : TUSB_TRISB;
    TRISB : longWord;
    TRISBCLR : longWord;
    TRISBSET : longWord;
    TRISBINV : longWord;
  end;
  TPORTB_PORTB = record
  private
    function  getRB0 : TBits_1; inline;
    function  getRB1 : TBits_1; inline;
    function  getRB10 : TBits_1; inline;
    function  getRB11 : TBits_1; inline;
    function  getRB12 : TBits_1; inline;
    function  getRB13 : TBits_1; inline;
    function  getRB14 : TBits_1; inline;
    function  getRB15 : TBits_1; inline;
    function  getRB2 : TBits_1; inline;
    function  getRB3 : TBits_1; inline;
    function  getRB4 : TBits_1; inline;
    function  getRB5 : TBits_1; inline;
    function  getRB6 : TBits_1; inline;
    function  getRB7 : TBits_1; inline;
    function  getRB8 : TBits_1; inline;
    function  getRB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRB0(thebits : TBits_1); inline;
    procedure setRB1(thebits : TBits_1); inline;
    procedure setRB10(thebits : TBits_1); inline;
    procedure setRB11(thebits : TBits_1); inline;
    procedure setRB12(thebits : TBits_1); inline;
    procedure setRB13(thebits : TBits_1); inline;
    procedure setRB14(thebits : TBits_1); inline;
    procedure setRB15(thebits : TBits_1); inline;
    procedure setRB2(thebits : TBits_1); inline;
    procedure setRB3(thebits : TBits_1); inline;
    procedure setRB4(thebits : TBits_1); inline;
    procedure setRB5(thebits : TBits_1); inline;
    procedure setRB6(thebits : TBits_1); inline;
    procedure setRB7(thebits : TBits_1); inline;
    procedure setRB8(thebits : TBits_1); inline;
    procedure setRB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRB0; inline;
    procedure clearRB10; inline;
    procedure clearRB11; inline;
    procedure clearRB12; inline;
    procedure clearRB13; inline;
    procedure clearRB14; inline;
    procedure clearRB15; inline;
    procedure clearRB1; inline;
    procedure clearRB2; inline;
    procedure clearRB3; inline;
    procedure clearRB4; inline;
    procedure clearRB5; inline;
    procedure clearRB6; inline;
    procedure clearRB7; inline;
    procedure clearRB8; inline;
    procedure clearRB9; inline;
    procedure setRB0; inline;
    procedure setRB10; inline;
    procedure setRB11; inline;
    procedure setRB12; inline;
    procedure setRB13; inline;
    procedure setRB14; inline;
    procedure setRB15; inline;
    procedure setRB1; inline;
    procedure setRB2; inline;
    procedure setRB3; inline;
    procedure setRB4; inline;
    procedure setRB5; inline;
    procedure setRB6; inline;
    procedure setRB7; inline;
    procedure setRB8; inline;
    procedure setRB9; inline;
    property RB0 : TBits_1 read getRB0 write setRB0;
    property RB1 : TBits_1 read getRB1 write setRB1;
    property RB10 : TBits_1 read getRB10 write setRB10;
    property RB11 : TBits_1 read getRB11 write setRB11;
    property RB12 : TBits_1 read getRB12 write setRB12;
    property RB13 : TBits_1 read getRB13 write setRB13;
    property RB14 : TBits_1 read getRB14 write setRB14;
    property RB15 : TBits_1 read getRB15 write setRB15;
    property RB2 : TBits_1 read getRB2 write setRB2;
    property RB3 : TBits_1 read getRB3 write setRB3;
    property RB4 : TBits_1 read getRB4 write setRB4;
    property RB5 : TBits_1 read getRB5 write setRB5;
    property RB6 : TBits_1 read getRB6 write setRB6;
    property RB7 : TBits_1 read getRB7 write setRB7;
    property RB8 : TBits_1 read getRB8 write setRB8;
    property RB9 : TBits_1 read getRB9 write setRB9;
    property w : TBits_32 read getw write setw;
  end;
  TPortB_bits=(RB0=0,RB1=1,RB2=2,RB3=3,RB4=4,RB5=5,RB6=6,RB7=7,RB8=8,RB9=9,RB10=10,RB11=11,RB12=12,RB13=13,RB14=14,RB15=15);
  TPortB_bitset = set of TPortB_bits;
  TPORTB_LATB = record
  private
    function  getLATB0 : TBits_1; inline;
    function  getLATB1 : TBits_1; inline;
    function  getLATB10 : TBits_1; inline;
    function  getLATB11 : TBits_1; inline;
    function  getLATB12 : TBits_1; inline;
    function  getLATB13 : TBits_1; inline;
    function  getLATB14 : TBits_1; inline;
    function  getLATB15 : TBits_1; inline;
    function  getLATB2 : TBits_1; inline;
    function  getLATB3 : TBits_1; inline;
    function  getLATB4 : TBits_1; inline;
    function  getLATB5 : TBits_1; inline;
    function  getLATB6 : TBits_1; inline;
    function  getLATB7 : TBits_1; inline;
    function  getLATB8 : TBits_1; inline;
    function  getLATB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATB0(thebits : TBits_1); inline;
    procedure setLATB1(thebits : TBits_1); inline;
    procedure setLATB10(thebits : TBits_1); inline;
    procedure setLATB11(thebits : TBits_1); inline;
    procedure setLATB12(thebits : TBits_1); inline;
    procedure setLATB13(thebits : TBits_1); inline;
    procedure setLATB14(thebits : TBits_1); inline;
    procedure setLATB15(thebits : TBits_1); inline;
    procedure setLATB2(thebits : TBits_1); inline;
    procedure setLATB3(thebits : TBits_1); inline;
    procedure setLATB4(thebits : TBits_1); inline;
    procedure setLATB5(thebits : TBits_1); inline;
    procedure setLATB6(thebits : TBits_1); inline;
    procedure setLATB7(thebits : TBits_1); inline;
    procedure setLATB8(thebits : TBits_1); inline;
    procedure setLATB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATB0; inline;
    procedure clearLATB10; inline;
    procedure clearLATB11; inline;
    procedure clearLATB12; inline;
    procedure clearLATB13; inline;
    procedure clearLATB14; inline;
    procedure clearLATB15; inline;
    procedure clearLATB1; inline;
    procedure clearLATB2; inline;
    procedure clearLATB3; inline;
    procedure clearLATB4; inline;
    procedure clearLATB5; inline;
    procedure clearLATB6; inline;
    procedure clearLATB7; inline;
    procedure clearLATB8; inline;
    procedure clearLATB9; inline;
    procedure setLATB0; inline;
    procedure setLATB10; inline;
    procedure setLATB11; inline;
    procedure setLATB12; inline;
    procedure setLATB13; inline;
    procedure setLATB14; inline;
    procedure setLATB15; inline;
    procedure setLATB1; inline;
    procedure setLATB2; inline;
    procedure setLATB3; inline;
    procedure setLATB4; inline;
    procedure setLATB5; inline;
    procedure setLATB6; inline;
    procedure setLATB7; inline;
    procedure setLATB8; inline;
    procedure setLATB9; inline;
    property LATB0 : TBits_1 read getLATB0 write setLATB0;
    property LATB1 : TBits_1 read getLATB1 write setLATB1;
    property LATB10 : TBits_1 read getLATB10 write setLATB10;
    property LATB11 : TBits_1 read getLATB11 write setLATB11;
    property LATB12 : TBits_1 read getLATB12 write setLATB12;
    property LATB13 : TBits_1 read getLATB13 write setLATB13;
    property LATB14 : TBits_1 read getLATB14 write setLATB14;
    property LATB15 : TBits_1 read getLATB15 write setLATB15;
    property LATB2 : TBits_1 read getLATB2 write setLATB2;
    property LATB3 : TBits_1 read getLATB3 write setLATB3;
    property LATB4 : TBits_1 read getLATB4 write setLATB4;
    property LATB5 : TBits_1 read getLATB5 write setLATB5;
    property LATB6 : TBits_1 read getLATB6 write setLATB6;
    property LATB7 : TBits_1 read getLATB7 write setLATB7;
    property LATB8 : TBits_1 read getLATB8 write setLATB8;
    property LATB9 : TBits_1 read getLATB9 write setLATB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_ODCB = record
  private
    function  getODCB0 : TBits_1; inline;
    function  getODCB1 : TBits_1; inline;
    function  getODCB10 : TBits_1; inline;
    function  getODCB11 : TBits_1; inline;
    function  getODCB12 : TBits_1; inline;
    function  getODCB13 : TBits_1; inline;
    function  getODCB14 : TBits_1; inline;
    function  getODCB15 : TBits_1; inline;
    function  getODCB2 : TBits_1; inline;
    function  getODCB3 : TBits_1; inline;
    function  getODCB4 : TBits_1; inline;
    function  getODCB5 : TBits_1; inline;
    function  getODCB6 : TBits_1; inline;
    function  getODCB7 : TBits_1; inline;
    function  getODCB8 : TBits_1; inline;
    function  getODCB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCB0(thebits : TBits_1); inline;
    procedure setODCB1(thebits : TBits_1); inline;
    procedure setODCB10(thebits : TBits_1); inline;
    procedure setODCB11(thebits : TBits_1); inline;
    procedure setODCB12(thebits : TBits_1); inline;
    procedure setODCB13(thebits : TBits_1); inline;
    procedure setODCB14(thebits : TBits_1); inline;
    procedure setODCB15(thebits : TBits_1); inline;
    procedure setODCB2(thebits : TBits_1); inline;
    procedure setODCB3(thebits : TBits_1); inline;
    procedure setODCB4(thebits : TBits_1); inline;
    procedure setODCB5(thebits : TBits_1); inline;
    procedure setODCB6(thebits : TBits_1); inline;
    procedure setODCB7(thebits : TBits_1); inline;
    procedure setODCB8(thebits : TBits_1); inline;
    procedure setODCB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCB0; inline;
    procedure clearODCB10; inline;
    procedure clearODCB11; inline;
    procedure clearODCB12; inline;
    procedure clearODCB13; inline;
    procedure clearODCB14; inline;
    procedure clearODCB15; inline;
    procedure clearODCB1; inline;
    procedure clearODCB2; inline;
    procedure clearODCB3; inline;
    procedure clearODCB4; inline;
    procedure clearODCB5; inline;
    procedure clearODCB6; inline;
    procedure clearODCB7; inline;
    procedure clearODCB8; inline;
    procedure clearODCB9; inline;
    procedure setODCB0; inline;
    procedure setODCB10; inline;
    procedure setODCB11; inline;
    procedure setODCB12; inline;
    procedure setODCB13; inline;
    procedure setODCB14; inline;
    procedure setODCB15; inline;
    procedure setODCB1; inline;
    procedure setODCB2; inline;
    procedure setODCB3; inline;
    procedure setODCB4; inline;
    procedure setODCB5; inline;
    procedure setODCB6; inline;
    procedure setODCB7; inline;
    procedure setODCB8; inline;
    procedure setODCB9; inline;
    property ODCB0 : TBits_1 read getODCB0 write setODCB0;
    property ODCB1 : TBits_1 read getODCB1 write setODCB1;
    property ODCB10 : TBits_1 read getODCB10 write setODCB10;
    property ODCB11 : TBits_1 read getODCB11 write setODCB11;
    property ODCB12 : TBits_1 read getODCB12 write setODCB12;
    property ODCB13 : TBits_1 read getODCB13 write setODCB13;
    property ODCB14 : TBits_1 read getODCB14 write setODCB14;
    property ODCB15 : TBits_1 read getODCB15 write setODCB15;
    property ODCB2 : TBits_1 read getODCB2 write setODCB2;
    property ODCB3 : TBits_1 read getODCB3 write setODCB3;
    property ODCB4 : TBits_1 read getODCB4 write setODCB4;
    property ODCB5 : TBits_1 read getODCB5 write setODCB5;
    property ODCB6 : TBits_1 read getODCB6 write setODCB6;
    property ODCB7 : TBits_1 read getODCB7 write setODCB7;
    property ODCB8 : TBits_1 read getODCB8 write setODCB8;
    property ODCB9 : TBits_1 read getODCB9 write setODCB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_CNPUB = record
  private
    function  getCNPUB0 : TBits_1; inline;
    function  getCNPUB1 : TBits_1; inline;
    function  getCNPUB10 : TBits_1; inline;
    function  getCNPUB11 : TBits_1; inline;
    function  getCNPUB12 : TBits_1; inline;
    function  getCNPUB13 : TBits_1; inline;
    function  getCNPUB14 : TBits_1; inline;
    function  getCNPUB15 : TBits_1; inline;
    function  getCNPUB2 : TBits_1; inline;
    function  getCNPUB3 : TBits_1; inline;
    function  getCNPUB4 : TBits_1; inline;
    function  getCNPUB5 : TBits_1; inline;
    function  getCNPUB6 : TBits_1; inline;
    function  getCNPUB7 : TBits_1; inline;
    function  getCNPUB8 : TBits_1; inline;
    function  getCNPUB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPUB0(thebits : TBits_1); inline;
    procedure setCNPUB1(thebits : TBits_1); inline;
    procedure setCNPUB10(thebits : TBits_1); inline;
    procedure setCNPUB11(thebits : TBits_1); inline;
    procedure setCNPUB12(thebits : TBits_1); inline;
    procedure setCNPUB13(thebits : TBits_1); inline;
    procedure setCNPUB14(thebits : TBits_1); inline;
    procedure setCNPUB15(thebits : TBits_1); inline;
    procedure setCNPUB2(thebits : TBits_1); inline;
    procedure setCNPUB3(thebits : TBits_1); inline;
    procedure setCNPUB4(thebits : TBits_1); inline;
    procedure setCNPUB5(thebits : TBits_1); inline;
    procedure setCNPUB6(thebits : TBits_1); inline;
    procedure setCNPUB7(thebits : TBits_1); inline;
    procedure setCNPUB8(thebits : TBits_1); inline;
    procedure setCNPUB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPUB0; inline;
    procedure clearCNPUB10; inline;
    procedure clearCNPUB11; inline;
    procedure clearCNPUB12; inline;
    procedure clearCNPUB13; inline;
    procedure clearCNPUB14; inline;
    procedure clearCNPUB15; inline;
    procedure clearCNPUB1; inline;
    procedure clearCNPUB2; inline;
    procedure clearCNPUB3; inline;
    procedure clearCNPUB4; inline;
    procedure clearCNPUB5; inline;
    procedure clearCNPUB6; inline;
    procedure clearCNPUB7; inline;
    procedure clearCNPUB8; inline;
    procedure clearCNPUB9; inline;
    procedure setCNPUB0; inline;
    procedure setCNPUB10; inline;
    procedure setCNPUB11; inline;
    procedure setCNPUB12; inline;
    procedure setCNPUB13; inline;
    procedure setCNPUB14; inline;
    procedure setCNPUB15; inline;
    procedure setCNPUB1; inline;
    procedure setCNPUB2; inline;
    procedure setCNPUB3; inline;
    procedure setCNPUB4; inline;
    procedure setCNPUB5; inline;
    procedure setCNPUB6; inline;
    procedure setCNPUB7; inline;
    procedure setCNPUB8; inline;
    procedure setCNPUB9; inline;
    property CNPUB0 : TBits_1 read getCNPUB0 write setCNPUB0;
    property CNPUB1 : TBits_1 read getCNPUB1 write setCNPUB1;
    property CNPUB10 : TBits_1 read getCNPUB10 write setCNPUB10;
    property CNPUB11 : TBits_1 read getCNPUB11 write setCNPUB11;
    property CNPUB12 : TBits_1 read getCNPUB12 write setCNPUB12;
    property CNPUB13 : TBits_1 read getCNPUB13 write setCNPUB13;
    property CNPUB14 : TBits_1 read getCNPUB14 write setCNPUB14;
    property CNPUB15 : TBits_1 read getCNPUB15 write setCNPUB15;
    property CNPUB2 : TBits_1 read getCNPUB2 write setCNPUB2;
    property CNPUB3 : TBits_1 read getCNPUB3 write setCNPUB3;
    property CNPUB4 : TBits_1 read getCNPUB4 write setCNPUB4;
    property CNPUB5 : TBits_1 read getCNPUB5 write setCNPUB5;
    property CNPUB6 : TBits_1 read getCNPUB6 write setCNPUB6;
    property CNPUB7 : TBits_1 read getCNPUB7 write setCNPUB7;
    property CNPUB8 : TBits_1 read getCNPUB8 write setCNPUB8;
    property CNPUB9 : TBits_1 read getCNPUB9 write setCNPUB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_CNPDB = record
  private
    function  getCNPDB0 : TBits_1; inline;
    function  getCNPDB1 : TBits_1; inline;
    function  getCNPDB10 : TBits_1; inline;
    function  getCNPDB11 : TBits_1; inline;
    function  getCNPDB12 : TBits_1; inline;
    function  getCNPDB13 : TBits_1; inline;
    function  getCNPDB14 : TBits_1; inline;
    function  getCNPDB15 : TBits_1; inline;
    function  getCNPDB2 : TBits_1; inline;
    function  getCNPDB3 : TBits_1; inline;
    function  getCNPDB4 : TBits_1; inline;
    function  getCNPDB5 : TBits_1; inline;
    function  getCNPDB6 : TBits_1; inline;
    function  getCNPDB7 : TBits_1; inline;
    function  getCNPDB8 : TBits_1; inline;
    function  getCNPDB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPDB0(thebits : TBits_1); inline;
    procedure setCNPDB1(thebits : TBits_1); inline;
    procedure setCNPDB10(thebits : TBits_1); inline;
    procedure setCNPDB11(thebits : TBits_1); inline;
    procedure setCNPDB12(thebits : TBits_1); inline;
    procedure setCNPDB13(thebits : TBits_1); inline;
    procedure setCNPDB14(thebits : TBits_1); inline;
    procedure setCNPDB15(thebits : TBits_1); inline;
    procedure setCNPDB2(thebits : TBits_1); inline;
    procedure setCNPDB3(thebits : TBits_1); inline;
    procedure setCNPDB4(thebits : TBits_1); inline;
    procedure setCNPDB5(thebits : TBits_1); inline;
    procedure setCNPDB6(thebits : TBits_1); inline;
    procedure setCNPDB7(thebits : TBits_1); inline;
    procedure setCNPDB8(thebits : TBits_1); inline;
    procedure setCNPDB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPDB0; inline;
    procedure clearCNPDB10; inline;
    procedure clearCNPDB11; inline;
    procedure clearCNPDB12; inline;
    procedure clearCNPDB13; inline;
    procedure clearCNPDB14; inline;
    procedure clearCNPDB15; inline;
    procedure clearCNPDB1; inline;
    procedure clearCNPDB2; inline;
    procedure clearCNPDB3; inline;
    procedure clearCNPDB4; inline;
    procedure clearCNPDB5; inline;
    procedure clearCNPDB6; inline;
    procedure clearCNPDB7; inline;
    procedure clearCNPDB8; inline;
    procedure clearCNPDB9; inline;
    procedure setCNPDB0; inline;
    procedure setCNPDB10; inline;
    procedure setCNPDB11; inline;
    procedure setCNPDB12; inline;
    procedure setCNPDB13; inline;
    procedure setCNPDB14; inline;
    procedure setCNPDB15; inline;
    procedure setCNPDB1; inline;
    procedure setCNPDB2; inline;
    procedure setCNPDB3; inline;
    procedure setCNPDB4; inline;
    procedure setCNPDB5; inline;
    procedure setCNPDB6; inline;
    procedure setCNPDB7; inline;
    procedure setCNPDB8; inline;
    procedure setCNPDB9; inline;
    property CNPDB0 : TBits_1 read getCNPDB0 write setCNPDB0;
    property CNPDB1 : TBits_1 read getCNPDB1 write setCNPDB1;
    property CNPDB10 : TBits_1 read getCNPDB10 write setCNPDB10;
    property CNPDB11 : TBits_1 read getCNPDB11 write setCNPDB11;
    property CNPDB12 : TBits_1 read getCNPDB12 write setCNPDB12;
    property CNPDB13 : TBits_1 read getCNPDB13 write setCNPDB13;
    property CNPDB14 : TBits_1 read getCNPDB14 write setCNPDB14;
    property CNPDB15 : TBits_1 read getCNPDB15 write setCNPDB15;
    property CNPDB2 : TBits_1 read getCNPDB2 write setCNPDB2;
    property CNPDB3 : TBits_1 read getCNPDB3 write setCNPDB3;
    property CNPDB4 : TBits_1 read getCNPDB4 write setCNPDB4;
    property CNPDB5 : TBits_1 read getCNPDB5 write setCNPDB5;
    property CNPDB6 : TBits_1 read getCNPDB6 write setCNPDB6;
    property CNPDB7 : TBits_1 read getCNPDB7 write setCNPDB7;
    property CNPDB8 : TBits_1 read getCNPDB8 write setCNPDB8;
    property CNPDB9 : TBits_1 read getCNPDB9 write setCNPDB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_CNCONB = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_CNENB = record
  private
    function  getCNIEB0 : TBits_1; inline;
    function  getCNIEB1 : TBits_1; inline;
    function  getCNIEB10 : TBits_1; inline;
    function  getCNIEB11 : TBits_1; inline;
    function  getCNIEB12 : TBits_1; inline;
    function  getCNIEB13 : TBits_1; inline;
    function  getCNIEB14 : TBits_1; inline;
    function  getCNIEB15 : TBits_1; inline;
    function  getCNIEB2 : TBits_1; inline;
    function  getCNIEB3 : TBits_1; inline;
    function  getCNIEB4 : TBits_1; inline;
    function  getCNIEB5 : TBits_1; inline;
    function  getCNIEB6 : TBits_1; inline;
    function  getCNIEB7 : TBits_1; inline;
    function  getCNIEB8 : TBits_1; inline;
    function  getCNIEB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNIEB0(thebits : TBits_1); inline;
    procedure setCNIEB1(thebits : TBits_1); inline;
    procedure setCNIEB10(thebits : TBits_1); inline;
    procedure setCNIEB11(thebits : TBits_1); inline;
    procedure setCNIEB12(thebits : TBits_1); inline;
    procedure setCNIEB13(thebits : TBits_1); inline;
    procedure setCNIEB14(thebits : TBits_1); inline;
    procedure setCNIEB15(thebits : TBits_1); inline;
    procedure setCNIEB2(thebits : TBits_1); inline;
    procedure setCNIEB3(thebits : TBits_1); inline;
    procedure setCNIEB4(thebits : TBits_1); inline;
    procedure setCNIEB5(thebits : TBits_1); inline;
    procedure setCNIEB6(thebits : TBits_1); inline;
    procedure setCNIEB7(thebits : TBits_1); inline;
    procedure setCNIEB8(thebits : TBits_1); inline;
    procedure setCNIEB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNIEB0; inline;
    procedure clearCNIEB10; inline;
    procedure clearCNIEB11; inline;
    procedure clearCNIEB12; inline;
    procedure clearCNIEB13; inline;
    procedure clearCNIEB14; inline;
    procedure clearCNIEB15; inline;
    procedure clearCNIEB1; inline;
    procedure clearCNIEB2; inline;
    procedure clearCNIEB3; inline;
    procedure clearCNIEB4; inline;
    procedure clearCNIEB5; inline;
    procedure clearCNIEB6; inline;
    procedure clearCNIEB7; inline;
    procedure clearCNIEB8; inline;
    procedure clearCNIEB9; inline;
    procedure setCNIEB0; inline;
    procedure setCNIEB10; inline;
    procedure setCNIEB11; inline;
    procedure setCNIEB12; inline;
    procedure setCNIEB13; inline;
    procedure setCNIEB14; inline;
    procedure setCNIEB15; inline;
    procedure setCNIEB1; inline;
    procedure setCNIEB2; inline;
    procedure setCNIEB3; inline;
    procedure setCNIEB4; inline;
    procedure setCNIEB5; inline;
    procedure setCNIEB6; inline;
    procedure setCNIEB7; inline;
    procedure setCNIEB8; inline;
    procedure setCNIEB9; inline;
    property CNIEB0 : TBits_1 read getCNIEB0 write setCNIEB0;
    property CNIEB1 : TBits_1 read getCNIEB1 write setCNIEB1;
    property CNIEB10 : TBits_1 read getCNIEB10 write setCNIEB10;
    property CNIEB11 : TBits_1 read getCNIEB11 write setCNIEB11;
    property CNIEB12 : TBits_1 read getCNIEB12 write setCNIEB12;
    property CNIEB13 : TBits_1 read getCNIEB13 write setCNIEB13;
    property CNIEB14 : TBits_1 read getCNIEB14 write setCNIEB14;
    property CNIEB15 : TBits_1 read getCNIEB15 write setCNIEB15;
    property CNIEB2 : TBits_1 read getCNIEB2 write setCNIEB2;
    property CNIEB3 : TBits_1 read getCNIEB3 write setCNIEB3;
    property CNIEB4 : TBits_1 read getCNIEB4 write setCNIEB4;
    property CNIEB5 : TBits_1 read getCNIEB5 write setCNIEB5;
    property CNIEB6 : TBits_1 read getCNIEB6 write setCNIEB6;
    property CNIEB7 : TBits_1 read getCNIEB7 write setCNIEB7;
    property CNIEB8 : TBits_1 read getCNIEB8 write setCNIEB8;
    property CNIEB9 : TBits_1 read getCNIEB9 write setCNIEB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_CNSTATB = record
  private
    function  getCNSTATB0 : TBits_1; inline;
    function  getCNSTATB1 : TBits_1; inline;
    function  getCNSTATB10 : TBits_1; inline;
    function  getCNSTATB11 : TBits_1; inline;
    function  getCNSTATB12 : TBits_1; inline;
    function  getCNSTATB13 : TBits_1; inline;
    function  getCNSTATB14 : TBits_1; inline;
    function  getCNSTATB15 : TBits_1; inline;
    function  getCNSTATB2 : TBits_1; inline;
    function  getCNSTATB3 : TBits_1; inline;
    function  getCNSTATB4 : TBits_1; inline;
    function  getCNSTATB5 : TBits_1; inline;
    function  getCNSTATB6 : TBits_1; inline;
    function  getCNSTATB7 : TBits_1; inline;
    function  getCNSTATB8 : TBits_1; inline;
    function  getCNSTATB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNSTATB0(thebits : TBits_1); inline;
    procedure setCNSTATB1(thebits : TBits_1); inline;
    procedure setCNSTATB10(thebits : TBits_1); inline;
    procedure setCNSTATB11(thebits : TBits_1); inline;
    procedure setCNSTATB12(thebits : TBits_1); inline;
    procedure setCNSTATB13(thebits : TBits_1); inline;
    procedure setCNSTATB14(thebits : TBits_1); inline;
    procedure setCNSTATB15(thebits : TBits_1); inline;
    procedure setCNSTATB2(thebits : TBits_1); inline;
    procedure setCNSTATB3(thebits : TBits_1); inline;
    procedure setCNSTATB4(thebits : TBits_1); inline;
    procedure setCNSTATB5(thebits : TBits_1); inline;
    procedure setCNSTATB6(thebits : TBits_1); inline;
    procedure setCNSTATB7(thebits : TBits_1); inline;
    procedure setCNSTATB8(thebits : TBits_1); inline;
    procedure setCNSTATB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNSTATB0; inline;
    procedure clearCNSTATB10; inline;
    procedure clearCNSTATB11; inline;
    procedure clearCNSTATB12; inline;
    procedure clearCNSTATB13; inline;
    procedure clearCNSTATB14; inline;
    procedure clearCNSTATB15; inline;
    procedure clearCNSTATB1; inline;
    procedure clearCNSTATB2; inline;
    procedure clearCNSTATB3; inline;
    procedure clearCNSTATB4; inline;
    procedure clearCNSTATB5; inline;
    procedure clearCNSTATB6; inline;
    procedure clearCNSTATB7; inline;
    procedure clearCNSTATB8; inline;
    procedure clearCNSTATB9; inline;
    procedure setCNSTATB0; inline;
    procedure setCNSTATB10; inline;
    procedure setCNSTATB11; inline;
    procedure setCNSTATB12; inline;
    procedure setCNSTATB13; inline;
    procedure setCNSTATB14; inline;
    procedure setCNSTATB15; inline;
    procedure setCNSTATB1; inline;
    procedure setCNSTATB2; inline;
    procedure setCNSTATB3; inline;
    procedure setCNSTATB4; inline;
    procedure setCNSTATB5; inline;
    procedure setCNSTATB6; inline;
    procedure setCNSTATB7; inline;
    procedure setCNSTATB8; inline;
    procedure setCNSTATB9; inline;
    property CNSTATB0 : TBits_1 read getCNSTATB0 write setCNSTATB0;
    property CNSTATB1 : TBits_1 read getCNSTATB1 write setCNSTATB1;
    property CNSTATB10 : TBits_1 read getCNSTATB10 write setCNSTATB10;
    property CNSTATB11 : TBits_1 read getCNSTATB11 write setCNSTATB11;
    property CNSTATB12 : TBits_1 read getCNSTATB12 write setCNSTATB12;
    property CNSTATB13 : TBits_1 read getCNSTATB13 write setCNSTATB13;
    property CNSTATB14 : TBits_1 read getCNSTATB14 write setCNSTATB14;
    property CNSTATB15 : TBits_1 read getCNSTATB15 write setCNSTATB15;
    property CNSTATB2 : TBits_1 read getCNSTATB2 write setCNSTATB2;
    property CNSTATB3 : TBits_1 read getCNSTATB3 write setCNSTATB3;
    property CNSTATB4 : TBits_1 read getCNSTATB4 write setCNSTATB4;
    property CNSTATB5 : TBits_1 read getCNSTATB5 write setCNSTATB5;
    property CNSTATB6 : TBits_1 read getCNSTATB6 write setCNSTATB6;
    property CNSTATB7 : TBits_1 read getCNSTATB7 write setCNSTATB7;
    property CNSTATB8 : TBits_1 read getCNSTATB8 write setCNSTATB8;
    property CNSTATB9 : TBits_1 read getCNSTATB9 write setCNSTATB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_ANSELC = record
  private
    function  getANSC12 : TBits_1; inline;
    function  getANSC13 : TBits_1; inline;
    function  getANSC14 : TBits_1; inline;
    function  getANSC15 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setANSC12(thebits : TBits_1); inline;
    procedure setANSC13(thebits : TBits_1); inline;
    procedure setANSC14(thebits : TBits_1); inline;
    procedure setANSC15(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearANSC12; inline;
    procedure clearANSC13; inline;
    procedure clearANSC14; inline;
    procedure clearANSC15; inline;
    procedure setANSC12; inline;
    procedure setANSC13; inline;
    procedure setANSC14; inline;
    procedure setANSC15; inline;
    property ANSC12 : TBits_1 read getANSC12 write setANSC12;
    property ANSC13 : TBits_1 read getANSC13 write setANSC13;
    property ANSC14 : TBits_1 read getANSC14 write setANSC14;
    property ANSC15 : TBits_1 read getANSC15 write setANSC15;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_TRISC = record
  private
    function  getTRISC12 : TBits_1; inline;
    function  getTRISC13 : TBits_1; inline;
    function  getTRISC14 : TBits_1; inline;
    function  getTRISC15 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISC12(thebits : TBits_1); inline;
    procedure setTRISC13(thebits : TBits_1); inline;
    procedure setTRISC14(thebits : TBits_1); inline;
    procedure setTRISC15(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISC12; inline;
    procedure clearTRISC13; inline;
    procedure clearTRISC14; inline;
    procedure clearTRISC15; inline;
    procedure setTRISC12; inline;
    procedure setTRISC13; inline;
    procedure setTRISC14; inline;
    procedure setTRISC15; inline;
    property TRISC12 : TBits_1 read getTRISC12 write setTRISC12;
    property TRISC13 : TBits_1 read getTRISC13 write setTRISC13;
    property TRISC14 : TBits_1 read getTRISC14 write setTRISC14;
    property TRISC15 : TBits_1 read getTRISC15 write setTRISC15;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTBRegisters = record
    PORTBbits : TPORTB_PORTB;
    PORTB : longWord;
    PORTBCLR : longWord;
    PORTBSET : longWord;
    PORTBINV : longWord;
    LATBbits : TPORTB_LATB;
    LATB : longWord;
    LATBCLR : longWord;
    LATBSET : longWord;
    LATBINV : longWord;
    ODCBbits : TPORTB_ODCB;
    ODCB : longWord;
    ODCBCLR : longWord;
    ODCBSET : longWord;
    ODCBINV : longWord;
    CNPUBbits : TPORTB_CNPUB;
    CNPUB : longWord;
    CNPUBCLR : longWord;
    CNPUBSET : longWord;
    CNPUBINV : longWord;
    CNPDBbits : TPORTB_CNPDB;
    CNPDB : longWord;
    CNPDBCLR : longWord;
    CNPDBSET : longWord;
    CNPDBINV : longWord;
    CNCONBbits : TPORTB_CNCONB;
    CNCONB : longWord;
    CNCONBCLR : longWord;
    CNCONBSET : longWord;
    CNCONBINV : longWord;
    CNENBbits : TPORTB_CNENB;
    CNENB : longWord;
    CNENBCLR : longWord;
    CNENBSET : longWord;
    CNENBINV : longWord;
    CNSTATBbits : TPORTB_CNSTATB;
    CNSTATB : longWord;
    CNSTATBCLR : longWord;
    CNSTATBSET : longWord;
    CNSTATBINV : longWord;
    ANSELCbits : TPORTB_ANSELC;
    ANSELC : longWord;
    ANSELCCLR : longWord;
    ANSELCSET : longWord;
    ANSELCINV : longWord;
    TRISCbits : TPORTB_TRISC;
    TRISC : longWord;
    TRISCCLR : longWord;
    TRISCSET : longWord;
    TRISCINV : longWord;
  end;
  TPORTC_PORTC = record
  private
    function  getRC12 : TBits_1; inline;
    function  getRC13 : TBits_1; inline;
    function  getRC14 : TBits_1; inline;
    function  getRC15 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRC12(thebits : TBits_1); inline;
    procedure setRC13(thebits : TBits_1); inline;
    procedure setRC14(thebits : TBits_1); inline;
    procedure setRC15(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRC12; inline;
    procedure clearRC13; inline;
    procedure clearRC14; inline;
    procedure clearRC15; inline;
    procedure setRC12; inline;
    procedure setRC13; inline;
    procedure setRC14; inline;
    procedure setRC15; inline;
    property RC12 : TBits_1 read getRC12 write setRC12;
    property RC13 : TBits_1 read getRC13 write setRC13;
    property RC14 : TBits_1 read getRC14 write setRC14;
    property RC15 : TBits_1 read getRC15 write setRC15;
    property w : TBits_32 read getw write setw;
  end;
  TPortC_bits=(RC12=12,RC13=13,RC14=14,RC15=15);
  TPortC_bitset = set of TPortC_bits;
  TPORTC_LATC = record
  private
    function  getLATC12 : TBits_1; inline;
    function  getLATC13 : TBits_1; inline;
    function  getLATC14 : TBits_1; inline;
    function  getLATC15 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATC12(thebits : TBits_1); inline;
    procedure setLATC13(thebits : TBits_1); inline;
    procedure setLATC14(thebits : TBits_1); inline;
    procedure setLATC15(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATC12; inline;
    procedure clearLATC13; inline;
    procedure clearLATC14; inline;
    procedure clearLATC15; inline;
    procedure setLATC12; inline;
    procedure setLATC13; inline;
    procedure setLATC14; inline;
    procedure setLATC15; inline;
    property LATC12 : TBits_1 read getLATC12 write setLATC12;
    property LATC13 : TBits_1 read getLATC13 write setLATC13;
    property LATC14 : TBits_1 read getLATC14 write setLATC14;
    property LATC15 : TBits_1 read getLATC15 write setLATC15;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_ODCC = record
  private
    function  getODCC12 : TBits_1; inline;
    function  getODCC13 : TBits_1; inline;
    function  getODCC14 : TBits_1; inline;
    function  getODCC15 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCC12(thebits : TBits_1); inline;
    procedure setODCC13(thebits : TBits_1); inline;
    procedure setODCC14(thebits : TBits_1); inline;
    procedure setODCC15(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCC12; inline;
    procedure clearODCC13; inline;
    procedure clearODCC14; inline;
    procedure clearODCC15; inline;
    procedure setODCC12; inline;
    procedure setODCC13; inline;
    procedure setODCC14; inline;
    procedure setODCC15; inline;
    property ODCC12 : TBits_1 read getODCC12 write setODCC12;
    property ODCC13 : TBits_1 read getODCC13 write setODCC13;
    property ODCC14 : TBits_1 read getODCC14 write setODCC14;
    property ODCC15 : TBits_1 read getODCC15 write setODCC15;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_CNPUC = record
  private
    function  getCNPUC12 : TBits_1; inline;
    function  getCNPUC13 : TBits_1; inline;
    function  getCNPUC14 : TBits_1; inline;
    function  getCNPUC15 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPUC12(thebits : TBits_1); inline;
    procedure setCNPUC13(thebits : TBits_1); inline;
    procedure setCNPUC14(thebits : TBits_1); inline;
    procedure setCNPUC15(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPUC12; inline;
    procedure clearCNPUC13; inline;
    procedure clearCNPUC14; inline;
    procedure clearCNPUC15; inline;
    procedure setCNPUC12; inline;
    procedure setCNPUC13; inline;
    procedure setCNPUC14; inline;
    procedure setCNPUC15; inline;
    property CNPUC12 : TBits_1 read getCNPUC12 write setCNPUC12;
    property CNPUC13 : TBits_1 read getCNPUC13 write setCNPUC13;
    property CNPUC14 : TBits_1 read getCNPUC14 write setCNPUC14;
    property CNPUC15 : TBits_1 read getCNPUC15 write setCNPUC15;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_CNPDC = record
  private
    function  getCNPDC12 : TBits_1; inline;
    function  getCNPDC13 : TBits_1; inline;
    function  getCNPDC14 : TBits_1; inline;
    function  getCNPDC15 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPDC12(thebits : TBits_1); inline;
    procedure setCNPDC13(thebits : TBits_1); inline;
    procedure setCNPDC14(thebits : TBits_1); inline;
    procedure setCNPDC15(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPDC12; inline;
    procedure clearCNPDC13; inline;
    procedure clearCNPDC14; inline;
    procedure clearCNPDC15; inline;
    procedure setCNPDC12; inline;
    procedure setCNPDC13; inline;
    procedure setCNPDC14; inline;
    procedure setCNPDC15; inline;
    property CNPDC12 : TBits_1 read getCNPDC12 write setCNPDC12;
    property CNPDC13 : TBits_1 read getCNPDC13 write setCNPDC13;
    property CNPDC14 : TBits_1 read getCNPDC14 write setCNPDC14;
    property CNPDC15 : TBits_1 read getCNPDC15 write setCNPDC15;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_CNCONC = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_CNENC = record
  private
    function  getCNIEC12 : TBits_1; inline;
    function  getCNIEC13 : TBits_1; inline;
    function  getCNIEC14 : TBits_1; inline;
    function  getCNIEC15 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNIEC12(thebits : TBits_1); inline;
    procedure setCNIEC13(thebits : TBits_1); inline;
    procedure setCNIEC14(thebits : TBits_1); inline;
    procedure setCNIEC15(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNIEC12; inline;
    procedure clearCNIEC13; inline;
    procedure clearCNIEC14; inline;
    procedure clearCNIEC15; inline;
    procedure setCNIEC12; inline;
    procedure setCNIEC13; inline;
    procedure setCNIEC14; inline;
    procedure setCNIEC15; inline;
    property CNIEC12 : TBits_1 read getCNIEC12 write setCNIEC12;
    property CNIEC13 : TBits_1 read getCNIEC13 write setCNIEC13;
    property CNIEC14 : TBits_1 read getCNIEC14 write setCNIEC14;
    property CNIEC15 : TBits_1 read getCNIEC15 write setCNIEC15;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_CNSTATC = record
  private
    function  getCNSTATC12 : TBits_1; inline;
    function  getCNSTATC13 : TBits_1; inline;
    function  getCNSTATC14 : TBits_1; inline;
    function  getCNSTATC15 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNSTATC12(thebits : TBits_1); inline;
    procedure setCNSTATC13(thebits : TBits_1); inline;
    procedure setCNSTATC14(thebits : TBits_1); inline;
    procedure setCNSTATC15(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNSTATC12; inline;
    procedure clearCNSTATC13; inline;
    procedure clearCNSTATC14; inline;
    procedure clearCNSTATC15; inline;
    procedure setCNSTATC12; inline;
    procedure setCNSTATC13; inline;
    procedure setCNSTATC14; inline;
    procedure setCNSTATC15; inline;
    property CNSTATC12 : TBits_1 read getCNSTATC12 write setCNSTATC12;
    property CNSTATC13 : TBits_1 read getCNSTATC13 write setCNSTATC13;
    property CNSTATC14 : TBits_1 read getCNSTATC14 write setCNSTATC14;
    property CNSTATC15 : TBits_1 read getCNSTATC15 write setCNSTATC15;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_ANSELD = record
  private
    function  getANSD1 : TBits_1; inline;
    function  getANSD2 : TBits_1; inline;
    function  getANSD3 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setANSD1(thebits : TBits_1); inline;
    procedure setANSD2(thebits : TBits_1); inline;
    procedure setANSD3(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearANSD1; inline;
    procedure clearANSD2; inline;
    procedure clearANSD3; inline;
    procedure setANSD1; inline;
    procedure setANSD2; inline;
    procedure setANSD3; inline;
    property ANSD1 : TBits_1 read getANSD1 write setANSD1;
    property ANSD2 : TBits_1 read getANSD2 write setANSD2;
    property ANSD3 : TBits_1 read getANSD3 write setANSD3;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_TRISD = record
  private
    function  getTRISD0 : TBits_1; inline;
    function  getTRISD1 : TBits_1; inline;
    function  getTRISD10 : TBits_1; inline;
    function  getTRISD11 : TBits_1; inline;
    function  getTRISD2 : TBits_1; inline;
    function  getTRISD3 : TBits_1; inline;
    function  getTRISD4 : TBits_1; inline;
    function  getTRISD5 : TBits_1; inline;
    function  getTRISD6 : TBits_1; inline;
    function  getTRISD7 : TBits_1; inline;
    function  getTRISD8 : TBits_1; inline;
    function  getTRISD9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISD0(thebits : TBits_1); inline;
    procedure setTRISD1(thebits : TBits_1); inline;
    procedure setTRISD10(thebits : TBits_1); inline;
    procedure setTRISD11(thebits : TBits_1); inline;
    procedure setTRISD2(thebits : TBits_1); inline;
    procedure setTRISD3(thebits : TBits_1); inline;
    procedure setTRISD4(thebits : TBits_1); inline;
    procedure setTRISD5(thebits : TBits_1); inline;
    procedure setTRISD6(thebits : TBits_1); inline;
    procedure setTRISD7(thebits : TBits_1); inline;
    procedure setTRISD8(thebits : TBits_1); inline;
    procedure setTRISD9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISD0; inline;
    procedure clearTRISD10; inline;
    procedure clearTRISD11; inline;
    procedure clearTRISD1; inline;
    procedure clearTRISD2; inline;
    procedure clearTRISD3; inline;
    procedure clearTRISD4; inline;
    procedure clearTRISD5; inline;
    procedure clearTRISD6; inline;
    procedure clearTRISD7; inline;
    procedure clearTRISD8; inline;
    procedure clearTRISD9; inline;
    procedure setTRISD0; inline;
    procedure setTRISD10; inline;
    procedure setTRISD11; inline;
    procedure setTRISD1; inline;
    procedure setTRISD2; inline;
    procedure setTRISD3; inline;
    procedure setTRISD4; inline;
    procedure setTRISD5; inline;
    procedure setTRISD6; inline;
    procedure setTRISD7; inline;
    procedure setTRISD8; inline;
    procedure setTRISD9; inline;
    property TRISD0 : TBits_1 read getTRISD0 write setTRISD0;
    property TRISD1 : TBits_1 read getTRISD1 write setTRISD1;
    property TRISD10 : TBits_1 read getTRISD10 write setTRISD10;
    property TRISD11 : TBits_1 read getTRISD11 write setTRISD11;
    property TRISD2 : TBits_1 read getTRISD2 write setTRISD2;
    property TRISD3 : TBits_1 read getTRISD3 write setTRISD3;
    property TRISD4 : TBits_1 read getTRISD4 write setTRISD4;
    property TRISD5 : TBits_1 read getTRISD5 write setTRISD5;
    property TRISD6 : TBits_1 read getTRISD6 write setTRISD6;
    property TRISD7 : TBits_1 read getTRISD7 write setTRISD7;
    property TRISD8 : TBits_1 read getTRISD8 write setTRISD8;
    property TRISD9 : TBits_1 read getTRISD9 write setTRISD9;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTCRegisters = record
    PORTCbits : TPORTC_PORTC;
    PORTC : longWord;
    PORTCCLR : longWord;
    PORTCSET : longWord;
    PORTCINV : longWord;
    LATCbits : TPORTC_LATC;
    LATC : longWord;
    LATCCLR : longWord;
    LATCSET : longWord;
    LATCINV : longWord;
    ODCCbits : TPORTC_ODCC;
    ODCC : longWord;
    ODCCCLR : longWord;
    ODCCSET : longWord;
    ODCCINV : longWord;
    CNPUCbits : TPORTC_CNPUC;
    CNPUC : longWord;
    CNPUCCLR : longWord;
    CNPUCSET : longWord;
    CNPUCINV : longWord;
    CNPDCbits : TPORTC_CNPDC;
    CNPDC : longWord;
    CNPDCCLR : longWord;
    CNPDCSET : longWord;
    CNPDCINV : longWord;
    CNCONCbits : TPORTC_CNCONC;
    CNCONC : longWord;
    CNCONCCLR : longWord;
    CNCONCSET : longWord;
    CNCONCINV : longWord;
    CNENCbits : TPORTC_CNENC;
    CNENC : longWord;
    CNENCCLR : longWord;
    CNENCSET : longWord;
    CNENCINV : longWord;
    CNSTATCbits : TPORTC_CNSTATC;
    CNSTATC : longWord;
    CNSTATCCLR : longWord;
    CNSTATCSET : longWord;
    CNSTATCINV : longWord;
    ANSELDbits : TPORTC_ANSELD;
    ANSELD : longWord;
    ANSELDCLR : longWord;
    ANSELDSET : longWord;
    ANSELDINV : longWord;
    TRISDbits : TPORTC_TRISD;
    TRISD : longWord;
    TRISDCLR : longWord;
    TRISDSET : longWord;
    TRISDINV : longWord;
  end;
  TPORTD_PORTD = record
  private
    function  getRD0 : TBits_1; inline;
    function  getRD1 : TBits_1; inline;
    function  getRD10 : TBits_1; inline;
    function  getRD11 : TBits_1; inline;
    function  getRD2 : TBits_1; inline;
    function  getRD3 : TBits_1; inline;
    function  getRD4 : TBits_1; inline;
    function  getRD5 : TBits_1; inline;
    function  getRD6 : TBits_1; inline;
    function  getRD7 : TBits_1; inline;
    function  getRD8 : TBits_1; inline;
    function  getRD9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRD0(thebits : TBits_1); inline;
    procedure setRD1(thebits : TBits_1); inline;
    procedure setRD10(thebits : TBits_1); inline;
    procedure setRD11(thebits : TBits_1); inline;
    procedure setRD2(thebits : TBits_1); inline;
    procedure setRD3(thebits : TBits_1); inline;
    procedure setRD4(thebits : TBits_1); inline;
    procedure setRD5(thebits : TBits_1); inline;
    procedure setRD6(thebits : TBits_1); inline;
    procedure setRD7(thebits : TBits_1); inline;
    procedure setRD8(thebits : TBits_1); inline;
    procedure setRD9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRD0; inline;
    procedure clearRD10; inline;
    procedure clearRD11; inline;
    procedure clearRD1; inline;
    procedure clearRD2; inline;
    procedure clearRD3; inline;
    procedure clearRD4; inline;
    procedure clearRD5; inline;
    procedure clearRD6; inline;
    procedure clearRD7; inline;
    procedure clearRD8; inline;
    procedure clearRD9; inline;
    procedure setRD0; inline;
    procedure setRD10; inline;
    procedure setRD11; inline;
    procedure setRD1; inline;
    procedure setRD2; inline;
    procedure setRD3; inline;
    procedure setRD4; inline;
    procedure setRD5; inline;
    procedure setRD6; inline;
    procedure setRD7; inline;
    procedure setRD8; inline;
    procedure setRD9; inline;
    property RD0 : TBits_1 read getRD0 write setRD0;
    property RD1 : TBits_1 read getRD1 write setRD1;
    property RD10 : TBits_1 read getRD10 write setRD10;
    property RD11 : TBits_1 read getRD11 write setRD11;
    property RD2 : TBits_1 read getRD2 write setRD2;
    property RD3 : TBits_1 read getRD3 write setRD3;
    property RD4 : TBits_1 read getRD4 write setRD4;
    property RD5 : TBits_1 read getRD5 write setRD5;
    property RD6 : TBits_1 read getRD6 write setRD6;
    property RD7 : TBits_1 read getRD7 write setRD7;
    property RD8 : TBits_1 read getRD8 write setRD8;
    property RD9 : TBits_1 read getRD9 write setRD9;
    property w : TBits_32 read getw write setw;
  end;
  TPortD_bits=(RD0=0,RD1=1,RD2=2,RD3=3,RD4=4,RD5=5,RD6=6,RD7=7,RD8=8,RD9=9,RD10=10,RD11=11);
  TPortD_bitset = set of TPortD_bits;
  TPORTD_LATD = record
  private
    function  getLATD0 : TBits_1; inline;
    function  getLATD1 : TBits_1; inline;
    function  getLATD10 : TBits_1; inline;
    function  getLATD11 : TBits_1; inline;
    function  getLATD2 : TBits_1; inline;
    function  getLATD3 : TBits_1; inline;
    function  getLATD4 : TBits_1; inline;
    function  getLATD5 : TBits_1; inline;
    function  getLATD6 : TBits_1; inline;
    function  getLATD7 : TBits_1; inline;
    function  getLATD8 : TBits_1; inline;
    function  getLATD9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATD0(thebits : TBits_1); inline;
    procedure setLATD1(thebits : TBits_1); inline;
    procedure setLATD10(thebits : TBits_1); inline;
    procedure setLATD11(thebits : TBits_1); inline;
    procedure setLATD2(thebits : TBits_1); inline;
    procedure setLATD3(thebits : TBits_1); inline;
    procedure setLATD4(thebits : TBits_1); inline;
    procedure setLATD5(thebits : TBits_1); inline;
    procedure setLATD6(thebits : TBits_1); inline;
    procedure setLATD7(thebits : TBits_1); inline;
    procedure setLATD8(thebits : TBits_1); inline;
    procedure setLATD9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATD0; inline;
    procedure clearLATD10; inline;
    procedure clearLATD11; inline;
    procedure clearLATD1; inline;
    procedure clearLATD2; inline;
    procedure clearLATD3; inline;
    procedure clearLATD4; inline;
    procedure clearLATD5; inline;
    procedure clearLATD6; inline;
    procedure clearLATD7; inline;
    procedure clearLATD8; inline;
    procedure clearLATD9; inline;
    procedure setLATD0; inline;
    procedure setLATD10; inline;
    procedure setLATD11; inline;
    procedure setLATD1; inline;
    procedure setLATD2; inline;
    procedure setLATD3; inline;
    procedure setLATD4; inline;
    procedure setLATD5; inline;
    procedure setLATD6; inline;
    procedure setLATD7; inline;
    procedure setLATD8; inline;
    procedure setLATD9; inline;
    property LATD0 : TBits_1 read getLATD0 write setLATD0;
    property LATD1 : TBits_1 read getLATD1 write setLATD1;
    property LATD10 : TBits_1 read getLATD10 write setLATD10;
    property LATD11 : TBits_1 read getLATD11 write setLATD11;
    property LATD2 : TBits_1 read getLATD2 write setLATD2;
    property LATD3 : TBits_1 read getLATD3 write setLATD3;
    property LATD4 : TBits_1 read getLATD4 write setLATD4;
    property LATD5 : TBits_1 read getLATD5 write setLATD5;
    property LATD6 : TBits_1 read getLATD6 write setLATD6;
    property LATD7 : TBits_1 read getLATD7 write setLATD7;
    property LATD8 : TBits_1 read getLATD8 write setLATD8;
    property LATD9 : TBits_1 read getLATD9 write setLATD9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTD_ODCD = record
  private
    function  getODCD0 : TBits_1; inline;
    function  getODCD1 : TBits_1; inline;
    function  getODCD10 : TBits_1; inline;
    function  getODCD11 : TBits_1; inline;
    function  getODCD2 : TBits_1; inline;
    function  getODCD3 : TBits_1; inline;
    function  getODCD4 : TBits_1; inline;
    function  getODCD5 : TBits_1; inline;
    function  getODCD6 : TBits_1; inline;
    function  getODCD7 : TBits_1; inline;
    function  getODCD8 : TBits_1; inline;
    function  getODCD9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCD0(thebits : TBits_1); inline;
    procedure setODCD1(thebits : TBits_1); inline;
    procedure setODCD10(thebits : TBits_1); inline;
    procedure setODCD11(thebits : TBits_1); inline;
    procedure setODCD2(thebits : TBits_1); inline;
    procedure setODCD3(thebits : TBits_1); inline;
    procedure setODCD4(thebits : TBits_1); inline;
    procedure setODCD5(thebits : TBits_1); inline;
    procedure setODCD6(thebits : TBits_1); inline;
    procedure setODCD7(thebits : TBits_1); inline;
    procedure setODCD8(thebits : TBits_1); inline;
    procedure setODCD9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCD0; inline;
    procedure clearODCD10; inline;
    procedure clearODCD11; inline;
    procedure clearODCD1; inline;
    procedure clearODCD2; inline;
    procedure clearODCD3; inline;
    procedure clearODCD4; inline;
    procedure clearODCD5; inline;
    procedure clearODCD6; inline;
    procedure clearODCD7; inline;
    procedure clearODCD8; inline;
    procedure clearODCD9; inline;
    procedure setODCD0; inline;
    procedure setODCD10; inline;
    procedure setODCD11; inline;
    procedure setODCD1; inline;
    procedure setODCD2; inline;
    procedure setODCD3; inline;
    procedure setODCD4; inline;
    procedure setODCD5; inline;
    procedure setODCD6; inline;
    procedure setODCD7; inline;
    procedure setODCD8; inline;
    procedure setODCD9; inline;
    property ODCD0 : TBits_1 read getODCD0 write setODCD0;
    property ODCD1 : TBits_1 read getODCD1 write setODCD1;
    property ODCD10 : TBits_1 read getODCD10 write setODCD10;
    property ODCD11 : TBits_1 read getODCD11 write setODCD11;
    property ODCD2 : TBits_1 read getODCD2 write setODCD2;
    property ODCD3 : TBits_1 read getODCD3 write setODCD3;
    property ODCD4 : TBits_1 read getODCD4 write setODCD4;
    property ODCD5 : TBits_1 read getODCD5 write setODCD5;
    property ODCD6 : TBits_1 read getODCD6 write setODCD6;
    property ODCD7 : TBits_1 read getODCD7 write setODCD7;
    property ODCD8 : TBits_1 read getODCD8 write setODCD8;
    property ODCD9 : TBits_1 read getODCD9 write setODCD9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTD_CNPUD = record
  private
    function  getCNPUD0 : TBits_1; inline;
    function  getCNPUD1 : TBits_1; inline;
    function  getCNPUD10 : TBits_1; inline;
    function  getCNPUD11 : TBits_1; inline;
    function  getCNPUD2 : TBits_1; inline;
    function  getCNPUD3 : TBits_1; inline;
    function  getCNPUD4 : TBits_1; inline;
    function  getCNPUD5 : TBits_1; inline;
    function  getCNPUD6 : TBits_1; inline;
    function  getCNPUD7 : TBits_1; inline;
    function  getCNPUD8 : TBits_1; inline;
    function  getCNPUD9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPUD0(thebits : TBits_1); inline;
    procedure setCNPUD1(thebits : TBits_1); inline;
    procedure setCNPUD10(thebits : TBits_1); inline;
    procedure setCNPUD11(thebits : TBits_1); inline;
    procedure setCNPUD2(thebits : TBits_1); inline;
    procedure setCNPUD3(thebits : TBits_1); inline;
    procedure setCNPUD4(thebits : TBits_1); inline;
    procedure setCNPUD5(thebits : TBits_1); inline;
    procedure setCNPUD6(thebits : TBits_1); inline;
    procedure setCNPUD7(thebits : TBits_1); inline;
    procedure setCNPUD8(thebits : TBits_1); inline;
    procedure setCNPUD9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPUD0; inline;
    procedure clearCNPUD10; inline;
    procedure clearCNPUD11; inline;
    procedure clearCNPUD1; inline;
    procedure clearCNPUD2; inline;
    procedure clearCNPUD3; inline;
    procedure clearCNPUD4; inline;
    procedure clearCNPUD5; inline;
    procedure clearCNPUD6; inline;
    procedure clearCNPUD7; inline;
    procedure clearCNPUD8; inline;
    procedure clearCNPUD9; inline;
    procedure setCNPUD0; inline;
    procedure setCNPUD10; inline;
    procedure setCNPUD11; inline;
    procedure setCNPUD1; inline;
    procedure setCNPUD2; inline;
    procedure setCNPUD3; inline;
    procedure setCNPUD4; inline;
    procedure setCNPUD5; inline;
    procedure setCNPUD6; inline;
    procedure setCNPUD7; inline;
    procedure setCNPUD8; inline;
    procedure setCNPUD9; inline;
    property CNPUD0 : TBits_1 read getCNPUD0 write setCNPUD0;
    property CNPUD1 : TBits_1 read getCNPUD1 write setCNPUD1;
    property CNPUD10 : TBits_1 read getCNPUD10 write setCNPUD10;
    property CNPUD11 : TBits_1 read getCNPUD11 write setCNPUD11;
    property CNPUD2 : TBits_1 read getCNPUD2 write setCNPUD2;
    property CNPUD3 : TBits_1 read getCNPUD3 write setCNPUD3;
    property CNPUD4 : TBits_1 read getCNPUD4 write setCNPUD4;
    property CNPUD5 : TBits_1 read getCNPUD5 write setCNPUD5;
    property CNPUD6 : TBits_1 read getCNPUD6 write setCNPUD6;
    property CNPUD7 : TBits_1 read getCNPUD7 write setCNPUD7;
    property CNPUD8 : TBits_1 read getCNPUD8 write setCNPUD8;
    property CNPUD9 : TBits_1 read getCNPUD9 write setCNPUD9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTD_CNPDD = record
  private
    function  getCNPDD0 : TBits_1; inline;
    function  getCNPDD1 : TBits_1; inline;
    function  getCNPDD10 : TBits_1; inline;
    function  getCNPDD11 : TBits_1; inline;
    function  getCNPDD2 : TBits_1; inline;
    function  getCNPDD3 : TBits_1; inline;
    function  getCNPDD4 : TBits_1; inline;
    function  getCNPDD5 : TBits_1; inline;
    function  getCNPDD6 : TBits_1; inline;
    function  getCNPDD7 : TBits_1; inline;
    function  getCNPDD8 : TBits_1; inline;
    function  getCNPDD9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPDD0(thebits : TBits_1); inline;
    procedure setCNPDD1(thebits : TBits_1); inline;
    procedure setCNPDD10(thebits : TBits_1); inline;
    procedure setCNPDD11(thebits : TBits_1); inline;
    procedure setCNPDD2(thebits : TBits_1); inline;
    procedure setCNPDD3(thebits : TBits_1); inline;
    procedure setCNPDD4(thebits : TBits_1); inline;
    procedure setCNPDD5(thebits : TBits_1); inline;
    procedure setCNPDD6(thebits : TBits_1); inline;
    procedure setCNPDD7(thebits : TBits_1); inline;
    procedure setCNPDD8(thebits : TBits_1); inline;
    procedure setCNPDD9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPDD0; inline;
    procedure clearCNPDD10; inline;
    procedure clearCNPDD11; inline;
    procedure clearCNPDD1; inline;
    procedure clearCNPDD2; inline;
    procedure clearCNPDD3; inline;
    procedure clearCNPDD4; inline;
    procedure clearCNPDD5; inline;
    procedure clearCNPDD6; inline;
    procedure clearCNPDD7; inline;
    procedure clearCNPDD8; inline;
    procedure clearCNPDD9; inline;
    procedure setCNPDD0; inline;
    procedure setCNPDD10; inline;
    procedure setCNPDD11; inline;
    procedure setCNPDD1; inline;
    procedure setCNPDD2; inline;
    procedure setCNPDD3; inline;
    procedure setCNPDD4; inline;
    procedure setCNPDD5; inline;
    procedure setCNPDD6; inline;
    procedure setCNPDD7; inline;
    procedure setCNPDD8; inline;
    procedure setCNPDD9; inline;
    property CNPDD0 : TBits_1 read getCNPDD0 write setCNPDD0;
    property CNPDD1 : TBits_1 read getCNPDD1 write setCNPDD1;
    property CNPDD10 : TBits_1 read getCNPDD10 write setCNPDD10;
    property CNPDD11 : TBits_1 read getCNPDD11 write setCNPDD11;
    property CNPDD2 : TBits_1 read getCNPDD2 write setCNPDD2;
    property CNPDD3 : TBits_1 read getCNPDD3 write setCNPDD3;
    property CNPDD4 : TBits_1 read getCNPDD4 write setCNPDD4;
    property CNPDD5 : TBits_1 read getCNPDD5 write setCNPDD5;
    property CNPDD6 : TBits_1 read getCNPDD6 write setCNPDD6;
    property CNPDD7 : TBits_1 read getCNPDD7 write setCNPDD7;
    property CNPDD8 : TBits_1 read getCNPDD8 write setCNPDD8;
    property CNPDD9 : TBits_1 read getCNPDD9 write setCNPDD9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTD_CNCOND = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TPORTD_CNEND = record
  private
    function  getCNIED0 : TBits_1; inline;
    function  getCNIED1 : TBits_1; inline;
    function  getCNIED10 : TBits_1; inline;
    function  getCNIED11 : TBits_1; inline;
    function  getCNIED2 : TBits_1; inline;
    function  getCNIED3 : TBits_1; inline;
    function  getCNIED4 : TBits_1; inline;
    function  getCNIED5 : TBits_1; inline;
    function  getCNIED6 : TBits_1; inline;
    function  getCNIED7 : TBits_1; inline;
    function  getCNIED8 : TBits_1; inline;
    function  getCNIED9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNIED0(thebits : TBits_1); inline;
    procedure setCNIED1(thebits : TBits_1); inline;
    procedure setCNIED10(thebits : TBits_1); inline;
    procedure setCNIED11(thebits : TBits_1); inline;
    procedure setCNIED2(thebits : TBits_1); inline;
    procedure setCNIED3(thebits : TBits_1); inline;
    procedure setCNIED4(thebits : TBits_1); inline;
    procedure setCNIED5(thebits : TBits_1); inline;
    procedure setCNIED6(thebits : TBits_1); inline;
    procedure setCNIED7(thebits : TBits_1); inline;
    procedure setCNIED8(thebits : TBits_1); inline;
    procedure setCNIED9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNIED0; inline;
    procedure clearCNIED10; inline;
    procedure clearCNIED11; inline;
    procedure clearCNIED1; inline;
    procedure clearCNIED2; inline;
    procedure clearCNIED3; inline;
    procedure clearCNIED4; inline;
    procedure clearCNIED5; inline;
    procedure clearCNIED6; inline;
    procedure clearCNIED7; inline;
    procedure clearCNIED8; inline;
    procedure clearCNIED9; inline;
    procedure setCNIED0; inline;
    procedure setCNIED10; inline;
    procedure setCNIED11; inline;
    procedure setCNIED1; inline;
    procedure setCNIED2; inline;
    procedure setCNIED3; inline;
    procedure setCNIED4; inline;
    procedure setCNIED5; inline;
    procedure setCNIED6; inline;
    procedure setCNIED7; inline;
    procedure setCNIED8; inline;
    procedure setCNIED9; inline;
    property CNIED0 : TBits_1 read getCNIED0 write setCNIED0;
    property CNIED1 : TBits_1 read getCNIED1 write setCNIED1;
    property CNIED10 : TBits_1 read getCNIED10 write setCNIED10;
    property CNIED11 : TBits_1 read getCNIED11 write setCNIED11;
    property CNIED2 : TBits_1 read getCNIED2 write setCNIED2;
    property CNIED3 : TBits_1 read getCNIED3 write setCNIED3;
    property CNIED4 : TBits_1 read getCNIED4 write setCNIED4;
    property CNIED5 : TBits_1 read getCNIED5 write setCNIED5;
    property CNIED6 : TBits_1 read getCNIED6 write setCNIED6;
    property CNIED7 : TBits_1 read getCNIED7 write setCNIED7;
    property CNIED8 : TBits_1 read getCNIED8 write setCNIED8;
    property CNIED9 : TBits_1 read getCNIED9 write setCNIED9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTD_CNSTATD = record
  private
    function  getCNSTATD0 : TBits_1; inline;
    function  getCNSTATD1 : TBits_1; inline;
    function  getCNSTATD10 : TBits_1; inline;
    function  getCNSTATD11 : TBits_1; inline;
    function  getCNSTATD2 : TBits_1; inline;
    function  getCNSTATD3 : TBits_1; inline;
    function  getCNSTATD4 : TBits_1; inline;
    function  getCNSTATD5 : TBits_1; inline;
    function  getCNSTATD6 : TBits_1; inline;
    function  getCNSTATD7 : TBits_1; inline;
    function  getCNSTATD8 : TBits_1; inline;
    function  getCNSTATD9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNSTATD0(thebits : TBits_1); inline;
    procedure setCNSTATD1(thebits : TBits_1); inline;
    procedure setCNSTATD10(thebits : TBits_1); inline;
    procedure setCNSTATD11(thebits : TBits_1); inline;
    procedure setCNSTATD2(thebits : TBits_1); inline;
    procedure setCNSTATD3(thebits : TBits_1); inline;
    procedure setCNSTATD4(thebits : TBits_1); inline;
    procedure setCNSTATD5(thebits : TBits_1); inline;
    procedure setCNSTATD6(thebits : TBits_1); inline;
    procedure setCNSTATD7(thebits : TBits_1); inline;
    procedure setCNSTATD8(thebits : TBits_1); inline;
    procedure setCNSTATD9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNSTATD0; inline;
    procedure clearCNSTATD10; inline;
    procedure clearCNSTATD11; inline;
    procedure clearCNSTATD1; inline;
    procedure clearCNSTATD2; inline;
    procedure clearCNSTATD3; inline;
    procedure clearCNSTATD4; inline;
    procedure clearCNSTATD5; inline;
    procedure clearCNSTATD6; inline;
    procedure clearCNSTATD7; inline;
    procedure clearCNSTATD8; inline;
    procedure clearCNSTATD9; inline;
    procedure setCNSTATD0; inline;
    procedure setCNSTATD10; inline;
    procedure setCNSTATD11; inline;
    procedure setCNSTATD1; inline;
    procedure setCNSTATD2; inline;
    procedure setCNSTATD3; inline;
    procedure setCNSTATD4; inline;
    procedure setCNSTATD5; inline;
    procedure setCNSTATD6; inline;
    procedure setCNSTATD7; inline;
    procedure setCNSTATD8; inline;
    procedure setCNSTATD9; inline;
    property CNSTATD0 : TBits_1 read getCNSTATD0 write setCNSTATD0;
    property CNSTATD1 : TBits_1 read getCNSTATD1 write setCNSTATD1;
    property CNSTATD10 : TBits_1 read getCNSTATD10 write setCNSTATD10;
    property CNSTATD11 : TBits_1 read getCNSTATD11 write setCNSTATD11;
    property CNSTATD2 : TBits_1 read getCNSTATD2 write setCNSTATD2;
    property CNSTATD3 : TBits_1 read getCNSTATD3 write setCNSTATD3;
    property CNSTATD4 : TBits_1 read getCNSTATD4 write setCNSTATD4;
    property CNSTATD5 : TBits_1 read getCNSTATD5 write setCNSTATD5;
    property CNSTATD6 : TBits_1 read getCNSTATD6 write setCNSTATD6;
    property CNSTATD7 : TBits_1 read getCNSTATD7 write setCNSTATD7;
    property CNSTATD8 : TBits_1 read getCNSTATD8 write setCNSTATD8;
    property CNSTATD9 : TBits_1 read getCNSTATD9 write setCNSTATD9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTD_ANSELE = record
  private
    function  getANSE2 : TBits_1; inline;
    function  getANSE4 : TBits_1; inline;
    function  getANSE5 : TBits_1; inline;
    function  getANSE6 : TBits_1; inline;
    function  getANSE7 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setANSE2(thebits : TBits_1); inline;
    procedure setANSE4(thebits : TBits_1); inline;
    procedure setANSE5(thebits : TBits_1); inline;
    procedure setANSE6(thebits : TBits_1); inline;
    procedure setANSE7(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearANSE2; inline;
    procedure clearANSE4; inline;
    procedure clearANSE5; inline;
    procedure clearANSE6; inline;
    procedure clearANSE7; inline;
    procedure setANSE2; inline;
    procedure setANSE4; inline;
    procedure setANSE5; inline;
    procedure setANSE6; inline;
    procedure setANSE7; inline;
    property ANSE2 : TBits_1 read getANSE2 write setANSE2;
    property ANSE4 : TBits_1 read getANSE4 write setANSE4;
    property ANSE5 : TBits_1 read getANSE5 write setANSE5;
    property ANSE6 : TBits_1 read getANSE6 write setANSE6;
    property ANSE7 : TBits_1 read getANSE7 write setANSE7;
    property w : TBits_32 read getw write setw;
  end;
  TPORTD_TRISE = record
  private
    function  getTRISE0 : TBits_1; inline;
    function  getTRISE1 : TBits_1; inline;
    function  getTRISE2 : TBits_1; inline;
    function  getTRISE3 : TBits_1; inline;
    function  getTRISE4 : TBits_1; inline;
    function  getTRISE5 : TBits_1; inline;
    function  getTRISE6 : TBits_1; inline;
    function  getTRISE7 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISE0(thebits : TBits_1); inline;
    procedure setTRISE1(thebits : TBits_1); inline;
    procedure setTRISE2(thebits : TBits_1); inline;
    procedure setTRISE3(thebits : TBits_1); inline;
    procedure setTRISE4(thebits : TBits_1); inline;
    procedure setTRISE5(thebits : TBits_1); inline;
    procedure setTRISE6(thebits : TBits_1); inline;
    procedure setTRISE7(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISE0; inline;
    procedure clearTRISE1; inline;
    procedure clearTRISE2; inline;
    procedure clearTRISE3; inline;
    procedure clearTRISE4; inline;
    procedure clearTRISE5; inline;
    procedure clearTRISE6; inline;
    procedure clearTRISE7; inline;
    procedure setTRISE0; inline;
    procedure setTRISE1; inline;
    procedure setTRISE2; inline;
    procedure setTRISE3; inline;
    procedure setTRISE4; inline;
    procedure setTRISE5; inline;
    procedure setTRISE6; inline;
    procedure setTRISE7; inline;
    property TRISE0 : TBits_1 read getTRISE0 write setTRISE0;
    property TRISE1 : TBits_1 read getTRISE1 write setTRISE1;
    property TRISE2 : TBits_1 read getTRISE2 write setTRISE2;
    property TRISE3 : TBits_1 read getTRISE3 write setTRISE3;
    property TRISE4 : TBits_1 read getTRISE4 write setTRISE4;
    property TRISE5 : TBits_1 read getTRISE5 write setTRISE5;
    property TRISE6 : TBits_1 read getTRISE6 write setTRISE6;
    property TRISE7 : TBits_1 read getTRISE7 write setTRISE7;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTDRegisters = record
    PORTDbits : TPORTD_PORTD;
    PORTD : longWord;
    PORTDCLR : longWord;
    PORTDSET : longWord;
    PORTDINV : longWord;
    LATDbits : TPORTD_LATD;
    LATD : longWord;
    LATDCLR : longWord;
    LATDSET : longWord;
    LATDINV : longWord;
    ODCDbits : TPORTD_ODCD;
    ODCD : longWord;
    ODCDCLR : longWord;
    ODCDSET : longWord;
    ODCDINV : longWord;
    CNPUDbits : TPORTD_CNPUD;
    CNPUD : longWord;
    CNPUDCLR : longWord;
    CNPUDSET : longWord;
    CNPUDINV : longWord;
    CNPDDbits : TPORTD_CNPDD;
    CNPDD : longWord;
    CNPDDCLR : longWord;
    CNPDDSET : longWord;
    CNPDDINV : longWord;
    CNCONDbits : TPORTD_CNCOND;
    CNCOND : longWord;
    CNCONDCLR : longWord;
    CNCONDSET : longWord;
    CNCONDINV : longWord;
    CNENDbits : TPORTD_CNEND;
    CNEND : longWord;
    CNENDCLR : longWord;
    CNENDSET : longWord;
    CNENDINV : longWord;
    CNSTATDbits : TPORTD_CNSTATD;
    CNSTATD : longWord;
    CNSTATDCLR : longWord;
    CNSTATDSET : longWord;
    CNSTATDINV : longWord;
    ANSELEbits : TPORTD_ANSELE;
    ANSELE : longWord;
    ANSELECLR : longWord;
    ANSELESET : longWord;
    ANSELEINV : longWord;
    TRISEbits : TPORTD_TRISE;
    TRISE : longWord;
    TRISECLR : longWord;
    TRISESET : longWord;
    TRISEINV : longWord;
  end;
  TPORTE_PORTE = record
  private
    function  getRE0 : TBits_1; inline;
    function  getRE1 : TBits_1; inline;
    function  getRE2 : TBits_1; inline;
    function  getRE3 : TBits_1; inline;
    function  getRE4 : TBits_1; inline;
    function  getRE5 : TBits_1; inline;
    function  getRE6 : TBits_1; inline;
    function  getRE7 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRE0(thebits : TBits_1); inline;
    procedure setRE1(thebits : TBits_1); inline;
    procedure setRE2(thebits : TBits_1); inline;
    procedure setRE3(thebits : TBits_1); inline;
    procedure setRE4(thebits : TBits_1); inline;
    procedure setRE5(thebits : TBits_1); inline;
    procedure setRE6(thebits : TBits_1); inline;
    procedure setRE7(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRE0; inline;
    procedure clearRE1; inline;
    procedure clearRE2; inline;
    procedure clearRE3; inline;
    procedure clearRE4; inline;
    procedure clearRE5; inline;
    procedure clearRE6; inline;
    procedure clearRE7; inline;
    procedure setRE0; inline;
    procedure setRE1; inline;
    procedure setRE2; inline;
    procedure setRE3; inline;
    procedure setRE4; inline;
    procedure setRE5; inline;
    procedure setRE6; inline;
    procedure setRE7; inline;
    property RE0 : TBits_1 read getRE0 write setRE0;
    property RE1 : TBits_1 read getRE1 write setRE1;
    property RE2 : TBits_1 read getRE2 write setRE2;
    property RE3 : TBits_1 read getRE3 write setRE3;
    property RE4 : TBits_1 read getRE4 write setRE4;
    property RE5 : TBits_1 read getRE5 write setRE5;
    property RE6 : TBits_1 read getRE6 write setRE6;
    property RE7 : TBits_1 read getRE7 write setRE7;
    property w : TBits_32 read getw write setw;
  end;
  TPortE_bits=(RE0=0,RE1=1,RE2=2,RE3=3,RE4=4,RE5=5,RE6=6,RE7=7);
  TPortE_bitset = set of TPortE_bits;
  TPORTE_LATE = record
  private
    function  getLATE0 : TBits_1; inline;
    function  getLATE1 : TBits_1; inline;
    function  getLATE2 : TBits_1; inline;
    function  getLATE3 : TBits_1; inline;
    function  getLATE4 : TBits_1; inline;
    function  getLATE5 : TBits_1; inline;
    function  getLATE6 : TBits_1; inline;
    function  getLATE7 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATE0(thebits : TBits_1); inline;
    procedure setLATE1(thebits : TBits_1); inline;
    procedure setLATE2(thebits : TBits_1); inline;
    procedure setLATE3(thebits : TBits_1); inline;
    procedure setLATE4(thebits : TBits_1); inline;
    procedure setLATE5(thebits : TBits_1); inline;
    procedure setLATE6(thebits : TBits_1); inline;
    procedure setLATE7(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATE0; inline;
    procedure clearLATE1; inline;
    procedure clearLATE2; inline;
    procedure clearLATE3; inline;
    procedure clearLATE4; inline;
    procedure clearLATE5; inline;
    procedure clearLATE6; inline;
    procedure clearLATE7; inline;
    procedure setLATE0; inline;
    procedure setLATE1; inline;
    procedure setLATE2; inline;
    procedure setLATE3; inline;
    procedure setLATE4; inline;
    procedure setLATE5; inline;
    procedure setLATE6; inline;
    procedure setLATE7; inline;
    property LATE0 : TBits_1 read getLATE0 write setLATE0;
    property LATE1 : TBits_1 read getLATE1 write setLATE1;
    property LATE2 : TBits_1 read getLATE2 write setLATE2;
    property LATE3 : TBits_1 read getLATE3 write setLATE3;
    property LATE4 : TBits_1 read getLATE4 write setLATE4;
    property LATE5 : TBits_1 read getLATE5 write setLATE5;
    property LATE6 : TBits_1 read getLATE6 write setLATE6;
    property LATE7 : TBits_1 read getLATE7 write setLATE7;
    property w : TBits_32 read getw write setw;
  end;
  TPORTE_ODCE = record
  private
    function  getODCE0 : TBits_1; inline;
    function  getODCE1 : TBits_1; inline;
    function  getODCE2 : TBits_1; inline;
    function  getODCE3 : TBits_1; inline;
    function  getODCE4 : TBits_1; inline;
    function  getODCE5 : TBits_1; inline;
    function  getODCE6 : TBits_1; inline;
    function  getODCE7 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCE0(thebits : TBits_1); inline;
    procedure setODCE1(thebits : TBits_1); inline;
    procedure setODCE2(thebits : TBits_1); inline;
    procedure setODCE3(thebits : TBits_1); inline;
    procedure setODCE4(thebits : TBits_1); inline;
    procedure setODCE5(thebits : TBits_1); inline;
    procedure setODCE6(thebits : TBits_1); inline;
    procedure setODCE7(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCE0; inline;
    procedure clearODCE1; inline;
    procedure clearODCE2; inline;
    procedure clearODCE3; inline;
    procedure clearODCE4; inline;
    procedure clearODCE5; inline;
    procedure clearODCE6; inline;
    procedure clearODCE7; inline;
    procedure setODCE0; inline;
    procedure setODCE1; inline;
    procedure setODCE2; inline;
    procedure setODCE3; inline;
    procedure setODCE4; inline;
    procedure setODCE5; inline;
    procedure setODCE6; inline;
    procedure setODCE7; inline;
    property ODCE0 : TBits_1 read getODCE0 write setODCE0;
    property ODCE1 : TBits_1 read getODCE1 write setODCE1;
    property ODCE2 : TBits_1 read getODCE2 write setODCE2;
    property ODCE3 : TBits_1 read getODCE3 write setODCE3;
    property ODCE4 : TBits_1 read getODCE4 write setODCE4;
    property ODCE5 : TBits_1 read getODCE5 write setODCE5;
    property ODCE6 : TBits_1 read getODCE6 write setODCE6;
    property ODCE7 : TBits_1 read getODCE7 write setODCE7;
    property w : TBits_32 read getw write setw;
  end;
  TPORTE_CNPUE = record
  private
    function  getCNPUE0 : TBits_1; inline;
    function  getCNPUE1 : TBits_1; inline;
    function  getCNPUE2 : TBits_1; inline;
    function  getCNPUE3 : TBits_1; inline;
    function  getCNPUE4 : TBits_1; inline;
    function  getCNPUE5 : TBits_1; inline;
    function  getCNPUE6 : TBits_1; inline;
    function  getCNPUE7 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPUE0(thebits : TBits_1); inline;
    procedure setCNPUE1(thebits : TBits_1); inline;
    procedure setCNPUE2(thebits : TBits_1); inline;
    procedure setCNPUE3(thebits : TBits_1); inline;
    procedure setCNPUE4(thebits : TBits_1); inline;
    procedure setCNPUE5(thebits : TBits_1); inline;
    procedure setCNPUE6(thebits : TBits_1); inline;
    procedure setCNPUE7(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPUE0; inline;
    procedure clearCNPUE1; inline;
    procedure clearCNPUE2; inline;
    procedure clearCNPUE3; inline;
    procedure clearCNPUE4; inline;
    procedure clearCNPUE5; inline;
    procedure clearCNPUE6; inline;
    procedure clearCNPUE7; inline;
    procedure setCNPUE0; inline;
    procedure setCNPUE1; inline;
    procedure setCNPUE2; inline;
    procedure setCNPUE3; inline;
    procedure setCNPUE4; inline;
    procedure setCNPUE5; inline;
    procedure setCNPUE6; inline;
    procedure setCNPUE7; inline;
    property CNPUE0 : TBits_1 read getCNPUE0 write setCNPUE0;
    property CNPUE1 : TBits_1 read getCNPUE1 write setCNPUE1;
    property CNPUE2 : TBits_1 read getCNPUE2 write setCNPUE2;
    property CNPUE3 : TBits_1 read getCNPUE3 write setCNPUE3;
    property CNPUE4 : TBits_1 read getCNPUE4 write setCNPUE4;
    property CNPUE5 : TBits_1 read getCNPUE5 write setCNPUE5;
    property CNPUE6 : TBits_1 read getCNPUE6 write setCNPUE6;
    property CNPUE7 : TBits_1 read getCNPUE7 write setCNPUE7;
    property w : TBits_32 read getw write setw;
  end;
  TPORTE_CNPDE = record
  private
    function  getCNPDE0 : TBits_1; inline;
    function  getCNPDE1 : TBits_1; inline;
    function  getCNPDE2 : TBits_1; inline;
    function  getCNPDE3 : TBits_1; inline;
    function  getCNPDE4 : TBits_1; inline;
    function  getCNPDE5 : TBits_1; inline;
    function  getCNPDE6 : TBits_1; inline;
    function  getCNPDE7 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPDE0(thebits : TBits_1); inline;
    procedure setCNPDE1(thebits : TBits_1); inline;
    procedure setCNPDE2(thebits : TBits_1); inline;
    procedure setCNPDE3(thebits : TBits_1); inline;
    procedure setCNPDE4(thebits : TBits_1); inline;
    procedure setCNPDE5(thebits : TBits_1); inline;
    procedure setCNPDE6(thebits : TBits_1); inline;
    procedure setCNPDE7(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPDE0; inline;
    procedure clearCNPDE1; inline;
    procedure clearCNPDE2; inline;
    procedure clearCNPDE3; inline;
    procedure clearCNPDE4; inline;
    procedure clearCNPDE5; inline;
    procedure clearCNPDE6; inline;
    procedure clearCNPDE7; inline;
    procedure setCNPDE0; inline;
    procedure setCNPDE1; inline;
    procedure setCNPDE2; inline;
    procedure setCNPDE3; inline;
    procedure setCNPDE4; inline;
    procedure setCNPDE5; inline;
    procedure setCNPDE6; inline;
    procedure setCNPDE7; inline;
    property CNPDE0 : TBits_1 read getCNPDE0 write setCNPDE0;
    property CNPDE1 : TBits_1 read getCNPDE1 write setCNPDE1;
    property CNPDE2 : TBits_1 read getCNPDE2 write setCNPDE2;
    property CNPDE3 : TBits_1 read getCNPDE3 write setCNPDE3;
    property CNPDE4 : TBits_1 read getCNPDE4 write setCNPDE4;
    property CNPDE5 : TBits_1 read getCNPDE5 write setCNPDE5;
    property CNPDE6 : TBits_1 read getCNPDE6 write setCNPDE6;
    property CNPDE7 : TBits_1 read getCNPDE7 write setCNPDE7;
    property w : TBits_32 read getw write setw;
  end;
  TPORTE_CNCONE = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TPORTE_CNENE = record
  private
    function  getCNIEE0 : TBits_1; inline;
    function  getCNIEE1 : TBits_1; inline;
    function  getCNIEE2 : TBits_1; inline;
    function  getCNIEE3 : TBits_1; inline;
    function  getCNIEE4 : TBits_1; inline;
    function  getCNIEE5 : TBits_1; inline;
    function  getCNIEE6 : TBits_1; inline;
    function  getCNIEE7 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNIEE0(thebits : TBits_1); inline;
    procedure setCNIEE1(thebits : TBits_1); inline;
    procedure setCNIEE2(thebits : TBits_1); inline;
    procedure setCNIEE3(thebits : TBits_1); inline;
    procedure setCNIEE4(thebits : TBits_1); inline;
    procedure setCNIEE5(thebits : TBits_1); inline;
    procedure setCNIEE6(thebits : TBits_1); inline;
    procedure setCNIEE7(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNIEE0; inline;
    procedure clearCNIEE1; inline;
    procedure clearCNIEE2; inline;
    procedure clearCNIEE3; inline;
    procedure clearCNIEE4; inline;
    procedure clearCNIEE5; inline;
    procedure clearCNIEE6; inline;
    procedure clearCNIEE7; inline;
    procedure setCNIEE0; inline;
    procedure setCNIEE1; inline;
    procedure setCNIEE2; inline;
    procedure setCNIEE3; inline;
    procedure setCNIEE4; inline;
    procedure setCNIEE5; inline;
    procedure setCNIEE6; inline;
    procedure setCNIEE7; inline;
    property CNIEE0 : TBits_1 read getCNIEE0 write setCNIEE0;
    property CNIEE1 : TBits_1 read getCNIEE1 write setCNIEE1;
    property CNIEE2 : TBits_1 read getCNIEE2 write setCNIEE2;
    property CNIEE3 : TBits_1 read getCNIEE3 write setCNIEE3;
    property CNIEE4 : TBits_1 read getCNIEE4 write setCNIEE4;
    property CNIEE5 : TBits_1 read getCNIEE5 write setCNIEE5;
    property CNIEE6 : TBits_1 read getCNIEE6 write setCNIEE6;
    property CNIEE7 : TBits_1 read getCNIEE7 write setCNIEE7;
    property w : TBits_32 read getw write setw;
  end;
  TPORTE_CNSTATE = record
  private
    function  getCNSTATE0 : TBits_1; inline;
    function  getCNSTATE1 : TBits_1; inline;
    function  getCNSTATE2 : TBits_1; inline;
    function  getCNSTATE3 : TBits_1; inline;
    function  getCNSTATE4 : TBits_1; inline;
    function  getCNSTATE5 : TBits_1; inline;
    function  getCNSTATE6 : TBits_1; inline;
    function  getCNSTATE7 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNSTATE0(thebits : TBits_1); inline;
    procedure setCNSTATE1(thebits : TBits_1); inline;
    procedure setCNSTATE2(thebits : TBits_1); inline;
    procedure setCNSTATE3(thebits : TBits_1); inline;
    procedure setCNSTATE4(thebits : TBits_1); inline;
    procedure setCNSTATE5(thebits : TBits_1); inline;
    procedure setCNSTATE6(thebits : TBits_1); inline;
    procedure setCNSTATE7(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNSTATE0; inline;
    procedure clearCNSTATE1; inline;
    procedure clearCNSTATE2; inline;
    procedure clearCNSTATE3; inline;
    procedure clearCNSTATE4; inline;
    procedure clearCNSTATE5; inline;
    procedure clearCNSTATE6; inline;
    procedure clearCNSTATE7; inline;
    procedure setCNSTATE0; inline;
    procedure setCNSTATE1; inline;
    procedure setCNSTATE2; inline;
    procedure setCNSTATE3; inline;
    procedure setCNSTATE4; inline;
    procedure setCNSTATE5; inline;
    procedure setCNSTATE6; inline;
    procedure setCNSTATE7; inline;
    property CNSTATE0 : TBits_1 read getCNSTATE0 write setCNSTATE0;
    property CNSTATE1 : TBits_1 read getCNSTATE1 write setCNSTATE1;
    property CNSTATE2 : TBits_1 read getCNSTATE2 write setCNSTATE2;
    property CNSTATE3 : TBits_1 read getCNSTATE3 write setCNSTATE3;
    property CNSTATE4 : TBits_1 read getCNSTATE4 write setCNSTATE4;
    property CNSTATE5 : TBits_1 read getCNSTATE5 write setCNSTATE5;
    property CNSTATE6 : TBits_1 read getCNSTATE6 write setCNSTATE6;
    property CNSTATE7 : TBits_1 read getCNSTATE7 write setCNSTATE7;
    property w : TBits_32 read getw write setw;
  end;
  TPORTE_ANSELF = record
  private
    function  getANSF0 : TBits_1; inline;
    function  getANSF1 : TBits_1; inline;
    function  getANSF2 : TBits_1; inline;
    function  getANSF3 : TBits_1; inline;
    function  getANSF4 : TBits_1; inline;
    function  getANSF5 : TBits_1; inline;
    function  getANSF6 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setANSF0(thebits : TBits_1); inline;
    procedure setANSF1(thebits : TBits_1); inline;
    procedure setANSF2(thebits : TBits_1); inline;
    procedure setANSF3(thebits : TBits_1); inline;
    procedure setANSF4(thebits : TBits_1); inline;
    procedure setANSF5(thebits : TBits_1); inline;
    procedure setANSF6(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearANSF0; inline;
    procedure clearANSF1; inline;
    procedure clearANSF2; inline;
    procedure clearANSF3; inline;
    procedure clearANSF4; inline;
    procedure clearANSF5; inline;
    procedure clearANSF6; inline;
    procedure setANSF0; inline;
    procedure setANSF1; inline;
    procedure setANSF2; inline;
    procedure setANSF3; inline;
    procedure setANSF4; inline;
    procedure setANSF5; inline;
    procedure setANSF6; inline;
    property ANSF0 : TBits_1 read getANSF0 write setANSF0;
    property ANSF1 : TBits_1 read getANSF1 write setANSF1;
    property ANSF2 : TBits_1 read getANSF2 write setANSF2;
    property ANSF3 : TBits_1 read getANSF3 write setANSF3;
    property ANSF4 : TBits_1 read getANSF4 write setANSF4;
    property ANSF5 : TBits_1 read getANSF5 write setANSF5;
    property ANSF6 : TBits_1 read getANSF6 write setANSF6;
    property w : TBits_32 read getw write setw;
  end;
  TPORTE_TRISF = record
  private
    function  getTRISF0 : TBits_1; inline;
    function  getTRISF1 : TBits_1; inline;
    function  getTRISF2 : TBits_1; inline;
    function  getTRISF3 : TBits_1; inline;
    function  getTRISF4 : TBits_1; inline;
    function  getTRISF5 : TBits_1; inline;
    function  getTRISF6 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISF0(thebits : TBits_1); inline;
    procedure setTRISF1(thebits : TBits_1); inline;
    procedure setTRISF2(thebits : TBits_1); inline;
    procedure setTRISF3(thebits : TBits_1); inline;
    procedure setTRISF4(thebits : TBits_1); inline;
    procedure setTRISF5(thebits : TBits_1); inline;
    procedure setTRISF6(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISF0; inline;
    procedure clearTRISF1; inline;
    procedure clearTRISF2; inline;
    procedure clearTRISF3; inline;
    procedure clearTRISF4; inline;
    procedure clearTRISF5; inline;
    procedure clearTRISF6; inline;
    procedure setTRISF0; inline;
    procedure setTRISF1; inline;
    procedure setTRISF2; inline;
    procedure setTRISF3; inline;
    procedure setTRISF4; inline;
    procedure setTRISF5; inline;
    procedure setTRISF6; inline;
    property TRISF0 : TBits_1 read getTRISF0 write setTRISF0;
    property TRISF1 : TBits_1 read getTRISF1 write setTRISF1;
    property TRISF2 : TBits_1 read getTRISF2 write setTRISF2;
    property TRISF3 : TBits_1 read getTRISF3 write setTRISF3;
    property TRISF4 : TBits_1 read getTRISF4 write setTRISF4;
    property TRISF5 : TBits_1 read getTRISF5 write setTRISF5;
    property TRISF6 : TBits_1 read getTRISF6 write setTRISF6;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTERegisters = record
    PORTEbits : TPORTE_PORTE;
    PORTE : longWord;
    PORTECLR : longWord;
    PORTESET : longWord;
    PORTEINV : longWord;
    LATEbits : TPORTE_LATE;
    LATE : longWord;
    LATECLR : longWord;
    LATESET : longWord;
    LATEINV : longWord;
    ODCEbits : TPORTE_ODCE;
    ODCE : longWord;
    ODCECLR : longWord;
    ODCESET : longWord;
    ODCEINV : longWord;
    CNPUEbits : TPORTE_CNPUE;
    CNPUE : longWord;
    CNPUECLR : longWord;
    CNPUESET : longWord;
    CNPUEINV : longWord;
    CNPDEbits : TPORTE_CNPDE;
    CNPDE : longWord;
    CNPDECLR : longWord;
    CNPDESET : longWord;
    CNPDEINV : longWord;
    CNCONEbits : TPORTE_CNCONE;
    CNCONE : longWord;
    CNCONECLR : longWord;
    CNCONESET : longWord;
    CNCONEINV : longWord;
    CNENEbits : TPORTE_CNENE;
    CNENE : longWord;
    CNENECLR : longWord;
    CNENESET : longWord;
    CNENEINV : longWord;
    CNSTATEbits : TPORTE_CNSTATE;
    CNSTATE : longWord;
    CNSTATECLR : longWord;
    CNSTATESET : longWord;
    CNSTATEINV : longWord;
    ANSELFbits : TPORTE_ANSELF;
    ANSELF : longWord;
    ANSELFCLR : longWord;
    ANSELFSET : longWord;
    ANSELFINV : longWord;
    TRISFbits : TPORTE_TRISF;
    TRISF : longWord;
    TRISFCLR : longWord;
    TRISFSET : longWord;
    TRISFINV : longWord;
  end;
  TPORTF_PORTF = record
  private
    function  getRF0 : TBits_1; inline;
    function  getRF1 : TBits_1; inline;
    function  getRF2 : TBits_1; inline;
    function  getRF3 : TBits_1; inline;
    function  getRF4 : TBits_1; inline;
    function  getRF5 : TBits_1; inline;
    function  getRF6 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRF0(thebits : TBits_1); inline;
    procedure setRF1(thebits : TBits_1); inline;
    procedure setRF2(thebits : TBits_1); inline;
    procedure setRF3(thebits : TBits_1); inline;
    procedure setRF4(thebits : TBits_1); inline;
    procedure setRF5(thebits : TBits_1); inline;
    procedure setRF6(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRF0; inline;
    procedure clearRF1; inline;
    procedure clearRF2; inline;
    procedure clearRF3; inline;
    procedure clearRF4; inline;
    procedure clearRF5; inline;
    procedure clearRF6; inline;
    procedure setRF0; inline;
    procedure setRF1; inline;
    procedure setRF2; inline;
    procedure setRF3; inline;
    procedure setRF4; inline;
    procedure setRF5; inline;
    procedure setRF6; inline;
    property RF0 : TBits_1 read getRF0 write setRF0;
    property RF1 : TBits_1 read getRF1 write setRF1;
    property RF2 : TBits_1 read getRF2 write setRF2;
    property RF3 : TBits_1 read getRF3 write setRF3;
    property RF4 : TBits_1 read getRF4 write setRF4;
    property RF5 : TBits_1 read getRF5 write setRF5;
    property RF6 : TBits_1 read getRF6 write setRF6;
    property w : TBits_32 read getw write setw;
  end;
  TPortF_bits=(RF0=0,RF1=1,RF2=2,RF3=3,RF4=4,RF5=5,RF6=6);
  TPortF_bitset = set of TPortF_bits;
  TPORTF_LATF = record
  private
    function  getLATF0 : TBits_1; inline;
    function  getLATF1 : TBits_1; inline;
    function  getLATF2 : TBits_1; inline;
    function  getLATF3 : TBits_1; inline;
    function  getLATF4 : TBits_1; inline;
    function  getLATF5 : TBits_1; inline;
    function  getLATF6 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATF0(thebits : TBits_1); inline;
    procedure setLATF1(thebits : TBits_1); inline;
    procedure setLATF2(thebits : TBits_1); inline;
    procedure setLATF3(thebits : TBits_1); inline;
    procedure setLATF4(thebits : TBits_1); inline;
    procedure setLATF5(thebits : TBits_1); inline;
    procedure setLATF6(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATF0; inline;
    procedure clearLATF1; inline;
    procedure clearLATF2; inline;
    procedure clearLATF3; inline;
    procedure clearLATF4; inline;
    procedure clearLATF5; inline;
    procedure clearLATF6; inline;
    procedure setLATF0; inline;
    procedure setLATF1; inline;
    procedure setLATF2; inline;
    procedure setLATF3; inline;
    procedure setLATF4; inline;
    procedure setLATF5; inline;
    procedure setLATF6; inline;
    property LATF0 : TBits_1 read getLATF0 write setLATF0;
    property LATF1 : TBits_1 read getLATF1 write setLATF1;
    property LATF2 : TBits_1 read getLATF2 write setLATF2;
    property LATF3 : TBits_1 read getLATF3 write setLATF3;
    property LATF4 : TBits_1 read getLATF4 write setLATF4;
    property LATF5 : TBits_1 read getLATF5 write setLATF5;
    property LATF6 : TBits_1 read getLATF6 write setLATF6;
    property w : TBits_32 read getw write setw;
  end;
  TPORTF_ODCF = record
  private
    function  getODCF0 : TBits_1; inline;
    function  getODCF1 : TBits_1; inline;
    function  getODCF2 : TBits_1; inline;
    function  getODCF3 : TBits_1; inline;
    function  getODCF4 : TBits_1; inline;
    function  getODCF5 : TBits_1; inline;
    function  getODCF6 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCF0(thebits : TBits_1); inline;
    procedure setODCF1(thebits : TBits_1); inline;
    procedure setODCF2(thebits : TBits_1); inline;
    procedure setODCF3(thebits : TBits_1); inline;
    procedure setODCF4(thebits : TBits_1); inline;
    procedure setODCF5(thebits : TBits_1); inline;
    procedure setODCF6(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCF0; inline;
    procedure clearODCF1; inline;
    procedure clearODCF2; inline;
    procedure clearODCF3; inline;
    procedure clearODCF4; inline;
    procedure clearODCF5; inline;
    procedure clearODCF6; inline;
    procedure setODCF0; inline;
    procedure setODCF1; inline;
    procedure setODCF2; inline;
    procedure setODCF3; inline;
    procedure setODCF4; inline;
    procedure setODCF5; inline;
    procedure setODCF6; inline;
    property ODCF0 : TBits_1 read getODCF0 write setODCF0;
    property ODCF1 : TBits_1 read getODCF1 write setODCF1;
    property ODCF2 : TBits_1 read getODCF2 write setODCF2;
    property ODCF3 : TBits_1 read getODCF3 write setODCF3;
    property ODCF4 : TBits_1 read getODCF4 write setODCF4;
    property ODCF5 : TBits_1 read getODCF5 write setODCF5;
    property ODCF6 : TBits_1 read getODCF6 write setODCF6;
    property w : TBits_32 read getw write setw;
  end;
  TPORTF_CNPUF = record
  private
    function  getCNPUF0 : TBits_1; inline;
    function  getCNPUF1 : TBits_1; inline;
    function  getCNPUF2 : TBits_1; inline;
    function  getCNPUF3 : TBits_1; inline;
    function  getCNPUF4 : TBits_1; inline;
    function  getCNPUF5 : TBits_1; inline;
    function  getCNPUF6 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPUF0(thebits : TBits_1); inline;
    procedure setCNPUF1(thebits : TBits_1); inline;
    procedure setCNPUF2(thebits : TBits_1); inline;
    procedure setCNPUF3(thebits : TBits_1); inline;
    procedure setCNPUF4(thebits : TBits_1); inline;
    procedure setCNPUF5(thebits : TBits_1); inline;
    procedure setCNPUF6(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPUF0; inline;
    procedure clearCNPUF1; inline;
    procedure clearCNPUF2; inline;
    procedure clearCNPUF3; inline;
    procedure clearCNPUF4; inline;
    procedure clearCNPUF5; inline;
    procedure clearCNPUF6; inline;
    procedure setCNPUF0; inline;
    procedure setCNPUF1; inline;
    procedure setCNPUF2; inline;
    procedure setCNPUF3; inline;
    procedure setCNPUF4; inline;
    procedure setCNPUF5; inline;
    procedure setCNPUF6; inline;
    property CNPUF0 : TBits_1 read getCNPUF0 write setCNPUF0;
    property CNPUF1 : TBits_1 read getCNPUF1 write setCNPUF1;
    property CNPUF2 : TBits_1 read getCNPUF2 write setCNPUF2;
    property CNPUF3 : TBits_1 read getCNPUF3 write setCNPUF3;
    property CNPUF4 : TBits_1 read getCNPUF4 write setCNPUF4;
    property CNPUF5 : TBits_1 read getCNPUF5 write setCNPUF5;
    property CNPUF6 : TBits_1 read getCNPUF6 write setCNPUF6;
    property w : TBits_32 read getw write setw;
  end;
  TPORTF_CNPDF = record
  private
    function  getCNPDF0 : TBits_1; inline;
    function  getCNPDF1 : TBits_1; inline;
    function  getCNPDF2 : TBits_1; inline;
    function  getCNPDF3 : TBits_1; inline;
    function  getCNPDF4 : TBits_1; inline;
    function  getCNPDF5 : TBits_1; inline;
    function  getCNPDF6 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPDF0(thebits : TBits_1); inline;
    procedure setCNPDF1(thebits : TBits_1); inline;
    procedure setCNPDF2(thebits : TBits_1); inline;
    procedure setCNPDF3(thebits : TBits_1); inline;
    procedure setCNPDF4(thebits : TBits_1); inline;
    procedure setCNPDF5(thebits : TBits_1); inline;
    procedure setCNPDF6(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPDF0; inline;
    procedure clearCNPDF1; inline;
    procedure clearCNPDF2; inline;
    procedure clearCNPDF3; inline;
    procedure clearCNPDF4; inline;
    procedure clearCNPDF5; inline;
    procedure clearCNPDF6; inline;
    procedure setCNPDF0; inline;
    procedure setCNPDF1; inline;
    procedure setCNPDF2; inline;
    procedure setCNPDF3; inline;
    procedure setCNPDF4; inline;
    procedure setCNPDF5; inline;
    procedure setCNPDF6; inline;
    property CNPDF0 : TBits_1 read getCNPDF0 write setCNPDF0;
    property CNPDF1 : TBits_1 read getCNPDF1 write setCNPDF1;
    property CNPDF2 : TBits_1 read getCNPDF2 write setCNPDF2;
    property CNPDF3 : TBits_1 read getCNPDF3 write setCNPDF3;
    property CNPDF4 : TBits_1 read getCNPDF4 write setCNPDF4;
    property CNPDF5 : TBits_1 read getCNPDF5 write setCNPDF5;
    property CNPDF6 : TBits_1 read getCNPDF6 write setCNPDF6;
    property w : TBits_32 read getw write setw;
  end;
  TPORTF_CNCONF = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TPORTF_CNENF = record
  private
    function  getCNIEF0 : TBits_1; inline;
    function  getCNIEF1 : TBits_1; inline;
    function  getCNIEF2 : TBits_1; inline;
    function  getCNIEF3 : TBits_1; inline;
    function  getCNIEF4 : TBits_1; inline;
    function  getCNIEF5 : TBits_1; inline;
    function  getCNIEF6 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNIEF0(thebits : TBits_1); inline;
    procedure setCNIEF1(thebits : TBits_1); inline;
    procedure setCNIEF2(thebits : TBits_1); inline;
    procedure setCNIEF3(thebits : TBits_1); inline;
    procedure setCNIEF4(thebits : TBits_1); inline;
    procedure setCNIEF5(thebits : TBits_1); inline;
    procedure setCNIEF6(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNIEF0; inline;
    procedure clearCNIEF1; inline;
    procedure clearCNIEF2; inline;
    procedure clearCNIEF3; inline;
    procedure clearCNIEF4; inline;
    procedure clearCNIEF5; inline;
    procedure clearCNIEF6; inline;
    procedure setCNIEF0; inline;
    procedure setCNIEF1; inline;
    procedure setCNIEF2; inline;
    procedure setCNIEF3; inline;
    procedure setCNIEF4; inline;
    procedure setCNIEF5; inline;
    procedure setCNIEF6; inline;
    property CNIEF0 : TBits_1 read getCNIEF0 write setCNIEF0;
    property CNIEF1 : TBits_1 read getCNIEF1 write setCNIEF1;
    property CNIEF2 : TBits_1 read getCNIEF2 write setCNIEF2;
    property CNIEF3 : TBits_1 read getCNIEF3 write setCNIEF3;
    property CNIEF4 : TBits_1 read getCNIEF4 write setCNIEF4;
    property CNIEF5 : TBits_1 read getCNIEF5 write setCNIEF5;
    property CNIEF6 : TBits_1 read getCNIEF6 write setCNIEF6;
    property w : TBits_32 read getw write setw;
  end;
  TPORTF_CNSTATF = record
  private
    function  getCNSTATF0 : TBits_1; inline;
    function  getCNSTATF1 : TBits_1; inline;
    function  getCNSTATF2 : TBits_1; inline;
    function  getCNSTATF3 : TBits_1; inline;
    function  getCNSTATF4 : TBits_1; inline;
    function  getCNSTATF5 : TBits_1; inline;
    function  getCNSTATF6 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNSTATF0(thebits : TBits_1); inline;
    procedure setCNSTATF1(thebits : TBits_1); inline;
    procedure setCNSTATF2(thebits : TBits_1); inline;
    procedure setCNSTATF3(thebits : TBits_1); inline;
    procedure setCNSTATF4(thebits : TBits_1); inline;
    procedure setCNSTATF5(thebits : TBits_1); inline;
    procedure setCNSTATF6(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNSTATF0; inline;
    procedure clearCNSTATF1; inline;
    procedure clearCNSTATF2; inline;
    procedure clearCNSTATF3; inline;
    procedure clearCNSTATF4; inline;
    procedure clearCNSTATF5; inline;
    procedure clearCNSTATF6; inline;
    procedure setCNSTATF0; inline;
    procedure setCNSTATF1; inline;
    procedure setCNSTATF2; inline;
    procedure setCNSTATF3; inline;
    procedure setCNSTATF4; inline;
    procedure setCNSTATF5; inline;
    procedure setCNSTATF6; inline;
    property CNSTATF0 : TBits_1 read getCNSTATF0 write setCNSTATF0;
    property CNSTATF1 : TBits_1 read getCNSTATF1 write setCNSTATF1;
    property CNSTATF2 : TBits_1 read getCNSTATF2 write setCNSTATF2;
    property CNSTATF3 : TBits_1 read getCNSTATF3 write setCNSTATF3;
    property CNSTATF4 : TBits_1 read getCNSTATF4 write setCNSTATF4;
    property CNSTATF5 : TBits_1 read getCNSTATF5 write setCNSTATF5;
    property CNSTATF6 : TBits_1 read getCNSTATF6 write setCNSTATF6;
    property w : TBits_32 read getw write setw;
  end;
  TPORTF_ANSELG = record
  private
    function  getANSG6 : TBits_1; inline;
    function  getANSG7 : TBits_1; inline;
    function  getANSG8 : TBits_1; inline;
    function  getANSG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setANSG6(thebits : TBits_1); inline;
    procedure setANSG7(thebits : TBits_1); inline;
    procedure setANSG8(thebits : TBits_1); inline;
    procedure setANSG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearANSG6; inline;
    procedure clearANSG7; inline;
    procedure clearANSG8; inline;
    procedure clearANSG9; inline;
    procedure setANSG6; inline;
    procedure setANSG7; inline;
    procedure setANSG8; inline;
    procedure setANSG9; inline;
    property ANSG6 : TBits_1 read getANSG6 write setANSG6;
    property ANSG7 : TBits_1 read getANSG7 write setANSG7;
    property ANSG8 : TBits_1 read getANSG8 write setANSG8;
    property ANSG9 : TBits_1 read getANSG9 write setANSG9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTF_TRISG = record
  private
    function  getTRISG2 : TBits_1; inline;
    function  getTRISG3 : TBits_1; inline;
    function  getTRISG6 : TBits_1; inline;
    function  getTRISG7 : TBits_1; inline;
    function  getTRISG8 : TBits_1; inline;
    function  getTRISG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISG2(thebits : TBits_1); inline;
    procedure setTRISG3(thebits : TBits_1); inline;
    procedure setTRISG6(thebits : TBits_1); inline;
    procedure setTRISG7(thebits : TBits_1); inline;
    procedure setTRISG8(thebits : TBits_1); inline;
    procedure setTRISG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISG2; inline;
    procedure clearTRISG3; inline;
    procedure clearTRISG6; inline;
    procedure clearTRISG7; inline;
    procedure clearTRISG8; inline;
    procedure clearTRISG9; inline;
    procedure setTRISG2; inline;
    procedure setTRISG3; inline;
    procedure setTRISG6; inline;
    procedure setTRISG7; inline;
    procedure setTRISG8; inline;
    procedure setTRISG9; inline;
    property TRISG2 : TBits_1 read getTRISG2 write setTRISG2;
    property TRISG3 : TBits_1 read getTRISG3 write setTRISG3;
    property TRISG6 : TBits_1 read getTRISG6 write setTRISG6;
    property TRISG7 : TBits_1 read getTRISG7 write setTRISG7;
    property TRISG8 : TBits_1 read getTRISG8 write setTRISG8;
    property TRISG9 : TBits_1 read getTRISG9 write setTRISG9;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTFRegisters = record
    PORTFbits : TPORTF_PORTF;
    PORTF : longWord;
    PORTFCLR : longWord;
    PORTFSET : longWord;
    PORTFINV : longWord;
    LATFbits : TPORTF_LATF;
    LATF : longWord;
    LATFCLR : longWord;
    LATFSET : longWord;
    LATFINV : longWord;
    ODCFbits : TPORTF_ODCF;
    ODCF : longWord;
    ODCFCLR : longWord;
    ODCFSET : longWord;
    ODCFINV : longWord;
    CNPUFbits : TPORTF_CNPUF;
    CNPUF : longWord;
    CNPUFCLR : longWord;
    CNPUFSET : longWord;
    CNPUFINV : longWord;
    CNPDFbits : TPORTF_CNPDF;
    CNPDF : longWord;
    CNPDFCLR : longWord;
    CNPDFSET : longWord;
    CNPDFINV : longWord;
    CNCONFbits : TPORTF_CNCONF;
    CNCONF : longWord;
    CNCONFCLR : longWord;
    CNCONFSET : longWord;
    CNCONFINV : longWord;
    CNENFbits : TPORTF_CNENF;
    CNENF : longWord;
    CNENFCLR : longWord;
    CNENFSET : longWord;
    CNENFINV : longWord;
    CNSTATFbits : TPORTF_CNSTATF;
    CNSTATF : longWord;
    CNSTATFCLR : longWord;
    CNSTATFSET : longWord;
    CNSTATFINV : longWord;
    ANSELGbits : TPORTF_ANSELG;
    ANSELG : longWord;
    ANSELGCLR : longWord;
    ANSELGSET : longWord;
    ANSELGINV : longWord;
    TRISGbits : TPORTF_TRISG;
    TRISG : longWord;
    TRISGCLR : longWord;
    TRISGSET : longWord;
    TRISGINV : longWord;
  end;
  TPORTG_PORTG = record
  private
    function  getRG2 : TBits_1; inline;
    function  getRG3 : TBits_1; inline;
    function  getRG6 : TBits_1; inline;
    function  getRG7 : TBits_1; inline;
    function  getRG8 : TBits_1; inline;
    function  getRG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRG2(thebits : TBits_1); inline;
    procedure setRG3(thebits : TBits_1); inline;
    procedure setRG6(thebits : TBits_1); inline;
    procedure setRG7(thebits : TBits_1); inline;
    procedure setRG8(thebits : TBits_1); inline;
    procedure setRG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRG2; inline;
    procedure clearRG3; inline;
    procedure clearRG6; inline;
    procedure clearRG7; inline;
    procedure clearRG8; inline;
    procedure clearRG9; inline;
    procedure setRG2; inline;
    procedure setRG3; inline;
    procedure setRG6; inline;
    procedure setRG7; inline;
    procedure setRG8; inline;
    procedure setRG9; inline;
    property RG2 : TBits_1 read getRG2 write setRG2;
    property RG3 : TBits_1 read getRG3 write setRG3;
    property RG6 : TBits_1 read getRG6 write setRG6;
    property RG7 : TBits_1 read getRG7 write setRG7;
    property RG8 : TBits_1 read getRG8 write setRG8;
    property RG9 : TBits_1 read getRG9 write setRG9;
    property w : TBits_32 read getw write setw;
  end;
  TPortG_bits=(RG2=2,RG3=3,RG6=6,RG7=7,RG8=8,RG9=9);
  TPortG_bitset = set of TPortG_bits;
  TPORTG_LATG = record
  private
    function  getLATG2 : TBits_1; inline;
    function  getLATG3 : TBits_1; inline;
    function  getLATG6 : TBits_1; inline;
    function  getLATG7 : TBits_1; inline;
    function  getLATG8 : TBits_1; inline;
    function  getLATG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATG2(thebits : TBits_1); inline;
    procedure setLATG3(thebits : TBits_1); inline;
    procedure setLATG6(thebits : TBits_1); inline;
    procedure setLATG7(thebits : TBits_1); inline;
    procedure setLATG8(thebits : TBits_1); inline;
    procedure setLATG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATG2; inline;
    procedure clearLATG3; inline;
    procedure clearLATG6; inline;
    procedure clearLATG7; inline;
    procedure clearLATG8; inline;
    procedure clearLATG9; inline;
    procedure setLATG2; inline;
    procedure setLATG3; inline;
    procedure setLATG6; inline;
    procedure setLATG7; inline;
    procedure setLATG8; inline;
    procedure setLATG9; inline;
    property LATG2 : TBits_1 read getLATG2 write setLATG2;
    property LATG3 : TBits_1 read getLATG3 write setLATG3;
    property LATG6 : TBits_1 read getLATG6 write setLATG6;
    property LATG7 : TBits_1 read getLATG7 write setLATG7;
    property LATG8 : TBits_1 read getLATG8 write setLATG8;
    property LATG9 : TBits_1 read getLATG9 write setLATG9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTG_ODCG = record
  private
    function  getODCG2 : TBits_1; inline;
    function  getODCG3 : TBits_1; inline;
    function  getODCG6 : TBits_1; inline;
    function  getODCG7 : TBits_1; inline;
    function  getODCG8 : TBits_1; inline;
    function  getODCG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCG2(thebits : TBits_1); inline;
    procedure setODCG3(thebits : TBits_1); inline;
    procedure setODCG6(thebits : TBits_1); inline;
    procedure setODCG7(thebits : TBits_1); inline;
    procedure setODCG8(thebits : TBits_1); inline;
    procedure setODCG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCG2; inline;
    procedure clearODCG3; inline;
    procedure clearODCG6; inline;
    procedure clearODCG7; inline;
    procedure clearODCG8; inline;
    procedure clearODCG9; inline;
    procedure setODCG2; inline;
    procedure setODCG3; inline;
    procedure setODCG6; inline;
    procedure setODCG7; inline;
    procedure setODCG8; inline;
    procedure setODCG9; inline;
    property ODCG2 : TBits_1 read getODCG2 write setODCG2;
    property ODCG3 : TBits_1 read getODCG3 write setODCG3;
    property ODCG6 : TBits_1 read getODCG6 write setODCG6;
    property ODCG7 : TBits_1 read getODCG7 write setODCG7;
    property ODCG8 : TBits_1 read getODCG8 write setODCG8;
    property ODCG9 : TBits_1 read getODCG9 write setODCG9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTG_CNPUG = record
  private
    function  getCNPUG2 : TBits_1; inline;
    function  getCNPUG3 : TBits_1; inline;
    function  getCNPUG6 : TBits_1; inline;
    function  getCNPUG7 : TBits_1; inline;
    function  getCNPUG8 : TBits_1; inline;
    function  getCNPUG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPUG2(thebits : TBits_1); inline;
    procedure setCNPUG3(thebits : TBits_1); inline;
    procedure setCNPUG6(thebits : TBits_1); inline;
    procedure setCNPUG7(thebits : TBits_1); inline;
    procedure setCNPUG8(thebits : TBits_1); inline;
    procedure setCNPUG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPUG2; inline;
    procedure clearCNPUG3; inline;
    procedure clearCNPUG6; inline;
    procedure clearCNPUG7; inline;
    procedure clearCNPUG8; inline;
    procedure clearCNPUG9; inline;
    procedure setCNPUG2; inline;
    procedure setCNPUG3; inline;
    procedure setCNPUG6; inline;
    procedure setCNPUG7; inline;
    procedure setCNPUG8; inline;
    procedure setCNPUG9; inline;
    property CNPUG2 : TBits_1 read getCNPUG2 write setCNPUG2;
    property CNPUG3 : TBits_1 read getCNPUG3 write setCNPUG3;
    property CNPUG6 : TBits_1 read getCNPUG6 write setCNPUG6;
    property CNPUG7 : TBits_1 read getCNPUG7 write setCNPUG7;
    property CNPUG8 : TBits_1 read getCNPUG8 write setCNPUG8;
    property CNPUG9 : TBits_1 read getCNPUG9 write setCNPUG9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTG_CNPDG = record
  private
    function  getCNPDG2 : TBits_1; inline;
    function  getCNPDG3 : TBits_1; inline;
    function  getCNPDG6 : TBits_1; inline;
    function  getCNPDG7 : TBits_1; inline;
    function  getCNPDG8 : TBits_1; inline;
    function  getCNPDG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPDG2(thebits : TBits_1); inline;
    procedure setCNPDG3(thebits : TBits_1); inline;
    procedure setCNPDG6(thebits : TBits_1); inline;
    procedure setCNPDG7(thebits : TBits_1); inline;
    procedure setCNPDG8(thebits : TBits_1); inline;
    procedure setCNPDG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPDG2; inline;
    procedure clearCNPDG3; inline;
    procedure clearCNPDG6; inline;
    procedure clearCNPDG7; inline;
    procedure clearCNPDG8; inline;
    procedure clearCNPDG9; inline;
    procedure setCNPDG2; inline;
    procedure setCNPDG3; inline;
    procedure setCNPDG6; inline;
    procedure setCNPDG7; inline;
    procedure setCNPDG8; inline;
    procedure setCNPDG9; inline;
    property CNPDG2 : TBits_1 read getCNPDG2 write setCNPDG2;
    property CNPDG3 : TBits_1 read getCNPDG3 write setCNPDG3;
    property CNPDG6 : TBits_1 read getCNPDG6 write setCNPDG6;
    property CNPDG7 : TBits_1 read getCNPDG7 write setCNPDG7;
    property CNPDG8 : TBits_1 read getCNPDG8 write setCNPDG8;
    property CNPDG9 : TBits_1 read getCNPDG9 write setCNPDG9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTG_CNCONG = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TPORTG_CNENG = record
  private
    function  getCNIEG2 : TBits_1; inline;
    function  getCNIEG3 : TBits_1; inline;
    function  getCNIEG6 : TBits_1; inline;
    function  getCNIEG7 : TBits_1; inline;
    function  getCNIEG8 : TBits_1; inline;
    function  getCNIEG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNIEG2(thebits : TBits_1); inline;
    procedure setCNIEG3(thebits : TBits_1); inline;
    procedure setCNIEG6(thebits : TBits_1); inline;
    procedure setCNIEG7(thebits : TBits_1); inline;
    procedure setCNIEG8(thebits : TBits_1); inline;
    procedure setCNIEG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNIEG2; inline;
    procedure clearCNIEG3; inline;
    procedure clearCNIEG6; inline;
    procedure clearCNIEG7; inline;
    procedure clearCNIEG8; inline;
    procedure clearCNIEG9; inline;
    procedure setCNIEG2; inline;
    procedure setCNIEG3; inline;
    procedure setCNIEG6; inline;
    procedure setCNIEG7; inline;
    procedure setCNIEG8; inline;
    procedure setCNIEG9; inline;
    property CNIEG2 : TBits_1 read getCNIEG2 write setCNIEG2;
    property CNIEG3 : TBits_1 read getCNIEG3 write setCNIEG3;
    property CNIEG6 : TBits_1 read getCNIEG6 write setCNIEG6;
    property CNIEG7 : TBits_1 read getCNIEG7 write setCNIEG7;
    property CNIEG8 : TBits_1 read getCNIEG8 write setCNIEG8;
    property CNIEG9 : TBits_1 read getCNIEG9 write setCNIEG9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTG_CNSTATG = record
  private
    function  getCNSTATG2 : TBits_1; inline;
    function  getCNSTATG3 : TBits_1; inline;
    function  getCNSTATG6 : TBits_1; inline;
    function  getCNSTATG7 : TBits_1; inline;
    function  getCNSTATG8 : TBits_1; inline;
    function  getCNSTATG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNSTATG2(thebits : TBits_1); inline;
    procedure setCNSTATG3(thebits : TBits_1); inline;
    procedure setCNSTATG6(thebits : TBits_1); inline;
    procedure setCNSTATG7(thebits : TBits_1); inline;
    procedure setCNSTATG8(thebits : TBits_1); inline;
    procedure setCNSTATG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNSTATG2; inline;
    procedure clearCNSTATG3; inline;
    procedure clearCNSTATG6; inline;
    procedure clearCNSTATG7; inline;
    procedure clearCNSTATG8; inline;
    procedure clearCNSTATG9; inline;
    procedure setCNSTATG2; inline;
    procedure setCNSTATG3; inline;
    procedure setCNSTATG6; inline;
    procedure setCNSTATG7; inline;
    procedure setCNSTATG8; inline;
    procedure setCNSTATG9; inline;
    property CNSTATG2 : TBits_1 read getCNSTATG2 write setCNSTATG2;
    property CNSTATG3 : TBits_1 read getCNSTATG3 write setCNSTATG3;
    property CNSTATG6 : TBits_1 read getCNSTATG6 write setCNSTATG6;
    property CNSTATG7 : TBits_1 read getCNSTATG7 write setCNSTATG7;
    property CNSTATG8 : TBits_1 read getCNSTATG8 write setCNSTATG8;
    property CNSTATG9 : TBits_1 read getCNSTATG9 write setCNSTATG9;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTGRegisters = record
    PORTGbits : TPORTG_PORTG;
    PORTG : longWord;
    PORTGCLR : longWord;
    PORTGSET : longWord;
    PORTGINV : longWord;
    LATGbits : TPORTG_LATG;
    LATG : longWord;
    LATGCLR : longWord;
    LATGSET : longWord;
    LATGINV : longWord;
    ODCGbits : TPORTG_ODCG;
    ODCG : longWord;
    ODCGCLR : longWord;
    ODCGSET : longWord;
    ODCGINV : longWord;
    CNPUGbits : TPORTG_CNPUG;
    CNPUG : longWord;
    CNPUGCLR : longWord;
    CNPUGSET : longWord;
    CNPUGINV : longWord;
    CNPDGbits : TPORTG_CNPDG;
    CNPDG : longWord;
    CNPDGCLR : longWord;
    CNPDGSET : longWord;
    CNPDGINV : longWord;
    CNCONGbits : TPORTG_CNCONG;
    CNCONG : longWord;
    CNCONGCLR : longWord;
    CNCONGSET : longWord;
    CNCONGINV : longWord;
    CNENGbits : TPORTG_CNENG;
    CNENG : longWord;
    CNENGCLR : longWord;
    CNENGSET : longWord;
    CNENGINV : longWord;
    CNSTATGbits : TPORTG_CNSTATG;
    CNSTATG : longWord;
    CNSTATGCLR : longWord;
    CNSTATGSET : longWord;
    CNSTATGINV : longWord;
  end;
  TDEVCFG_DEVCFG3 = record
  private
    function  getFSRSSEL : TBits_3; inline;
    function  getFUSBIDIO : TBits_1; inline;
    function  getFVBUSONIO : TBits_1; inline;
    function  getIOL1WAY : TBits_1; inline;
    function  getPMDL1WAY : TBits_1; inline;
    function  getUSERID : TBits_16; inline;
    function  getw : TBits_32; inline;
    procedure setFSRSSEL(thebits : TBits_3); inline;
    procedure setFUSBIDIO(thebits : TBits_1); inline;
    procedure setFVBUSONIO(thebits : TBits_1); inline;
    procedure setIOL1WAY(thebits : TBits_1); inline;
    procedure setPMDL1WAY(thebits : TBits_1); inline;
    procedure setUSERID(thebits : TBits_16); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFUSBIDIO; inline;
    procedure clearFVBUSONIO; inline;
    procedure clearIOL1WAY; inline;
    procedure clearPMDL1WAY; inline;
    procedure setFUSBIDIO; inline;
    procedure setFVBUSONIO; inline;
    procedure setIOL1WAY; inline;
    procedure setPMDL1WAY; inline;
    property FSRSSEL : TBits_3 read getFSRSSEL write setFSRSSEL;
    property FUSBIDIO : TBits_1 read getFUSBIDIO write setFUSBIDIO;
    property FVBUSONIO : TBits_1 read getFVBUSONIO write setFVBUSONIO;
    property IOL1WAY : TBits_1 read getIOL1WAY write setIOL1WAY;
    property PMDL1WAY : TBits_1 read getPMDL1WAY write setPMDL1WAY;
    property USERID : TBits_16 read getUSERID write setUSERID;
    property w : TBits_32 read getw write setw;
  end;
  TDEVCFG_DEVCFG2 = record
  private
    function  getFPLLIDIV : TBits_3; inline;
    function  getFPLLMUL : TBits_3; inline;
    function  getFPLLODIV : TBits_3; inline;
    function  getUPLLEN : TBits_1; inline;
    function  getUPLLIDIV : TBits_3; inline;
    function  getw : TBits_32; inline;
    procedure setFPLLIDIV(thebits : TBits_3); inline;
    procedure setFPLLMUL(thebits : TBits_3); inline;
    procedure setFPLLODIV(thebits : TBits_3); inline;
    procedure setUPLLEN(thebits : TBits_1); inline;
    procedure setUPLLIDIV(thebits : TBits_3); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearUPLLEN; inline;
    procedure setUPLLEN; inline;
    property FPLLIDIV : TBits_3 read getFPLLIDIV write setFPLLIDIV;
    property FPLLMUL : TBits_3 read getFPLLMUL write setFPLLMUL;
    property FPLLODIV : TBits_3 read getFPLLODIV write setFPLLODIV;
    property UPLLEN : TBits_1 read getUPLLEN write setUPLLEN;
    property UPLLIDIV : TBits_3 read getUPLLIDIV write setUPLLIDIV;
    property w : TBits_32 read getw write setw;
  end;
  TDEVCFG_DEVCFG1 = record
  private
    function  getFCKSM : TBits_2; inline;
    function  getFNOSC : TBits_3; inline;
    function  getFPBDIV : TBits_2; inline;
    function  getFSOSCEN : TBits_1; inline;
    function  getFWDTEN : TBits_1; inline;
    function  getFWDTWINSZ : TBits_2; inline;
    function  getIESO : TBits_1; inline;
    function  getOSCIOFNC : TBits_1; inline;
    function  getPOSCMOD : TBits_2; inline;
    function  getWDTPS : TBits_5; inline;
    function  getWINDIS : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setFCKSM(thebits : TBits_2); inline;
    procedure setFNOSC(thebits : TBits_3); inline;
    procedure setFPBDIV(thebits : TBits_2); inline;
    procedure setFSOSCEN(thebits : TBits_1); inline;
    procedure setFWDTEN(thebits : TBits_1); inline;
    procedure setFWDTWINSZ(thebits : TBits_2); inline;
    procedure setIESO(thebits : TBits_1); inline;
    procedure setOSCIOFNC(thebits : TBits_1); inline;
    procedure setPOSCMOD(thebits : TBits_2); inline;
    procedure setWDTPS(thebits : TBits_5); inline;
    procedure setWINDIS(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFSOSCEN; inline;
    procedure clearFWDTEN; inline;
    procedure clearIESO; inline;
    procedure clearOSCIOFNC; inline;
    procedure clearWINDIS; inline;
    procedure setFSOSCEN; inline;
    procedure setFWDTEN; inline;
    procedure setIESO; inline;
    procedure setOSCIOFNC; inline;
    procedure setWINDIS; inline;
    property FCKSM : TBits_2 read getFCKSM write setFCKSM;
    property FNOSC : TBits_3 read getFNOSC write setFNOSC;
    property FPBDIV : TBits_2 read getFPBDIV write setFPBDIV;
    property FSOSCEN : TBits_1 read getFSOSCEN write setFSOSCEN;
    property FWDTEN : TBits_1 read getFWDTEN write setFWDTEN;
    property FWDTWINSZ : TBits_2 read getFWDTWINSZ write setFWDTWINSZ;
    property IESO : TBits_1 read getIESO write setIESO;
    property OSCIOFNC : TBits_1 read getOSCIOFNC write setOSCIOFNC;
    property POSCMOD : TBits_2 read getPOSCMOD write setPOSCMOD;
    property WDTPS : TBits_5 read getWDTPS write setWDTPS;
    property WINDIS : TBits_1 read getWINDIS write setWINDIS;
    property w : TBits_32 read getw write setw;
  end;
  TDEVCFG_DEVCFG0 = record
  private
    function  getBWP : TBits_1; inline;
    function  getCP : TBits_1; inline;
    function  getDEBUG : TBits_2; inline;
    function  getFDEBUG : TBits_2; inline;
    function  getICESEL : TBits_2; inline;
    function  getJTAGEN : TBits_1; inline;
    function  getPWP : TBits_8; inline;
    function  getw : TBits_32; inline;
    procedure setBWP(thebits : TBits_1); inline;
    procedure setCP(thebits : TBits_1); inline;
    procedure setDEBUG(thebits : TBits_2); inline;
    procedure setFDEBUG(thebits : TBits_2); inline;
    procedure setICESEL(thebits : TBits_2); inline;
    procedure setJTAGEN(thebits : TBits_1); inline;
    procedure setPWP(thebits : TBits_8); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBWP; inline;
    procedure clearCP; inline;
    procedure clearJTAGEN; inline;
    procedure setBWP; inline;
    procedure setCP; inline;
    procedure setJTAGEN; inline;
    property BWP : TBits_1 read getBWP write setBWP;
    property CP : TBits_1 read getCP write setCP;
    property DEBUG : TBits_2 read getDEBUG write setDEBUG;
    property FDEBUG : TBits_2 read getFDEBUG write setFDEBUG;
    property ICESEL : TBits_2 read getICESEL write setICESEL;
    property JTAGEN : TBits_1 read getJTAGEN write setJTAGEN;
    property PWP : TBits_8 read getPWP write setPWP;
    property w : TBits_32 read getw write setw;
  end;
const
  _CORE_TIMER_IRQ = 0;
  _CORE_SOFTWARE_0_IRQ = 1;
  _CORE_SOFTWARE_1_IRQ = 2;
  _EXTERNAL_0_IRQ = 3;
  _TIMER_1_IRQ = 4;
  _INPUT_CAPTURE_ERROR_1_IRQ = 5;
  _INPUT_CAPTURE_1_IRQ = 6;
  _OUTPUT_COMPARE_1_IRQ = 7;
  _EXTERNAL_1_IRQ = 8;
  _TIMER_2_IRQ = 9;
  _INPUT_CAPTURE_ERROR_2_IRQ = 10;
  _INPUT_CAPTURE_2_IRQ = 11;
  _OUTPUT_COMPARE_2_IRQ = 12;
  _EXTERNAL_2_IRQ = 13;
  _TIMER_3_IRQ = 14;
  _INPUT_CAPTURE_ERROR_3_IRQ = 15;
  _INPUT_CAPTURE_3_IRQ = 16;
  _OUTPUT_COMPARE_3_IRQ = 17;
  _EXTERNAL_3_IRQ = 18;
  _TIMER_4_IRQ = 19;
  _INPUT_CAPTURE_ERROR_4_IRQ = 20;
  _INPUT_CAPTURE_4_IRQ = 21;
  _OUTPUT_COMPARE_4_IRQ = 22;
  _EXTERNAL_4_IRQ = 23;
  _TIMER_5_IRQ = 24;
  _INPUT_CAPTURE_ERROR_5_IRQ = 25;
  _INPUT_CAPTURE_5_IRQ = 26;
  _OUTPUT_COMPARE_5_IRQ = 27;
  _ADC_IRQ = 28;
  _FAIL_SAFE_MONITOR_IRQ = 29;
  _RTCC_IRQ = 30;
  _FLASH_CONTROL_IRQ = 31;
  _COMPARATOR_1_IRQ = 32;
  _COMPARATOR_2_IRQ = 33;
  _USB_IRQ = 34;
  _SPI1_ERR_IRQ = 35;
  _SPI1_RX_IRQ = 36;
  _SPI1_TX_IRQ = 37;
  _UART1_ERR_IRQ = 38;
  _UART1_RX_IRQ = 39;
  _UART1_TX_IRQ = 40;
  _I2C1_BUS_IRQ = 41;
  _I2C1_SLAVE_IRQ = 42;
  _I2C1_MASTER_IRQ = 43;
  _CHANGE_NOTICE_A_IRQ = 44;
  _CHANGE_NOTICE_B_IRQ = 45;
  _CHANGE_NOTICE_C_IRQ = 46;
  _CHANGE_NOTICE_D_IRQ = 47;
  _CHANGE_NOTICE_E_IRQ = 48;
  _CHANGE_NOTICE_F_IRQ = 49;
  _CHANGE_NOTICE_G_IRQ = 50;
  _PMP_IRQ = 51;
  _PMP_ERROR_IRQ = 52;
  _SPI2_ERR_IRQ = 53;
  _SPI2_RX_IRQ = 54;
  _SPI2_TX_IRQ = 55;
  _UART2_ERR_IRQ = 56;
  _UART2_RX_IRQ = 57;
  _UART2_TX_IRQ = 58;
  _I2C2_BUS_IRQ = 59;
  _I2C2_SLAVE_IRQ = 60;
  _I2C2_MASTER_IRQ = 61;
  _UART3_ERR_IRQ = 62;
  _UART3_RX_IRQ = 63;
  _UART3_TX_IRQ = 64;
  _UART4_ERR_IRQ = 65;
  _UART4_RX_IRQ = 66;
  _UART4_TX_IRQ = 67;
  _CTMU_IRQ = 71;
  _DMA0_IRQ = 72;
  _DMA1_IRQ = 73;
  _DMA2_IRQ = 74;
  _DMA3_IRQ = 75;
const
  ADC10_BASE_ADDRESS = $BF809000;
var
  ADC10 : TADC10Registers absolute ADC10_BASE_ADDRESS;
const
  BMX_BASE_ADDRESS = $BF882000;
var
  BMX : TBMXRegisters absolute BMX_BASE_ADDRESS;
const
  CFG_BASE_ADDRESS = $BF80F200;
var
  CFG : TCFGRegisters absolute CFG_BASE_ADDRESS;
const
  CMP_BASE_ADDRESS = $BF80A000;
var
  CMP : TCMPRegisters absolute CMP_BASE_ADDRESS;
const
  CVR_BASE_ADDRESS = $BF809800;
var
  CVR : TCVRRegisters absolute CVR_BASE_ADDRESS;
const
  DMAC_BASE_ADDRESS = $BF883000;
var
  DMAC : TDMACRegisters absolute DMAC_BASE_ADDRESS;
const
  DMAC0_BASE_ADDRESS = $BF883060;
var
  DMAC0 : TDMAC0Registers absolute DMAC0_BASE_ADDRESS;
const
  DMAC1_BASE_ADDRESS = $BF883120;
var
  DMAC1 : TDMAC1Registers absolute DMAC1_BASE_ADDRESS;
const
  DMAC2_BASE_ADDRESS = $BF8831E0;
var
  DMAC2 : TDMAC2Registers absolute DMAC2_BASE_ADDRESS;
const
  DMAC3_BASE_ADDRESS = $BF8832A0;
var
  DMAC3 : TDMAC3Registers absolute DMAC3_BASE_ADDRESS;
const
  I2C1_BASE_ADDRESS = $BF805000;
var
  I2C1 : TI2C1Registers absolute I2C1_BASE_ADDRESS;
const
  I2C2_BASE_ADDRESS = $BF805100;
var
  I2C2 : TI2C2Registers absolute I2C2_BASE_ADDRESS;
const
  ICAP1_BASE_ADDRESS = $BF802000;
var
  ICAP1 : TICAP1Registers absolute ICAP1_BASE_ADDRESS;
const
  ICAP2_BASE_ADDRESS = $BF802200;
var
  ICAP2 : TICAP2Registers absolute ICAP2_BASE_ADDRESS;
const
  ICAP3_BASE_ADDRESS = $BF802400;
var
  ICAP3 : TICAP3Registers absolute ICAP3_BASE_ADDRESS;
const
  ICAP4_BASE_ADDRESS = $BF802600;
var
  ICAP4 : TICAP4Registers absolute ICAP4_BASE_ADDRESS;
const
  ICAP5_BASE_ADDRESS = $BF802800;
var
  ICAP5 : TICAP5Registers absolute ICAP5_BASE_ADDRESS;
const
  INT_BASE_ADDRESS = $BF881000;
var
  INT : TINTRegisters absolute INT_BASE_ADDRESS;
const
  NVM_BASE_ADDRESS = $BF80F400;
var
  NVM : TNVMRegisters absolute NVM_BASE_ADDRESS;
const
  OCMP1_BASE_ADDRESS = $BF803000;
var
  OCMP1 : TOCMP1Registers absolute OCMP1_BASE_ADDRESS;
const
  OCMP2_BASE_ADDRESS = $BF803200;
var
  OCMP2 : TOCMP2Registers absolute OCMP2_BASE_ADDRESS;
const
  OCMP3_BASE_ADDRESS = $BF803400;
var
  OCMP3 : TOCMP3Registers absolute OCMP3_BASE_ADDRESS;
const
  OCMP4_BASE_ADDRESS = $BF803600;
var
  OCMP4 : TOCMP4Registers absolute OCMP4_BASE_ADDRESS;
const
  OCMP5_BASE_ADDRESS = $BF803800;
var
  OCMP5 : TOCMP5Registers absolute OCMP5_BASE_ADDRESS;
const
  OSC_BASE_ADDRESS = $BF80F000;
var
  OSC : TOSCRegisters absolute OSC_BASE_ADDRESS;
const
  PCACHE_BASE_ADDRESS = $BF884000;
var
  PCACHE : TPCACHERegisters absolute PCACHE_BASE_ADDRESS;
const
  PMP_BASE_ADDRESS = $BF807000;
var
  PMP : TPMPRegisters absolute PMP_BASE_ADDRESS;
const
  PORTB_BASE_ADDRESS = $BF886120;
var
  PORTB : TPORTBRegisters absolute PORTB_BASE_ADDRESS;
const
  PORTC_BASE_ADDRESS = $BF886220;
var
  PORTC : TPORTCRegisters absolute PORTC_BASE_ADDRESS;
const
  PORTD_BASE_ADDRESS = $BF886320;
var
  PORTD : TPORTDRegisters absolute PORTD_BASE_ADDRESS;
const
  PORTE_BASE_ADDRESS = $BF886420;
var
  PORTE : TPORTERegisters absolute PORTE_BASE_ADDRESS;
const
  PORTF_BASE_ADDRESS = $BF886520;
var
  PORTF : TPORTFRegisters absolute PORTF_BASE_ADDRESS;
const
  PORTG_BASE_ADDRESS = $BF886620;
var
  PORTG : TPORTGRegisters absolute PORTG_BASE_ADDRESS;
const
  RCON_BASE_ADDRESS = $BF80F600;
var
  RCON : TRCONRegisters absolute RCON_BASE_ADDRESS;
const
  RTCC_BASE_ADDRESS = $BF800200;
var
  RTCC : TRTCCRegisters absolute RTCC_BASE_ADDRESS;
const
  SPI1_BASE_ADDRESS = $BF805800;
var
  SPI1 : TSPI1Registers absolute SPI1_BASE_ADDRESS;
const
  SPI2_BASE_ADDRESS = $BF805A00;
var
  SPI2 : TSPI2Registers absolute SPI2_BASE_ADDRESS;
const
  TMR1_BASE_ADDRESS = $BF800600;
var
  TMR1 : TTMR1Registers absolute TMR1_BASE_ADDRESS;
const
  TMR2_BASE_ADDRESS = $BF800800;
var
  TMR2 : TTMR2Registers absolute TMR2_BASE_ADDRESS;
const
  TMR3_BASE_ADDRESS = $BF800A00;
var
  TMR3 : TTMR3Registers absolute TMR3_BASE_ADDRESS;
const
  TMR4_BASE_ADDRESS = $BF800C00;
var
  TMR4 : TTMR4Registers absolute TMR4_BASE_ADDRESS;
const
  TMR5_BASE_ADDRESS = $BF800E00;
var
  TMR5 : TTMR5Registers absolute TMR5_BASE_ADDRESS;
const
  UART1_BASE_ADDRESS = $BF806000;
var
  UART1 : TUART1Registers absolute UART1_BASE_ADDRESS;
const
  UART2_BASE_ADDRESS = $BF806200;
var
  UART2 : TUART2Registers absolute UART2_BASE_ADDRESS;
const
  UART3_BASE_ADDRESS = $BF806400;
var
  UART3 : TUART3Registers absolute UART3_BASE_ADDRESS;
const
  UART4_BASE_ADDRESS = $BF806600;
var
  UART4 : TUART4Registers absolute UART4_BASE_ADDRESS;
const
  USB_BASE_ADDRESS = $BF885040;
var
  USB : TUSBRegisters absolute USB_BASE_ADDRESS;
const
  WDT_BASE_ADDRESS = $BF800000;
var
  WDT : TWDTRegisters absolute WDT_BASE_ADDRESS;
implementation
type
  TDefRegMap = record
    val : longWord;
    clr : longWord;
    &set : longWord;
    inv : longWord;
  end;

  pTDefRegMap = ^TDefRegMap;

procedure TWDT_WDTCON.setWDTCLR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TWDT_WDTCON.clearWDTCLR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TWDT_WDTCON.setWDTCLR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TWDT_WDTCON.getWDTCLR : TBits_1; inline;
begin
  getWDTCLR := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TWDT_WDTCON.setWDTWINEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TWDT_WDTCON.clearWDTWINEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TWDT_WDTCON.setWDTWINEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TWDT_WDTCON.getWDTWINEN : TBits_1; inline;
begin
  getWDTWINEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TWDT_WDTCON.setSWDTPS(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF83 or ( thebits shl 2 );
end;
function  TWDT_WDTCON.getSWDTPS : TBits_5; inline;
begin
  getSWDTPS := (pTDefRegMap(@Self)^.val and $0000007C) shr 2;
end;
procedure TWDT_WDTCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TWDT_WDTCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TWDT_WDTCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TWDT_WDTCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TWDT_WDTCON.setSWDTPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TWDT_WDTCON.clearSWDTPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TWDT_WDTCON.setSWDTPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TWDT_WDTCON.getSWDTPS0 : TBits_1; inline;
begin
  getSWDTPS0 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TWDT_WDTCON.setSWDTPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TWDT_WDTCON.clearSWDTPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TWDT_WDTCON.setSWDTPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TWDT_WDTCON.getSWDTPS1 : TBits_1; inline;
begin
  getSWDTPS1 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TWDT_WDTCON.setSWDTPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TWDT_WDTCON.clearSWDTPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TWDT_WDTCON.setSWDTPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TWDT_WDTCON.getSWDTPS2 : TBits_1; inline;
begin
  getSWDTPS2 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TWDT_WDTCON.setSWDTPS3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TWDT_WDTCON.clearSWDTPS3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TWDT_WDTCON.setSWDTPS3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TWDT_WDTCON.getSWDTPS3 : TBits_1; inline;
begin
  getSWDTPS3 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TWDT_WDTCON.setSWDTPS4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TWDT_WDTCON.clearSWDTPS4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TWDT_WDTCON.setSWDTPS4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TWDT_WDTCON.getSWDTPS4 : TBits_1; inline;
begin
  getSWDTPS4 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TWDT_WDTCON.setWDTPSTA(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF83 or ( thebits shl 2 );
end;
function  TWDT_WDTCON.getWDTPSTA : TBits_5; inline;
begin
  getWDTPSTA := (pTDefRegMap(@Self)^.val and $0000007C) shr 2;
end;
procedure TWDT_WDTCON.setWDTPS(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF83 or ( thebits shl 2 );
end;
function  TWDT_WDTCON.getWDTPS : TBits_5; inline;
begin
  getWDTPS := (pTDefRegMap(@Self)^.val and $0000007C) shr 2;
end;
procedure TWDT_WDTCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TWDT_WDTCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_RTCCON.setRTCOE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TRTCC_RTCCON.clearRTCOE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TRTCC_RTCCON.setRTCOE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TRTCC_RTCCON.getRTCOE : TBits_1; inline;
begin
  getRTCOE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TRTCC_RTCCON.setHALFSEC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TRTCC_RTCCON.clearHALFSEC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TRTCC_RTCCON.setHALFSEC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TRTCC_RTCCON.getHALFSEC : TBits_1; inline;
begin
  getHALFSEC := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TRTCC_RTCCON.setRTCSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TRTCC_RTCCON.clearRTCSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TRTCC_RTCCON.setRTCSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TRTCC_RTCCON.getRTCSYNC : TBits_1; inline;
begin
  getRTCSYNC := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TRTCC_RTCCON.setRTCWREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TRTCC_RTCCON.clearRTCWREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TRTCC_RTCCON.setRTCWREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TRTCC_RTCCON.getRTCWREN : TBits_1; inline;
begin
  getRTCWREN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TRTCC_RTCCON.setRTCCLKON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TRTCC_RTCCON.clearRTCCLKON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TRTCC_RTCCON.setRTCCLKON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TRTCC_RTCCON.getRTCCLKON : TBits_1; inline;
begin
  getRTCCLKON := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TRTCC_RTCCON.setRTSECSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TRTCC_RTCCON.clearRTSECSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TRTCC_RTCCON.setRTSECSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TRTCC_RTCCON.getRTSECSEL : TBits_1; inline;
begin
  getRTSECSEL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TRTCC_RTCCON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TRTCC_RTCCON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TRTCC_RTCCON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TRTCC_RTCCON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TRTCC_RTCCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TRTCC_RTCCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TRTCC_RTCCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TRTCC_RTCCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TRTCC_RTCCON.setCAL(thebits : TBits_10); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FC00FFFF or ( thebits shl 16 );
end;
function  TRTCC_RTCCON.getCAL : TBits_10; inline;
begin
  getCAL := (pTDefRegMap(@Self)^.val and $03FF0000) shr 16;
end;
procedure TRTCC_RTCCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_RTCCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_RTCALRM.setARPT(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF00 or ( thebits shl 0 );
end;
function  TRTCC_RTCALRM.getARPT : TBits_8; inline;
begin
  getARPT := (pTDefRegMap(@Self)^.val and $000000FF) shr 0;
end;
procedure TRTCC_RTCALRM.setAMASK(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_RTCALRM.getAMASK : TBits_4; inline;
begin
  getAMASK := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_RTCALRM.setALRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TRTCC_RTCALRM.clearALRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TRTCC_RTCALRM.setALRMSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TRTCC_RTCALRM.getALRMSYNC : TBits_1; inline;
begin
  getALRMSYNC := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TRTCC_RTCALRM.setPIV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TRTCC_RTCALRM.clearPIV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TRTCC_RTCALRM.setPIV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TRTCC_RTCALRM.getPIV : TBits_1; inline;
begin
  getPIV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TRTCC_RTCALRM.setCHIME; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TRTCC_RTCALRM.clearCHIME; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TRTCC_RTCALRM.setCHIME(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TRTCC_RTCALRM.getCHIME : TBits_1; inline;
begin
  getCHIME := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TRTCC_RTCALRM.setALRMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TRTCC_RTCALRM.clearALRMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TRTCC_RTCALRM.setALRMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TRTCC_RTCALRM.getALRMEN : TBits_1; inline;
begin
  getALRMEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TRTCC_RTCALRM.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_RTCALRM.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_RTCTIME.setSEC01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_RTCTIME.getSEC01 : TBits_4; inline;
begin
  getSEC01 := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_RTCTIME.setSEC10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0FFF or ( thebits shl 12 );
end;
function  TRTCC_RTCTIME.getSEC10 : TBits_4; inline;
begin
  getSEC10 := (pTDefRegMap(@Self)^.val and $0000F000) shr 12;
end;
procedure TRTCC_RTCTIME.setMIN01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TRTCC_RTCTIME.getMIN01 : TBits_4; inline;
begin
  getMIN01 := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TRTCC_RTCTIME.setMIN10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF0FFFFF or ( thebits shl 20 );
end;
function  TRTCC_RTCTIME.getMIN10 : TBits_4; inline;
begin
  getMIN10 := (pTDefRegMap(@Self)^.val and $00F00000) shr 20;
end;
procedure TRTCC_RTCTIME.setHR01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F0FFFFFF or ( thebits shl 24 );
end;
function  TRTCC_RTCTIME.getHR01 : TBits_4; inline;
begin
  getHR01 := (pTDefRegMap(@Self)^.val and $0F000000) shr 24;
end;
procedure TRTCC_RTCTIME.setHR10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $0FFFFFFF or ( thebits shl 28 );
end;
function  TRTCC_RTCTIME.getHR10 : TBits_4; inline;
begin
  getHR10 := (pTDefRegMap(@Self)^.val and $F0000000) shr 28;
end;
procedure TRTCC_RTCTIME.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_RTCTIME.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_RTCDATE.setWDAY01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TRTCC_RTCDATE.getWDAY01 : TBits_4; inline;
begin
  getWDAY01 := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TRTCC_RTCDATE.setDAY01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_RTCDATE.getDAY01 : TBits_4; inline;
begin
  getDAY01 := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_RTCDATE.setDAY10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0FFF or ( thebits shl 12 );
end;
function  TRTCC_RTCDATE.getDAY10 : TBits_4; inline;
begin
  getDAY10 := (pTDefRegMap(@Self)^.val and $0000F000) shr 12;
end;
procedure TRTCC_RTCDATE.setMONTH01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TRTCC_RTCDATE.getMONTH01 : TBits_4; inline;
begin
  getMONTH01 := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TRTCC_RTCDATE.setMONTH10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF0FFFFF or ( thebits shl 20 );
end;
function  TRTCC_RTCDATE.getMONTH10 : TBits_4; inline;
begin
  getMONTH10 := (pTDefRegMap(@Self)^.val and $00F00000) shr 20;
end;
procedure TRTCC_RTCDATE.setYEAR01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F0FFFFFF or ( thebits shl 24 );
end;
function  TRTCC_RTCDATE.getYEAR01 : TBits_4; inline;
begin
  getYEAR01 := (pTDefRegMap(@Self)^.val and $0F000000) shr 24;
end;
procedure TRTCC_RTCDATE.setYEAR10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $0FFFFFFF or ( thebits shl 28 );
end;
function  TRTCC_RTCDATE.getYEAR10 : TBits_4; inline;
begin
  getYEAR10 := (pTDefRegMap(@Self)^.val and $F0000000) shr 28;
end;
procedure TRTCC_RTCDATE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_RTCDATE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_ALRMTIME.setSEC01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_ALRMTIME.getSEC01 : TBits_4; inline;
begin
  getSEC01 := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_ALRMTIME.setSEC10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0FFF or ( thebits shl 12 );
end;
function  TRTCC_ALRMTIME.getSEC10 : TBits_4; inline;
begin
  getSEC10 := (pTDefRegMap(@Self)^.val and $0000F000) shr 12;
end;
procedure TRTCC_ALRMTIME.setMIN01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TRTCC_ALRMTIME.getMIN01 : TBits_4; inline;
begin
  getMIN01 := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TRTCC_ALRMTIME.setMIN10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF0FFFFF or ( thebits shl 20 );
end;
function  TRTCC_ALRMTIME.getMIN10 : TBits_4; inline;
begin
  getMIN10 := (pTDefRegMap(@Self)^.val and $00F00000) shr 20;
end;
procedure TRTCC_ALRMTIME.setHR01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F0FFFFFF or ( thebits shl 24 );
end;
function  TRTCC_ALRMTIME.getHR01 : TBits_4; inline;
begin
  getHR01 := (pTDefRegMap(@Self)^.val and $0F000000) shr 24;
end;
procedure TRTCC_ALRMTIME.setHR10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $0FFFFFFF or ( thebits shl 28 );
end;
function  TRTCC_ALRMTIME.getHR10 : TBits_4; inline;
begin
  getHR10 := (pTDefRegMap(@Self)^.val and $F0000000) shr 28;
end;
procedure TRTCC_ALRMTIME.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_ALRMTIME.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_ALRMDATE.setWDAY01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TRTCC_ALRMDATE.getWDAY01 : TBits_4; inline;
begin
  getWDAY01 := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TRTCC_ALRMDATE.setDAY01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_ALRMDATE.getDAY01 : TBits_4; inline;
begin
  getDAY01 := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_ALRMDATE.setDAY10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0FFF or ( thebits shl 12 );
end;
function  TRTCC_ALRMDATE.getDAY10 : TBits_4; inline;
begin
  getDAY10 := (pTDefRegMap(@Self)^.val and $0000F000) shr 12;
end;
procedure TRTCC_ALRMDATE.setMONTH01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TRTCC_ALRMDATE.getMONTH01 : TBits_4; inline;
begin
  getMONTH01 := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TRTCC_ALRMDATE.setMONTH10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF0FFFFF or ( thebits shl 20 );
end;
function  TRTCC_ALRMDATE.getMONTH10 : TBits_4; inline;
begin
  getMONTH10 := (pTDefRegMap(@Self)^.val and $00F00000) shr 20;
end;
procedure TRTCC_ALRMDATE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_ALRMDATE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR1_T1CON.setTCS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TTMR1_T1CON.clearTCS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TTMR1_T1CON.setTCS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TTMR1_T1CON.getTCS : TBits_1; inline;
begin
  getTCS := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TTMR1_T1CON.setTSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TTMR1_T1CON.clearTSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TTMR1_T1CON.setTSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TTMR1_T1CON.getTSYNC : TBits_1; inline;
begin
  getTSYNC := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TTMR1_T1CON.setTCKPS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFCF or ( thebits shl 4 );
end;
function  TTMR1_T1CON.getTCKPS : TBits_2; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000030) shr 4;
end;
procedure TTMR1_T1CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR1_T1CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR1_T1CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR1_T1CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR1_T1CON.setTWIP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TTMR1_T1CON.clearTWIP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TTMR1_T1CON.setTWIP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TTMR1_T1CON.getTWIP : TBits_1; inline;
begin
  getTWIP := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TTMR1_T1CON.setTWDIS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TTMR1_T1CON.clearTWDIS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TTMR1_T1CON.setTWDIS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TTMR1_T1CON.getTWDIS : TBits_1; inline;
begin
  getTWDIS := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TTMR1_T1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR1_T1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR1_T1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR1_T1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR1_T1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR1_T1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR1_T1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR1_T1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR1_T1CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR1_T1CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR1_T1CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR1_T1CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR1_T1CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR1_T1CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR1_T1CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR1_T1CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR1_T1CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR1_T1CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR1_T1CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR1_T1CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR1_T1CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR1_T1CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR1_T1CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR1_T1CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR1_T1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR1_T1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR2_T2CON.setTCS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TTMR2_T2CON.clearTCS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TTMR2_T2CON.setTCS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TTMR2_T2CON.getTCS : TBits_1; inline;
begin
  getTCS := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TTMR2_T2CON.setT32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TTMR2_T2CON.clearT32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TTMR2_T2CON.setT32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TTMR2_T2CON.getT32 : TBits_1; inline;
begin
  getT32 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TTMR2_T2CON.setTCKPS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TTMR2_T2CON.getTCKPS : TBits_3; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TTMR2_T2CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR2_T2CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR2_T2CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR2_T2CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR2_T2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR2_T2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR2_T2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR2_T2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR2_T2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR2_T2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR2_T2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR2_T2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR2_T2CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR2_T2CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR2_T2CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR2_T2CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR2_T2CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR2_T2CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR2_T2CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR2_T2CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR2_T2CON.setTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TTMR2_T2CON.clearTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TTMR2_T2CON.setTCKPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TTMR2_T2CON.getTCKPS2 : TBits_1; inline;
begin
  getTCKPS2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TTMR2_T2CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR2_T2CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR2_T2CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR2_T2CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR2_T2CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR2_T2CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR2_T2CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR2_T2CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR2_T2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR2_T2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR3_T3CON.setTCS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TTMR3_T3CON.clearTCS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TTMR3_T3CON.setTCS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TTMR3_T3CON.getTCS : TBits_1; inline;
begin
  getTCS := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TTMR3_T3CON.setT32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TTMR3_T3CON.clearT32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TTMR3_T3CON.setT32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TTMR3_T3CON.getT32 : TBits_1; inline;
begin
  getT32 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TTMR3_T3CON.setTCKPS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TTMR3_T3CON.getTCKPS : TBits_3; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TTMR3_T3CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR3_T3CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR3_T3CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR3_T3CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR3_T3CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR3_T3CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR3_T3CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR3_T3CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR3_T3CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR3_T3CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR3_T3CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR3_T3CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR3_T3CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR3_T3CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR3_T3CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR3_T3CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR3_T3CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR3_T3CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR3_T3CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR3_T3CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR3_T3CON.setTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TTMR3_T3CON.clearTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TTMR3_T3CON.setTCKPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TTMR3_T3CON.getTCKPS2 : TBits_1; inline;
begin
  getTCKPS2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TTMR3_T3CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR3_T3CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR3_T3CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR3_T3CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR3_T3CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR3_T3CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR3_T3CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR3_T3CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR3_T3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR3_T3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR4_T4CON.setTCS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TTMR4_T4CON.clearTCS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TTMR4_T4CON.setTCS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TTMR4_T4CON.getTCS : TBits_1; inline;
begin
  getTCS := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TTMR4_T4CON.setT32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TTMR4_T4CON.clearT32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TTMR4_T4CON.setT32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TTMR4_T4CON.getT32 : TBits_1; inline;
begin
  getT32 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TTMR4_T4CON.setTCKPS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TTMR4_T4CON.getTCKPS : TBits_3; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TTMR4_T4CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR4_T4CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR4_T4CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR4_T4CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR4_T4CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR4_T4CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR4_T4CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR4_T4CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR4_T4CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR4_T4CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR4_T4CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR4_T4CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR4_T4CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR4_T4CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR4_T4CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR4_T4CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR4_T4CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR4_T4CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR4_T4CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR4_T4CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR4_T4CON.setTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TTMR4_T4CON.clearTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TTMR4_T4CON.setTCKPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TTMR4_T4CON.getTCKPS2 : TBits_1; inline;
begin
  getTCKPS2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TTMR4_T4CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR4_T4CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR4_T4CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR4_T4CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR4_T4CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR4_T4CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR4_T4CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR4_T4CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR4_T4CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR4_T4CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR5_T5CON.setTCS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TTMR5_T5CON.clearTCS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TTMR5_T5CON.setTCS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TTMR5_T5CON.getTCS : TBits_1; inline;
begin
  getTCS := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TTMR5_T5CON.setT32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TTMR5_T5CON.clearT32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TTMR5_T5CON.setT32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TTMR5_T5CON.getT32 : TBits_1; inline;
begin
  getT32 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TTMR5_T5CON.setTCKPS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TTMR5_T5CON.getTCKPS : TBits_3; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TTMR5_T5CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR5_T5CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR5_T5CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR5_T5CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR5_T5CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR5_T5CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR5_T5CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR5_T5CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR5_T5CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR5_T5CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR5_T5CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR5_T5CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR5_T5CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR5_T5CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR5_T5CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR5_T5CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR5_T5CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR5_T5CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR5_T5CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR5_T5CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR5_T5CON.setTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TTMR5_T5CON.clearTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TTMR5_T5CON.setTCKPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TTMR5_T5CON.getTCKPS2 : TBits_1; inline;
begin
  getTCKPS2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TTMR5_T5CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR5_T5CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR5_T5CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR5_T5CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR5_T5CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR5_T5CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR5_T5CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR5_T5CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR5_T5CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR5_T5CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP1_IC1CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP1_IC1CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP1_IC1CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP1_IC1CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP1_IC1CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP1_IC1CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP1_IC1CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP1_IC1CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP1_IC1CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP1_IC1CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP1_IC1CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP1_IC1CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP1_IC1CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP1_IC1CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP1_IC1CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP1_IC1CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP1_IC1CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP1_IC1CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP1_IC1CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP1_IC1CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP1_IC1CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP1_IC1CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP1_IC1CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP1_IC1CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP1_IC1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP1_IC1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP1_IC1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP1_IC1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP1_IC1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP1_IC1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP1_IC1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP1_IC1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP1_IC1CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP1_IC1CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP1_IC1CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP1_IC1CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP1_IC1CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP1_IC1CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP1_IC1CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP1_IC1CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP1_IC1CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP1_IC1CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP1_IC1CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP1_IC1CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP1_IC1CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP1_IC1CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP1_IC1CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP1_IC1CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP1_IC1CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP1_IC1CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP1_IC1CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP1_IC1CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP1_IC1CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP1_IC1CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP1_IC1CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP1_IC1CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP1_IC1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP1_IC1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP2_IC2CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP2_IC2CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP2_IC2CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP2_IC2CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP2_IC2CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP2_IC2CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP2_IC2CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP2_IC2CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP2_IC2CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP2_IC2CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP2_IC2CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP2_IC2CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP2_IC2CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP2_IC2CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP2_IC2CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP2_IC2CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP2_IC2CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP2_IC2CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP2_IC2CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP2_IC2CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP2_IC2CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP2_IC2CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP2_IC2CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP2_IC2CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP2_IC2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP2_IC2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP2_IC2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP2_IC2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP2_IC2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP2_IC2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP2_IC2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP2_IC2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP2_IC2CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP2_IC2CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP2_IC2CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP2_IC2CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP2_IC2CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP2_IC2CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP2_IC2CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP2_IC2CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP2_IC2CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP2_IC2CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP2_IC2CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP2_IC2CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP2_IC2CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP2_IC2CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP2_IC2CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP2_IC2CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP2_IC2CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP2_IC2CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP2_IC2CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP2_IC2CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP2_IC2CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP2_IC2CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP2_IC2CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP2_IC2CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP2_IC2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP2_IC2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP3_IC3CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP3_IC3CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP3_IC3CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP3_IC3CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP3_IC3CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP3_IC3CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP3_IC3CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP3_IC3CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP3_IC3CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP3_IC3CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP3_IC3CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP3_IC3CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP3_IC3CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP3_IC3CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP3_IC3CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP3_IC3CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP3_IC3CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP3_IC3CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP3_IC3CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP3_IC3CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP3_IC3CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP3_IC3CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP3_IC3CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP3_IC3CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP3_IC3CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP3_IC3CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP3_IC3CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP3_IC3CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP3_IC3CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP3_IC3CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP3_IC3CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP3_IC3CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP3_IC3CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP3_IC3CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP3_IC3CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP3_IC3CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP3_IC3CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP3_IC3CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP3_IC3CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP3_IC3CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP3_IC3CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP3_IC3CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP3_IC3CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP3_IC3CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP3_IC3CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP3_IC3CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP3_IC3CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP3_IC3CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP3_IC3CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP3_IC3CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP3_IC3CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP3_IC3CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP3_IC3CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP3_IC3CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP3_IC3CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP3_IC3CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP3_IC3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP3_IC3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP4_IC4CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP4_IC4CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP4_IC4CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP4_IC4CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP4_IC4CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP4_IC4CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP4_IC4CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP4_IC4CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP4_IC4CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP4_IC4CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP4_IC4CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP4_IC4CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP4_IC4CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP4_IC4CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP4_IC4CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP4_IC4CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP4_IC4CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP4_IC4CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP4_IC4CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP4_IC4CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP4_IC4CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP4_IC4CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP4_IC4CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP4_IC4CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP4_IC4CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP4_IC4CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP4_IC4CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP4_IC4CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP4_IC4CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP4_IC4CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP4_IC4CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP4_IC4CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP4_IC4CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP4_IC4CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP4_IC4CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP4_IC4CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP4_IC4CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP4_IC4CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP4_IC4CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP4_IC4CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP4_IC4CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP4_IC4CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP4_IC4CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP4_IC4CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP4_IC4CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP4_IC4CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP4_IC4CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP4_IC4CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP4_IC4CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP4_IC4CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP4_IC4CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP4_IC4CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP4_IC4CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP4_IC4CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP4_IC4CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP4_IC4CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP4_IC4CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP4_IC4CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP5_IC5CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP5_IC5CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP5_IC5CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP5_IC5CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP5_IC5CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP5_IC5CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP5_IC5CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP5_IC5CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP5_IC5CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP5_IC5CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP5_IC5CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP5_IC5CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP5_IC5CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP5_IC5CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP5_IC5CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP5_IC5CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP5_IC5CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP5_IC5CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP5_IC5CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP5_IC5CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP5_IC5CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP5_IC5CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP5_IC5CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP5_IC5CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP5_IC5CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP5_IC5CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP5_IC5CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP5_IC5CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP5_IC5CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP5_IC5CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP5_IC5CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP5_IC5CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP5_IC5CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP5_IC5CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP5_IC5CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP5_IC5CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP5_IC5CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP5_IC5CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP5_IC5CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP5_IC5CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP5_IC5CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP5_IC5CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP5_IC5CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP5_IC5CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP5_IC5CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP5_IC5CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP5_IC5CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP5_IC5CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP5_IC5CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP5_IC5CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP5_IC5CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP5_IC5CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP5_IC5CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP5_IC5CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP5_IC5CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP5_IC5CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP5_IC5CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP5_IC5CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP1_OC1CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP1_OC1CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP1_OC1CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP1_OC1CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP1_OC1CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP1_OC1CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP1_OC1CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP1_OC1CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP1_OC1CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP1_OC1CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP1_OC1CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP1_OC1CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP1_OC1CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP1_OC1CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP1_OC1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP1_OC1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP1_OC1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP1_OC1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP1_OC1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP1_OC1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP1_OC1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP1_OC1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP1_OC1CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP1_OC1CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP1_OC1CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP1_OC1CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP1_OC1CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP1_OC1CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP1_OC1CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP1_OC1CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP1_OC1CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP1_OC1CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP1_OC1CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP1_OC1CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP1_OC1CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP1_OC1CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP1_OC1CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP1_OC1CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP1_OC1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP1_OC1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP2_OC2CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP2_OC2CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP2_OC2CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP2_OC2CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP2_OC2CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP2_OC2CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP2_OC2CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP2_OC2CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP2_OC2CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP2_OC2CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP2_OC2CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP2_OC2CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP2_OC2CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP2_OC2CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP2_OC2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP2_OC2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP2_OC2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP2_OC2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP2_OC2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP2_OC2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP2_OC2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP2_OC2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP2_OC2CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP2_OC2CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP2_OC2CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP2_OC2CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP2_OC2CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP2_OC2CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP2_OC2CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP2_OC2CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP2_OC2CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP2_OC2CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP2_OC2CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP2_OC2CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP2_OC2CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP2_OC2CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP2_OC2CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP2_OC2CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP2_OC2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP2_OC2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP3_OC3CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP3_OC3CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP3_OC3CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP3_OC3CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP3_OC3CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP3_OC3CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP3_OC3CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP3_OC3CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP3_OC3CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP3_OC3CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP3_OC3CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP3_OC3CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP3_OC3CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP3_OC3CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP3_OC3CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP3_OC3CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP3_OC3CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP3_OC3CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP3_OC3CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP3_OC3CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP3_OC3CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP3_OC3CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP3_OC3CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP3_OC3CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP3_OC3CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP3_OC3CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP3_OC3CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP3_OC3CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP3_OC3CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP3_OC3CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP3_OC3CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP3_OC3CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP3_OC3CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP3_OC3CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP3_OC3CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP3_OC3CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP3_OC3CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP3_OC3CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP3_OC3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP3_OC3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP4_OC4CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP4_OC4CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP4_OC4CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP4_OC4CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP4_OC4CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP4_OC4CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP4_OC4CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP4_OC4CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP4_OC4CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP4_OC4CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP4_OC4CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP4_OC4CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP4_OC4CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP4_OC4CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP4_OC4CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP4_OC4CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP4_OC4CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP4_OC4CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP4_OC4CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP4_OC4CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP4_OC4CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP4_OC4CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP4_OC4CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP4_OC4CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP4_OC4CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP4_OC4CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP4_OC4CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP4_OC4CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP4_OC4CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP4_OC4CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP4_OC4CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP4_OC4CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP4_OC4CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP4_OC4CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP4_OC4CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP4_OC4CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP4_OC4CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP4_OC4CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP4_OC4CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP4_OC4CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP5_OC5CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP5_OC5CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP5_OC5CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP5_OC5CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP5_OC5CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP5_OC5CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP5_OC5CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP5_OC5CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP5_OC5CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP5_OC5CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP5_OC5CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP5_OC5CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP5_OC5CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP5_OC5CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP5_OC5CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP5_OC5CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP5_OC5CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP5_OC5CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP5_OC5CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP5_OC5CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP5_OC5CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP5_OC5CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP5_OC5CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP5_OC5CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP5_OC5CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP5_OC5CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP5_OC5CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP5_OC5CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP5_OC5CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP5_OC5CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP5_OC5CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP5_OC5CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP5_OC5CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP5_OC5CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP5_OC5CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP5_OC5CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP5_OC5CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP5_OC5CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP5_OC5CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP5_OC5CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1_I2C1111CON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1_I2C1111CON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1_I2C1111CON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1_I2C1111CON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1_I2C1111CON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1_I2C1111CON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1_I2C1111CON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1_I2C1111CON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1_I2C1111CON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1_I2C1111CON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1_I2C1111CON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1_I2C1111CON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1_I2C1111CON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1_I2C1111CON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1_I2C1111CON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1_I2C1111CON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1_I2C1111CON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1_I2C1111CON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1_I2C1111CON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1_I2C1111CON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1_I2C1111CON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1_I2C1111CON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1_I2C1111CON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1_I2C1111CON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1_I2C1111CON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1111CON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1111CON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1111CON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1111CON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1_I2C1111CON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1_I2C1111CON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1_I2C1111CON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1_I2C1111CON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1_I2C1111CON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1_I2C1111CON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1_I2C1111CON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1_I2C1111CON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1_I2C1111CON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1_I2C1111CON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1_I2C1111CON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1_I2C1111CON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1_I2C1111CON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1_I2C1111CON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1_I2C1111CON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1_I2C1111CON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1_I2C1111CON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1_I2C1111CON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1_I2C1111CON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1_I2C1111CON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C1_I2C1111CON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C1_I2C1111CON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C1_I2C1111CON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C1_I2C1111CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1_I2C1111CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1_I2C1111CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1_I2C1111CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1_I2C1111CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1111CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1111CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1111CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1111CON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1_I2C1111CON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1_I2C1111CON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1_I2C1111CON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1_I2C1111CON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1_I2C1111CON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1_I2C1111CON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1_I2C1111CON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1_I2C1111CON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1111CON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1111CON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1111CON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1111CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1_I2C1111CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1_I2C1CON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1_I2C1CON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1_I2C1CON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1_I2C1CON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1_I2C1CON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1_I2C1CON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1_I2C1CON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1_I2C1CON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1_I2C1CON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1_I2C1CON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1_I2C1CON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1_I2C1CON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1_I2C1CON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1_I2C1CON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1_I2C1CON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1_I2C1CON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1_I2C1CON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1_I2C1CON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1_I2C1CON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1_I2C1CON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1_I2C1CON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1_I2C1CON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1_I2C1CON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1_I2C1CON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1_I2C1CON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1CON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1CON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1CON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1CON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1_I2C1CON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1_I2C1CON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1_I2C1CON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1_I2C1CON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1_I2C1CON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1_I2C1CON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1_I2C1CON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1_I2C1CON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1_I2C1CON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1_I2C1CON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1_I2C1CON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1_I2C1CON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1_I2C1CON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1_I2C1CON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1_I2C1CON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1_I2C1CON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1_I2C1CON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1_I2C1CON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1_I2C1CON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1_I2C1CON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C1_I2C1CON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C1_I2C1CON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C1_I2C1CON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C1_I2C1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1_I2C1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1_I2C1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1_I2C1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1_I2C1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1CON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1_I2C1CON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1_I2C1CON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1_I2C1CON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1_I2C1CON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1_I2C1CON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1_I2C1CON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1_I2C1CON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1_I2C1CON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1CON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1CON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1CON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1_I2C1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1_I2C1111STAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1_I2C1111STAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1_I2C1111STAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1_I2C1111STAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1_I2C1111STAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1_I2C1111STAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1_I2C1111STAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1_I2C1111STAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1_I2C1111STAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1_I2C1111STAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1_I2C1111STAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1_I2C1111STAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1_I2C1111STAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1_I2C1111STAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1_I2C1111STAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1_I2C1111STAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1_I2C1111STAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1_I2C1111STAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1_I2C1111STAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1_I2C1111STAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1_I2C1111STAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1_I2C1111STAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1_I2C1111STAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1_I2C1111STAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1_I2C1111STAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1111STAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1111STAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1111STAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1111STAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1_I2C1111STAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1_I2C1111STAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1_I2C1111STAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1_I2C1111STAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1_I2C1111STAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1_I2C1111STAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1_I2C1111STAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1_I2C1111STAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1_I2C1111STAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1_I2C1111STAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1_I2C1111STAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1_I2C1111STAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1_I2C1111STAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1_I2C1111STAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1_I2C1111STAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1_I2C1111STAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C1_I2C1111STAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C1_I2C1111STAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C1_I2C1111STAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C1_I2C1111STAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1111STAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1111STAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1111STAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1111STAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1111STAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1111STAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1111STAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1111STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1_I2C1111STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1_I2C1STAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1_I2C1STAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1_I2C1STAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1_I2C1STAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1_I2C1STAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1_I2C1STAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1_I2C1STAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1_I2C1STAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1_I2C1STAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1_I2C1STAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1_I2C1STAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1_I2C1STAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1_I2C1STAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1_I2C1STAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1_I2C1STAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1_I2C1STAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1_I2C1STAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1_I2C1STAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1_I2C1STAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1_I2C1STAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1_I2C1STAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1_I2C1STAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1_I2C1STAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1_I2C1STAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1_I2C1STAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1STAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1STAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1STAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1STAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1_I2C1STAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1_I2C1STAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1_I2C1STAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1_I2C1STAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1_I2C1STAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1_I2C1STAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1_I2C1STAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1_I2C1STAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1_I2C1STAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1_I2C1STAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1_I2C1STAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1_I2C1STAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1_I2C1STAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1_I2C1STAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1_I2C1STAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1_I2C1STAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C1_I2C1STAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C1_I2C1STAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C1_I2C1STAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C1_I2C1STAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1STAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1STAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1STAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1STAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1STAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1STAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1STAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1_I2C1STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C2_I2C2CON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C2_I2C2CON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C2_I2C2CON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C2_I2C2CON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C2_I2C2CON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C2_I2C2CON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C2_I2C2CON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C2_I2C2CON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C2_I2C2CON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C2_I2C2CON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C2_I2C2CON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C2_I2C2CON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C2_I2C2CON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C2_I2C2CON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C2_I2C2CON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C2_I2C2CON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C2_I2C2CON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C2_I2C2CON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C2_I2C2CON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C2_I2C2CON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C2_I2C2CON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C2_I2C2CON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C2_I2C2CON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C2_I2C2CON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C2_I2C2CON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2_I2C2CON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2_I2C2CON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2_I2C2CON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2_I2C2CON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C2_I2C2CON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C2_I2C2CON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C2_I2C2CON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C2_I2C2CON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C2_I2C2CON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C2_I2C2CON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C2_I2C2CON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C2_I2C2CON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C2_I2C2CON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C2_I2C2CON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C2_I2C2CON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C2_I2C2CON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C2_I2C2CON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C2_I2C2CON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C2_I2C2CON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C2_I2C2CON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C2_I2C2CON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C2_I2C2CON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C2_I2C2CON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C2_I2C2CON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C2_I2C2CON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C2_I2C2CON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C2_I2C2CON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C2_I2C2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C2_I2C2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C2_I2C2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C2_I2C2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C2_I2C2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2_I2C2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2_I2C2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2_I2C2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2_I2C2CON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C2_I2C2CON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C2_I2C2CON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C2_I2C2CON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C2_I2C2CON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C2_I2C2CON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C2_I2C2CON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C2_I2C2CON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C2_I2C2CON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2_I2C2CON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2_I2C2CON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2_I2C2CON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2_I2C2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C2_I2C2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C2_I2CABCON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C2_I2CABCON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C2_I2CABCON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C2_I2CABCON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C2_I2CABCON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C2_I2CABCON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C2_I2CABCON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C2_I2CABCON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C2_I2CABCON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C2_I2CABCON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C2_I2CABCON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C2_I2CABCON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C2_I2CABCON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C2_I2CABCON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C2_I2CABCON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C2_I2CABCON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C2_I2CABCON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C2_I2CABCON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C2_I2CABCON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C2_I2CABCON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C2_I2CABCON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C2_I2CABCON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C2_I2CABCON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C2_I2CABCON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C2_I2CABCON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2_I2CABCON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2_I2CABCON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2_I2CABCON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2_I2CABCON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C2_I2CABCON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C2_I2CABCON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C2_I2CABCON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C2_I2CABCON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C2_I2CABCON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C2_I2CABCON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C2_I2CABCON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C2_I2CABCON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C2_I2CABCON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C2_I2CABCON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C2_I2CABCON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C2_I2CABCON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C2_I2CABCON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C2_I2CABCON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C2_I2CABCON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C2_I2CABCON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C2_I2CABCON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C2_I2CABCON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C2_I2CABCON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C2_I2CABCON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C2_I2CABCON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C2_I2CABCON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C2_I2CABCON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C2_I2CABCON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C2_I2CABCON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C2_I2CABCON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C2_I2CABCON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C2_I2CABCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2_I2CABCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2_I2CABCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2_I2CABCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2_I2CABCON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C2_I2CABCON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C2_I2CABCON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C2_I2CABCON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C2_I2CABCON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C2_I2CABCON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C2_I2CABCON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C2_I2CABCON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C2_I2CABCON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2_I2CABCON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2_I2CABCON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2_I2CABCON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2_I2CABCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C2_I2CABCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C2_I2C2STAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C2_I2C2STAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C2_I2C2STAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C2_I2C2STAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C2_I2C2STAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C2_I2C2STAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C2_I2C2STAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C2_I2C2STAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C2_I2C2STAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C2_I2C2STAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C2_I2C2STAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C2_I2C2STAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C2_I2C2STAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C2_I2C2STAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C2_I2C2STAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C2_I2C2STAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C2_I2C2STAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C2_I2C2STAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C2_I2C2STAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C2_I2C2STAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C2_I2C2STAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C2_I2C2STAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C2_I2C2STAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C2_I2C2STAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C2_I2C2STAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2_I2C2STAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2_I2C2STAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2_I2C2STAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2_I2C2STAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C2_I2C2STAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C2_I2C2STAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C2_I2C2STAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C2_I2C2STAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C2_I2C2STAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C2_I2C2STAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C2_I2C2STAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C2_I2C2STAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C2_I2C2STAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C2_I2C2STAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C2_I2C2STAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C2_I2C2STAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C2_I2C2STAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C2_I2C2STAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C2_I2C2STAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C2_I2C2STAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C2_I2C2STAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C2_I2C2STAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C2_I2C2STAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C2_I2C2STAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2_I2C2STAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2_I2C2STAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2_I2C2STAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2_I2C2STAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2_I2C2STAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2_I2C2STAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2_I2C2STAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2_I2C2STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C2_I2C2STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C2_I2CABSTAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C2_I2CABSTAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C2_I2CABSTAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C2_I2CABSTAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C2_I2CABSTAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C2_I2CABSTAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C2_I2CABSTAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C2_I2CABSTAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C2_I2CABSTAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C2_I2CABSTAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C2_I2CABSTAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C2_I2CABSTAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C2_I2CABSTAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C2_I2CABSTAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C2_I2CABSTAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C2_I2CABSTAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C2_I2CABSTAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C2_I2CABSTAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C2_I2CABSTAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C2_I2CABSTAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C2_I2CABSTAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C2_I2CABSTAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C2_I2CABSTAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C2_I2CABSTAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C2_I2CABSTAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2_I2CABSTAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2_I2CABSTAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2_I2CABSTAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2_I2CABSTAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C2_I2CABSTAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C2_I2CABSTAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C2_I2CABSTAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C2_I2CABSTAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C2_I2CABSTAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C2_I2CABSTAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C2_I2CABSTAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C2_I2CABSTAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C2_I2CABSTAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C2_I2CABSTAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C2_I2CABSTAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C2_I2CABSTAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C2_I2CABSTAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C2_I2CABSTAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C2_I2CABSTAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C2_I2CABSTAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C2_I2CABSTAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C2_I2CABSTAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C2_I2CABSTAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C2_I2CABSTAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2_I2CABSTAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2_I2CABSTAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2_I2CABSTAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2_I2CABSTAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2_I2CABSTAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2_I2CABSTAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2_I2CABSTAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2_I2CABSTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C2_I2CABSTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI1_SPI1CON.setSRXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI1_SPI1CON.getSRXISEL : TBits_2; inline;
begin
  getSRXISEL := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI1_SPI1CON.setSTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF3 or ( thebits shl 2 );
end;
function  TSPI1_SPI1CON.getSTXISEL : TBits_2; inline;
begin
  getSTXISEL := (pTDefRegMap(@Self)^.val and $0000000C) shr 2;
end;
procedure TSPI1_SPI1CON.setDISSDI; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TSPI1_SPI1CON.clearDISSDI; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TSPI1_SPI1CON.setDISSDI(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TSPI1_SPI1CON.getDISSDI : TBits_1; inline;
begin
  getDISSDI := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TSPI1_SPI1CON.setMSTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI1_SPI1CON.clearMSTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI1_SPI1CON.setMSTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI1_SPI1CON.getMSTEN : TBits_1; inline;
begin
  getMSTEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI1_SPI1CON.setCKP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI1_SPI1CON.clearCKP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI1_SPI1CON.setCKP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI1_SPI1CON.getCKP : TBits_1; inline;
begin
  getCKP := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI1_SPI1CON.setSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI1_SPI1CON.clearSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI1_SPI1CON.setSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI1_SPI1CON.getSSEN : TBits_1; inline;
begin
  getSSEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI1_SPI1CON.setCKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI1_SPI1CON.clearCKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI1_SPI1CON.setCKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI1_SPI1CON.getCKE : TBits_1; inline;
begin
  getCKE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI1_SPI1CON.setSMP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI1_SPI1CON.clearSMP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI1_SPI1CON.setSMP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI1_SPI1CON.getSMP : TBits_1; inline;
begin
  getSMP := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI1_SPI1CON.setMODE16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI1_SPI1CON.clearMODE16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI1_SPI1CON.setMODE16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI1_SPI1CON.getMODE16 : TBits_1; inline;
begin
  getMODE16 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI1_SPI1CON.setMODE32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI1_SPI1CON.clearMODE32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI1_SPI1CON.setMODE32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI1_SPI1CON.getMODE32 : TBits_1; inline;
begin
  getMODE32 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI1_SPI1CON.setDISSDO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI1_SPI1CON.clearDISSDO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI1_SPI1CON.setDISSDO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI1_SPI1CON.getDISSDO : TBits_1; inline;
begin
  getDISSDO := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI1_SPI1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TSPI1_SPI1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TSPI1_SPI1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TSPI1_SPI1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TSPI1_SPI1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI1_SPI1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI1_SPI1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI1_SPI1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI1_SPI1CON.setENHBUF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TSPI1_SPI1CON.clearENHBUF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TSPI1_SPI1CON.setENHBUF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TSPI1_SPI1CON.getENHBUF : TBits_1; inline;
begin
  getENHBUF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TSPI1_SPI1CON.setSPIFE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TSPI1_SPI1CON.clearSPIFE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TSPI1_SPI1CON.setSPIFE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TSPI1_SPI1CON.getSPIFE : TBits_1; inline;
begin
  getSPIFE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TSPI1_SPI1CON.setMCLKSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TSPI1_SPI1CON.clearMCLKSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TSPI1_SPI1CON.setMCLKSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TSPI1_SPI1CON.getMCLKSEL : TBits_1; inline;
begin
  getMCLKSEL := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TSPI1_SPI1CON.setFRMCNT(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TSPI1_SPI1CON.getFRMCNT : TBits_3; inline;
begin
  getFRMCNT := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TSPI1_SPI1CON.setFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TSPI1_SPI1CON.clearFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TSPI1_SPI1CON.setFRMSYPW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TSPI1_SPI1CON.getFRMSYPW : TBits_1; inline;
begin
  getFRMSYPW := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TSPI1_SPI1CON.setMSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TSPI1_SPI1CON.clearMSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TSPI1_SPI1CON.setMSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TSPI1_SPI1CON.getMSSEN : TBits_1; inline;
begin
  getMSSEN := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TSPI1_SPI1CON.setFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TSPI1_SPI1CON.clearFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TSPI1_SPI1CON.setFRMPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TSPI1_SPI1CON.getFRMPOL : TBits_1; inline;
begin
  getFRMPOL := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TSPI1_SPI1CON.setFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TSPI1_SPI1CON.clearFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TSPI1_SPI1CON.setFRMSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TSPI1_SPI1CON.getFRMSYNC : TBits_1; inline;
begin
  getFRMSYNC := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TSPI1_SPI1CON.setFRMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TSPI1_SPI1CON.clearFRMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TSPI1_SPI1CON.setFRMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TSPI1_SPI1CON.getFRMEN : TBits_1; inline;
begin
  getFRMEN := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TSPI1_SPI1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI1_SPI1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI1_SPI1STAT.setSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI1_SPI1STAT.clearSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI1_SPI1STAT.setSPIRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI1_SPI1STAT.getSPIRBF : TBits_1; inline;
begin
  getSPIRBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI1_SPI1STAT.setSPITBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI1_SPI1STAT.clearSPITBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI1_SPI1STAT.setSPITBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI1_SPI1STAT.getSPITBF : TBits_1; inline;
begin
  getSPITBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI1_SPI1STAT.setSPITBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI1_SPI1STAT.clearSPITBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI1_SPI1STAT.setSPITBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI1_SPI1STAT.getSPITBE : TBits_1; inline;
begin
  getSPITBE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI1_SPI1STAT.setSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI1_SPI1STAT.clearSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI1_SPI1STAT.setSPIRBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI1_SPI1STAT.getSPIRBE : TBits_1; inline;
begin
  getSPIRBE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI1_SPI1STAT.setSPIROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI1_SPI1STAT.clearSPIROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI1_SPI1STAT.setSPIROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI1_SPI1STAT.getSPIROV : TBits_1; inline;
begin
  getSPIROV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI1_SPI1STAT.setSRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI1_SPI1STAT.clearSRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI1_SPI1STAT.setSRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI1_SPI1STAT.getSRMT : TBits_1; inline;
begin
  getSRMT := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI1_SPI1STAT.setSPITUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI1_SPI1STAT.clearSPITUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI1_SPI1STAT.setSPITUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI1_SPI1STAT.getSPITUR : TBits_1; inline;
begin
  getSPITUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI1_SPI1STAT.setSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI1_SPI1STAT.clearSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI1_SPI1STAT.setSPIBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI1_SPI1STAT.getSPIBUSY : TBits_1; inline;
begin
  getSPIBUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI1_SPI1STAT.setFRMERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI1_SPI1STAT.clearFRMERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI1_SPI1STAT.setFRMERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI1_SPI1STAT.getFRMERR : TBits_1; inline;
begin
  getFRMERR := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI1_SPI1STAT.setTXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TSPI1_SPI1STAT.getTXBUFELM : TBits_5; inline;
begin
  getTXBUFELM := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TSPI1_SPI1STAT.setRXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TSPI1_SPI1STAT.getRXBUFELM : TBits_5; inline;
begin
  getRXBUFELM := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TSPI1_SPI1STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI1_SPI1STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI1_SPI1CON2.setAUDMOD(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI1_SPI1CON2.getAUDMOD : TBits_2; inline;
begin
  getAUDMOD := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI1_SPI1CON2.setAUDMONO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI1_SPI1CON2.clearAUDMONO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI1_SPI1CON2.setAUDMONO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI1_SPI1CON2.getAUDMONO : TBits_1; inline;
begin
  getAUDMONO := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI1_SPI1CON2.setAUDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI1_SPI1CON2.clearAUDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI1_SPI1CON2.setAUDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI1_SPI1CON2.getAUDEN : TBits_1; inline;
begin
  getAUDEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI1_SPI1CON2.setIGNTUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI1_SPI1CON2.clearIGNTUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI1_SPI1CON2.setIGNTUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI1_SPI1CON2.getIGNTUR : TBits_1; inline;
begin
  getIGNTUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI1_SPI1CON2.setIGNROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI1_SPI1CON2.clearIGNROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI1_SPI1CON2.setIGNROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI1_SPI1CON2.getIGNROV : TBits_1; inline;
begin
  getIGNROV := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI1_SPI1CON2.setSPITUREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI1_SPI1CON2.clearSPITUREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI1_SPI1CON2.setSPITUREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI1_SPI1CON2.getSPITUREN : TBits_1; inline;
begin
  getSPITUREN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI1_SPI1CON2.setSPIROVEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI1_SPI1CON2.clearSPIROVEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI1_SPI1CON2.setSPIROVEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI1_SPI1CON2.getSPIROVEN : TBits_1; inline;
begin
  getSPIROVEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI1_SPI1CON2.setFRMERREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI1_SPI1CON2.clearFRMERREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI1_SPI1CON2.setFRMERREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI1_SPI1CON2.getFRMERREN : TBits_1; inline;
begin
  getFRMERREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI1_SPI1CON2.setSPISGNEXT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI1_SPI1CON2.clearSPISGNEXT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI1_SPI1CON2.setSPISGNEXT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI1_SPI1CON2.getSPISGNEXT : TBits_1; inline;
begin
  getSPISGNEXT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI1_SPI1CON2.setAUDMOD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI1_SPI1CON2.clearAUDMOD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI1_SPI1CON2.setAUDMOD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI1_SPI1CON2.getAUDMOD0 : TBits_1; inline;
begin
  getAUDMOD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI1_SPI1CON2.setAUDMOD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI1_SPI1CON2.clearAUDMOD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI1_SPI1CON2.setAUDMOD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI1_SPI1CON2.getAUDMOD1 : TBits_1; inline;
begin
  getAUDMOD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI1_SPI1CON2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI1_SPI1CON2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI2_SPI2CON.setSRXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI2_SPI2CON.getSRXISEL : TBits_2; inline;
begin
  getSRXISEL := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI2_SPI2CON.setSTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF3 or ( thebits shl 2 );
end;
function  TSPI2_SPI2CON.getSTXISEL : TBits_2; inline;
begin
  getSTXISEL := (pTDefRegMap(@Self)^.val and $0000000C) shr 2;
end;
procedure TSPI2_SPI2CON.setDISSDI; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TSPI2_SPI2CON.clearDISSDI; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TSPI2_SPI2CON.setDISSDI(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TSPI2_SPI2CON.getDISSDI : TBits_1; inline;
begin
  getDISSDI := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TSPI2_SPI2CON.setMSTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI2_SPI2CON.clearMSTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI2_SPI2CON.setMSTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI2_SPI2CON.getMSTEN : TBits_1; inline;
begin
  getMSTEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI2_SPI2CON.setCKP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI2_SPI2CON.clearCKP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI2_SPI2CON.setCKP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI2_SPI2CON.getCKP : TBits_1; inline;
begin
  getCKP := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI2_SPI2CON.setSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI2_SPI2CON.clearSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI2_SPI2CON.setSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI2_SPI2CON.getSSEN : TBits_1; inline;
begin
  getSSEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI2_SPI2CON.setCKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI2_SPI2CON.clearCKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI2_SPI2CON.setCKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI2_SPI2CON.getCKE : TBits_1; inline;
begin
  getCKE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI2_SPI2CON.setSMP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI2_SPI2CON.clearSMP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI2_SPI2CON.setSMP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI2_SPI2CON.getSMP : TBits_1; inline;
begin
  getSMP := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI2_SPI2CON.setMODE16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI2_SPI2CON.clearMODE16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI2_SPI2CON.setMODE16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI2_SPI2CON.getMODE16 : TBits_1; inline;
begin
  getMODE16 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI2_SPI2CON.setMODE32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI2_SPI2CON.clearMODE32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI2_SPI2CON.setMODE32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI2_SPI2CON.getMODE32 : TBits_1; inline;
begin
  getMODE32 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI2_SPI2CON.setDISSDO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI2_SPI2CON.clearDISSDO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI2_SPI2CON.setDISSDO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI2_SPI2CON.getDISSDO : TBits_1; inline;
begin
  getDISSDO := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI2_SPI2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TSPI2_SPI2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TSPI2_SPI2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TSPI2_SPI2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TSPI2_SPI2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI2_SPI2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI2_SPI2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI2_SPI2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI2_SPI2CON.setENHBUF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TSPI2_SPI2CON.clearENHBUF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TSPI2_SPI2CON.setENHBUF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TSPI2_SPI2CON.getENHBUF : TBits_1; inline;
begin
  getENHBUF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TSPI2_SPI2CON.setSPIFE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TSPI2_SPI2CON.clearSPIFE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TSPI2_SPI2CON.setSPIFE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TSPI2_SPI2CON.getSPIFE : TBits_1; inline;
begin
  getSPIFE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TSPI2_SPI2CON.setMCLKSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TSPI2_SPI2CON.clearMCLKSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TSPI2_SPI2CON.setMCLKSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TSPI2_SPI2CON.getMCLKSEL : TBits_1; inline;
begin
  getMCLKSEL := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TSPI2_SPI2CON.setFRMCNT(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TSPI2_SPI2CON.getFRMCNT : TBits_3; inline;
begin
  getFRMCNT := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TSPI2_SPI2CON.setFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TSPI2_SPI2CON.clearFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TSPI2_SPI2CON.setFRMSYPW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TSPI2_SPI2CON.getFRMSYPW : TBits_1; inline;
begin
  getFRMSYPW := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TSPI2_SPI2CON.setMSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TSPI2_SPI2CON.clearMSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TSPI2_SPI2CON.setMSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TSPI2_SPI2CON.getMSSEN : TBits_1; inline;
begin
  getMSSEN := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TSPI2_SPI2CON.setFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TSPI2_SPI2CON.clearFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TSPI2_SPI2CON.setFRMPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TSPI2_SPI2CON.getFRMPOL : TBits_1; inline;
begin
  getFRMPOL := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TSPI2_SPI2CON.setFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TSPI2_SPI2CON.clearFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TSPI2_SPI2CON.setFRMSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TSPI2_SPI2CON.getFRMSYNC : TBits_1; inline;
begin
  getFRMSYNC := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TSPI2_SPI2CON.setFRMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TSPI2_SPI2CON.clearFRMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TSPI2_SPI2CON.setFRMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TSPI2_SPI2CON.getFRMEN : TBits_1; inline;
begin
  getFRMEN := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TSPI2_SPI2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI2_SPI2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI2_SPI2STAT.setSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI2_SPI2STAT.clearSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI2_SPI2STAT.setSPIRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI2_SPI2STAT.getSPIRBF : TBits_1; inline;
begin
  getSPIRBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI2_SPI2STAT.setSPITBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI2_SPI2STAT.clearSPITBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI2_SPI2STAT.setSPITBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI2_SPI2STAT.getSPITBF : TBits_1; inline;
begin
  getSPITBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI2_SPI2STAT.setSPITBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI2_SPI2STAT.clearSPITBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI2_SPI2STAT.setSPITBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI2_SPI2STAT.getSPITBE : TBits_1; inline;
begin
  getSPITBE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI2_SPI2STAT.setSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI2_SPI2STAT.clearSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI2_SPI2STAT.setSPIRBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI2_SPI2STAT.getSPIRBE : TBits_1; inline;
begin
  getSPIRBE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI2_SPI2STAT.setSPIROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI2_SPI2STAT.clearSPIROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI2_SPI2STAT.setSPIROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI2_SPI2STAT.getSPIROV : TBits_1; inline;
begin
  getSPIROV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI2_SPI2STAT.setSRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI2_SPI2STAT.clearSRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI2_SPI2STAT.setSRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI2_SPI2STAT.getSRMT : TBits_1; inline;
begin
  getSRMT := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI2_SPI2STAT.setSPITUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI2_SPI2STAT.clearSPITUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI2_SPI2STAT.setSPITUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI2_SPI2STAT.getSPITUR : TBits_1; inline;
begin
  getSPITUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI2_SPI2STAT.setSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI2_SPI2STAT.clearSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI2_SPI2STAT.setSPIBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI2_SPI2STAT.getSPIBUSY : TBits_1; inline;
begin
  getSPIBUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI2_SPI2STAT.setFRMERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI2_SPI2STAT.clearFRMERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI2_SPI2STAT.setFRMERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI2_SPI2STAT.getFRMERR : TBits_1; inline;
begin
  getFRMERR := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI2_SPI2STAT.setTXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TSPI2_SPI2STAT.getTXBUFELM : TBits_5; inline;
begin
  getTXBUFELM := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TSPI2_SPI2STAT.setRXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TSPI2_SPI2STAT.getRXBUFELM : TBits_5; inline;
begin
  getRXBUFELM := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TSPI2_SPI2STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI2_SPI2STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI2_SPI2CON2.setAUDMOD(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI2_SPI2CON2.getAUDMOD : TBits_2; inline;
begin
  getAUDMOD := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI2_SPI2CON2.setAUDMONO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI2_SPI2CON2.clearAUDMONO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI2_SPI2CON2.setAUDMONO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI2_SPI2CON2.getAUDMONO : TBits_1; inline;
begin
  getAUDMONO := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI2_SPI2CON2.setAUDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI2_SPI2CON2.clearAUDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI2_SPI2CON2.setAUDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI2_SPI2CON2.getAUDEN : TBits_1; inline;
begin
  getAUDEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI2_SPI2CON2.setIGNTUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI2_SPI2CON2.clearIGNTUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI2_SPI2CON2.setIGNTUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI2_SPI2CON2.getIGNTUR : TBits_1; inline;
begin
  getIGNTUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI2_SPI2CON2.setIGNROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI2_SPI2CON2.clearIGNROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI2_SPI2CON2.setIGNROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI2_SPI2CON2.getIGNROV : TBits_1; inline;
begin
  getIGNROV := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI2_SPI2CON2.setSPITUREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI2_SPI2CON2.clearSPITUREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI2_SPI2CON2.setSPITUREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI2_SPI2CON2.getSPITUREN : TBits_1; inline;
begin
  getSPITUREN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI2_SPI2CON2.setSPIROVEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI2_SPI2CON2.clearSPIROVEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI2_SPI2CON2.setSPIROVEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI2_SPI2CON2.getSPIROVEN : TBits_1; inline;
begin
  getSPIROVEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI2_SPI2CON2.setFRMERREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI2_SPI2CON2.clearFRMERREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI2_SPI2CON2.setFRMERREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI2_SPI2CON2.getFRMERREN : TBits_1; inline;
begin
  getFRMERREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI2_SPI2CON2.setSPISGNEXT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI2_SPI2CON2.clearSPISGNEXT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI2_SPI2CON2.setSPISGNEXT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI2_SPI2CON2.getSPISGNEXT : TBits_1; inline;
begin
  getSPISGNEXT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI2_SPI2CON2.setAUDMOD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI2_SPI2CON2.clearAUDMOD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI2_SPI2CON2.setAUDMOD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI2_SPI2CON2.getAUDMOD0 : TBits_1; inline;
begin
  getAUDMOD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI2_SPI2CON2.setAUDMOD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI2_SPI2CON2.clearAUDMOD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI2_SPI2CON2.setAUDMOD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI2_SPI2CON2.getAUDMOD1 : TBits_1; inline;
begin
  getAUDMOD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI2_SPI2CON2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI2_SPI2CON2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART1_U1MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART1_U1MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART1_U1MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART1_U1MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART1_U1MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART1_U1MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART1_U1MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART1_U1MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART1_U1MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART1_U1MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART1_U1MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART1_U1MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART1_U1MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART1_U1MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART1_U1MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART1_U1MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART1_U1MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART1_U1MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART1_U1MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART1_U1MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART1_U1MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART1_U1MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART1_U1MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART1_U1MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART1_U1MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART1_U1MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART1_U1MODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART1_U1MODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART1_U1MODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART1_U1MODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART1_U1MODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART1_U1MODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART1_U1MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART1_U1MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART1_U1MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART1_U1MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART1_U1MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1_U1MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1_U1MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1_U1MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1_U1MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1_U1MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1_U1MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1_U1MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1_U1MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART1_U1MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART1_U1MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART1_U1MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART1_U1MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART1_U1MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART1_U1MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART1_U1MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART1_U1MODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART1_U1MODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART1_U1MODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART1_U1MODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART1_U1MODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART1_U1MODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART1_U1MODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART1_U1MODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART1_U1MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1_U1MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1_U1MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1_U1MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1_U1MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1_U1MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1_U1MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1_U1MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1_U1MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART1_U1MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART1_UDCMODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART1_UDCMODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART1_UDCMODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART1_UDCMODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART1_UDCMODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART1_UDCMODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART1_UDCMODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART1_UDCMODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART1_UDCMODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART1_UDCMODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART1_UDCMODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART1_UDCMODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART1_UDCMODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART1_UDCMODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART1_UDCMODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART1_UDCMODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART1_UDCMODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART1_UDCMODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART1_UDCMODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART1_UDCMODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART1_UDCMODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART1_UDCMODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART1_UDCMODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART1_UDCMODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART1_UDCMODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART1_UDCMODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART1_UDCMODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART1_UDCMODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART1_UDCMODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART1_UDCMODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART1_UDCMODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART1_UDCMODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART1_UDCMODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART1_UDCMODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART1_UDCMODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART1_UDCMODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART1_UDCMODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1_UDCMODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1_UDCMODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1_UDCMODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1_UDCMODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1_UDCMODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1_UDCMODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1_UDCMODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1_UDCMODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART1_UDCMODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART1_UDCMODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART1_UDCMODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART1_UDCMODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART1_UDCMODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART1_UDCMODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART1_UDCMODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART1_UDCMODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART1_UDCMODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART1_UDCMODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART1_UDCMODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART1_UDCMODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART1_UDCMODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART1_UDCMODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART1_UDCMODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART1_UDCMODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1_UDCMODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1_UDCMODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1_UDCMODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1_UDCMODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1_UDCMODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1_UDCMODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1_UDCMODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1_UDCMODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART1_UDCMODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART1_U1STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART1_U1STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART1_U1STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART1_U1STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART1_U1STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART1_U1STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART1_U1STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART1_U1STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART1_U1STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART1_U1STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART1_U1STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART1_U1STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART1_U1STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART1_U1STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART1_U1STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART1_U1STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART1_U1STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART1_U1STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART1_U1STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART1_U1STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART1_U1STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART1_U1STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART1_U1STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART1_U1STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART1_U1STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART1_U1STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART1_U1STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART1_U1STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART1_U1STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART1_U1STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART1_U1STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART1_U1STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART1_U1STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART1_U1STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART1_U1STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART1_U1STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART1_U1STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART1_U1STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART1_U1STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART1_U1STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART1_U1STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART1_U1STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART1_U1STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART1_U1STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART1_U1STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART1_U1STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART1_U1STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1_U1STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1_U1STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1_U1STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1_U1STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART1_U1STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART1_U1STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART1_U1STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART1_U1STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART1_U1STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART1_U1STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART1_U1STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART1_U1STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART1_U1STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART1_U1STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART1_U1STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART1_U1STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART1_U1STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART1_U1STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART1_U1STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART1_U1STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART1_U1STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART1_U1STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART1_U1STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART1_U1STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1_U1STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1_U1STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1_U1STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1_U1STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART1_U1STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART1_U1STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART1_U1STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART1_UDCSTA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART1_UDCSTA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART1_UDCSTA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART1_UDCSTA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART1_UDCSTA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART1_UDCSTA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART1_UDCSTA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART1_UDCSTA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART1_UDCSTA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART1_UDCSTA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART1_UDCSTA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART1_UDCSTA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART1_UDCSTA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART1_UDCSTA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART1_UDCSTA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART1_UDCSTA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART1_UDCSTA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART1_UDCSTA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART1_UDCSTA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART1_UDCSTA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART1_UDCSTA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART1_UDCSTA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART1_UDCSTA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART1_UDCSTA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART1_UDCSTA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART1_UDCSTA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART1_UDCSTA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART1_UDCSTA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART1_UDCSTA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART1_UDCSTA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART1_UDCSTA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART1_UDCSTA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART1_UDCSTA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART1_UDCSTA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART1_UDCSTA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART1_UDCSTA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART1_UDCSTA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART1_UDCSTA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART1_UDCSTA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART1_UDCSTA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART1_UDCSTA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART1_UDCSTA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART1_UDCSTA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART1_UDCSTA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART1_UDCSTA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART1_UDCSTA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART1_UDCSTA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1_UDCSTA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1_UDCSTA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1_UDCSTA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1_UDCSTA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART1_UDCSTA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART1_UDCSTA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART1_UDCSTA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART1_UDCSTA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART1_UDCSTA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART1_UDCSTA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART1_UDCSTA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART1_UDCSTA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART1_UDCSTA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART1_UDCSTA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART1_UDCSTA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART1_UDCSTA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART1_UDCSTA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART1_UDCSTA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART1_UDCSTA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART1_UDCSTA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART1_UDCSTA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART1_UDCSTA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART1_UDCSTA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART1_UDCSTA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1_UDCSTA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1_UDCSTA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1_UDCSTA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1_UDCSTA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART1_UDCSTA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART1_UDCSTA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART1_UDCSTA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2_U2MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2_U2MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2_U2MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2_U2MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2_U2MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART2_U2MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART2_U2MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2_U2MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2_U2MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2_U2MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2_U2MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2_U2MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2_U2MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2_U2MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2_U2MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2_U2MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2_U2MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2_U2MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2_U2MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2_U2MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2_U2MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2_U2MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2_U2MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2_U2MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2_U2MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2_U2MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2_U2MODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART2_U2MODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART2_U2MODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2_U2MODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2_U2MODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2_U2MODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2_U2MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2_U2MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2_U2MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2_U2MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2_U2MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U2MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U2MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U2MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U2MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U2MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U2MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U2MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U2MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2_U2MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2_U2MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2_U2MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2_U2MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2_U2MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2_U2MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2_U2MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2_U2MODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2_U2MODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2_U2MODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2_U2MODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2_U2MODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2_U2MODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2_U2MODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2_U2MODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2_U2MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U2MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U2MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U2MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U2MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U2MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U2MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U2MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U2MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2_U2MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2_U8932MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2_U8932MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2_U8932MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2_U8932MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2_U8932MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART2_U8932MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART2_U8932MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2_U8932MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2_U8932MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2_U8932MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2_U8932MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2_U8932MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2_U8932MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2_U8932MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2_U8932MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2_U8932MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2_U8932MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2_U8932MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2_U8932MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2_U8932MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2_U8932MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2_U8932MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2_U8932MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2_U8932MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2_U8932MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2_U8932MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2_U8932MODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART2_U8932MODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART2_U8932MODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2_U8932MODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2_U8932MODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2_U8932MODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2_U8932MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2_U8932MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2_U8932MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2_U8932MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2_U8932MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U8932MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U8932MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U8932MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U8932MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U8932MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U8932MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U8932MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U8932MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2_U8932MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2_U8932MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2_U8932MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2_U8932MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2_U8932MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2_U8932MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2_U8932MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2_U8932MODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2_U8932MODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2_U8932MODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2_U8932MODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2_U8932MODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2_U8932MODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2_U8932MODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2_U8932MODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2_U8932MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U8932MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U8932MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U8932MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U8932MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U8932MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U8932MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U8932MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U8932MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2_U8932MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2_U2STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2_U2STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2_U2STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2_U2STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2_U2STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2_U2STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2_U2STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2_U2STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2_U2STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2_U2STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2_U2STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2_U2STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2_U2STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2_U2STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2_U2STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2_U2STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2_U2STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2_U2STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2_U2STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2_U2STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2_U2STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2_U2STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2_U2STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2_U2STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2_U2STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART2_U2STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART2_U2STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2_U2STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2_U2STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2_U2STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2_U2STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2_U2STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2_U2STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2_U2STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2_U2STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART2_U2STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART2_U2STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART2_U2STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART2_U2STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2_U2STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2_U2STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2_U2STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2_U2STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2_U2STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2_U2STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2_U2STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2_U2STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U2STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U2STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U2STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U2STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2_U2STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2_U2STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART2_U2STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART2_U2STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART2_U2STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART2_U2STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART2_U2STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART2_U2STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2_U2STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2_U2STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2_U2STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2_U2STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2_U2STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2_U2STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2_U2STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2_U2STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART2_U2STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART2_U2STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART2_U2STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART2_U2STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U2STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U2STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U2STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U2STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2_U2STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2_U2STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2_U2STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2_U8932STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2_U8932STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2_U8932STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2_U8932STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2_U8932STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2_U8932STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2_U8932STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2_U8932STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2_U8932STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2_U8932STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2_U8932STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2_U8932STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2_U8932STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2_U8932STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2_U8932STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2_U8932STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2_U8932STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2_U8932STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2_U8932STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2_U8932STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2_U8932STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2_U8932STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2_U8932STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2_U8932STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2_U8932STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART2_U8932STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART2_U8932STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2_U8932STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2_U8932STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2_U8932STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2_U8932STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2_U8932STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2_U8932STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2_U8932STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2_U8932STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART2_U8932STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART2_U8932STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART2_U8932STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART2_U8932STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2_U8932STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2_U8932STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2_U8932STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2_U8932STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2_U8932STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2_U8932STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2_U8932STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2_U8932STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U8932STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U8932STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U8932STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U8932STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2_U8932STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2_U8932STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART2_U8932STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART2_U8932STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART2_U8932STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART2_U8932STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART2_U8932STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART2_U8932STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2_U8932STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2_U8932STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2_U8932STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2_U8932STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2_U8932STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2_U8932STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2_U8932STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2_U8932STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART2_U8932STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART2_U8932STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART2_U8932STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART2_U8932STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U8932STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U8932STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U8932STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U8932STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2_U8932STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2_U8932STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2_U8932STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART3_U39MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART3_U39MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART3_U39MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART3_U39MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART3_U39MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART3_U39MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART3_U39MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART3_U39MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART3_U39MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART3_U39MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART3_U39MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART3_U39MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART3_U39MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART3_U39MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART3_U39MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART3_U39MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART3_U39MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART3_U39MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART3_U39MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART3_U39MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART3_U39MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART3_U39MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART3_U39MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART3_U39MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART3_U39MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART3_U39MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART3_U39MODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART3_U39MODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART3_U39MODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART3_U39MODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART3_U39MODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART3_U39MODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART3_U39MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART3_U39MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART3_U39MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART3_U39MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART3_U39MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART3_U39MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART3_U39MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART3_U39MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART3_U39MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART3_U39MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART3_U39MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART3_U39MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART3_U39MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART3_U39MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART3_U39MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART3_U39MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART3_U39MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART3_U39MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART3_U39MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART3_U39MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART3_U39MODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART3_U39MODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART3_U39MODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART3_U39MODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART3_U39MODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART3_U39MODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART3_U39MODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART3_U39MODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART3_U39MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART3_U39MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART3_U39MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART3_U39MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART3_U39MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART3_U39MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART3_U39MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART3_U39MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART3_U39MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART3_U39MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART3_U3MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART3_U3MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART3_U3MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART3_U3MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART3_U3MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART3_U3MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART3_U3MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART3_U3MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART3_U3MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART3_U3MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART3_U3MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART3_U3MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART3_U3MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART3_U3MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART3_U3MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART3_U3MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART3_U3MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART3_U3MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART3_U3MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART3_U3MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART3_U3MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART3_U3MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART3_U3MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART3_U3MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART3_U3MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART3_U3MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART3_U3MODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART3_U3MODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART3_U3MODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART3_U3MODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART3_U3MODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART3_U3MODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART3_U3MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART3_U3MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART3_U3MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART3_U3MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART3_U3MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART3_U3MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART3_U3MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART3_U3MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART3_U3MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART3_U3MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART3_U3MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART3_U3MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART3_U3MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART3_U3MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART3_U3MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART3_U3MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART3_U3MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART3_U3MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART3_U3MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART3_U3MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART3_U3MODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART3_U3MODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART3_U3MODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART3_U3MODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART3_U3MODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART3_U3MODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART3_U3MODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART3_U3MODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART3_U3MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART3_U3MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART3_U3MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART3_U3MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART3_U3MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART3_U3MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART3_U3MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART3_U3MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART3_U3MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART3_U3MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART3_U39STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART3_U39STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART3_U39STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART3_U39STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART3_U39STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART3_U39STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART3_U39STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART3_U39STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART3_U39STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART3_U39STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART3_U39STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART3_U39STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART3_U39STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART3_U39STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART3_U39STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART3_U39STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART3_U39STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART3_U39STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART3_U39STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART3_U39STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART3_U39STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART3_U39STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART3_U39STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART3_U39STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART3_U39STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART3_U39STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART3_U39STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART3_U39STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART3_U39STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART3_U39STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART3_U39STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART3_U39STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART3_U39STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART3_U39STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART3_U39STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART3_U39STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART3_U39STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART3_U39STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART3_U39STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART3_U39STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART3_U39STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART3_U39STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART3_U39STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART3_U39STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART3_U39STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART3_U39STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART3_U39STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART3_U39STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART3_U39STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART3_U39STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART3_U39STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART3_U39STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART3_U39STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART3_U39STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART3_U39STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART3_U39STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART3_U39STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART3_U39STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART3_U39STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART3_U39STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART3_U39STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART3_U39STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART3_U39STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART3_U39STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART3_U39STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART3_U39STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART3_U39STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART3_U39STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART3_U39STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART3_U39STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART3_U39STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART3_U39STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART3_U39STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART3_U39STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART3_U39STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART3_U39STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART3_U39STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART3_U39STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART3_U3STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART3_U3STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART3_U3STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART3_U3STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART3_U3STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART3_U3STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART3_U3STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART3_U3STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART3_U3STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART3_U3STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART3_U3STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART3_U3STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART3_U3STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART3_U3STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART3_U3STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART3_U3STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART3_U3STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART3_U3STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART3_U3STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART3_U3STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART3_U3STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART3_U3STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART3_U3STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART3_U3STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART3_U3STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART3_U3STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART3_U3STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART3_U3STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART3_U3STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART3_U3STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART3_U3STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART3_U3STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART3_U3STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART3_U3STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART3_U3STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART3_U3STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART3_U3STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART3_U3STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART3_U3STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART3_U3STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART3_U3STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART3_U3STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART3_U3STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART3_U3STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART3_U3STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART3_U3STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART3_U3STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART3_U3STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART3_U3STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART3_U3STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART3_U3STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART3_U3STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART3_U3STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART3_U3STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART3_U3STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART3_U3STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART3_U3STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART3_U3STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART3_U3STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART3_U3STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART3_U3STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART3_U3STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART3_U3STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART3_U3STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART3_U3STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART3_U3STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART3_U3STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART3_U3STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART3_U3STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART3_U3STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART3_U3STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART3_U3STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART3_U3STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART3_U3STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART3_U3STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART3_U3STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART3_U3STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART3_U3STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART4_U4MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART4_U4MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART4_U4MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART4_U4MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART4_U4MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART4_U4MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART4_U4MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART4_U4MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART4_U4MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART4_U4MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART4_U4MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART4_U4MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART4_U4MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART4_U4MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART4_U4MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART4_U4MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART4_U4MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART4_U4MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART4_U4MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART4_U4MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART4_U4MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART4_U4MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART4_U4MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART4_U4MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART4_U4MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART4_U4MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART4_U4MODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART4_U4MODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART4_U4MODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART4_U4MODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART4_U4MODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART4_U4MODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART4_U4MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART4_U4MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART4_U4MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART4_U4MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART4_U4MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART4_U4MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART4_U4MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART4_U4MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART4_U4MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART4_U4MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART4_U4MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART4_U4MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART4_U4MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART4_U4MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART4_U4MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART4_U4MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART4_U4MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART4_U4MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART4_U4MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART4_U4MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART4_U4MODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART4_U4MODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART4_U4MODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART4_U4MODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART4_U4MODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART4_U4MODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART4_U4MODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART4_U4MODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART4_U4MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART4_U4MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART4_U4MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART4_U4MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART4_U4MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART4_U4MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART4_U4MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART4_U4MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART4_U4MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART4_U4MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART4_UodMODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART4_UodMODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART4_UodMODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART4_UodMODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART4_UodMODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART4_UodMODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART4_UodMODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART4_UodMODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART4_UodMODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART4_UodMODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART4_UodMODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART4_UodMODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART4_UodMODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART4_UodMODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART4_UodMODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART4_UodMODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART4_UodMODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART4_UodMODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART4_UodMODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART4_UodMODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART4_UodMODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART4_UodMODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART4_UodMODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART4_UodMODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART4_UodMODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART4_UodMODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART4_UodMODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART4_UodMODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART4_UodMODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART4_UodMODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART4_UodMODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART4_UodMODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART4_UodMODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART4_UodMODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART4_UodMODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART4_UodMODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART4_UodMODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART4_UodMODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART4_UodMODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART4_UodMODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART4_UodMODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART4_UodMODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART4_UodMODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART4_UodMODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART4_UodMODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART4_UodMODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART4_UodMODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART4_UodMODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART4_UodMODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART4_UodMODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART4_UodMODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART4_UodMODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART4_UodMODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART4_UodMODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART4_UodMODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART4_UodMODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART4_UodMODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART4_UodMODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART4_UodMODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART4_UodMODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART4_UodMODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART4_UodMODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART4_UodMODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART4_UodMODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART4_UodMODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART4_UodMODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART4_UodMODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART4_UodMODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART4_UodMODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART4_UodMODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART4_U4STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART4_U4STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART4_U4STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART4_U4STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART4_U4STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART4_U4STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART4_U4STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART4_U4STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART4_U4STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART4_U4STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART4_U4STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART4_U4STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART4_U4STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART4_U4STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART4_U4STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART4_U4STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART4_U4STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART4_U4STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART4_U4STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART4_U4STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART4_U4STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART4_U4STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART4_U4STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART4_U4STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART4_U4STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART4_U4STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART4_U4STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART4_U4STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART4_U4STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART4_U4STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART4_U4STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART4_U4STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART4_U4STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART4_U4STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART4_U4STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART4_U4STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART4_U4STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART4_U4STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART4_U4STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART4_U4STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART4_U4STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART4_U4STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART4_U4STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART4_U4STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART4_U4STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART4_U4STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART4_U4STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART4_U4STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART4_U4STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART4_U4STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART4_U4STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART4_U4STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART4_U4STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART4_U4STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART4_U4STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART4_U4STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART4_U4STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART4_U4STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART4_U4STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART4_U4STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART4_U4STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART4_U4STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART4_U4STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART4_U4STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART4_U4STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART4_U4STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART4_U4STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART4_U4STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART4_U4STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART4_U4STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART4_U4STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART4_U4STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART4_U4STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART4_U4STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART4_U4STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART4_U4STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART4_U4STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART4_U4STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART4_UodSTA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART4_UodSTA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART4_UodSTA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART4_UodSTA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART4_UodSTA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART4_UodSTA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART4_UodSTA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART4_UodSTA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART4_UodSTA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART4_UodSTA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART4_UodSTA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART4_UodSTA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART4_UodSTA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART4_UodSTA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART4_UodSTA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART4_UodSTA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART4_UodSTA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART4_UodSTA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART4_UodSTA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART4_UodSTA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART4_UodSTA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART4_UodSTA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART4_UodSTA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART4_UodSTA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART4_UodSTA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART4_UodSTA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART4_UodSTA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART4_UodSTA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART4_UodSTA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART4_UodSTA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART4_UodSTA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART4_UodSTA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART4_UodSTA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART4_UodSTA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART4_UodSTA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART4_UodSTA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART4_UodSTA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART4_UodSTA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART4_UodSTA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART4_UodSTA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART4_UodSTA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART4_UodSTA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART4_UodSTA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART4_UodSTA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART4_UodSTA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART4_UodSTA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART4_UodSTA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART4_UodSTA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART4_UodSTA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART4_UodSTA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART4_UodSTA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART4_UodSTA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART4_UodSTA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART4_UodSTA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART4_UodSTA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART4_UodSTA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART4_UodSTA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART4_UodSTA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART4_UodSTA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART4_UodSTA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART4_UodSTA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART4_UodSTA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART4_UodSTA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART4_UodSTA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART4_UodSTA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART4_UodSTA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART4_UodSTA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART4_UodSTA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART4_UodSTA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART4_UodSTA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART4_UodSTA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART4_UodSTA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART4_UodSTA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART4_UodSTA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART4_UodSTA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART4_UodSTA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART4_UodSTA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART4_UodSTA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMCON.setRDSP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPMP_PMCON.clearRDSP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPMP_PMCON.setRDSP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPMP_PMCON.getRDSP : TBits_1; inline;
begin
  getRDSP := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPMP_PMCON.setWRSP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPMP_PMCON.clearWRSP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPMP_PMCON.setWRSP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPMP_PMCON.getWRSP : TBits_1; inline;
begin
  getWRSP := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPMP_PMCON.setCS1P; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPMP_PMCON.clearCS1P; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPMP_PMCON.setCS1P(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPMP_PMCON.getCS1P : TBits_1; inline;
begin
  getCS1P := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPMP_PMCON.setCS2P; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPMP_PMCON.clearCS2P; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPMP_PMCON.setCS2P(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPMP_PMCON.getCS2P : TBits_1; inline;
begin
  getCS2P := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPMP_PMCON.setALP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPMP_PMCON.clearALP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPMP_PMCON.setALP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPMP_PMCON.getALP : TBits_1; inline;
begin
  getALP := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPMP_PMCON.setCSF(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TPMP_PMCON.getCSF : TBits_2; inline;
begin
  getCSF := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TPMP_PMCON.setPTRDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPMP_PMCON.clearPTRDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPMP_PMCON.setPTRDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPMP_PMCON.getPTRDEN : TBits_1; inline;
begin
  getPTRDEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPMP_PMCON.setPTWREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPMP_PMCON.clearPTWREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPMP_PMCON.setPTWREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPMP_PMCON.getPTWREN : TBits_1; inline;
begin
  getPTWREN := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPMP_PMCON.setPMPTTL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPMP_PMCON.clearPMPTTL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPMP_PMCON.setPMPTTL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPMP_PMCON.getPMPTTL : TBits_1; inline;
begin
  getPMPTTL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPMP_PMCON.setADRMUX(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE7FF or ( thebits shl 11 );
end;
function  TPMP_PMCON.getADRMUX : TBits_2; inline;
begin
  getADRMUX := (pTDefRegMap(@Self)^.val and $00001800) shr 11;
end;
procedure TPMP_PMCON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPMP_PMCON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPMP_PMCON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPMP_PMCON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPMP_PMCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMCON.setCSF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPMP_PMCON.clearCSF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPMP_PMCON.setCSF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPMP_PMCON.getCSF0 : TBits_1; inline;
begin
  getCSF0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPMP_PMCON.setCSF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPMP_PMCON.clearCSF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPMP_PMCON.setCSF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPMP_PMCON.getCSF1 : TBits_1; inline;
begin
  getCSF1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPMP_PMCON.setADRMUX0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPMP_PMCON.clearADRMUX0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPMP_PMCON.setADRMUX0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPMP_PMCON.getADRMUX0 : TBits_1; inline;
begin
  getADRMUX0 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPMP_PMCON.setADRMUX1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPMP_PMCON.clearADRMUX1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPMP_PMCON.setADRMUX1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPMP_PMCON.getADRMUX1 : TBits_1; inline;
begin
  getADRMUX1 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPMP_PMCON.setPSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPMP_PMCON.clearPSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPMP_PMCON.setPSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPMP_PMCON.getPSIDL : TBits_1; inline;
begin
  getPSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPMP_PMCON.setPMPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMCON.clearPMPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMCON.setPMPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMCON.getPMPEN : TBits_1; inline;
begin
  getPMPEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMMODE.setWAITE(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TPMP_PMMODE.getWAITE : TBits_2; inline;
begin
  getWAITE := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TPMP_PMMODE.setWAITM(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFC3 or ( thebits shl 2 );
end;
function  TPMP_PMMODE.getWAITM : TBits_4; inline;
begin
  getWAITM := (pTDefRegMap(@Self)^.val and $0000003C) shr 2;
end;
procedure TPMP_PMMODE.setWAITB(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TPMP_PMMODE.getWAITB : TBits_2; inline;
begin
  getWAITB := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TPMP_PMMODE.setMODE(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TPMP_PMMODE.getMODE : TBits_2; inline;
begin
  getMODE := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TPMP_PMMODE.setMODE16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPMP_PMMODE.clearMODE16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPMP_PMMODE.setMODE16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPMP_PMMODE.getMODE16 : TBits_1; inline;
begin
  getMODE16 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPMP_PMMODE.setINCM(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE7FF or ( thebits shl 11 );
end;
function  TPMP_PMMODE.getINCM : TBits_2; inline;
begin
  getINCM := (pTDefRegMap(@Self)^.val and $00001800) shr 11;
end;
procedure TPMP_PMMODE.setIRQM(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF9FFF or ( thebits shl 13 );
end;
function  TPMP_PMMODE.getIRQM : TBits_2; inline;
begin
  getIRQM := (pTDefRegMap(@Self)^.val and $00006000) shr 13;
end;
procedure TPMP_PMMODE.setBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMMODE.clearBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMMODE.setBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMMODE.getBUSY : TBits_1; inline;
begin
  getBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMMODE.setWAITE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPMP_PMMODE.clearWAITE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPMP_PMMODE.setWAITE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPMP_PMMODE.getWAITE0 : TBits_1; inline;
begin
  getWAITE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPMP_PMMODE.setWAITE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPMP_PMMODE.clearWAITE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPMP_PMMODE.setWAITE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPMP_PMMODE.getWAITE1 : TBits_1; inline;
begin
  getWAITE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPMP_PMMODE.setWAITM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPMP_PMMODE.clearWAITM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPMP_PMMODE.setWAITM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPMP_PMMODE.getWAITM0 : TBits_1; inline;
begin
  getWAITM0 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPMP_PMMODE.setWAITM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPMP_PMMODE.clearWAITM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPMP_PMMODE.setWAITM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPMP_PMMODE.getWAITM1 : TBits_1; inline;
begin
  getWAITM1 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPMP_PMMODE.setWAITM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPMP_PMMODE.clearWAITM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPMP_PMMODE.setWAITM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPMP_PMMODE.getWAITM2 : TBits_1; inline;
begin
  getWAITM2 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPMP_PMMODE.setWAITM3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPMP_PMMODE.clearWAITM3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPMP_PMMODE.setWAITM3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPMP_PMMODE.getWAITM3 : TBits_1; inline;
begin
  getWAITM3 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPMP_PMMODE.setWAITB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPMP_PMMODE.clearWAITB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPMP_PMMODE.setWAITB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPMP_PMMODE.getWAITB0 : TBits_1; inline;
begin
  getWAITB0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPMP_PMMODE.setWAITB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPMP_PMMODE.clearWAITB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPMP_PMMODE.setWAITB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPMP_PMMODE.getWAITB1 : TBits_1; inline;
begin
  getWAITB1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPMP_PMMODE.setMODE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPMP_PMMODE.clearMODE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPMP_PMMODE.setMODE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPMP_PMMODE.getMODE0 : TBits_1; inline;
begin
  getMODE0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPMP_PMMODE.setMODE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPMP_PMMODE.clearMODE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPMP_PMMODE.setMODE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPMP_PMMODE.getMODE1 : TBits_1; inline;
begin
  getMODE1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPMP_PMMODE.setINCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPMP_PMMODE.clearINCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPMP_PMMODE.setINCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPMP_PMMODE.getINCM0 : TBits_1; inline;
begin
  getINCM0 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPMP_PMMODE.setINCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPMP_PMMODE.clearINCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPMP_PMMODE.setINCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPMP_PMMODE.getINCM1 : TBits_1; inline;
begin
  getINCM1 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPMP_PMMODE.setIRQM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPMP_PMMODE.clearIRQM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPMP_PMMODE.setIRQM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPMP_PMMODE.getIRQM0 : TBits_1; inline;
begin
  getIRQM0 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPMP_PMMODE.setIRQM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPMP_PMMODE.clearIRQM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPMP_PMMODE.setIRQM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPMP_PMMODE.getIRQM1 : TBits_1; inline;
begin
  getIRQM1 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPMP_PMMODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMMODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMADDR.setADDR(thebits : TBits_14); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFC000 or ( thebits shl 0 );
end;
function  TPMP_PMADDR.getADDR : TBits_14; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00003FFF) shr 0;
end;
procedure TPMP_PMADDR.setCS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TPMP_PMADDR.getCS : TBits_2; inline;
begin
  getCS := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TPMP_PMADDR.setPADDR(thebits : TBits_14); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFC000 or ( thebits shl 0 );
end;
function  TPMP_PMADDR.getPADDR : TBits_14; inline;
begin
  getPADDR := (pTDefRegMap(@Self)^.val and $00003FFF) shr 0;
end;
procedure TPMP_PMADDR.setCS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPMP_PMADDR.clearCS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPMP_PMADDR.setCS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPMP_PMADDR.getCS1 : TBits_1; inline;
begin
  getCS1 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPMP_PMADDR.setCS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMADDR.clearCS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMADDR.setCS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMADDR.getCS2 : TBits_1; inline;
begin
  getCS2 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMADDR.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMADDR.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMDOUT.setDATAOUT(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMDOUT.getDATAOUT : TBits_32; inline;
begin
  getDATAOUT := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMDOUT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMDOUT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMDIN.setDATAIN(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMDIN.getDATAIN : TBits_32; inline;
begin
  getDATAIN := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMDIN.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMDIN.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMAEN.setPTEN(thebits : TBits_16); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0000 or ( thebits shl 0 );
end;
function  TPMP_PMAEN.getPTEN : TBits_16; inline;
begin
  getPTEN := (pTDefRegMap(@Self)^.val and $0000FFFF) shr 0;
end;
procedure TPMP_PMAEN.setPTEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPMP_PMAEN.clearPTEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPMP_PMAEN.setPTEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPMP_PMAEN.getPTEN0 : TBits_1; inline;
begin
  getPTEN0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPMP_PMAEN.setPTEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPMP_PMAEN.clearPTEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPMP_PMAEN.setPTEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPMP_PMAEN.getPTEN1 : TBits_1; inline;
begin
  getPTEN1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPMP_PMAEN.setPTEN2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPMP_PMAEN.clearPTEN2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPMP_PMAEN.setPTEN2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPMP_PMAEN.getPTEN2 : TBits_1; inline;
begin
  getPTEN2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPMP_PMAEN.setPTEN3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPMP_PMAEN.clearPTEN3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPMP_PMAEN.setPTEN3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPMP_PMAEN.getPTEN3 : TBits_1; inline;
begin
  getPTEN3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPMP_PMAEN.setPTEN4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPMP_PMAEN.clearPTEN4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPMP_PMAEN.setPTEN4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPMP_PMAEN.getPTEN4 : TBits_1; inline;
begin
  getPTEN4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPMP_PMAEN.setPTEN5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPMP_PMAEN.clearPTEN5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPMP_PMAEN.setPTEN5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPMP_PMAEN.getPTEN5 : TBits_1; inline;
begin
  getPTEN5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPMP_PMAEN.setPTEN6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPMP_PMAEN.clearPTEN6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPMP_PMAEN.setPTEN6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPMP_PMAEN.getPTEN6 : TBits_1; inline;
begin
  getPTEN6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPMP_PMAEN.setPTEN7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPMP_PMAEN.clearPTEN7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPMP_PMAEN.setPTEN7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPMP_PMAEN.getPTEN7 : TBits_1; inline;
begin
  getPTEN7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPMP_PMAEN.setPTEN8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPMP_PMAEN.clearPTEN8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPMP_PMAEN.setPTEN8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPMP_PMAEN.getPTEN8 : TBits_1; inline;
begin
  getPTEN8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPMP_PMAEN.setPTEN9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPMP_PMAEN.clearPTEN9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPMP_PMAEN.setPTEN9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPMP_PMAEN.getPTEN9 : TBits_1; inline;
begin
  getPTEN9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPMP_PMAEN.setPTEN10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPMP_PMAEN.clearPTEN10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPMP_PMAEN.setPTEN10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPMP_PMAEN.getPTEN10 : TBits_1; inline;
begin
  getPTEN10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPMP_PMAEN.setPTEN11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPMP_PMAEN.clearPTEN11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPMP_PMAEN.setPTEN11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPMP_PMAEN.getPTEN11 : TBits_1; inline;
begin
  getPTEN11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPMP_PMAEN.setPTEN12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPMP_PMAEN.clearPTEN12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPMP_PMAEN.setPTEN12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPMP_PMAEN.getPTEN12 : TBits_1; inline;
begin
  getPTEN12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPMP_PMAEN.setPTEN13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPMP_PMAEN.clearPTEN13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPMP_PMAEN.setPTEN13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPMP_PMAEN.getPTEN13 : TBits_1; inline;
begin
  getPTEN13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPMP_PMAEN.setPTEN14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPMP_PMAEN.clearPTEN14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPMP_PMAEN.setPTEN14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPMP_PMAEN.getPTEN14 : TBits_1; inline;
begin
  getPTEN14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPMP_PMAEN.setPTEN15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMAEN.clearPTEN15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMAEN.setPTEN15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMAEN.getPTEN15 : TBits_1; inline;
begin
  getPTEN15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMAEN.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMAEN.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMSTAT.setOB0E; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPMP_PMSTAT.clearOB0E; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPMP_PMSTAT.setOB0E(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPMP_PMSTAT.getOB0E : TBits_1; inline;
begin
  getOB0E := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPMP_PMSTAT.setOB1E; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPMP_PMSTAT.clearOB1E; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPMP_PMSTAT.setOB1E(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPMP_PMSTAT.getOB1E : TBits_1; inline;
begin
  getOB1E := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPMP_PMSTAT.setOB2E; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPMP_PMSTAT.clearOB2E; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPMP_PMSTAT.setOB2E(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPMP_PMSTAT.getOB2E : TBits_1; inline;
begin
  getOB2E := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPMP_PMSTAT.setOB3E; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPMP_PMSTAT.clearOB3E; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPMP_PMSTAT.setOB3E(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPMP_PMSTAT.getOB3E : TBits_1; inline;
begin
  getOB3E := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPMP_PMSTAT.setOBUF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPMP_PMSTAT.clearOBUF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPMP_PMSTAT.setOBUF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPMP_PMSTAT.getOBUF : TBits_1; inline;
begin
  getOBUF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPMP_PMSTAT.setOBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPMP_PMSTAT.clearOBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPMP_PMSTAT.setOBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPMP_PMSTAT.getOBE : TBits_1; inline;
begin
  getOBE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPMP_PMSTAT.setIB0F; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPMP_PMSTAT.clearIB0F; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPMP_PMSTAT.setIB0F(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPMP_PMSTAT.getIB0F : TBits_1; inline;
begin
  getIB0F := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPMP_PMSTAT.setIB1F; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPMP_PMSTAT.clearIB1F; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPMP_PMSTAT.setIB1F(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPMP_PMSTAT.getIB1F : TBits_1; inline;
begin
  getIB1F := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPMP_PMSTAT.setIB2F; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPMP_PMSTAT.clearIB2F; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPMP_PMSTAT.setIB2F(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPMP_PMSTAT.getIB2F : TBits_1; inline;
begin
  getIB2F := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPMP_PMSTAT.setIB3F; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPMP_PMSTAT.clearIB3F; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPMP_PMSTAT.setIB3F(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPMP_PMSTAT.getIB3F : TBits_1; inline;
begin
  getIB3F := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPMP_PMSTAT.setIBOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPMP_PMSTAT.clearIBOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPMP_PMSTAT.setIBOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPMP_PMSTAT.getIBOV : TBits_1; inline;
begin
  getIBOV := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPMP_PMSTAT.setIBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMSTAT.clearIBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMSTAT.setIBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMSTAT.getIBF : TBits_1; inline;
begin
  getIBF := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMSTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMSTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CON1.setDONE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TADC10_AD1CON1.clearDONE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TADC10_AD1CON1.setDONE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TADC10_AD1CON1.getDONE : TBits_1; inline;
begin
  getDONE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TADC10_AD1CON1.setSAMP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TADC10_AD1CON1.clearSAMP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TADC10_AD1CON1.setSAMP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TADC10_AD1CON1.getSAMP : TBits_1; inline;
begin
  getSAMP := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TADC10_AD1CON1.setASAM; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TADC10_AD1CON1.clearASAM; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TADC10_AD1CON1.setASAM(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TADC10_AD1CON1.getASAM : TBits_1; inline;
begin
  getASAM := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TADC10_AD1CON1.setCLRASAM; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TADC10_AD1CON1.clearCLRASAM; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TADC10_AD1CON1.setCLRASAM(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TADC10_AD1CON1.getCLRASAM : TBits_1; inline;
begin
  getCLRASAM := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TADC10_AD1CON1.setSSRC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF1F or ( thebits shl 5 );
end;
function  TADC10_AD1CON1.getSSRC : TBits_3; inline;
begin
  getSSRC := (pTDefRegMap(@Self)^.val and $000000E0) shr 5;
end;
procedure TADC10_AD1CON1.setFORM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF8FF or ( thebits shl 8 );
end;
function  TADC10_AD1CON1.getFORM : TBits_3; inline;
begin
  getFORM := (pTDefRegMap(@Self)^.val and $00000700) shr 8;
end;
procedure TADC10_AD1CON1.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TADC10_AD1CON1.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TADC10_AD1CON1.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TADC10_AD1CON1.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TADC10_AD1CON1.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CON1.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CON1.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CON1.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CON1.setSSRC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TADC10_AD1CON1.clearSSRC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TADC10_AD1CON1.setSSRC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TADC10_AD1CON1.getSSRC0 : TBits_1; inline;
begin
  getSSRC0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TADC10_AD1CON1.setSSRC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TADC10_AD1CON1.clearSSRC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TADC10_AD1CON1.setSSRC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TADC10_AD1CON1.getSSRC1 : TBits_1; inline;
begin
  getSSRC1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TADC10_AD1CON1.setSSRC2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TADC10_AD1CON1.clearSSRC2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TADC10_AD1CON1.setSSRC2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TADC10_AD1CON1.getSSRC2 : TBits_1; inline;
begin
  getSSRC2 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TADC10_AD1CON1.setFORM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TADC10_AD1CON1.clearFORM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TADC10_AD1CON1.setFORM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TADC10_AD1CON1.getFORM0 : TBits_1; inline;
begin
  getFORM0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TADC10_AD1CON1.setFORM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TADC10_AD1CON1.clearFORM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TADC10_AD1CON1.setFORM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TADC10_AD1CON1.getFORM1 : TBits_1; inline;
begin
  getFORM1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TADC10_AD1CON1.setFORM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TADC10_AD1CON1.clearFORM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TADC10_AD1CON1.setFORM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TADC10_AD1CON1.getFORM2 : TBits_1; inline;
begin
  getFORM2 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TADC10_AD1CON1.setADSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TADC10_AD1CON1.clearADSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TADC10_AD1CON1.setADSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TADC10_AD1CON1.getADSIDL : TBits_1; inline;
begin
  getADSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TADC10_AD1CON1.setADON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CON1.clearADON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CON1.setADON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CON1.getADON : TBits_1; inline;
begin
  getADON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CON1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CON1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CON2.setALTS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TADC10_AD1CON2.clearALTS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TADC10_AD1CON2.setALTS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TADC10_AD1CON2.getALTS : TBits_1; inline;
begin
  getALTS := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TADC10_AD1CON2.setBUFM; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TADC10_AD1CON2.clearBUFM; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TADC10_AD1CON2.setBUFM(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TADC10_AD1CON2.getBUFM : TBits_1; inline;
begin
  getBUFM := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TADC10_AD1CON2.setSMPI(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFC3 or ( thebits shl 2 );
end;
function  TADC10_AD1CON2.getSMPI : TBits_4; inline;
begin
  getSMPI := (pTDefRegMap(@Self)^.val and $0000003C) shr 2;
end;
procedure TADC10_AD1CON2.setBUFS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TADC10_AD1CON2.clearBUFS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TADC10_AD1CON2.setBUFS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TADC10_AD1CON2.getBUFS : TBits_1; inline;
begin
  getBUFS := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TADC10_AD1CON2.setCSCNA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TADC10_AD1CON2.clearCSCNA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TADC10_AD1CON2.setCSCNA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TADC10_AD1CON2.getCSCNA : TBits_1; inline;
begin
  getCSCNA := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TADC10_AD1CON2.setOFFCAL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TADC10_AD1CON2.clearOFFCAL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TADC10_AD1CON2.setOFFCAL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TADC10_AD1CON2.getOFFCAL : TBits_1; inline;
begin
  getOFFCAL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TADC10_AD1CON2.setVCFG(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF1FFF or ( thebits shl 13 );
end;
function  TADC10_AD1CON2.getVCFG : TBits_3; inline;
begin
  getVCFG := (pTDefRegMap(@Self)^.val and $0000E000) shr 13;
end;
procedure TADC10_AD1CON2.setSMPI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TADC10_AD1CON2.clearSMPI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TADC10_AD1CON2.setSMPI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TADC10_AD1CON2.getSMPI0 : TBits_1; inline;
begin
  getSMPI0 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TADC10_AD1CON2.setSMPI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TADC10_AD1CON2.clearSMPI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TADC10_AD1CON2.setSMPI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TADC10_AD1CON2.getSMPI1 : TBits_1; inline;
begin
  getSMPI1 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TADC10_AD1CON2.setSMPI2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TADC10_AD1CON2.clearSMPI2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TADC10_AD1CON2.setSMPI2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TADC10_AD1CON2.getSMPI2 : TBits_1; inline;
begin
  getSMPI2 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TADC10_AD1CON2.setSMPI3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TADC10_AD1CON2.clearSMPI3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TADC10_AD1CON2.setSMPI3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TADC10_AD1CON2.getSMPI3 : TBits_1; inline;
begin
  getSMPI3 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TADC10_AD1CON2.setVCFG0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TADC10_AD1CON2.clearVCFG0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TADC10_AD1CON2.setVCFG0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TADC10_AD1CON2.getVCFG0 : TBits_1; inline;
begin
  getVCFG0 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TADC10_AD1CON2.setVCFG1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TADC10_AD1CON2.clearVCFG1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TADC10_AD1CON2.setVCFG1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TADC10_AD1CON2.getVCFG1 : TBits_1; inline;
begin
  getVCFG1 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TADC10_AD1CON2.setVCFG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CON2.clearVCFG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CON2.setVCFG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CON2.getVCFG2 : TBits_1; inline;
begin
  getVCFG2 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CON2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CON2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CON3.setADCS(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF00 or ( thebits shl 0 );
end;
function  TADC10_AD1CON3.getADCS : TBits_8; inline;
begin
  getADCS := (pTDefRegMap(@Self)^.val and $000000FF) shr 0;
end;
procedure TADC10_AD1CON3.setSAMC(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TADC10_AD1CON3.getSAMC : TBits_5; inline;
begin
  getSAMC := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TADC10_AD1CON3.setADRC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CON3.clearADRC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CON3.setADRC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CON3.getADRC : TBits_1; inline;
begin
  getADRC := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CON3.setADCS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TADC10_AD1CON3.clearADCS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TADC10_AD1CON3.setADCS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TADC10_AD1CON3.getADCS0 : TBits_1; inline;
begin
  getADCS0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TADC10_AD1CON3.setADCS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TADC10_AD1CON3.clearADCS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TADC10_AD1CON3.setADCS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TADC10_AD1CON3.getADCS1 : TBits_1; inline;
begin
  getADCS1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TADC10_AD1CON3.setADCS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TADC10_AD1CON3.clearADCS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TADC10_AD1CON3.setADCS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TADC10_AD1CON3.getADCS2 : TBits_1; inline;
begin
  getADCS2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TADC10_AD1CON3.setADCS3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TADC10_AD1CON3.clearADCS3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TADC10_AD1CON3.setADCS3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TADC10_AD1CON3.getADCS3 : TBits_1; inline;
begin
  getADCS3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TADC10_AD1CON3.setADCS4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TADC10_AD1CON3.clearADCS4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TADC10_AD1CON3.setADCS4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TADC10_AD1CON3.getADCS4 : TBits_1; inline;
begin
  getADCS4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TADC10_AD1CON3.setADCS5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TADC10_AD1CON3.clearADCS5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TADC10_AD1CON3.setADCS5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TADC10_AD1CON3.getADCS5 : TBits_1; inline;
begin
  getADCS5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TADC10_AD1CON3.setADCS6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TADC10_AD1CON3.clearADCS6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TADC10_AD1CON3.setADCS6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TADC10_AD1CON3.getADCS6 : TBits_1; inline;
begin
  getADCS6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TADC10_AD1CON3.setADCS7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TADC10_AD1CON3.clearADCS7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TADC10_AD1CON3.setADCS7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TADC10_AD1CON3.getADCS7 : TBits_1; inline;
begin
  getADCS7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TADC10_AD1CON3.setSAMC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TADC10_AD1CON3.clearSAMC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TADC10_AD1CON3.setSAMC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TADC10_AD1CON3.getSAMC0 : TBits_1; inline;
begin
  getSAMC0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TADC10_AD1CON3.setSAMC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TADC10_AD1CON3.clearSAMC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TADC10_AD1CON3.setSAMC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TADC10_AD1CON3.getSAMC1 : TBits_1; inline;
begin
  getSAMC1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TADC10_AD1CON3.setSAMC2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TADC10_AD1CON3.clearSAMC2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TADC10_AD1CON3.setSAMC2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TADC10_AD1CON3.getSAMC2 : TBits_1; inline;
begin
  getSAMC2 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TADC10_AD1CON3.setSAMC3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TADC10_AD1CON3.clearSAMC3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TADC10_AD1CON3.setSAMC3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TADC10_AD1CON3.getSAMC3 : TBits_1; inline;
begin
  getSAMC3 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TADC10_AD1CON3.setSAMC4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TADC10_AD1CON3.clearSAMC4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TADC10_AD1CON3.setSAMC4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TADC10_AD1CON3.getSAMC4 : TBits_1; inline;
begin
  getSAMC4 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TADC10_AD1CON3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CON3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CHS.setCH0SA(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TADC10_AD1CHS.getCH0SA : TBits_5; inline;
begin
  getCH0SA := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TADC10_AD1CHS.setCH0NA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TADC10_AD1CHS.clearCH0NA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TADC10_AD1CHS.setCH0NA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TADC10_AD1CHS.getCH0NA : TBits_1; inline;
begin
  getCH0NA := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TADC10_AD1CHS.setCH0SB(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TADC10_AD1CHS.getCH0SB : TBits_5; inline;
begin
  getCH0SB := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TADC10_AD1CHS.setCH0NB; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TADC10_AD1CHS.clearCH0NB; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TADC10_AD1CHS.setCH0NB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TADC10_AD1CHS.getCH0NB : TBits_1; inline;
begin
  getCH0NB := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TADC10_AD1CHS.setCH0SA0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TADC10_AD1CHS.clearCH0SA0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TADC10_AD1CHS.setCH0SA0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TADC10_AD1CHS.getCH0SA0 : TBits_1; inline;
begin
  getCH0SA0 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TADC10_AD1CHS.setCH0SA1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TADC10_AD1CHS.clearCH0SA1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TADC10_AD1CHS.setCH0SA1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TADC10_AD1CHS.getCH0SA1 : TBits_1; inline;
begin
  getCH0SA1 := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TADC10_AD1CHS.setCH0SA2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TADC10_AD1CHS.clearCH0SA2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TADC10_AD1CHS.setCH0SA2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TADC10_AD1CHS.getCH0SA2 : TBits_1; inline;
begin
  getCH0SA2 := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TADC10_AD1CHS.setCH0SA3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TADC10_AD1CHS.clearCH0SA3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TADC10_AD1CHS.setCH0SA3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TADC10_AD1CHS.getCH0SA3 : TBits_1; inline;
begin
  getCH0SA3 := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TADC10_AD1CHS.setCH0SA4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TADC10_AD1CHS.clearCH0SA4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TADC10_AD1CHS.setCH0SA4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TADC10_AD1CHS.getCH0SA4 : TBits_1; inline;
begin
  getCH0SA4 := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TADC10_AD1CHS.setCH0SB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TADC10_AD1CHS.clearCH0SB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TADC10_AD1CHS.setCH0SB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TADC10_AD1CHS.getCH0SB0 : TBits_1; inline;
begin
  getCH0SB0 := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TADC10_AD1CHS.setCH0SB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TADC10_AD1CHS.clearCH0SB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TADC10_AD1CHS.setCH0SB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TADC10_AD1CHS.getCH0SB1 : TBits_1; inline;
begin
  getCH0SB1 := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TADC10_AD1CHS.setCH0SB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TADC10_AD1CHS.clearCH0SB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TADC10_AD1CHS.setCH0SB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TADC10_AD1CHS.getCH0SB2 : TBits_1; inline;
begin
  getCH0SB2 := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TADC10_AD1CHS.setCH0SB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TADC10_AD1CHS.clearCH0SB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TADC10_AD1CHS.setCH0SB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TADC10_AD1CHS.getCH0SB3 : TBits_1; inline;
begin
  getCH0SB3 := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TADC10_AD1CHS.setCH0SB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TADC10_AD1CHS.clearCH0SB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TADC10_AD1CHS.setCH0SB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TADC10_AD1CHS.getCH0SB4 : TBits_1; inline;
begin
  getCH0SB4 := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TADC10_AD1CHS.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CHS.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CSSL.setCSSL(thebits : TBits_31); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $80000000 or ( thebits shl 0 );
end;
function  TADC10_AD1CSSL.getCSSL : TBits_31; inline;
begin
  getCSSL := (pTDefRegMap(@Self)^.val and $7FFFFFFF) shr 0;
end;
procedure TADC10_AD1CSSL.setCSSL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TADC10_AD1CSSL.clearCSSL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TADC10_AD1CSSL.setCSSL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TADC10_AD1CSSL.getCSSL0 : TBits_1; inline;
begin
  getCSSL0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TADC10_AD1CSSL.setCSSL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TADC10_AD1CSSL.clearCSSL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TADC10_AD1CSSL.setCSSL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TADC10_AD1CSSL.getCSSL1 : TBits_1; inline;
begin
  getCSSL1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TADC10_AD1CSSL.setCSSL2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TADC10_AD1CSSL.clearCSSL2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TADC10_AD1CSSL.setCSSL2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TADC10_AD1CSSL.getCSSL2 : TBits_1; inline;
begin
  getCSSL2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TADC10_AD1CSSL.setCSSL3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TADC10_AD1CSSL.clearCSSL3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TADC10_AD1CSSL.setCSSL3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TADC10_AD1CSSL.getCSSL3 : TBits_1; inline;
begin
  getCSSL3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TADC10_AD1CSSL.setCSSL4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TADC10_AD1CSSL.clearCSSL4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TADC10_AD1CSSL.setCSSL4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TADC10_AD1CSSL.getCSSL4 : TBits_1; inline;
begin
  getCSSL4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TADC10_AD1CSSL.setCSSL5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TADC10_AD1CSSL.clearCSSL5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TADC10_AD1CSSL.setCSSL5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TADC10_AD1CSSL.getCSSL5 : TBits_1; inline;
begin
  getCSSL5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TADC10_AD1CSSL.setCSSL6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TADC10_AD1CSSL.clearCSSL6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TADC10_AD1CSSL.setCSSL6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TADC10_AD1CSSL.getCSSL6 : TBits_1; inline;
begin
  getCSSL6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TADC10_AD1CSSL.setCSSL7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TADC10_AD1CSSL.clearCSSL7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TADC10_AD1CSSL.setCSSL7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TADC10_AD1CSSL.getCSSL7 : TBits_1; inline;
begin
  getCSSL7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TADC10_AD1CSSL.setCSSL8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TADC10_AD1CSSL.clearCSSL8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TADC10_AD1CSSL.setCSSL8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TADC10_AD1CSSL.getCSSL8 : TBits_1; inline;
begin
  getCSSL8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TADC10_AD1CSSL.setCSSL9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TADC10_AD1CSSL.clearCSSL9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TADC10_AD1CSSL.setCSSL9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TADC10_AD1CSSL.getCSSL9 : TBits_1; inline;
begin
  getCSSL9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TADC10_AD1CSSL.setCSSL10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TADC10_AD1CSSL.clearCSSL10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TADC10_AD1CSSL.setCSSL10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TADC10_AD1CSSL.getCSSL10 : TBits_1; inline;
begin
  getCSSL10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TADC10_AD1CSSL.setCSSL11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TADC10_AD1CSSL.clearCSSL11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TADC10_AD1CSSL.setCSSL11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TADC10_AD1CSSL.getCSSL11 : TBits_1; inline;
begin
  getCSSL11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TADC10_AD1CSSL.setCSSL12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TADC10_AD1CSSL.clearCSSL12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TADC10_AD1CSSL.setCSSL12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TADC10_AD1CSSL.getCSSL12 : TBits_1; inline;
begin
  getCSSL12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TADC10_AD1CSSL.setCSSL13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TADC10_AD1CSSL.clearCSSL13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TADC10_AD1CSSL.setCSSL13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TADC10_AD1CSSL.getCSSL13 : TBits_1; inline;
begin
  getCSSL13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TADC10_AD1CSSL.setCSSL14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TADC10_AD1CSSL.clearCSSL14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TADC10_AD1CSSL.setCSSL14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TADC10_AD1CSSL.getCSSL14 : TBits_1; inline;
begin
  getCSSL14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TADC10_AD1CSSL.setCSSL15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CSSL.clearCSSL15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CSSL.setCSSL15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CSSL.getCSSL15 : TBits_1; inline;
begin
  getCSSL15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CSSL.setCSSL16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TADC10_AD1CSSL.clearCSSL16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TADC10_AD1CSSL.setCSSL16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TADC10_AD1CSSL.getCSSL16 : TBits_1; inline;
begin
  getCSSL16 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TADC10_AD1CSSL.setCSSL17; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TADC10_AD1CSSL.clearCSSL17; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TADC10_AD1CSSL.setCSSL17(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TADC10_AD1CSSL.getCSSL17 : TBits_1; inline;
begin
  getCSSL17 := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TADC10_AD1CSSL.setCSSL18; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TADC10_AD1CSSL.clearCSSL18; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TADC10_AD1CSSL.setCSSL18(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TADC10_AD1CSSL.getCSSL18 : TBits_1; inline;
begin
  getCSSL18 := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TADC10_AD1CSSL.setCSSL19; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TADC10_AD1CSSL.clearCSSL19; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TADC10_AD1CSSL.setCSSL19(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TADC10_AD1CSSL.getCSSL19 : TBits_1; inline;
begin
  getCSSL19 := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TADC10_AD1CSSL.setCSSL20; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TADC10_AD1CSSL.clearCSSL20; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TADC10_AD1CSSL.setCSSL20(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TADC10_AD1CSSL.getCSSL20 : TBits_1; inline;
begin
  getCSSL20 := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TADC10_AD1CSSL.setCSSL21; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TADC10_AD1CSSL.clearCSSL21; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TADC10_AD1CSSL.setCSSL21(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TADC10_AD1CSSL.getCSSL21 : TBits_1; inline;
begin
  getCSSL21 := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TADC10_AD1CSSL.setCSSL22; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TADC10_AD1CSSL.clearCSSL22; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TADC10_AD1CSSL.setCSSL22(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TADC10_AD1CSSL.getCSSL22 : TBits_1; inline;
begin
  getCSSL22 := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TADC10_AD1CSSL.setCSSL23; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TADC10_AD1CSSL.clearCSSL23; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TADC10_AD1CSSL.setCSSL23(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TADC10_AD1CSSL.getCSSL23 : TBits_1; inline;
begin
  getCSSL23 := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TADC10_AD1CSSL.setCSSL24; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TADC10_AD1CSSL.clearCSSL24; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TADC10_AD1CSSL.setCSSL24(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TADC10_AD1CSSL.getCSSL24 : TBits_1; inline;
begin
  getCSSL24 := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TADC10_AD1CSSL.setCSSL25; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TADC10_AD1CSSL.clearCSSL25; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TADC10_AD1CSSL.setCSSL25(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TADC10_AD1CSSL.getCSSL25 : TBits_1; inline;
begin
  getCSSL25 := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TADC10_AD1CSSL.setCSSL26; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TADC10_AD1CSSL.clearCSSL26; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TADC10_AD1CSSL.setCSSL26(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TADC10_AD1CSSL.getCSSL26 : TBits_1; inline;
begin
  getCSSL26 := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TADC10_AD1CSSL.setCSSL27; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TADC10_AD1CSSL.clearCSSL27; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TADC10_AD1CSSL.setCSSL27(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TADC10_AD1CSSL.getCSSL27 : TBits_1; inline;
begin
  getCSSL27 := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TADC10_AD1CSSL.setCSSL28; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TADC10_AD1CSSL.clearCSSL28; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TADC10_AD1CSSL.setCSSL28(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TADC10_AD1CSSL.getCSSL28 : TBits_1; inline;
begin
  getCSSL28 := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TADC10_AD1CSSL.setCSSL29; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TADC10_AD1CSSL.clearCSSL29; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TADC10_AD1CSSL.setCSSL29(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TADC10_AD1CSSL.getCSSL29 : TBits_1; inline;
begin
  getCSSL29 := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TADC10_AD1CSSL.setCSSL30; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TADC10_AD1CSSL.clearCSSL30; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TADC10_AD1CSSL.setCSSL30(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TADC10_AD1CSSL.getCSSL30 : TBits_1; inline;
begin
  getCSSL30 := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TADC10_AD1CSSL.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CSSL.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCVR_CVRCON.setCVR(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TCVR_CVRCON.getCVR : TBits_4; inline;
begin
  getCVR := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TCVR_CVRCON.setCVRSS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCVR_CVRCON.clearCVRSS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCVR_CVRCON.setCVRSS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCVR_CVRCON.getCVRSS : TBits_1; inline;
begin
  getCVRSS := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCVR_CVRCON.setCVRR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCVR_CVRCON.clearCVRR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCVR_CVRCON.setCVRR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCVR_CVRCON.getCVRR : TBits_1; inline;
begin
  getCVRR := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCVR_CVRCON.setCVROE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCVR_CVRCON.clearCVROE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCVR_CVRCON.setCVROE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCVR_CVRCON.getCVROE : TBits_1; inline;
begin
  getCVROE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCVR_CVRCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCVR_CVRCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCVR_CVRCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCVR_CVRCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCVR_CVRCON.setCVR0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCVR_CVRCON.clearCVR0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCVR_CVRCON.setCVR0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCVR_CVRCON.getCVR0 : TBits_1; inline;
begin
  getCVR0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCVR_CVRCON.setCVR1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCVR_CVRCON.clearCVR1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCVR_CVRCON.setCVR1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCVR_CVRCON.getCVR1 : TBits_1; inline;
begin
  getCVR1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCVR_CVRCON.setCVR2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCVR_CVRCON.clearCVR2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCVR_CVRCON.setCVR2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCVR_CVRCON.getCVR2 : TBits_1; inline;
begin
  getCVR2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCVR_CVRCON.setCVR3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCVR_CVRCON.clearCVR3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCVR_CVRCON.setCVR3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCVR_CVRCON.getCVR3 : TBits_1; inline;
begin
  getCVR3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCVR_CVRCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCVR_CVRCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCMP_CM1CON.setCCH(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCMP_CM1CON.getCCH : TBits_2; inline;
begin
  getCCH := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCMP_CM1CON.setCREF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCMP_CM1CON.clearCREF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCMP_CM1CON.setCREF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCMP_CM1CON.getCREF : TBits_1; inline;
begin
  getCREF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCMP_CM1CON.setEVPOL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TCMP_CM1CON.getEVPOL : TBits_2; inline;
begin
  getEVPOL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TCMP_CM1CON.setCOUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCMP_CM1CON.clearCOUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCMP_CM1CON.setCOUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCMP_CM1CON.getCOUT : TBits_1; inline;
begin
  getCOUT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCMP_CM1CON.setCPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCMP_CM1CON.clearCPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCMP_CM1CON.setCPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCMP_CM1CON.getCPOL : TBits_1; inline;
begin
  getCPOL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCMP_CM1CON.setCOE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCMP_CM1CON.clearCOE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCMP_CM1CON.setCOE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCMP_CM1CON.getCOE : TBits_1; inline;
begin
  getCOE := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCMP_CM1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCMP_CM1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCMP_CM1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCMP_CM1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCMP_CM1CON.setCCH0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCMP_CM1CON.clearCCH0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCMP_CM1CON.setCCH0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCMP_CM1CON.getCCH0 : TBits_1; inline;
begin
  getCCH0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCMP_CM1CON.setCCH1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCMP_CM1CON.clearCCH1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCMP_CM1CON.setCCH1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCMP_CM1CON.getCCH1 : TBits_1; inline;
begin
  getCCH1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCMP_CM1CON.setEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCMP_CM1CON.clearEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCMP_CM1CON.setEVPOL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCMP_CM1CON.getEVPOL0 : TBits_1; inline;
begin
  getEVPOL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCMP_CM1CON.setEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCMP_CM1CON.clearEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCMP_CM1CON.setEVPOL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCMP_CM1CON.getEVPOL1 : TBits_1; inline;
begin
  getEVPOL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCMP_CM1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCMP_CM1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCMP_CM2CON.setCCH(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCMP_CM2CON.getCCH : TBits_2; inline;
begin
  getCCH := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCMP_CM2CON.setCREF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCMP_CM2CON.clearCREF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCMP_CM2CON.setCREF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCMP_CM2CON.getCREF : TBits_1; inline;
begin
  getCREF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCMP_CM2CON.setEVPOL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TCMP_CM2CON.getEVPOL : TBits_2; inline;
begin
  getEVPOL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TCMP_CM2CON.setCOUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCMP_CM2CON.clearCOUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCMP_CM2CON.setCOUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCMP_CM2CON.getCOUT : TBits_1; inline;
begin
  getCOUT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCMP_CM2CON.setCPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCMP_CM2CON.clearCPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCMP_CM2CON.setCPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCMP_CM2CON.getCPOL : TBits_1; inline;
begin
  getCPOL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCMP_CM2CON.setCOE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCMP_CM2CON.clearCOE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCMP_CM2CON.setCOE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCMP_CM2CON.getCOE : TBits_1; inline;
begin
  getCOE := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCMP_CM2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCMP_CM2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCMP_CM2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCMP_CM2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCMP_CM2CON.setCCH0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCMP_CM2CON.clearCCH0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCMP_CM2CON.setCCH0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCMP_CM2CON.getCCH0 : TBits_1; inline;
begin
  getCCH0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCMP_CM2CON.setCCH1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCMP_CM2CON.clearCCH1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCMP_CM2CON.setCCH1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCMP_CM2CON.getCCH1 : TBits_1; inline;
begin
  getCCH1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCMP_CM2CON.setEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCMP_CM2CON.clearEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCMP_CM2CON.setEVPOL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCMP_CM2CON.getEVPOL0 : TBits_1; inline;
begin
  getEVPOL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCMP_CM2CON.setEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCMP_CM2CON.clearEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCMP_CM2CON.setEVPOL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCMP_CM2CON.getEVPOL1 : TBits_1; inline;
begin
  getEVPOL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCMP_CM2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCMP_CM2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCMP_CMSTAT.setC1OUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCMP_CMSTAT.clearC1OUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCMP_CMSTAT.setC1OUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCMP_CMSTAT.getC1OUT : TBits_1; inline;
begin
  getC1OUT := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCMP_CMSTAT.setC2OUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCMP_CMSTAT.clearC2OUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCMP_CMSTAT.setC2OUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCMP_CMSTAT.getC2OUT : TBits_1; inline;
begin
  getC2OUT := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCMP_CMSTAT.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCMP_CMSTAT.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCMP_CMSTAT.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCMP_CMSTAT.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCMP_CMSTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCMP_CMSTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCMP_CTMUCON.setIRNG(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCMP_CTMUCON.getIRNG : TBits_2; inline;
begin
  getIRNG := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCMP_CTMUCON.setITRIM(thebits : TBits_6); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF03 or ( thebits shl 2 );
end;
function  TCMP_CTMUCON.getITRIM : TBits_6; inline;
begin
  getITRIM := (pTDefRegMap(@Self)^.val and $000000FC) shr 2;
end;
procedure TCMP_CTMUCON.setCTTRIG; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCMP_CTMUCON.clearCTTRIG; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCMP_CTMUCON.setCTTRIG(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCMP_CTMUCON.getCTTRIG : TBits_1; inline;
begin
  getCTTRIG := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCMP_CTMUCON.setIDISSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCMP_CTMUCON.clearIDISSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCMP_CTMUCON.setIDISSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCMP_CTMUCON.getIDISSEN : TBits_1; inline;
begin
  getIDISSEN := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCMP_CTMUCON.setEDGSEQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCMP_CTMUCON.clearEDGSEQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCMP_CTMUCON.setEDGSEQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCMP_CTMUCON.getEDGSEQEN : TBits_1; inline;
begin
  getEDGSEQEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCMP_CTMUCON.setEDGEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TCMP_CTMUCON.clearEDGEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TCMP_CTMUCON.setEDGEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TCMP_CTMUCON.getEDGEN : TBits_1; inline;
begin
  getEDGEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TCMP_CTMUCON.setTGEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCMP_CTMUCON.clearTGEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCMP_CTMUCON.setTGEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCMP_CTMUCON.getTGEN : TBits_1; inline;
begin
  getTGEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCMP_CTMUCON.setCTMUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCMP_CTMUCON.clearCTMUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCMP_CTMUCON.setCTMUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCMP_CTMUCON.getCTMUSIDL : TBits_1; inline;
begin
  getCTMUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCMP_CTMUCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCMP_CTMUCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCMP_CTMUCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCMP_CTMUCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCMP_CTMUCON.setEDG2SEL(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFC3FFFF or ( thebits shl 18 );
end;
function  TCMP_CTMUCON.getEDG2SEL : TBits_4; inline;
begin
  getEDG2SEL := (pTDefRegMap(@Self)^.val and $003C0000) shr 18;
end;
procedure TCMP_CTMUCON.setEDG2POL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TCMP_CTMUCON.clearEDG2POL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TCMP_CTMUCON.setEDG2POL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TCMP_CTMUCON.getEDG2POL : TBits_1; inline;
begin
  getEDG2POL := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TCMP_CTMUCON.setEDG2MOD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TCMP_CTMUCON.clearEDG2MOD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TCMP_CTMUCON.setEDG2MOD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TCMP_CTMUCON.getEDG2MOD : TBits_1; inline;
begin
  getEDG2MOD := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TCMP_CTMUCON.setEDG1STAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCMP_CTMUCON.clearEDG1STAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCMP_CTMUCON.setEDG1STAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCMP_CTMUCON.getEDG1STAT : TBits_1; inline;
begin
  getEDG1STAT := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCMP_CTMUCON.setEDG2STAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCMP_CTMUCON.clearEDG2STAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCMP_CTMUCON.setEDG2STAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCMP_CTMUCON.getEDG2STAT : TBits_1; inline;
begin
  getEDG2STAT := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCMP_CTMUCON.setEDG1SEL(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $C3FFFFFF or ( thebits shl 26 );
end;
function  TCMP_CTMUCON.getEDG1SEL : TBits_4; inline;
begin
  getEDG1SEL := (pTDefRegMap(@Self)^.val and $3C000000) shr 26;
end;
procedure TCMP_CTMUCON.setEDG1POL; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TCMP_CTMUCON.clearEDG1POL; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TCMP_CTMUCON.setEDG1POL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TCMP_CTMUCON.getEDG1POL : TBits_1; inline;
begin
  getEDG1POL := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TCMP_CTMUCON.setEDG1MOD; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TCMP_CTMUCON.clearEDG1MOD; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TCMP_CTMUCON.setEDG1MOD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TCMP_CTMUCON.getEDG1MOD : TBits_1; inline;
begin
  getEDG1MOD := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TCMP_CTMUCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCMP_CTMUCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOSC_OSCCON.setOSWEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOSC_OSCCON.clearOSWEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOSC_OSCCON.setOSWEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOSC_OSCCON.getOSWEN : TBits_1; inline;
begin
  getOSWEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOSC_OSCCON.setSOSCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOSC_OSCCON.clearSOSCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOSC_OSCCON.setSOSCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOSC_OSCCON.getSOSCEN : TBits_1; inline;
begin
  getSOSCEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOSC_OSCCON.setUFRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOSC_OSCCON.clearUFRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOSC_OSCCON.setUFRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOSC_OSCCON.getUFRCEN : TBits_1; inline;
begin
  getUFRCEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOSC_OSCCON.setCF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOSC_OSCCON.clearCF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOSC_OSCCON.setCF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOSC_OSCCON.getCF : TBits_1; inline;
begin
  getCF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOSC_OSCCON.setSLPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOSC_OSCCON.clearSLPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOSC_OSCCON.setSLPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOSC_OSCCON.getSLPEN : TBits_1; inline;
begin
  getSLPEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOSC_OSCCON.setSLOCK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOSC_OSCCON.clearSLOCK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOSC_OSCCON.setSLOCK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOSC_OSCCON.getSLOCK : TBits_1; inline;
begin
  getSLOCK := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOSC_OSCCON.setULOCK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TOSC_OSCCON.clearULOCK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TOSC_OSCCON.setULOCK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TOSC_OSCCON.getULOCK : TBits_1; inline;
begin
  getULOCK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TOSC_OSCCON.setCLKLOCK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TOSC_OSCCON.clearCLKLOCK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TOSC_OSCCON.setCLKLOCK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TOSC_OSCCON.getCLKLOCK : TBits_1; inline;
begin
  getCLKLOCK := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TOSC_OSCCON.setNOSC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF8FF or ( thebits shl 8 );
end;
function  TOSC_OSCCON.getNOSC : TBits_3; inline;
begin
  getNOSC := (pTDefRegMap(@Self)^.val and $00000700) shr 8;
end;
procedure TOSC_OSCCON.setCOSC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF8FFF or ( thebits shl 12 );
end;
function  TOSC_OSCCON.getCOSC : TBits_3; inline;
begin
  getCOSC := (pTDefRegMap(@Self)^.val and $00007000) shr 12;
end;
procedure TOSC_OSCCON.setPLLMULT(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF8FFFF or ( thebits shl 16 );
end;
function  TOSC_OSCCON.getPLLMULT : TBits_3; inline;
begin
  getPLLMULT := (pTDefRegMap(@Self)^.val and $00070000) shr 16;
end;
procedure TOSC_OSCCON.setPBDIV(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE7FFFF or ( thebits shl 19 );
end;
function  TOSC_OSCCON.getPBDIV : TBits_2; inline;
begin
  getPBDIV := (pTDefRegMap(@Self)^.val and $00180000) shr 19;
end;
procedure TOSC_OSCCON.setPBDIVRDY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TOSC_OSCCON.clearPBDIVRDY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TOSC_OSCCON.setPBDIVRDY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TOSC_OSCCON.getPBDIVRDY : TBits_1; inline;
begin
  getPBDIVRDY := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TOSC_OSCCON.setSOSCRDY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TOSC_OSCCON.clearSOSCRDY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TOSC_OSCCON.setSOSCRDY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TOSC_OSCCON.getSOSCRDY : TBits_1; inline;
begin
  getSOSCRDY := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TOSC_OSCCON.setFRCDIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TOSC_OSCCON.getFRCDIV : TBits_3; inline;
begin
  getFRCDIV := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TOSC_OSCCON.setPLLODIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $C7FFFFFF or ( thebits shl 27 );
end;
function  TOSC_OSCCON.getPLLODIV : TBits_3; inline;
begin
  getPLLODIV := (pTDefRegMap(@Self)^.val and $38000000) shr 27;
end;
procedure TOSC_OSCCON.setNOSC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TOSC_OSCCON.clearNOSC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TOSC_OSCCON.setNOSC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TOSC_OSCCON.getNOSC0 : TBits_1; inline;
begin
  getNOSC0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TOSC_OSCCON.setNOSC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TOSC_OSCCON.clearNOSC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TOSC_OSCCON.setNOSC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TOSC_OSCCON.getNOSC1 : TBits_1; inline;
begin
  getNOSC1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TOSC_OSCCON.setNOSC2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TOSC_OSCCON.clearNOSC2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TOSC_OSCCON.setNOSC2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TOSC_OSCCON.getNOSC2 : TBits_1; inline;
begin
  getNOSC2 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TOSC_OSCCON.setCOSC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TOSC_OSCCON.clearCOSC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TOSC_OSCCON.setCOSC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TOSC_OSCCON.getCOSC0 : TBits_1; inline;
begin
  getCOSC0 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TOSC_OSCCON.setCOSC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOSC_OSCCON.clearCOSC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOSC_OSCCON.setCOSC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOSC_OSCCON.getCOSC1 : TBits_1; inline;
begin
  getCOSC1 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOSC_OSCCON.setCOSC2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TOSC_OSCCON.clearCOSC2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TOSC_OSCCON.setCOSC2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TOSC_OSCCON.getCOSC2 : TBits_1; inline;
begin
  getCOSC2 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TOSC_OSCCON.setPLLMULT0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TOSC_OSCCON.clearPLLMULT0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TOSC_OSCCON.setPLLMULT0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TOSC_OSCCON.getPLLMULT0 : TBits_1; inline;
begin
  getPLLMULT0 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TOSC_OSCCON.setPLLMULT1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TOSC_OSCCON.clearPLLMULT1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TOSC_OSCCON.setPLLMULT1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TOSC_OSCCON.getPLLMULT1 : TBits_1; inline;
begin
  getPLLMULT1 := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TOSC_OSCCON.setPLLMULT2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TOSC_OSCCON.clearPLLMULT2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TOSC_OSCCON.setPLLMULT2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TOSC_OSCCON.getPLLMULT2 : TBits_1; inline;
begin
  getPLLMULT2 := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TOSC_OSCCON.setPBDIV0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TOSC_OSCCON.clearPBDIV0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TOSC_OSCCON.setPBDIV0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TOSC_OSCCON.getPBDIV0 : TBits_1; inline;
begin
  getPBDIV0 := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TOSC_OSCCON.setPBDIV1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TOSC_OSCCON.clearPBDIV1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TOSC_OSCCON.setPBDIV1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TOSC_OSCCON.getPBDIV1 : TBits_1; inline;
begin
  getPBDIV1 := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TOSC_OSCCON.setFRCDIV0; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TOSC_OSCCON.clearFRCDIV0; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TOSC_OSCCON.setFRCDIV0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TOSC_OSCCON.getFRCDIV0 : TBits_1; inline;
begin
  getFRCDIV0 := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TOSC_OSCCON.setFRCDIV1; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TOSC_OSCCON.clearFRCDIV1; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TOSC_OSCCON.setFRCDIV1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TOSC_OSCCON.getFRCDIV1 : TBits_1; inline;
begin
  getFRCDIV1 := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TOSC_OSCCON.setFRCDIV2; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TOSC_OSCCON.clearFRCDIV2; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TOSC_OSCCON.setFRCDIV2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TOSC_OSCCON.getFRCDIV2 : TBits_1; inline;
begin
  getFRCDIV2 := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TOSC_OSCCON.setPLLODIV0; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TOSC_OSCCON.clearPLLODIV0; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TOSC_OSCCON.setPLLODIV0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TOSC_OSCCON.getPLLODIV0 : TBits_1; inline;
begin
  getPLLODIV0 := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TOSC_OSCCON.setPLLODIV1; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TOSC_OSCCON.clearPLLODIV1; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TOSC_OSCCON.setPLLODIV1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TOSC_OSCCON.getPLLODIV1 : TBits_1; inline;
begin
  getPLLODIV1 := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TOSC_OSCCON.setPLLODIV2; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TOSC_OSCCON.clearPLLODIV2; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TOSC_OSCCON.setPLLODIV2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TOSC_OSCCON.getPLLODIV2 : TBits_1; inline;
begin
  getPLLODIV2 := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TOSC_OSCCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOSC_OSCCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOSC_OSCTUN.setTUN(thebits : TBits_6); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFC0 or ( thebits shl 0 );
end;
function  TOSC_OSCTUN.getTUN : TBits_6; inline;
begin
  getTUN := (pTDefRegMap(@Self)^.val and $0000003F) shr 0;
end;
procedure TOSC_OSCTUN.setTUN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOSC_OSCTUN.clearTUN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOSC_OSCTUN.setTUN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOSC_OSCTUN.getTUN0 : TBits_1; inline;
begin
  getTUN0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOSC_OSCTUN.setTUN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOSC_OSCTUN.clearTUN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOSC_OSCTUN.setTUN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOSC_OSCTUN.getTUN1 : TBits_1; inline;
begin
  getTUN1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOSC_OSCTUN.setTUN2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOSC_OSCTUN.clearTUN2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOSC_OSCTUN.setTUN2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOSC_OSCTUN.getTUN2 : TBits_1; inline;
begin
  getTUN2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOSC_OSCTUN.setTUN3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOSC_OSCTUN.clearTUN3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOSC_OSCTUN.setTUN3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOSC_OSCTUN.getTUN3 : TBits_1; inline;
begin
  getTUN3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOSC_OSCTUN.setTUN4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOSC_OSCTUN.clearTUN4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOSC_OSCTUN.setTUN4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOSC_OSCTUN.getTUN4 : TBits_1; inline;
begin
  getTUN4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOSC_OSCTUN.setTUN5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOSC_OSCTUN.clearTUN5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOSC_OSCTUN.setTUN5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOSC_OSCTUN.getTUN5 : TBits_1; inline;
begin
  getTUN5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOSC_OSCTUN.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOSC_OSCTUN.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOSC_REFOCON.setROSEL(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TOSC_REFOCON.getROSEL : TBits_4; inline;
begin
  getROSEL := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TOSC_REFOCON.setACTIVE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TOSC_REFOCON.clearACTIVE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TOSC_REFOCON.setACTIVE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TOSC_REFOCON.getACTIVE : TBits_1; inline;
begin
  getACTIVE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TOSC_REFOCON.setDIVSWEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TOSC_REFOCON.clearDIVSWEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TOSC_REFOCON.setDIVSWEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TOSC_REFOCON.getDIVSWEN : TBits_1; inline;
begin
  getDIVSWEN := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TOSC_REFOCON.setRSLP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TOSC_REFOCON.clearRSLP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TOSC_REFOCON.setRSLP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TOSC_REFOCON.getRSLP : TBits_1; inline;
begin
  getRSLP := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TOSC_REFOCON.setOE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TOSC_REFOCON.clearOE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TOSC_REFOCON.setOE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TOSC_REFOCON.getOE : TBits_1; inline;
begin
  getOE := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TOSC_REFOCON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOSC_REFOCON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOSC_REFOCON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOSC_REFOCON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOSC_REFOCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOSC_REFOCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOSC_REFOCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOSC_REFOCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOSC_REFOCON.setRODIV(thebits : TBits_15); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $8000FFFF or ( thebits shl 16 );
end;
function  TOSC_REFOCON.getRODIV : TBits_15; inline;
begin
  getRODIV := (pTDefRegMap(@Self)^.val and $7FFF0000) shr 16;
end;
procedure TOSC_REFOCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOSC_REFOCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOSC_REFOTRIM.setROTRIM(thebits : TBits_9); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $007FFFFF or ( thebits shl 23 );
end;
function  TOSC_REFOTRIM.getROTRIM : TBits_9; inline;
begin
  getROTRIM := (pTDefRegMap(@Self)^.val and $FF800000) shr 23;
end;
procedure TOSC_REFOTRIM.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOSC_REFOTRIM.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TNVM_NVMCON.setNVMOP(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TNVM_NVMCON.getNVMOP : TBits_4; inline;
begin
  getNVMOP := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TNVM_NVMCON.setLVDSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TNVM_NVMCON.clearLVDSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TNVM_NVMCON.setLVDSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TNVM_NVMCON.getLVDSTAT : TBits_1; inline;
begin
  getLVDSTAT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TNVM_NVMCON.setLVDERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TNVM_NVMCON.clearLVDERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TNVM_NVMCON.setLVDERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TNVM_NVMCON.getLVDERR : TBits_1; inline;
begin
  getLVDERR := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TNVM_NVMCON.setWRERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TNVM_NVMCON.clearWRERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TNVM_NVMCON.setWRERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TNVM_NVMCON.getWRERR : TBits_1; inline;
begin
  getWRERR := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TNVM_NVMCON.setWREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TNVM_NVMCON.clearWREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TNVM_NVMCON.setWREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TNVM_NVMCON.getWREN : TBits_1; inline;
begin
  getWREN := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TNVM_NVMCON.setWR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TNVM_NVMCON.clearWR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TNVM_NVMCON.setWR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TNVM_NVMCON.getWR : TBits_1; inline;
begin
  getWR := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TNVM_NVMCON.setNVMOP0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TNVM_NVMCON.clearNVMOP0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TNVM_NVMCON.setNVMOP0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TNVM_NVMCON.getNVMOP0 : TBits_1; inline;
begin
  getNVMOP0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TNVM_NVMCON.setNVMOP1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TNVM_NVMCON.clearNVMOP1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TNVM_NVMCON.setNVMOP1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TNVM_NVMCON.getNVMOP1 : TBits_1; inline;
begin
  getNVMOP1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TNVM_NVMCON.setNVMOP2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TNVM_NVMCON.clearNVMOP2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TNVM_NVMCON.setNVMOP2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TNVM_NVMCON.getNVMOP2 : TBits_1; inline;
begin
  getNVMOP2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TNVM_NVMCON.setNVMOP3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TNVM_NVMCON.clearNVMOP3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TNVM_NVMCON.setNVMOP3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TNVM_NVMCON.getNVMOP3 : TBits_1; inline;
begin
  getNVMOP3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TNVM_NVMCON.setPROGOP(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TNVM_NVMCON.getPROGOP : TBits_4; inline;
begin
  getPROGOP := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TNVM_NVMCON.setPROGOP0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TNVM_NVMCON.clearPROGOP0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TNVM_NVMCON.setPROGOP0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TNVM_NVMCON.getPROGOP0 : TBits_1; inline;
begin
  getPROGOP0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TNVM_NVMCON.setPROGOP1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TNVM_NVMCON.clearPROGOP1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TNVM_NVMCON.setPROGOP1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TNVM_NVMCON.getPROGOP1 : TBits_1; inline;
begin
  getPROGOP1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TNVM_NVMCON.setPROGOP2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TNVM_NVMCON.clearPROGOP2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TNVM_NVMCON.setPROGOP2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TNVM_NVMCON.getPROGOP2 : TBits_1; inline;
begin
  getPROGOP2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TNVM_NVMCON.setPROGOP3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TNVM_NVMCON.clearPROGOP3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TNVM_NVMCON.setPROGOP3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TNVM_NVMCON.getPROGOP3 : TBits_1; inline;
begin
  getPROGOP3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TNVM_NVMCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TNVM_NVMCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRCON_RCON.setPOR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TRCON_RCON.clearPOR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TRCON_RCON.setPOR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TRCON_RCON.getPOR : TBits_1; inline;
begin
  getPOR := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TRCON_RCON.setBOR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TRCON_RCON.clearBOR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TRCON_RCON.setBOR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TRCON_RCON.getBOR : TBits_1; inline;
begin
  getBOR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TRCON_RCON.setIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TRCON_RCON.clearIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TRCON_RCON.setIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TRCON_RCON.getIDLE : TBits_1; inline;
begin
  getIDLE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TRCON_RCON.setSLEEP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TRCON_RCON.clearSLEEP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TRCON_RCON.setSLEEP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TRCON_RCON.getSLEEP : TBits_1; inline;
begin
  getSLEEP := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TRCON_RCON.setWDTO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TRCON_RCON.clearWDTO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TRCON_RCON.setWDTO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TRCON_RCON.getWDTO : TBits_1; inline;
begin
  getWDTO := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TRCON_RCON.setSWR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TRCON_RCON.clearSWR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TRCON_RCON.setSWR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TRCON_RCON.getSWR : TBits_1; inline;
begin
  getSWR := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TRCON_RCON.setEXTR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TRCON_RCON.clearEXTR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TRCON_RCON.setEXTR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TRCON_RCON.getEXTR : TBits_1; inline;
begin
  getEXTR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TRCON_RCON.setVREGS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TRCON_RCON.clearVREGS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TRCON_RCON.setVREGS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TRCON_RCON.getVREGS : TBits_1; inline;
begin
  getVREGS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TRCON_RCON.setCMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TRCON_RCON.clearCMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TRCON_RCON.setCMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TRCON_RCON.getCMR : TBits_1; inline;
begin
  getCMR := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TRCON_RCON.setHVDR; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TRCON_RCON.clearHVDR; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TRCON_RCON.setHVDR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TRCON_RCON.getHVDR : TBits_1; inline;
begin
  getHVDR := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TRCON_RCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRCON_RCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRCON_RSWRST.setSWRST; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TRCON_RSWRST.clearSWRST; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TRCON_RSWRST.setSWRST(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TRCON_RSWRST.getSWRST : TBits_1; inline;
begin
  getSWRST := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TRCON_RSWRST.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRCON_RSWRST.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_INTCON.setINT0EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_INTCON.clearINT0EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_INTCON.setINT0EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_INTCON.getINT0EP : TBits_1; inline;
begin
  getINT0EP := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_INTCON.setINT1EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_INTCON.clearINT1EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_INTCON.setINT1EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_INTCON.getINT1EP : TBits_1; inline;
begin
  getINT1EP := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_INTCON.setINT2EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_INTCON.clearINT2EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_INTCON.setINT2EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_INTCON.getINT2EP : TBits_1; inline;
begin
  getINT2EP := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_INTCON.setINT3EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_INTCON.clearINT3EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_INTCON.setINT3EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_INTCON.getINT3EP : TBits_1; inline;
begin
  getINT3EP := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_INTCON.setINT4EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_INTCON.clearINT4EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_INTCON.setINT4EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_INTCON.getINT4EP : TBits_1; inline;
begin
  getINT4EP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_INTCON.setTPC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF8FF or ( thebits shl 8 );
end;
function  TINT_INTCON.getTPC : TBits_3; inline;
begin
  getTPC := (pTDefRegMap(@Self)^.val and $00000700) shr 8;
end;
procedure TINT_INTCON.setMVEC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TINT_INTCON.clearMVEC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TINT_INTCON.setMVEC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TINT_INTCON.getMVEC : TBits_1; inline;
begin
  getMVEC := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TINT_INTCON.setSS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_INTCON.clearSS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_INTCON.setSS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_INTCON.getSS0 : TBits_1; inline;
begin
  getSS0 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_INTCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_INTCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IFS0.setCTIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IFS0.clearCTIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IFS0.setCTIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IFS0.getCTIF : TBits_1; inline;
begin
  getCTIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IFS0.setCS0IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IFS0.clearCS0IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IFS0.setCS0IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IFS0.getCS0IF : TBits_1; inline;
begin
  getCS0IF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IFS0.setCS1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IFS0.clearCS1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IFS0.setCS1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IFS0.getCS1IF : TBits_1; inline;
begin
  getCS1IF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IFS0.setINT0IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IFS0.clearINT0IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IFS0.setINT0IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IFS0.getINT0IF : TBits_1; inline;
begin
  getINT0IF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IFS0.setT1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IFS0.clearT1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IFS0.setT1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IFS0.getT1IF : TBits_1; inline;
begin
  getT1IF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IFS0.setIC1EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IFS0.clearIC1EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IFS0.setIC1EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IFS0.getIC1EIF : TBits_1; inline;
begin
  getIC1EIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IFS0.setIC1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IFS0.clearIC1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IFS0.setIC1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IFS0.getIC1IF : TBits_1; inline;
begin
  getIC1IF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IFS0.setOC1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IFS0.clearOC1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IFS0.setOC1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IFS0.getOC1IF : TBits_1; inline;
begin
  getOC1IF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IFS0.setINT1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IFS0.clearINT1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IFS0.setINT1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IFS0.getINT1IF : TBits_1; inline;
begin
  getINT1IF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IFS0.setT2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IFS0.clearT2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IFS0.setT2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IFS0.getT2IF : TBits_1; inline;
begin
  getT2IF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IFS0.setIC2EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IFS0.clearIC2EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IFS0.setIC2EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IFS0.getIC2EIF : TBits_1; inline;
begin
  getIC2EIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IFS0.setIC2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IFS0.clearIC2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IFS0.setIC2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IFS0.getIC2IF : TBits_1; inline;
begin
  getIC2IF := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IFS0.setOC2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TINT_IFS0.clearOC2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TINT_IFS0.setOC2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TINT_IFS0.getOC2IF : TBits_1; inline;
begin
  getOC2IF := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TINT_IFS0.setINT2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TINT_IFS0.clearINT2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TINT_IFS0.setINT2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TINT_IFS0.getINT2IF : TBits_1; inline;
begin
  getINT2IF := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TINT_IFS0.setT3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TINT_IFS0.clearT3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TINT_IFS0.setT3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TINT_IFS0.getT3IF : TBits_1; inline;
begin
  getT3IF := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TINT_IFS0.setIC3EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TINT_IFS0.clearIC3EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TINT_IFS0.setIC3EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TINT_IFS0.getIC3EIF : TBits_1; inline;
begin
  getIC3EIF := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TINT_IFS0.setIC3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_IFS0.clearIC3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_IFS0.setIC3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_IFS0.getIC3IF : TBits_1; inline;
begin
  getIC3IF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_IFS0.setOC3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TINT_IFS0.clearOC3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TINT_IFS0.setOC3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TINT_IFS0.getOC3IF : TBits_1; inline;
begin
  getOC3IF := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TINT_IFS0.setINT3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TINT_IFS0.clearINT3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TINT_IFS0.setINT3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TINT_IFS0.getINT3IF : TBits_1; inline;
begin
  getINT3IF := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TINT_IFS0.setT4IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TINT_IFS0.clearT4IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TINT_IFS0.setT4IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TINT_IFS0.getT4IF : TBits_1; inline;
begin
  getT4IF := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TINT_IFS0.setIC4EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TINT_IFS0.clearIC4EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TINT_IFS0.setIC4EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TINT_IFS0.getIC4EIF : TBits_1; inline;
begin
  getIC4EIF := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TINT_IFS0.setIC4IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TINT_IFS0.clearIC4IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TINT_IFS0.setIC4IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TINT_IFS0.getIC4IF : TBits_1; inline;
begin
  getIC4IF := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TINT_IFS0.setOC4IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TINT_IFS0.clearOC4IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TINT_IFS0.setOC4IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TINT_IFS0.getOC4IF : TBits_1; inline;
begin
  getOC4IF := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TINT_IFS0.setINT4IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TINT_IFS0.clearINT4IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TINT_IFS0.setINT4IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TINT_IFS0.getINT4IF : TBits_1; inline;
begin
  getINT4IF := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TINT_IFS0.setT5IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TINT_IFS0.clearT5IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TINT_IFS0.setT5IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TINT_IFS0.getT5IF : TBits_1; inline;
begin
  getT5IF := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TINT_IFS0.setIC5EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TINT_IFS0.clearIC5EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TINT_IFS0.setIC5EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TINT_IFS0.getIC5EIF : TBits_1; inline;
begin
  getIC5EIF := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TINT_IFS0.setIC5IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IFS0.clearIC5IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IFS0.setIC5IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IFS0.getIC5IF : TBits_1; inline;
begin
  getIC5IF := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IFS0.setOC5IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IFS0.clearOC5IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IFS0.setOC5IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IFS0.getOC5IF : TBits_1; inline;
begin
  getOC5IF := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IFS0.setAD1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IFS0.clearAD1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IFS0.setAD1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IFS0.getAD1IF : TBits_1; inline;
begin
  getAD1IF := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IFS0.setFSCMIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TINT_IFS0.clearFSCMIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TINT_IFS0.setFSCMIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TINT_IFS0.getFSCMIF : TBits_1; inline;
begin
  getFSCMIF := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TINT_IFS0.setRTCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TINT_IFS0.clearRTCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TINT_IFS0.setRTCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TINT_IFS0.getRTCCIF : TBits_1; inline;
begin
  getRTCCIF := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TINT_IFS0.setFCEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TINT_IFS0.clearFCEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TINT_IFS0.setFCEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TINT_IFS0.getFCEIF : TBits_1; inline;
begin
  getFCEIF := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TINT_IFS0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IFS0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IFS1.setCMP1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IFS1.clearCMP1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IFS1.setCMP1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IFS1.getCMP1IF : TBits_1; inline;
begin
  getCMP1IF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IFS1.setCMP2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IFS1.clearCMP2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IFS1.setCMP2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IFS1.getCMP2IF : TBits_1; inline;
begin
  getCMP2IF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IFS1.setUSBIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IFS1.clearUSBIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IFS1.setUSBIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IFS1.getUSBIF : TBits_1; inline;
begin
  getUSBIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IFS1.setSPI1EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IFS1.clearSPI1EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IFS1.setSPI1EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IFS1.getSPI1EIF : TBits_1; inline;
begin
  getSPI1EIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IFS1.setSPI1RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IFS1.clearSPI1RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IFS1.setSPI1RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IFS1.getSPI1RXIF : TBits_1; inline;
begin
  getSPI1RXIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IFS1.setSPI1TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IFS1.clearSPI1TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IFS1.setSPI1TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IFS1.getSPI1TXIF : TBits_1; inline;
begin
  getSPI1TXIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IFS1.setU1EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IFS1.clearU1EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IFS1.setU1EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IFS1.getU1EIF : TBits_1; inline;
begin
  getU1EIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IFS1.setU1RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IFS1.clearU1RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IFS1.setU1RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IFS1.getU1RXIF : TBits_1; inline;
begin
  getU1RXIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IFS1.setU1TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IFS1.clearU1TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IFS1.setU1TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IFS1.getU1TXIF : TBits_1; inline;
begin
  getU1TXIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IFS1.setI2C1BIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IFS1.clearI2C1BIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IFS1.setI2C1BIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IFS1.getI2C1BIF : TBits_1; inline;
begin
  getI2C1BIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IFS1.setI2C1SIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IFS1.clearI2C1SIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IFS1.setI2C1SIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IFS1.getI2C1SIF : TBits_1; inline;
begin
  getI2C1SIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IFS1.setI2C1MIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IFS1.clearI2C1MIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IFS1.setI2C1MIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IFS1.getI2C1MIF : TBits_1; inline;
begin
  getI2C1MIF := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IFS1.setCNAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TINT_IFS1.clearCNAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TINT_IFS1.setCNAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TINT_IFS1.getCNAIF : TBits_1; inline;
begin
  getCNAIF := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TINT_IFS1.setCNBIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TINT_IFS1.clearCNBIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TINT_IFS1.setCNBIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TINT_IFS1.getCNBIF : TBits_1; inline;
begin
  getCNBIF := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TINT_IFS1.setCNCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TINT_IFS1.clearCNCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TINT_IFS1.setCNCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TINT_IFS1.getCNCIF : TBits_1; inline;
begin
  getCNCIF := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TINT_IFS1.setCNDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TINT_IFS1.clearCNDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TINT_IFS1.setCNDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TINT_IFS1.getCNDIF : TBits_1; inline;
begin
  getCNDIF := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TINT_IFS1.setCNEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_IFS1.clearCNEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_IFS1.setCNEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_IFS1.getCNEIF : TBits_1; inline;
begin
  getCNEIF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_IFS1.setCNFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TINT_IFS1.clearCNFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TINT_IFS1.setCNFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TINT_IFS1.getCNFIF : TBits_1; inline;
begin
  getCNFIF := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TINT_IFS1.setCNGIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TINT_IFS1.clearCNGIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TINT_IFS1.setCNGIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TINT_IFS1.getCNGIF : TBits_1; inline;
begin
  getCNGIF := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TINT_IFS1.setPMPIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TINT_IFS1.clearPMPIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TINT_IFS1.setPMPIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TINT_IFS1.getPMPIF : TBits_1; inline;
begin
  getPMPIF := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TINT_IFS1.setPMPEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TINT_IFS1.clearPMPEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TINT_IFS1.setPMPEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TINT_IFS1.getPMPEIF : TBits_1; inline;
begin
  getPMPEIF := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TINT_IFS1.setSPI2EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TINT_IFS1.clearSPI2EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TINT_IFS1.setSPI2EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TINT_IFS1.getSPI2EIF : TBits_1; inline;
begin
  getSPI2EIF := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TINT_IFS1.setSPI2RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TINT_IFS1.clearSPI2RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TINT_IFS1.setSPI2RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TINT_IFS1.getSPI2RXIF : TBits_1; inline;
begin
  getSPI2RXIF := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TINT_IFS1.setSPI2TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TINT_IFS1.clearSPI2TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TINT_IFS1.setSPI2TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TINT_IFS1.getSPI2TXIF : TBits_1; inline;
begin
  getSPI2TXIF := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TINT_IFS1.setU2EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TINT_IFS1.clearU2EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TINT_IFS1.setU2EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TINT_IFS1.getU2EIF : TBits_1; inline;
begin
  getU2EIF := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TINT_IFS1.setU2RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TINT_IFS1.clearU2RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TINT_IFS1.setU2RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TINT_IFS1.getU2RXIF : TBits_1; inline;
begin
  getU2RXIF := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TINT_IFS1.setU2TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IFS1.clearU2TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IFS1.setU2TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IFS1.getU2TXIF : TBits_1; inline;
begin
  getU2TXIF := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IFS1.setI2C2BIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IFS1.clearI2C2BIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IFS1.setI2C2BIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IFS1.getI2C2BIF : TBits_1; inline;
begin
  getI2C2BIF := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IFS1.setI2C2SIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IFS1.clearI2C2SIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IFS1.setI2C2SIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IFS1.getI2C2SIF : TBits_1; inline;
begin
  getI2C2SIF := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IFS1.setI2C2MIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TINT_IFS1.clearI2C2MIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TINT_IFS1.setI2C2MIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TINT_IFS1.getI2C2MIF : TBits_1; inline;
begin
  getI2C2MIF := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TINT_IFS1.setU3EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TINT_IFS1.clearU3EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TINT_IFS1.setU3EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TINT_IFS1.getU3EIF : TBits_1; inline;
begin
  getU3EIF := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TINT_IFS1.setU3RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TINT_IFS1.clearU3RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TINT_IFS1.setU3RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TINT_IFS1.getU3RXIF : TBits_1; inline;
begin
  getU3RXIF := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TINT_IFS1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IFS1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IEC0.setCTIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IEC0.clearCTIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IEC0.setCTIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IEC0.getCTIE : TBits_1; inline;
begin
  getCTIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IEC0.setCS0IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IEC0.clearCS0IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IEC0.setCS0IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IEC0.getCS0IE : TBits_1; inline;
begin
  getCS0IE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IEC0.setCS1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IEC0.clearCS1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IEC0.setCS1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IEC0.getCS1IE : TBits_1; inline;
begin
  getCS1IE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IEC0.setINT0IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IEC0.clearINT0IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IEC0.setINT0IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IEC0.getINT0IE : TBits_1; inline;
begin
  getINT0IE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IEC0.setT1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IEC0.clearT1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IEC0.setT1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IEC0.getT1IE : TBits_1; inline;
begin
  getT1IE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IEC0.setIC1EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IEC0.clearIC1EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IEC0.setIC1EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IEC0.getIC1EIE : TBits_1; inline;
begin
  getIC1EIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IEC0.setIC1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IEC0.clearIC1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IEC0.setIC1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IEC0.getIC1IE : TBits_1; inline;
begin
  getIC1IE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IEC0.setOC1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IEC0.clearOC1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IEC0.setOC1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IEC0.getOC1IE : TBits_1; inline;
begin
  getOC1IE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IEC0.setINT1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IEC0.clearINT1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IEC0.setINT1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IEC0.getINT1IE : TBits_1; inline;
begin
  getINT1IE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IEC0.setT2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IEC0.clearT2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IEC0.setT2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IEC0.getT2IE : TBits_1; inline;
begin
  getT2IE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IEC0.setIC2EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IEC0.clearIC2EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IEC0.setIC2EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IEC0.getIC2EIE : TBits_1; inline;
begin
  getIC2EIE := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IEC0.setIC2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IEC0.clearIC2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IEC0.setIC2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IEC0.getIC2IE : TBits_1; inline;
begin
  getIC2IE := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IEC0.setOC2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TINT_IEC0.clearOC2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TINT_IEC0.setOC2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TINT_IEC0.getOC2IE : TBits_1; inline;
begin
  getOC2IE := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TINT_IEC0.setINT2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TINT_IEC0.clearINT2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TINT_IEC0.setINT2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TINT_IEC0.getINT2IE : TBits_1; inline;
begin
  getINT2IE := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TINT_IEC0.setT3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TINT_IEC0.clearT3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TINT_IEC0.setT3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TINT_IEC0.getT3IE : TBits_1; inline;
begin
  getT3IE := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TINT_IEC0.setIC3EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TINT_IEC0.clearIC3EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TINT_IEC0.setIC3EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TINT_IEC0.getIC3EIE : TBits_1; inline;
begin
  getIC3EIE := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TINT_IEC0.setIC3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_IEC0.clearIC3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_IEC0.setIC3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_IEC0.getIC3IE : TBits_1; inline;
begin
  getIC3IE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_IEC0.setOC3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TINT_IEC0.clearOC3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TINT_IEC0.setOC3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TINT_IEC0.getOC3IE : TBits_1; inline;
begin
  getOC3IE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TINT_IEC0.setINT3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TINT_IEC0.clearINT3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TINT_IEC0.setINT3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TINT_IEC0.getINT3IE : TBits_1; inline;
begin
  getINT3IE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TINT_IEC0.setT4IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TINT_IEC0.clearT4IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TINT_IEC0.setT4IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TINT_IEC0.getT4IE : TBits_1; inline;
begin
  getT4IE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TINT_IEC0.setIC4EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TINT_IEC0.clearIC4EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TINT_IEC0.setIC4EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TINT_IEC0.getIC4EIE : TBits_1; inline;
begin
  getIC4EIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TINT_IEC0.setIC4IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TINT_IEC0.clearIC4IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TINT_IEC0.setIC4IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TINT_IEC0.getIC4IE : TBits_1; inline;
begin
  getIC4IE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TINT_IEC0.setOC4IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TINT_IEC0.clearOC4IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TINT_IEC0.setOC4IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TINT_IEC0.getOC4IE : TBits_1; inline;
begin
  getOC4IE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TINT_IEC0.setINT4IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TINT_IEC0.clearINT4IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TINT_IEC0.setINT4IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TINT_IEC0.getINT4IE : TBits_1; inline;
begin
  getINT4IE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TINT_IEC0.setT5IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TINT_IEC0.clearT5IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TINT_IEC0.setT5IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TINT_IEC0.getT5IE : TBits_1; inline;
begin
  getT5IE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TINT_IEC0.setIC5EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TINT_IEC0.clearIC5EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TINT_IEC0.setIC5EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TINT_IEC0.getIC5EIE : TBits_1; inline;
begin
  getIC5EIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TINT_IEC0.setIC5IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IEC0.clearIC5IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IEC0.setIC5IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IEC0.getIC5IE : TBits_1; inline;
begin
  getIC5IE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IEC0.setOC5IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IEC0.clearOC5IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IEC0.setOC5IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IEC0.getOC5IE : TBits_1; inline;
begin
  getOC5IE := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IEC0.setAD1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IEC0.clearAD1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IEC0.setAD1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IEC0.getAD1IE : TBits_1; inline;
begin
  getAD1IE := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IEC0.setFSCMIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TINT_IEC0.clearFSCMIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TINT_IEC0.setFSCMIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TINT_IEC0.getFSCMIE : TBits_1; inline;
begin
  getFSCMIE := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TINT_IEC0.setRTCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TINT_IEC0.clearRTCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TINT_IEC0.setRTCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TINT_IEC0.getRTCCIE : TBits_1; inline;
begin
  getRTCCIE := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TINT_IEC0.setFCEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TINT_IEC0.clearFCEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TINT_IEC0.setFCEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TINT_IEC0.getFCEIE : TBits_1; inline;
begin
  getFCEIE := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TINT_IEC0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IEC0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IEC1.setCMP1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IEC1.clearCMP1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IEC1.setCMP1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IEC1.getCMP1IE : TBits_1; inline;
begin
  getCMP1IE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IEC1.setCMP2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IEC1.clearCMP2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IEC1.setCMP2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IEC1.getCMP2IE : TBits_1; inline;
begin
  getCMP2IE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IEC1.setUSBIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IEC1.clearUSBIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IEC1.setUSBIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IEC1.getUSBIE : TBits_1; inline;
begin
  getUSBIE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IEC1.setSPI1EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IEC1.clearSPI1EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IEC1.setSPI1EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IEC1.getSPI1EIE : TBits_1; inline;
begin
  getSPI1EIE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IEC1.setSPI1RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IEC1.clearSPI1RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IEC1.setSPI1RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IEC1.getSPI1RXIE : TBits_1; inline;
begin
  getSPI1RXIE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IEC1.setSPI1TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IEC1.clearSPI1TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IEC1.setSPI1TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IEC1.getSPI1TXIE : TBits_1; inline;
begin
  getSPI1TXIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IEC1.setU1EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IEC1.clearU1EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IEC1.setU1EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IEC1.getU1EIE : TBits_1; inline;
begin
  getU1EIE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IEC1.setU1RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IEC1.clearU1RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IEC1.setU1RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IEC1.getU1RXIE : TBits_1; inline;
begin
  getU1RXIE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IEC1.setU1TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IEC1.clearU1TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IEC1.setU1TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IEC1.getU1TXIE : TBits_1; inline;
begin
  getU1TXIE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IEC1.setI2C1BIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IEC1.clearI2C1BIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IEC1.setI2C1BIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IEC1.getI2C1BIE : TBits_1; inline;
begin
  getI2C1BIE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IEC1.setI2C1SIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IEC1.clearI2C1SIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IEC1.setI2C1SIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IEC1.getI2C1SIE : TBits_1; inline;
begin
  getI2C1SIE := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IEC1.setI2C1MIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IEC1.clearI2C1MIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IEC1.setI2C1MIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IEC1.getI2C1MIE : TBits_1; inline;
begin
  getI2C1MIE := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IEC1.setCNAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TINT_IEC1.clearCNAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TINT_IEC1.setCNAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TINT_IEC1.getCNAIE : TBits_1; inline;
begin
  getCNAIE := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TINT_IEC1.setCNBIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TINT_IEC1.clearCNBIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TINT_IEC1.setCNBIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TINT_IEC1.getCNBIE : TBits_1; inline;
begin
  getCNBIE := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TINT_IEC1.setCNCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TINT_IEC1.clearCNCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TINT_IEC1.setCNCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TINT_IEC1.getCNCIE : TBits_1; inline;
begin
  getCNCIE := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TINT_IEC1.setCNDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TINT_IEC1.clearCNDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TINT_IEC1.setCNDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TINT_IEC1.getCNDIE : TBits_1; inline;
begin
  getCNDIE := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TINT_IEC1.setCNEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_IEC1.clearCNEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_IEC1.setCNEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_IEC1.getCNEIE : TBits_1; inline;
begin
  getCNEIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_IEC1.setCNFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TINT_IEC1.clearCNFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TINT_IEC1.setCNFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TINT_IEC1.getCNFIE : TBits_1; inline;
begin
  getCNFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TINT_IEC1.setCNGIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TINT_IEC1.clearCNGIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TINT_IEC1.setCNGIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TINT_IEC1.getCNGIE : TBits_1; inline;
begin
  getCNGIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TINT_IEC1.setPMPIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TINT_IEC1.clearPMPIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TINT_IEC1.setPMPIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TINT_IEC1.getPMPIE : TBits_1; inline;
begin
  getPMPIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TINT_IEC1.setPMPEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TINT_IEC1.clearPMPEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TINT_IEC1.setPMPEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TINT_IEC1.getPMPEIE : TBits_1; inline;
begin
  getPMPEIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TINT_IEC1.setSPI2EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TINT_IEC1.clearSPI2EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TINT_IEC1.setSPI2EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TINT_IEC1.getSPI2EIE : TBits_1; inline;
begin
  getSPI2EIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TINT_IEC1.setSPI2RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TINT_IEC1.clearSPI2RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TINT_IEC1.setSPI2RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TINT_IEC1.getSPI2RXIE : TBits_1; inline;
begin
  getSPI2RXIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TINT_IEC1.setSPI2TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TINT_IEC1.clearSPI2TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TINT_IEC1.setSPI2TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TINT_IEC1.getSPI2TXIE : TBits_1; inline;
begin
  getSPI2TXIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TINT_IEC1.setU2EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TINT_IEC1.clearU2EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TINT_IEC1.setU2EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TINT_IEC1.getU2EIE : TBits_1; inline;
begin
  getU2EIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TINT_IEC1.setU2RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TINT_IEC1.clearU2RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TINT_IEC1.setU2RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TINT_IEC1.getU2RXIE : TBits_1; inline;
begin
  getU2RXIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TINT_IEC1.setU2TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IEC1.clearU2TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IEC1.setU2TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IEC1.getU2TXIE : TBits_1; inline;
begin
  getU2TXIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IEC1.setI2C2BIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IEC1.clearI2C2BIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IEC1.setI2C2BIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IEC1.getI2C2BIE : TBits_1; inline;
begin
  getI2C2BIE := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IEC1.setI2C2SIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IEC1.clearI2C2SIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IEC1.setI2C2SIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IEC1.getI2C2SIE : TBits_1; inline;
begin
  getI2C2SIE := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IEC1.setI2C2MIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TINT_IEC1.clearI2C2MIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TINT_IEC1.setI2C2MIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TINT_IEC1.getI2C2MIE : TBits_1; inline;
begin
  getI2C2MIE := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TINT_IEC1.setU3EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TINT_IEC1.clearU3EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TINT_IEC1.setU3EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TINT_IEC1.getU3EIE : TBits_1; inline;
begin
  getU3EIE := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TINT_IEC1.setU3RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TINT_IEC1.clearU3RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TINT_IEC1.setU3RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TINT_IEC1.getU3RXIE : TBits_1; inline;
begin
  getU3RXIE := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TINT_IEC1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IEC1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC0.setCTIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC0.getCTIS : TBits_2; inline;
begin
  getCTIS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC0.setCTIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC0.getCTIP : TBits_3; inline;
begin
  getCTIP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC0.setCS0IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC0.getCS0IS : TBits_2; inline;
begin
  getCS0IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC0.setCS0IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC0.getCS0IP : TBits_3; inline;
begin
  getCS0IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC0.setCS1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC0.getCS1IS : TBits_2; inline;
begin
  getCS1IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC0.setCS1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC0.getCS1IP : TBits_3; inline;
begin
  getCS1IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC0.setINT0IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC0.getINT0IS : TBits_2; inline;
begin
  getINT0IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC0.setINT0IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC0.getINT0IP : TBits_3; inline;
begin
  getINT0IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC1.setT1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC1.getT1IS : TBits_2; inline;
begin
  getT1IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC1.setT1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC1.getT1IP : TBits_3; inline;
begin
  getT1IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC1.setIC1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC1.getIC1IS : TBits_2; inline;
begin
  getIC1IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC1.setIC1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC1.getIC1IP : TBits_3; inline;
begin
  getIC1IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC1.setOC1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC1.getOC1IS : TBits_2; inline;
begin
  getOC1IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC1.setOC1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC1.getOC1IP : TBits_3; inline;
begin
  getOC1IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC1.setINT1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC1.getINT1IS : TBits_2; inline;
begin
  getINT1IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC1.setINT1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC1.getINT1IP : TBits_3; inline;
begin
  getINT1IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC2.setT2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC2.getT2IS : TBits_2; inline;
begin
  getT2IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC2.setT2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC2.getT2IP : TBits_3; inline;
begin
  getT2IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC2.setIC2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC2.getIC2IS : TBits_2; inline;
begin
  getIC2IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC2.setIC2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC2.getIC2IP : TBits_3; inline;
begin
  getIC2IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC2.setOC2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC2.getOC2IS : TBits_2; inline;
begin
  getOC2IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC2.setOC2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC2.getOC2IP : TBits_3; inline;
begin
  getOC2IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC2.setINT2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC2.getINT2IS : TBits_2; inline;
begin
  getINT2IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC2.setINT2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC2.getINT2IP : TBits_3; inline;
begin
  getINT2IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC3.setT3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC3.getT3IS : TBits_2; inline;
begin
  getT3IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC3.setT3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC3.getT3IP : TBits_3; inline;
begin
  getT3IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC3.setIC3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC3.getIC3IS : TBits_2; inline;
begin
  getIC3IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC3.setIC3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC3.getIC3IP : TBits_3; inline;
begin
  getIC3IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC3.setOC3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC3.getOC3IS : TBits_2; inline;
begin
  getOC3IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC3.setOC3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC3.getOC3IP : TBits_3; inline;
begin
  getOC3IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC3.setINT3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC3.getINT3IS : TBits_2; inline;
begin
  getINT3IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC3.setINT3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC3.getINT3IP : TBits_3; inline;
begin
  getINT3IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC4.setT4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC4.getT4IS : TBits_2; inline;
begin
  getT4IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC4.setT4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC4.getT4IP : TBits_3; inline;
begin
  getT4IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC4.setIC4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC4.getIC4IS : TBits_2; inline;
begin
  getIC4IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC4.setIC4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC4.getIC4IP : TBits_3; inline;
begin
  getIC4IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC4.setOC4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC4.getOC4IS : TBits_2; inline;
begin
  getOC4IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC4.setOC4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC4.getOC4IP : TBits_3; inline;
begin
  getOC4IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC4.setINT4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC4.getINT4IS : TBits_2; inline;
begin
  getINT4IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC4.setINT4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC4.getINT4IP : TBits_3; inline;
begin
  getINT4IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC4.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC4.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC5.setT5IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC5.getT5IS : TBits_2; inline;
begin
  getT5IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC5.setT5IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC5.getT5IP : TBits_3; inline;
begin
  getT5IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC5.setIC5IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC5.getIC5IS : TBits_2; inline;
begin
  getIC5IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC5.setIC5IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC5.getIC5IP : TBits_3; inline;
begin
  getIC5IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC5.setOC5IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC5.getOC5IS : TBits_2; inline;
begin
  getOC5IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC5.setOC5IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC5.getOC5IP : TBits_3; inline;
begin
  getOC5IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC5.setAD1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC5.getAD1IS : TBits_2; inline;
begin
  getAD1IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC5.setAD1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC5.getAD1IP : TBits_3; inline;
begin
  getAD1IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC5.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC5.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC6.setFSCMIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC6.getFSCMIS : TBits_2; inline;
begin
  getFSCMIS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC6.setFSCMIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC6.getFSCMIP : TBits_3; inline;
begin
  getFSCMIP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC6.setRTCCIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC6.getRTCCIS : TBits_2; inline;
begin
  getRTCCIS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC6.setRTCCIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC6.getRTCCIP : TBits_3; inline;
begin
  getRTCCIP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC6.setFCEIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC6.getFCEIS : TBits_2; inline;
begin
  getFCEIS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC6.setFCEIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC6.getFCEIP : TBits_3; inline;
begin
  getFCEIP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC6.setCMP1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC6.getCMP1IS : TBits_2; inline;
begin
  getCMP1IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC6.setCMP1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC6.getCMP1IP : TBits_3; inline;
begin
  getCMP1IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC6.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC6.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC7.setCMP2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC7.getCMP2IS : TBits_2; inline;
begin
  getCMP2IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC7.setCMP2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC7.getCMP2IP : TBits_3; inline;
begin
  getCMP2IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC7.setUSBIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC7.getUSBIS : TBits_2; inline;
begin
  getUSBIS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC7.setUSBIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC7.getUSBIP : TBits_3; inline;
begin
  getUSBIP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC7.setSPI1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC7.getSPI1IS : TBits_2; inline;
begin
  getSPI1IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC7.setSPI1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC7.getSPI1IP : TBits_3; inline;
begin
  getSPI1IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC7.setU1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC7.getU1IS : TBits_2; inline;
begin
  getU1IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC7.setU1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC7.getU1IP : TBits_3; inline;
begin
  getU1IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC7.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC7.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC8.setI2C1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC8.getI2C1IS : TBits_2; inline;
begin
  getI2C1IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC8.setI2C1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC8.getI2C1IP : TBits_3; inline;
begin
  getI2C1IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC8.setCNIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC8.getCNIS : TBits_2; inline;
begin
  getCNIS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC8.setCNIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC8.getCNIP : TBits_3; inline;
begin
  getCNIP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC8.setPMPIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC8.getPMPIS : TBits_2; inline;
begin
  getPMPIS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC8.setPMPIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC8.getPMPIP : TBits_3; inline;
begin
  getPMPIP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC8.setSPI2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC8.getSPI2IS : TBits_2; inline;
begin
  getSPI2IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC8.setSPI2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC8.getSPI2IP : TBits_3; inline;
begin
  getSPI2IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC8.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC8.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC9.setU2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC9.getU2IS : TBits_2; inline;
begin
  getU2IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC9.setU2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC9.getU2IP : TBits_3; inline;
begin
  getU2IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC9.setI2C2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC9.getI2C2IS : TBits_2; inline;
begin
  getI2C2IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC9.setI2C2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC9.getI2C2IP : TBits_3; inline;
begin
  getI2C2IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC9.setU3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC9.getU3IS : TBits_2; inline;
begin
  getU3IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC9.setU3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC9.getU3IP : TBits_3; inline;
begin
  getU3IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC9.setU4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC9.getU4IS : TBits_2; inline;
begin
  getU4IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC9.setU4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC9.getU4IP : TBits_3; inline;
begin
  getU4IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC9.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC9.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC10.setCTMUIP(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC10.getCTMUIP : TBits_2; inline;
begin
  getCTMUIP := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC10.setCTMUIS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC10.getCTMUIS : TBits_3; inline;
begin
  getCTMUIS := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC10.setDMA0IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC10.getDMA0IS : TBits_2; inline;
begin
  getDMA0IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC10.setDMA0IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC10.getDMA0IP : TBits_3; inline;
begin
  getDMA0IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC10.setDMA1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC10.getDMA1IS : TBits_2; inline;
begin
  getDMA1IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC10.setDMA1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC10.getDMA1IP : TBits_3; inline;
begin
  getDMA1IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC10.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC10.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC11.setDMA2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC11.getDMA2IS : TBits_2; inline;
begin
  getDMA2IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC11.setDMA2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC11.getDMA2IP : TBits_3; inline;
begin
  getDMA2IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC11.setDMA3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC11.getDMA3IS : TBits_2; inline;
begin
  getDMA3IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC11.setDMA3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC11.getDMA3IP : TBits_3; inline;
begin
  getDMA3IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC11.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC11.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TBMX_BMXCON.setBMXARB(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TBMX_BMXCON.getBMXARB : TBits_3; inline;
begin
  getBMXARB := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TBMX_BMXCON.setBMXWSDRM; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TBMX_BMXCON.clearBMXWSDRM; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TBMX_BMXCON.setBMXWSDRM(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TBMX_BMXCON.getBMXWSDRM : TBits_1; inline;
begin
  getBMXWSDRM := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TBMX_BMXCON.setBMXERRIS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TBMX_BMXCON.clearBMXERRIS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TBMX_BMXCON.setBMXERRIS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TBMX_BMXCON.getBMXERRIS : TBits_1; inline;
begin
  getBMXERRIS := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TBMX_BMXCON.setBMXERRDS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TBMX_BMXCON.clearBMXERRDS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TBMX_BMXCON.setBMXERRDS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TBMX_BMXCON.getBMXERRDS : TBits_1; inline;
begin
  getBMXERRDS := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TBMX_BMXCON.setBMXERRDMA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TBMX_BMXCON.clearBMXERRDMA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TBMX_BMXCON.setBMXERRDMA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TBMX_BMXCON.getBMXERRDMA : TBits_1; inline;
begin
  getBMXERRDMA := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TBMX_BMXCON.setBMXERRICD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TBMX_BMXCON.clearBMXERRICD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TBMX_BMXCON.setBMXERRICD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TBMX_BMXCON.getBMXERRICD : TBits_1; inline;
begin
  getBMXERRICD := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TBMX_BMXCON.setBMXERRIXI; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TBMX_BMXCON.clearBMXERRIXI; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TBMX_BMXCON.setBMXERRIXI(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TBMX_BMXCON.getBMXERRIXI : TBits_1; inline;
begin
  getBMXERRIXI := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TBMX_BMXCON.setBMXCHEDMA; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TBMX_BMXCON.clearBMXCHEDMA; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TBMX_BMXCON.setBMXCHEDMA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TBMX_BMXCON.getBMXCHEDMA : TBits_1; inline;
begin
  getBMXCHEDMA := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TBMX_BMXCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TBMX_BMXCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC_DMACON.setDMABUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TDMAC_DMACON.clearDMABUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TDMAC_DMACON.setDMABUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TDMAC_DMACON.getDMABUSY : TBits_1; inline;
begin
  getDMABUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TDMAC_DMACON.setSUSPEND; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TDMAC_DMACON.clearSUSPEND; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TDMAC_DMACON.setSUSPEND(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TDMAC_DMACON.getSUSPEND : TBits_1; inline;
begin
  getSUSPEND := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TDMAC_DMACON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC_DMACON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC_DMACON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC_DMACON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC_DMACON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC_DMACON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC_DMASTAT.setDMACH(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TDMAC_DMASTAT.getDMACH : TBits_3; inline;
begin
  getDMACH := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TDMAC_DMASTAT.setRDWR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC_DMASTAT.clearRDWR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC_DMASTAT.setRDWR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC_DMASTAT.getRDWR : TBits_1; inline;
begin
  getRDWR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC_DMASTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC_DMASTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC_DCRCCON.setCRCCH(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TDMAC_DCRCCON.getCRCCH : TBits_3; inline;
begin
  getCRCCH := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TDMAC_DCRCCON.setCRCTYP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC_DCRCCON.clearCRCTYP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC_DCRCCON.setCRCTYP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC_DCRCCON.getCRCTYP : TBits_1; inline;
begin
  getCRCTYP := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC_DCRCCON.setCRCAPP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC_DCRCCON.clearCRCAPP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC_DCRCCON.setCRCAPP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC_DCRCCON.getCRCAPP : TBits_1; inline;
begin
  getCRCAPP := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC_DCRCCON.setCRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC_DCRCCON.clearCRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC_DCRCCON.setCRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC_DCRCCON.getCRCEN : TBits_1; inline;
begin
  getCRCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC_DCRCCON.setPLEN(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TDMAC_DCRCCON.getPLEN : TBits_5; inline;
begin
  getPLEN := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TDMAC_DCRCCON.setBITO; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TDMAC_DCRCCON.clearBITO; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TDMAC_DCRCCON.setBITO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TDMAC_DCRCCON.getBITO : TBits_1; inline;
begin
  getBITO := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TDMAC_DCRCCON.setWBO; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TDMAC_DCRCCON.clearWBO; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TDMAC_DCRCCON.setWBO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TDMAC_DCRCCON.getWBO : TBits_1; inline;
begin
  getWBO := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TDMAC_DCRCCON.setBYTO(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $CFFFFFFF or ( thebits shl 28 );
end;
function  TDMAC_DCRCCON.getBYTO : TBits_2; inline;
begin
  getBYTO := (pTDefRegMap(@Self)^.val and $30000000) shr 28;
end;
procedure TDMAC_DCRCCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC_DCRCCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC0_DCH0CON.setCHPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDMAC0_DCH0CON.getCHPRI : TBits_2; inline;
begin
  getCHPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDMAC0_DCH0CON.setCHEDET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC0_DCH0CON.clearCHEDET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC0_DCH0CON.setCHEDET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC0_DCH0CON.getCHEDET : TBits_1; inline;
begin
  getCHEDET := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC0_DCH0CON.setCHAEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC0_DCH0CON.clearCHAEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC0_DCH0CON.setCHAEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC0_DCH0CON.getCHAEN : TBits_1; inline;
begin
  getCHAEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC0_DCH0CON.setCHCHN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC0_DCH0CON.clearCHCHN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC0_DCH0CON.setCHCHN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC0_DCH0CON.getCHCHN : TBits_1; inline;
begin
  getCHCHN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC0_DCH0CON.setCHAED; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC0_DCH0CON.clearCHAED; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC0_DCH0CON.setCHAED(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC0_DCH0CON.getCHAED : TBits_1; inline;
begin
  getCHAED := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC0_DCH0CON.setCHEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC0_DCH0CON.clearCHEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC0_DCH0CON.setCHEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC0_DCH0CON.getCHEN : TBits_1; inline;
begin
  getCHEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC0_DCH0CON.setCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TDMAC0_DCH0CON.clearCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TDMAC0_DCH0CON.setCHCHNS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TDMAC0_DCH0CON.getCHCHNS : TBits_1; inline;
begin
  getCHCHNS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TDMAC0_DCH0CON.setCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC0_DCH0CON.clearCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC0_DCH0CON.setCHBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC0_DCH0CON.getCHBUSY : TBits_1; inline;
begin
  getCHBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC0_DCH0CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC0_DCH0CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC0_DCH0ECON.setAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC0_DCH0ECON.clearAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC0_DCH0ECON.setAIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC0_DCH0ECON.getAIRQEN : TBits_1; inline;
begin
  getAIRQEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC0_DCH0ECON.setSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC0_DCH0ECON.clearSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC0_DCH0ECON.setSIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC0_DCH0ECON.getSIRQEN : TBits_1; inline;
begin
  getSIRQEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC0_DCH0ECON.setPATEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC0_DCH0ECON.clearPATEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC0_DCH0ECON.setPATEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC0_DCH0ECON.getPATEN : TBits_1; inline;
begin
  getPATEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC0_DCH0ECON.setCABORT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC0_DCH0ECON.clearCABORT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC0_DCH0ECON.setCABORT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC0_DCH0ECON.getCABORT : TBits_1; inline;
begin
  getCABORT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC0_DCH0ECON.setCFORCE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC0_DCH0ECON.clearCFORCE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC0_DCH0ECON.setCFORCE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC0_DCH0ECON.getCFORCE : TBits_1; inline;
begin
  getCFORCE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC0_DCH0ECON.setCHSIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF00FF or ( thebits shl 8 );
end;
function  TDMAC0_DCH0ECON.getCHSIRQ : TBits_8; inline;
begin
  getCHSIRQ := (pTDefRegMap(@Self)^.val and $0000FF00) shr 8;
end;
procedure TDMAC0_DCH0ECON.setCHAIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TDMAC0_DCH0ECON.getCHAIRQ : TBits_8; inline;
begin
  getCHAIRQ := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TDMAC0_DCH0ECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC0_DCH0ECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC0_DCH0INT.setCHERIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TDMAC0_DCH0INT.clearCHERIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TDMAC0_DCH0INT.setCHERIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TDMAC0_DCH0INT.getCHERIF : TBits_1; inline;
begin
  getCHERIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TDMAC0_DCH0INT.setCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TDMAC0_DCH0INT.clearCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TDMAC0_DCH0INT.setCHTAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TDMAC0_DCH0INT.getCHTAIF : TBits_1; inline;
begin
  getCHTAIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TDMAC0_DCH0INT.setCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC0_DCH0INT.clearCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC0_DCH0INT.setCHCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC0_DCH0INT.getCHCCIF : TBits_1; inline;
begin
  getCHCCIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC0_DCH0INT.setCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC0_DCH0INT.clearCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC0_DCH0INT.setCHBCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC0_DCH0INT.getCHBCIF : TBits_1; inline;
begin
  getCHBCIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC0_DCH0INT.setCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC0_DCH0INT.clearCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC0_DCH0INT.setCHDHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC0_DCH0INT.getCHDHIF : TBits_1; inline;
begin
  getCHDHIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC0_DCH0INT.setCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC0_DCH0INT.clearCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC0_DCH0INT.setCHDDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC0_DCH0INT.getCHDDIF : TBits_1; inline;
begin
  getCHDDIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC0_DCH0INT.setCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC0_DCH0INT.clearCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC0_DCH0INT.setCHSHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC0_DCH0INT.getCHSHIF : TBits_1; inline;
begin
  getCHSHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC0_DCH0INT.setCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC0_DCH0INT.clearCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC0_DCH0INT.setCHSDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC0_DCH0INT.getCHSDIF : TBits_1; inline;
begin
  getCHSDIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC0_DCH0INT.setCHERIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TDMAC0_DCH0INT.clearCHERIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TDMAC0_DCH0INT.setCHERIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TDMAC0_DCH0INT.getCHERIE : TBits_1; inline;
begin
  getCHERIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TDMAC0_DCH0INT.setCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TDMAC0_DCH0INT.clearCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TDMAC0_DCH0INT.setCHTAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TDMAC0_DCH0INT.getCHTAIE : TBits_1; inline;
begin
  getCHTAIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TDMAC0_DCH0INT.setCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TDMAC0_DCH0INT.clearCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TDMAC0_DCH0INT.setCHCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TDMAC0_DCH0INT.getCHCCIE : TBits_1; inline;
begin
  getCHCCIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TDMAC0_DCH0INT.setCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TDMAC0_DCH0INT.clearCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TDMAC0_DCH0INT.setCHBCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TDMAC0_DCH0INT.getCHBCIE : TBits_1; inline;
begin
  getCHBCIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TDMAC0_DCH0INT.setCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TDMAC0_DCH0INT.clearCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TDMAC0_DCH0INT.setCHDHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TDMAC0_DCH0INT.getCHDHIE : TBits_1; inline;
begin
  getCHDHIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TDMAC0_DCH0INT.setCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TDMAC0_DCH0INT.clearCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TDMAC0_DCH0INT.setCHDDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TDMAC0_DCH0INT.getCHDDIE : TBits_1; inline;
begin
  getCHDDIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TDMAC0_DCH0INT.setCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDMAC0_DCH0INT.clearCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDMAC0_DCH0INT.setCHSHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDMAC0_DCH0INT.getCHSHIE : TBits_1; inline;
begin
  getCHSHIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDMAC0_DCH0INT.setCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDMAC0_DCH0INT.clearCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDMAC0_DCH0INT.setCHSDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDMAC0_DCH0INT.getCHSDIE : TBits_1; inline;
begin
  getCHSDIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDMAC0_DCH0INT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC0_DCH0INT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC1_DCH1CON.setCHPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDMAC1_DCH1CON.getCHPRI : TBits_2; inline;
begin
  getCHPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDMAC1_DCH1CON.setCHEDET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC1_DCH1CON.clearCHEDET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC1_DCH1CON.setCHEDET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC1_DCH1CON.getCHEDET : TBits_1; inline;
begin
  getCHEDET := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC1_DCH1CON.setCHAEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC1_DCH1CON.clearCHAEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC1_DCH1CON.setCHAEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC1_DCH1CON.getCHAEN : TBits_1; inline;
begin
  getCHAEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC1_DCH1CON.setCHCHN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC1_DCH1CON.clearCHCHN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC1_DCH1CON.setCHCHN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC1_DCH1CON.getCHCHN : TBits_1; inline;
begin
  getCHCHN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC1_DCH1CON.setCHAED; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC1_DCH1CON.clearCHAED; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC1_DCH1CON.setCHAED(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC1_DCH1CON.getCHAED : TBits_1; inline;
begin
  getCHAED := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC1_DCH1CON.setCHEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC1_DCH1CON.clearCHEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC1_DCH1CON.setCHEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC1_DCH1CON.getCHEN : TBits_1; inline;
begin
  getCHEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC1_DCH1CON.setCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TDMAC1_DCH1CON.clearCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TDMAC1_DCH1CON.setCHCHNS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TDMAC1_DCH1CON.getCHCHNS : TBits_1; inline;
begin
  getCHCHNS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TDMAC1_DCH1CON.setCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC1_DCH1CON.clearCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC1_DCH1CON.setCHBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC1_DCH1CON.getCHBUSY : TBits_1; inline;
begin
  getCHBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC1_DCH1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC1_DCH1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC1_DCH1ECON.setAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC1_DCH1ECON.clearAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC1_DCH1ECON.setAIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC1_DCH1ECON.getAIRQEN : TBits_1; inline;
begin
  getAIRQEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC1_DCH1ECON.setSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC1_DCH1ECON.clearSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC1_DCH1ECON.setSIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC1_DCH1ECON.getSIRQEN : TBits_1; inline;
begin
  getSIRQEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC1_DCH1ECON.setPATEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC1_DCH1ECON.clearPATEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC1_DCH1ECON.setPATEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC1_DCH1ECON.getPATEN : TBits_1; inline;
begin
  getPATEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC1_DCH1ECON.setCABORT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC1_DCH1ECON.clearCABORT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC1_DCH1ECON.setCABORT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC1_DCH1ECON.getCABORT : TBits_1; inline;
begin
  getCABORT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC1_DCH1ECON.setCFORCE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC1_DCH1ECON.clearCFORCE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC1_DCH1ECON.setCFORCE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC1_DCH1ECON.getCFORCE : TBits_1; inline;
begin
  getCFORCE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC1_DCH1ECON.setCHSIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF00FF or ( thebits shl 8 );
end;
function  TDMAC1_DCH1ECON.getCHSIRQ : TBits_8; inline;
begin
  getCHSIRQ := (pTDefRegMap(@Self)^.val and $0000FF00) shr 8;
end;
procedure TDMAC1_DCH1ECON.setCHAIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TDMAC1_DCH1ECON.getCHAIRQ : TBits_8; inline;
begin
  getCHAIRQ := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TDMAC1_DCH1ECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC1_DCH1ECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC1_DCH1INT.setCHERIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TDMAC1_DCH1INT.clearCHERIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TDMAC1_DCH1INT.setCHERIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TDMAC1_DCH1INT.getCHERIF : TBits_1; inline;
begin
  getCHERIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TDMAC1_DCH1INT.setCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TDMAC1_DCH1INT.clearCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TDMAC1_DCH1INT.setCHTAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TDMAC1_DCH1INT.getCHTAIF : TBits_1; inline;
begin
  getCHTAIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TDMAC1_DCH1INT.setCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC1_DCH1INT.clearCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC1_DCH1INT.setCHCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC1_DCH1INT.getCHCCIF : TBits_1; inline;
begin
  getCHCCIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC1_DCH1INT.setCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC1_DCH1INT.clearCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC1_DCH1INT.setCHBCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC1_DCH1INT.getCHBCIF : TBits_1; inline;
begin
  getCHBCIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC1_DCH1INT.setCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC1_DCH1INT.clearCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC1_DCH1INT.setCHDHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC1_DCH1INT.getCHDHIF : TBits_1; inline;
begin
  getCHDHIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC1_DCH1INT.setCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC1_DCH1INT.clearCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC1_DCH1INT.setCHDDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC1_DCH1INT.getCHDDIF : TBits_1; inline;
begin
  getCHDDIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC1_DCH1INT.setCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC1_DCH1INT.clearCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC1_DCH1INT.setCHSHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC1_DCH1INT.getCHSHIF : TBits_1; inline;
begin
  getCHSHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC1_DCH1INT.setCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC1_DCH1INT.clearCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC1_DCH1INT.setCHSDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC1_DCH1INT.getCHSDIF : TBits_1; inline;
begin
  getCHSDIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC1_DCH1INT.setCHERIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TDMAC1_DCH1INT.clearCHERIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TDMAC1_DCH1INT.setCHERIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TDMAC1_DCH1INT.getCHERIE : TBits_1; inline;
begin
  getCHERIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TDMAC1_DCH1INT.setCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TDMAC1_DCH1INT.clearCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TDMAC1_DCH1INT.setCHTAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TDMAC1_DCH1INT.getCHTAIE : TBits_1; inline;
begin
  getCHTAIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TDMAC1_DCH1INT.setCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TDMAC1_DCH1INT.clearCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TDMAC1_DCH1INT.setCHCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TDMAC1_DCH1INT.getCHCCIE : TBits_1; inline;
begin
  getCHCCIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TDMAC1_DCH1INT.setCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TDMAC1_DCH1INT.clearCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TDMAC1_DCH1INT.setCHBCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TDMAC1_DCH1INT.getCHBCIE : TBits_1; inline;
begin
  getCHBCIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TDMAC1_DCH1INT.setCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TDMAC1_DCH1INT.clearCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TDMAC1_DCH1INT.setCHDHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TDMAC1_DCH1INT.getCHDHIE : TBits_1; inline;
begin
  getCHDHIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TDMAC1_DCH1INT.setCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TDMAC1_DCH1INT.clearCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TDMAC1_DCH1INT.setCHDDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TDMAC1_DCH1INT.getCHDDIE : TBits_1; inline;
begin
  getCHDDIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TDMAC1_DCH1INT.setCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDMAC1_DCH1INT.clearCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDMAC1_DCH1INT.setCHSHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDMAC1_DCH1INT.getCHSHIE : TBits_1; inline;
begin
  getCHSHIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDMAC1_DCH1INT.setCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDMAC1_DCH1INT.clearCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDMAC1_DCH1INT.setCHSDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDMAC1_DCH1INT.getCHSDIE : TBits_1; inline;
begin
  getCHSDIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDMAC1_DCH1INT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC1_DCH1INT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC2_DCH2CON.setCHPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDMAC2_DCH2CON.getCHPRI : TBits_2; inline;
begin
  getCHPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDMAC2_DCH2CON.setCHEDET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC2_DCH2CON.clearCHEDET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC2_DCH2CON.setCHEDET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC2_DCH2CON.getCHEDET : TBits_1; inline;
begin
  getCHEDET := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC2_DCH2CON.setCHAEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC2_DCH2CON.clearCHAEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC2_DCH2CON.setCHAEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC2_DCH2CON.getCHAEN : TBits_1; inline;
begin
  getCHAEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC2_DCH2CON.setCHCHN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC2_DCH2CON.clearCHCHN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC2_DCH2CON.setCHCHN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC2_DCH2CON.getCHCHN : TBits_1; inline;
begin
  getCHCHN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC2_DCH2CON.setCHAED; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC2_DCH2CON.clearCHAED; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC2_DCH2CON.setCHAED(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC2_DCH2CON.getCHAED : TBits_1; inline;
begin
  getCHAED := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC2_DCH2CON.setCHEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC2_DCH2CON.clearCHEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC2_DCH2CON.setCHEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC2_DCH2CON.getCHEN : TBits_1; inline;
begin
  getCHEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC2_DCH2CON.setCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TDMAC2_DCH2CON.clearCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TDMAC2_DCH2CON.setCHCHNS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TDMAC2_DCH2CON.getCHCHNS : TBits_1; inline;
begin
  getCHCHNS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TDMAC2_DCH2CON.setCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC2_DCH2CON.clearCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC2_DCH2CON.setCHBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC2_DCH2CON.getCHBUSY : TBits_1; inline;
begin
  getCHBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC2_DCH2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC2_DCH2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC2_DCH2ECON.setAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC2_DCH2ECON.clearAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC2_DCH2ECON.setAIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC2_DCH2ECON.getAIRQEN : TBits_1; inline;
begin
  getAIRQEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC2_DCH2ECON.setSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC2_DCH2ECON.clearSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC2_DCH2ECON.setSIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC2_DCH2ECON.getSIRQEN : TBits_1; inline;
begin
  getSIRQEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC2_DCH2ECON.setPATEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC2_DCH2ECON.clearPATEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC2_DCH2ECON.setPATEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC2_DCH2ECON.getPATEN : TBits_1; inline;
begin
  getPATEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC2_DCH2ECON.setCABORT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC2_DCH2ECON.clearCABORT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC2_DCH2ECON.setCABORT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC2_DCH2ECON.getCABORT : TBits_1; inline;
begin
  getCABORT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC2_DCH2ECON.setCFORCE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC2_DCH2ECON.clearCFORCE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC2_DCH2ECON.setCFORCE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC2_DCH2ECON.getCFORCE : TBits_1; inline;
begin
  getCFORCE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC2_DCH2ECON.setCHSIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF00FF or ( thebits shl 8 );
end;
function  TDMAC2_DCH2ECON.getCHSIRQ : TBits_8; inline;
begin
  getCHSIRQ := (pTDefRegMap(@Self)^.val and $0000FF00) shr 8;
end;
procedure TDMAC2_DCH2ECON.setCHAIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TDMAC2_DCH2ECON.getCHAIRQ : TBits_8; inline;
begin
  getCHAIRQ := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TDMAC2_DCH2ECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC2_DCH2ECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC2_DCH2INT.setCHERIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TDMAC2_DCH2INT.clearCHERIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TDMAC2_DCH2INT.setCHERIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TDMAC2_DCH2INT.getCHERIF : TBits_1; inline;
begin
  getCHERIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TDMAC2_DCH2INT.setCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TDMAC2_DCH2INT.clearCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TDMAC2_DCH2INT.setCHTAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TDMAC2_DCH2INT.getCHTAIF : TBits_1; inline;
begin
  getCHTAIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TDMAC2_DCH2INT.setCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC2_DCH2INT.clearCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC2_DCH2INT.setCHCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC2_DCH2INT.getCHCCIF : TBits_1; inline;
begin
  getCHCCIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC2_DCH2INT.setCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC2_DCH2INT.clearCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC2_DCH2INT.setCHBCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC2_DCH2INT.getCHBCIF : TBits_1; inline;
begin
  getCHBCIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC2_DCH2INT.setCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC2_DCH2INT.clearCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC2_DCH2INT.setCHDHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC2_DCH2INT.getCHDHIF : TBits_1; inline;
begin
  getCHDHIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC2_DCH2INT.setCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC2_DCH2INT.clearCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC2_DCH2INT.setCHDDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC2_DCH2INT.getCHDDIF : TBits_1; inline;
begin
  getCHDDIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC2_DCH2INT.setCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC2_DCH2INT.clearCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC2_DCH2INT.setCHSHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC2_DCH2INT.getCHSHIF : TBits_1; inline;
begin
  getCHSHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC2_DCH2INT.setCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC2_DCH2INT.clearCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC2_DCH2INT.setCHSDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC2_DCH2INT.getCHSDIF : TBits_1; inline;
begin
  getCHSDIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC2_DCH2INT.setCHERIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TDMAC2_DCH2INT.clearCHERIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TDMAC2_DCH2INT.setCHERIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TDMAC2_DCH2INT.getCHERIE : TBits_1; inline;
begin
  getCHERIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TDMAC2_DCH2INT.setCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TDMAC2_DCH2INT.clearCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TDMAC2_DCH2INT.setCHTAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TDMAC2_DCH2INT.getCHTAIE : TBits_1; inline;
begin
  getCHTAIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TDMAC2_DCH2INT.setCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TDMAC2_DCH2INT.clearCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TDMAC2_DCH2INT.setCHCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TDMAC2_DCH2INT.getCHCCIE : TBits_1; inline;
begin
  getCHCCIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TDMAC2_DCH2INT.setCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TDMAC2_DCH2INT.clearCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TDMAC2_DCH2INT.setCHBCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TDMAC2_DCH2INT.getCHBCIE : TBits_1; inline;
begin
  getCHBCIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TDMAC2_DCH2INT.setCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TDMAC2_DCH2INT.clearCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TDMAC2_DCH2INT.setCHDHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TDMAC2_DCH2INT.getCHDHIE : TBits_1; inline;
begin
  getCHDHIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TDMAC2_DCH2INT.setCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TDMAC2_DCH2INT.clearCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TDMAC2_DCH2INT.setCHDDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TDMAC2_DCH2INT.getCHDDIE : TBits_1; inline;
begin
  getCHDDIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TDMAC2_DCH2INT.setCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDMAC2_DCH2INT.clearCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDMAC2_DCH2INT.setCHSHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDMAC2_DCH2INT.getCHSHIE : TBits_1; inline;
begin
  getCHSHIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDMAC2_DCH2INT.setCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDMAC2_DCH2INT.clearCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDMAC2_DCH2INT.setCHSDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDMAC2_DCH2INT.getCHSDIE : TBits_1; inline;
begin
  getCHSDIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDMAC2_DCH2INT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC2_DCH2INT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC3_DCH3CON.setCHPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDMAC3_DCH3CON.getCHPRI : TBits_2; inline;
begin
  getCHPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDMAC3_DCH3CON.setCHEDET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC3_DCH3CON.clearCHEDET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC3_DCH3CON.setCHEDET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC3_DCH3CON.getCHEDET : TBits_1; inline;
begin
  getCHEDET := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC3_DCH3CON.setCHAEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC3_DCH3CON.clearCHAEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC3_DCH3CON.setCHAEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC3_DCH3CON.getCHAEN : TBits_1; inline;
begin
  getCHAEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC3_DCH3CON.setCHCHN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC3_DCH3CON.clearCHCHN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC3_DCH3CON.setCHCHN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC3_DCH3CON.getCHCHN : TBits_1; inline;
begin
  getCHCHN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC3_DCH3CON.setCHAED; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC3_DCH3CON.clearCHAED; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC3_DCH3CON.setCHAED(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC3_DCH3CON.getCHAED : TBits_1; inline;
begin
  getCHAED := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC3_DCH3CON.setCHEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC3_DCH3CON.clearCHEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC3_DCH3CON.setCHEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC3_DCH3CON.getCHEN : TBits_1; inline;
begin
  getCHEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC3_DCH3CON.setCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TDMAC3_DCH3CON.clearCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TDMAC3_DCH3CON.setCHCHNS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TDMAC3_DCH3CON.getCHCHNS : TBits_1; inline;
begin
  getCHCHNS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TDMAC3_DCH3CON.setCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC3_DCH3CON.clearCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC3_DCH3CON.setCHBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC3_DCH3CON.getCHBUSY : TBits_1; inline;
begin
  getCHBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC3_DCH3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC3_DCH3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC3_DCH3ECON.setAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC3_DCH3ECON.clearAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC3_DCH3ECON.setAIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC3_DCH3ECON.getAIRQEN : TBits_1; inline;
begin
  getAIRQEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC3_DCH3ECON.setSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC3_DCH3ECON.clearSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC3_DCH3ECON.setSIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC3_DCH3ECON.getSIRQEN : TBits_1; inline;
begin
  getSIRQEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC3_DCH3ECON.setPATEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC3_DCH3ECON.clearPATEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC3_DCH3ECON.setPATEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC3_DCH3ECON.getPATEN : TBits_1; inline;
begin
  getPATEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC3_DCH3ECON.setCABORT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC3_DCH3ECON.clearCABORT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC3_DCH3ECON.setCABORT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC3_DCH3ECON.getCABORT : TBits_1; inline;
begin
  getCABORT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC3_DCH3ECON.setCFORCE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC3_DCH3ECON.clearCFORCE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC3_DCH3ECON.setCFORCE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC3_DCH3ECON.getCFORCE : TBits_1; inline;
begin
  getCFORCE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC3_DCH3ECON.setCHSIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF00FF or ( thebits shl 8 );
end;
function  TDMAC3_DCH3ECON.getCHSIRQ : TBits_8; inline;
begin
  getCHSIRQ := (pTDefRegMap(@Self)^.val and $0000FF00) shr 8;
end;
procedure TDMAC3_DCH3ECON.setCHAIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TDMAC3_DCH3ECON.getCHAIRQ : TBits_8; inline;
begin
  getCHAIRQ := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TDMAC3_DCH3ECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC3_DCH3ECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC3_DCH3INT.setCHERIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TDMAC3_DCH3INT.clearCHERIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TDMAC3_DCH3INT.setCHERIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TDMAC3_DCH3INT.getCHERIF : TBits_1; inline;
begin
  getCHERIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TDMAC3_DCH3INT.setCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TDMAC3_DCH3INT.clearCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TDMAC3_DCH3INT.setCHTAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TDMAC3_DCH3INT.getCHTAIF : TBits_1; inline;
begin
  getCHTAIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TDMAC3_DCH3INT.setCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC3_DCH3INT.clearCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC3_DCH3INT.setCHCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC3_DCH3INT.getCHCCIF : TBits_1; inline;
begin
  getCHCCIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC3_DCH3INT.setCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC3_DCH3INT.clearCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC3_DCH3INT.setCHBCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC3_DCH3INT.getCHBCIF : TBits_1; inline;
begin
  getCHBCIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC3_DCH3INT.setCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC3_DCH3INT.clearCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC3_DCH3INT.setCHDHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC3_DCH3INT.getCHDHIF : TBits_1; inline;
begin
  getCHDHIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC3_DCH3INT.setCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC3_DCH3INT.clearCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC3_DCH3INT.setCHDDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC3_DCH3INT.getCHDDIF : TBits_1; inline;
begin
  getCHDDIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC3_DCH3INT.setCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC3_DCH3INT.clearCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC3_DCH3INT.setCHSHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC3_DCH3INT.getCHSHIF : TBits_1; inline;
begin
  getCHSHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC3_DCH3INT.setCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC3_DCH3INT.clearCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC3_DCH3INT.setCHSDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC3_DCH3INT.getCHSDIF : TBits_1; inline;
begin
  getCHSDIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC3_DCH3INT.setCHERIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TDMAC3_DCH3INT.clearCHERIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TDMAC3_DCH3INT.setCHERIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TDMAC3_DCH3INT.getCHERIE : TBits_1; inline;
begin
  getCHERIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TDMAC3_DCH3INT.setCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TDMAC3_DCH3INT.clearCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TDMAC3_DCH3INT.setCHTAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TDMAC3_DCH3INT.getCHTAIE : TBits_1; inline;
begin
  getCHTAIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TDMAC3_DCH3INT.setCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TDMAC3_DCH3INT.clearCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TDMAC3_DCH3INT.setCHCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TDMAC3_DCH3INT.getCHCCIE : TBits_1; inline;
begin
  getCHCCIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TDMAC3_DCH3INT.setCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TDMAC3_DCH3INT.clearCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TDMAC3_DCH3INT.setCHBCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TDMAC3_DCH3INT.getCHBCIE : TBits_1; inline;
begin
  getCHBCIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TDMAC3_DCH3INT.setCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TDMAC3_DCH3INT.clearCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TDMAC3_DCH3INT.setCHDHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TDMAC3_DCH3INT.getCHDHIE : TBits_1; inline;
begin
  getCHDHIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TDMAC3_DCH3INT.setCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TDMAC3_DCH3INT.clearCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TDMAC3_DCH3INT.setCHDDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TDMAC3_DCH3INT.getCHDDIE : TBits_1; inline;
begin
  getCHDDIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TDMAC3_DCH3INT.setCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDMAC3_DCH3INT.clearCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDMAC3_DCH3INT.setCHSHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDMAC3_DCH3INT.getCHSHIE : TBits_1; inline;
begin
  getCHSHIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDMAC3_DCH3INT.setCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDMAC3_DCH3INT.clearCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDMAC3_DCH3INT.setCHSDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDMAC3_DCH3INT.getCHSDIE : TBits_1; inline;
begin
  getCHSDIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDMAC3_DCH3INT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC3_DCH3INT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPCACHE_CHECON.setPFMWS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TPCACHE_CHECON.getPFMWS : TBits_3; inline;
begin
  getPFMWS := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TPCACHE_CHECON.setPREFEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFCF or ( thebits shl 4 );
end;
function  TPCACHE_CHECON.getPREFEN : TBits_2; inline;
begin
  getPREFEN := (pTDefRegMap(@Self)^.val and $00000030) shr 4;
end;
procedure TPCACHE_CHECON.setDCSZ(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TPCACHE_CHECON.getDCSZ : TBits_2; inline;
begin
  getDCSZ := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TPCACHE_CHECON.setCHECOH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TPCACHE_CHECON.clearCHECOH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TPCACHE_CHECON.setCHECOH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TPCACHE_CHECON.getCHECOH : TBits_1; inline;
begin
  getCHECOH := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TPCACHE_CHECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPCACHE_CHECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPCACHE_CHETAG.setLTYPE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPCACHE_CHETAG.clearLTYPE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPCACHE_CHETAG.setLTYPE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPCACHE_CHETAG.getLTYPE : TBits_1; inline;
begin
  getLTYPE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPCACHE_CHETAG.setLLOCK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPCACHE_CHETAG.clearLLOCK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPCACHE_CHETAG.setLLOCK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPCACHE_CHETAG.getLLOCK : TBits_1; inline;
begin
  getLLOCK := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPCACHE_CHETAG.setLVALID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPCACHE_CHETAG.clearLVALID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPCACHE_CHETAG.setLVALID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPCACHE_CHETAG.getLVALID : TBits_1; inline;
begin
  getLVALID := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPCACHE_CHETAG.setLTAG(thebits : TBits_20); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00000F or ( thebits shl 4 );
end;
function  TPCACHE_CHETAG.getLTAG : TBits_20; inline;
begin
  getLTAG := (pTDefRegMap(@Self)^.val and $00FFFFF0) shr 4;
end;
procedure TPCACHE_CHETAG.setLTAGBOOT; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TPCACHE_CHETAG.clearLTAGBOOT; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TPCACHE_CHETAG.setLTAGBOOT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TPCACHE_CHETAG.getLTAGBOOT : TBits_1; inline;
begin
  getLTAGBOOT := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TPCACHE_CHETAG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPCACHE_CHETAG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUSB_U1IR.setURSTIF_DETACHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IR.clearURSTIF_DETACHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IR.setURSTIF_DETACHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IR.getURSTIF_DETACHIF : TBits_1; inline;
begin
  getURSTIF_DETACHIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IR.setUERRIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1IR.clearUERRIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1IR.setUERRIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1IR.getUERRIF : TBits_1; inline;
begin
  getUERRIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1IR.setSOFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1IR.clearSOFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1IR.setSOFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1IR.getSOFIF : TBits_1; inline;
begin
  getSOFIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1IR.setTRNIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1IR.clearTRNIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1IR.setTRNIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1IR.getTRNIF : TBits_1; inline;
begin
  getTRNIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1IR.setIDLEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1IR.clearIDLEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1IR.setIDLEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1IR.getIDLEIF : TBits_1; inline;
begin
  getIDLEIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1IR.setRESUMEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1IR.clearRESUMEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1IR.setRESUMEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1IR.getRESUMEIF : TBits_1; inline;
begin
  getRESUMEIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1IR.setATTACHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1IR.clearATTACHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1IR.setATTACHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1IR.getATTACHIF : TBits_1; inline;
begin
  getATTACHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1IR.setSTALLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1IR.clearSTALLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1IR.setSTALLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1IR.getSTALLIF : TBits_1; inline;
begin
  getSTALLIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1IR.setDETACHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IR.clearDETACHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IR.setDETACHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IR.getDETACHIF : TBits_1; inline;
begin
  getDETACHIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IR.setURSTIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IR.clearURSTIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IR.setURSTIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IR.getURSTIF : TBits_1; inline;
begin
  getURSTIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IE.setURSTIE_DETACHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IE.clearURSTIE_DETACHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IE.setURSTIE_DETACHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IE.getURSTIE_DETACHIE : TBits_1; inline;
begin
  getURSTIE_DETACHIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IE.setUERRIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1IE.clearUERRIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1IE.setUERRIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1IE.getUERRIE : TBits_1; inline;
begin
  getUERRIE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1IE.setSOFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1IE.clearSOFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1IE.setSOFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1IE.getSOFIE : TBits_1; inline;
begin
  getSOFIE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1IE.setTRNIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1IE.clearTRNIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1IE.setTRNIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1IE.getTRNIE : TBits_1; inline;
begin
  getTRNIE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1IE.setIDLEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1IE.clearIDLEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1IE.setIDLEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1IE.getIDLEIE : TBits_1; inline;
begin
  getIDLEIE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1IE.setRESUMEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1IE.clearRESUMEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1IE.setRESUMEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1IE.getRESUMEIE : TBits_1; inline;
begin
  getRESUMEIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1IE.setATTACHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1IE.clearATTACHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1IE.setATTACHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1IE.getATTACHIE : TBits_1; inline;
begin
  getATTACHIE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1IE.setSTALLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1IE.clearSTALLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1IE.setSTALLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1IE.getSTALLIE : TBits_1; inline;
begin
  getSTALLIE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1IE.setDETACHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IE.clearDETACHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IE.setDETACHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IE.getDETACHIE : TBits_1; inline;
begin
  getDETACHIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IE.setURSTIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IE.clearURSTIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IE.setURSTIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IE.getURSTIE : TBits_1; inline;
begin
  getURSTIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1EIR.setPIDEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1EIR.clearPIDEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1EIR.setPIDEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1EIR.getPIDEF : TBits_1; inline;
begin
  getPIDEF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1EIR.setCRC5EF_EOFEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIR.clearCRC5EF_EOFEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIR.setCRC5EF_EOFEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIR.getCRC5EF_EOFEF : TBits_1; inline;
begin
  getCRC5EF_EOFEF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIR.setCRC16EF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1EIR.clearCRC16EF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1EIR.setCRC16EF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1EIR.getCRC16EF : TBits_1; inline;
begin
  getCRC16EF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1EIR.setDFN8EF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1EIR.clearDFN8EF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1EIR.setDFN8EF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1EIR.getDFN8EF : TBits_1; inline;
begin
  getDFN8EF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1EIR.setBTOEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1EIR.clearBTOEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1EIR.setBTOEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1EIR.getBTOEF : TBits_1; inline;
begin
  getBTOEF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1EIR.setDMAEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1EIR.clearDMAEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1EIR.setDMAEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1EIR.getDMAEF : TBits_1; inline;
begin
  getDMAEF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1EIR.setBMXEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1EIR.clearBMXEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1EIR.setBMXEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1EIR.getBMXEF : TBits_1; inline;
begin
  getBMXEF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1EIR.setBTSEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1EIR.clearBTSEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1EIR.setBTSEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1EIR.getBTSEF : TBits_1; inline;
begin
  getBTSEF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1EIR.setCRC5EF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIR.clearCRC5EF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIR.setCRC5EF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIR.getCRC5EF : TBits_1; inline;
begin
  getCRC5EF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIR.setEOFEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIR.clearEOFEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIR.setEOFEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIR.getEOFEF : TBits_1; inline;
begin
  getEOFEF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIE.setPIDEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1EIE.clearPIDEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1EIE.setPIDEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1EIE.getPIDEE : TBits_1; inline;
begin
  getPIDEE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1EIE.setCRC5EE_EOFEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIE.clearCRC5EE_EOFEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIE.setCRC5EE_EOFEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIE.getCRC5EE_EOFEE : TBits_1; inline;
begin
  getCRC5EE_EOFEE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIE.setCRC16EE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1EIE.clearCRC16EE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1EIE.setCRC16EE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1EIE.getCRC16EE : TBits_1; inline;
begin
  getCRC16EE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1EIE.setDFN8EE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1EIE.clearDFN8EE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1EIE.setDFN8EE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1EIE.getDFN8EE : TBits_1; inline;
begin
  getDFN8EE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1EIE.setBTOEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1EIE.clearBTOEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1EIE.setBTOEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1EIE.getBTOEE : TBits_1; inline;
begin
  getBTOEE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1EIE.setDMAEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1EIE.clearDMAEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1EIE.setDMAEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1EIE.getDMAEE : TBits_1; inline;
begin
  getDMAEE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1EIE.setBMXEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1EIE.clearBMXEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1EIE.setBMXEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1EIE.getBMXEE : TBits_1; inline;
begin
  getBMXEE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1EIE.setBTSEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1EIE.clearBTSEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1EIE.setBTSEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1EIE.getBTSEE : TBits_1; inline;
begin
  getBTSEE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1EIE.setCRC5EE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIE.clearCRC5EE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIE.setCRC5EE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIE.getCRC5EE : TBits_1; inline;
begin
  getCRC5EE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIE.setEOFEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIE.clearEOFEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIE.setEOFEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIE.getEOFEE : TBits_1; inline;
begin
  getEOFEE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1STAT.setPPBI; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1STAT.clearPPBI; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1STAT.setPPBI(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1STAT.getPPBI : TBits_1; inline;
begin
  getPPBI := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1STAT.setDIR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1STAT.clearDIR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1STAT.setDIR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1STAT.getDIR : TBits_1; inline;
begin
  getDIR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1STAT.setENDPT(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF0F or ( thebits shl 4 );
end;
function  TUSB_U1STAT.getENDPT : TBits_4; inline;
begin
  getENDPT := (pTDefRegMap(@Self)^.val and $000000F0) shr 4;
end;
procedure TUSB_U1STAT.setENDPT0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1STAT.clearENDPT0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1STAT.setENDPT0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1STAT.getENDPT0 : TBits_1; inline;
begin
  getENDPT0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1STAT.setENDPT1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1STAT.clearENDPT1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1STAT.setENDPT1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1STAT.getENDPT1 : TBits_1; inline;
begin
  getENDPT1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1STAT.setENDPT2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1STAT.clearENDPT2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1STAT.setENDPT2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1STAT.getENDPT2 : TBits_1; inline;
begin
  getENDPT2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1STAT.setENDPT3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1STAT.clearENDPT3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1STAT.setENDPT3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1STAT.getENDPT3 : TBits_1; inline;
begin
  getENDPT3 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1CON.setUSBEN_SOFEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1CON.clearUSBEN_SOFEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1CON.setUSBEN_SOFEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1CON.getUSBEN_SOFEN : TBits_1; inline;
begin
  getUSBEN_SOFEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1CON.setPPBRST; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1CON.clearPPBRST; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1CON.setPPBRST(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1CON.getPPBRST : TBits_1; inline;
begin
  getPPBRST := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1CON.setRESUME; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1CON.clearRESUME; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1CON.setRESUME(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1CON.getRESUME : TBits_1; inline;
begin
  getRESUME := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1CON.setHOSTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1CON.clearHOSTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1CON.setHOSTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1CON.getHOSTEN : TBits_1; inline;
begin
  getHOSTEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1CON.setUSBRST; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1CON.clearUSBRST; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1CON.setUSBRST(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1CON.getUSBRST : TBits_1; inline;
begin
  getUSBRST := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1CON.setPKTDIS_TOKBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1CON.clearPKTDIS_TOKBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1CON.setPKTDIS_TOKBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1CON.getPKTDIS_TOKBUSY : TBits_1; inline;
begin
  getPKTDIS_TOKBUSY := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1CON.setSE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1CON.clearSE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1CON.setSE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1CON.getSE0 : TBits_1; inline;
begin
  getSE0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1CON.setJSTATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1CON.clearJSTATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1CON.setJSTATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1CON.getJSTATE : TBits_1; inline;
begin
  getJSTATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1CON.setUSBEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1CON.clearUSBEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1CON.setUSBEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1CON.getUSBEN : TBits_1; inline;
begin
  getUSBEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1CON.setSOFEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1CON.clearSOFEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1CON.setSOFEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1CON.getSOFEN : TBits_1; inline;
begin
  getSOFEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1CON.setPKTDIS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1CON.clearPKTDIS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1CON.setPKTDIS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1CON.getPKTDIS : TBits_1; inline;
begin
  getPKTDIS := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1CON.setTOKBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1CON.clearTOKBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1CON.setTOKBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1CON.getTOKBUSY : TBits_1; inline;
begin
  getTOKBUSY := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1ADDR.setDEVADDR(thebits : TBits_7); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF80 or ( thebits shl 0 );
end;
function  TUSB_U1ADDR.getDEVADDR : TBits_7; inline;
begin
  getDEVADDR := (pTDefRegMap(@Self)^.val and $0000007F) shr 0;
end;
procedure TUSB_U1ADDR.setLSPDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1ADDR.clearLSPDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1ADDR.setLSPDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1ADDR.getLSPDEN : TBits_1; inline;
begin
  getLSPDEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1ADDR.setDEVADDR0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1ADDR.clearDEVADDR0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1ADDR.setDEVADDR0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1ADDR.getDEVADDR0 : TBits_1; inline;
begin
  getDEVADDR0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1ADDR.setDEVADDR1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1ADDR.clearDEVADDR1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1ADDR.setDEVADDR1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1ADDR.getDEVADDR1 : TBits_1; inline;
begin
  getDEVADDR1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1ADDR.setDEVADDR2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1ADDR.clearDEVADDR2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1ADDR.setDEVADDR2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1ADDR.getDEVADDR2 : TBits_1; inline;
begin
  getDEVADDR2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1ADDR.setDEVADDR3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1ADDR.clearDEVADDR3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1ADDR.setDEVADDR3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1ADDR.getDEVADDR3 : TBits_1; inline;
begin
  getDEVADDR3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1ADDR.setDEVADDR4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1ADDR.clearDEVADDR4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1ADDR.setDEVADDR4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1ADDR.getDEVADDR4 : TBits_1; inline;
begin
  getDEVADDR4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1ADDR.setDEVADDR5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1ADDR.clearDEVADDR5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1ADDR.setDEVADDR5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1ADDR.getDEVADDR5 : TBits_1; inline;
begin
  getDEVADDR5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1ADDR.setDEVADDR6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1ADDR.clearDEVADDR6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1ADDR.setDEVADDR6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1ADDR.getDEVADDR6 : TBits_1; inline;
begin
  getDEVADDR6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1FRML.setFRML(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF00 or ( thebits shl 0 );
end;
function  TUSB_U1FRML.getFRML : TBits_8; inline;
begin
  getFRML := (pTDefRegMap(@Self)^.val and $000000FF) shr 0;
end;
procedure TUSB_U1FRML.setFRM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1FRML.clearFRM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1FRML.setFRM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1FRML.getFRM0 : TBits_1; inline;
begin
  getFRM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1FRML.setFRM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1FRML.clearFRM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1FRML.setFRM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1FRML.getFRM1 : TBits_1; inline;
begin
  getFRM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1FRML.setFRM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1FRML.clearFRM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1FRML.setFRM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1FRML.getFRM2 : TBits_1; inline;
begin
  getFRM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1FRML.setFRM3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1FRML.clearFRM3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1FRML.setFRM3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1FRML.getFRM3 : TBits_1; inline;
begin
  getFRM3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1FRML.setFRM4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1FRML.clearFRM4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1FRML.setFRM4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1FRML.getFRM4 : TBits_1; inline;
begin
  getFRM4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1FRML.setFRM5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1FRML.clearFRM5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1FRML.setFRM5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1FRML.getFRM5 : TBits_1; inline;
begin
  getFRM5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1FRML.setFRM6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1FRML.clearFRM6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1FRML.setFRM6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1FRML.getFRM6 : TBits_1; inline;
begin
  getFRM6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1FRML.setFRM7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1FRML.clearFRM7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1FRML.setFRM7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1FRML.getFRM7 : TBits_1; inline;
begin
  getFRM7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1FRMH.setFRMH(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TUSB_U1FRMH.getFRMH : TBits_3; inline;
begin
  getFRMH := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TUSB_U1FRMH.setFRM8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1FRMH.clearFRM8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1FRMH.setFRM8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1FRMH.getFRM8 : TBits_1; inline;
begin
  getFRM8 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1FRMH.setFRM9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1FRMH.clearFRM9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1FRMH.setFRM9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1FRMH.getFRM9 : TBits_1; inline;
begin
  getFRM9 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1FRMH.setFRM10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1FRMH.clearFRM10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1FRMH.setFRM10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1FRMH.getFRM10 : TBits_1; inline;
begin
  getFRM10 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1TOK.setEP(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TUSB_U1TOK.getEP : TBits_4; inline;
begin
  getEP := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TUSB_U1TOK.setPID(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF0F or ( thebits shl 4 );
end;
function  TUSB_U1TOK.getPID : TBits_4; inline;
begin
  getPID := (pTDefRegMap(@Self)^.val and $000000F0) shr 4;
end;
procedure TUSB_U1TOK.setEP0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1TOK.clearEP0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1TOK.setEP0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1TOK.getEP0 : TBits_1; inline;
begin
  getEP0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1TOK.setEP1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1TOK.clearEP1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1TOK.setEP1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1TOK.getEP1 : TBits_1; inline;
begin
  getEP1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1TOK.setEP2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1TOK.clearEP2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1TOK.setEP2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1TOK.getEP2 : TBits_1; inline;
begin
  getEP2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1TOK.setEP3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1TOK.clearEP3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1TOK.setEP3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1TOK.getEP3 : TBits_1; inline;
begin
  getEP3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1TOK.setPID0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1TOK.clearPID0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1TOK.setPID0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1TOK.getPID0 : TBits_1; inline;
begin
  getPID0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1TOK.setPID1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1TOK.clearPID1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1TOK.setPID1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1TOK.getPID1 : TBits_1; inline;
begin
  getPID1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1TOK.setPID2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1TOK.clearPID2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1TOK.setPID2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1TOK.getPID2 : TBits_1; inline;
begin
  getPID2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1TOK.setPID3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1TOK.clearPID3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1TOK.setPID3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1TOK.getPID3 : TBits_1; inline;
begin
  getPID3 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_ANSELB.setANSB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_ANSELB.clearANSB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_ANSELB.setANSB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_ANSELB.getANSB0 : TBits_1; inline;
begin
  getANSB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_ANSELB.setANSB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_ANSELB.clearANSB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_ANSELB.setANSB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_ANSELB.getANSB1 : TBits_1; inline;
begin
  getANSB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_ANSELB.setANSB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_ANSELB.clearANSB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_ANSELB.setANSB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_ANSELB.getANSB2 : TBits_1; inline;
begin
  getANSB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_ANSELB.setANSB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_ANSELB.clearANSB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_ANSELB.setANSB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_ANSELB.getANSB3 : TBits_1; inline;
begin
  getANSB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_ANSELB.setANSB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_ANSELB.clearANSB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_ANSELB.setANSB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_ANSELB.getANSB4 : TBits_1; inline;
begin
  getANSB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_ANSELB.setANSB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_ANSELB.clearANSB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_ANSELB.setANSB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_ANSELB.getANSB5 : TBits_1; inline;
begin
  getANSB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_ANSELB.setANSB6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_ANSELB.clearANSB6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_ANSELB.setANSB6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_ANSELB.getANSB6 : TBits_1; inline;
begin
  getANSB6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_ANSELB.setANSB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_ANSELB.clearANSB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_ANSELB.setANSB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_ANSELB.getANSB7 : TBits_1; inline;
begin
  getANSB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_ANSELB.setANSB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUSB_ANSELB.clearANSB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUSB_ANSELB.setANSB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUSB_ANSELB.getANSB8 : TBits_1; inline;
begin
  getANSB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUSB_ANSELB.setANSB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUSB_ANSELB.clearANSB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUSB_ANSELB.setANSB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUSB_ANSELB.getANSB9 : TBits_1; inline;
begin
  getANSB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUSB_ANSELB.setANSB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUSB_ANSELB.clearANSB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUSB_ANSELB.setANSB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUSB_ANSELB.getANSB10 : TBits_1; inline;
begin
  getANSB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUSB_ANSELB.setANSB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUSB_ANSELB.clearANSB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUSB_ANSELB.setANSB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUSB_ANSELB.getANSB11 : TBits_1; inline;
begin
  getANSB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUSB_ANSELB.setANSB12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUSB_ANSELB.clearANSB12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUSB_ANSELB.setANSB12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUSB_ANSELB.getANSB12 : TBits_1; inline;
begin
  getANSB12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUSB_ANSELB.setANSB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUSB_ANSELB.clearANSB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUSB_ANSELB.setANSB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUSB_ANSELB.getANSB13 : TBits_1; inline;
begin
  getANSB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUSB_ANSELB.setANSB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUSB_ANSELB.clearANSB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUSB_ANSELB.setANSB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUSB_ANSELB.getANSB14 : TBits_1; inline;
begin
  getANSB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUSB_ANSELB.setANSB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUSB_ANSELB.clearANSB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUSB_ANSELB.setANSB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUSB_ANSELB.getANSB15 : TBits_1; inline;
begin
  getANSB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUSB_ANSELB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUSB_ANSELB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUSB_TRISB.setTRISB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_TRISB.clearTRISB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_TRISB.setTRISB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_TRISB.getTRISB0 : TBits_1; inline;
begin
  getTRISB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_TRISB.setTRISB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_TRISB.clearTRISB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_TRISB.setTRISB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_TRISB.getTRISB1 : TBits_1; inline;
begin
  getTRISB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_TRISB.setTRISB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_TRISB.clearTRISB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_TRISB.setTRISB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_TRISB.getTRISB2 : TBits_1; inline;
begin
  getTRISB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_TRISB.setTRISB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_TRISB.clearTRISB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_TRISB.setTRISB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_TRISB.getTRISB3 : TBits_1; inline;
begin
  getTRISB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_TRISB.setTRISB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_TRISB.clearTRISB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_TRISB.setTRISB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_TRISB.getTRISB4 : TBits_1; inline;
begin
  getTRISB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_TRISB.setTRISB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_TRISB.clearTRISB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_TRISB.setTRISB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_TRISB.getTRISB5 : TBits_1; inline;
begin
  getTRISB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_TRISB.setTRISB6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_TRISB.clearTRISB6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_TRISB.setTRISB6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_TRISB.getTRISB6 : TBits_1; inline;
begin
  getTRISB6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_TRISB.setTRISB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_TRISB.clearTRISB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_TRISB.setTRISB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_TRISB.getTRISB7 : TBits_1; inline;
begin
  getTRISB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_TRISB.setTRISB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUSB_TRISB.clearTRISB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUSB_TRISB.setTRISB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUSB_TRISB.getTRISB8 : TBits_1; inline;
begin
  getTRISB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUSB_TRISB.setTRISB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUSB_TRISB.clearTRISB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUSB_TRISB.setTRISB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUSB_TRISB.getTRISB9 : TBits_1; inline;
begin
  getTRISB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUSB_TRISB.setTRISB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUSB_TRISB.clearTRISB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUSB_TRISB.setTRISB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUSB_TRISB.getTRISB10 : TBits_1; inline;
begin
  getTRISB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUSB_TRISB.setTRISB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUSB_TRISB.clearTRISB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUSB_TRISB.setTRISB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUSB_TRISB.getTRISB11 : TBits_1; inline;
begin
  getTRISB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUSB_TRISB.setTRISB12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUSB_TRISB.clearTRISB12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUSB_TRISB.setTRISB12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUSB_TRISB.getTRISB12 : TBits_1; inline;
begin
  getTRISB12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUSB_TRISB.setTRISB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUSB_TRISB.clearTRISB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUSB_TRISB.setTRISB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUSB_TRISB.getTRISB13 : TBits_1; inline;
begin
  getTRISB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUSB_TRISB.setTRISB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUSB_TRISB.clearTRISB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUSB_TRISB.setTRISB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUSB_TRISB.getTRISB14 : TBits_1; inline;
begin
  getTRISB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUSB_TRISB.setTRISB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUSB_TRISB.clearTRISB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUSB_TRISB.setTRISB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUSB_TRISB.getTRISB15 : TBits_1; inline;
begin
  getTRISB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUSB_TRISB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUSB_TRISB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_PORTB.setRB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_PORTB.clearRB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_PORTB.setRB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_PORTB.getRB0 : TBits_1; inline;
begin
  getRB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_PORTB.setRB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_PORTB.clearRB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_PORTB.setRB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_PORTB.getRB1 : TBits_1; inline;
begin
  getRB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_PORTB.setRB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_PORTB.clearRB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_PORTB.setRB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_PORTB.getRB2 : TBits_1; inline;
begin
  getRB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_PORTB.setRB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_PORTB.clearRB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_PORTB.setRB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_PORTB.getRB3 : TBits_1; inline;
begin
  getRB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_PORTB.setRB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_PORTB.clearRB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_PORTB.setRB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_PORTB.getRB4 : TBits_1; inline;
begin
  getRB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_PORTB.setRB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_PORTB.clearRB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_PORTB.setRB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_PORTB.getRB5 : TBits_1; inline;
begin
  getRB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_PORTB.setRB6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTB_PORTB.clearRB6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTB_PORTB.setRB6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTB_PORTB.getRB6 : TBits_1; inline;
begin
  getRB6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTB_PORTB.setRB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_PORTB.clearRB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_PORTB.setRB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_PORTB.getRB7 : TBits_1; inline;
begin
  getRB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_PORTB.setRB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_PORTB.clearRB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_PORTB.setRB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_PORTB.getRB8 : TBits_1; inline;
begin
  getRB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_PORTB.setRB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_PORTB.clearRB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_PORTB.setRB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_PORTB.getRB9 : TBits_1; inline;
begin
  getRB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_PORTB.setRB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_PORTB.clearRB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_PORTB.setRB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_PORTB.getRB10 : TBits_1; inline;
begin
  getRB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_PORTB.setRB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_PORTB.clearRB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_PORTB.setRB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_PORTB.getRB11 : TBits_1; inline;
begin
  getRB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_PORTB.setRB12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTB_PORTB.clearRB12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTB_PORTB.setRB12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTB_PORTB.getRB12 : TBits_1; inline;
begin
  getRB12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTB_PORTB.setRB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_PORTB.clearRB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_PORTB.setRB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_PORTB.getRB13 : TBits_1; inline;
begin
  getRB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_PORTB.setRB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_PORTB.clearRB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_PORTB.setRB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_PORTB.getRB14 : TBits_1; inline;
begin
  getRB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_PORTB.setRB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_PORTB.clearRB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_PORTB.setRB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_PORTB.getRB15 : TBits_1; inline;
begin
  getRB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_PORTB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_PORTB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_LATB.setLATB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_LATB.clearLATB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_LATB.setLATB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_LATB.getLATB0 : TBits_1; inline;
begin
  getLATB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_LATB.setLATB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_LATB.clearLATB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_LATB.setLATB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_LATB.getLATB1 : TBits_1; inline;
begin
  getLATB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_LATB.setLATB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_LATB.clearLATB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_LATB.setLATB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_LATB.getLATB2 : TBits_1; inline;
begin
  getLATB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_LATB.setLATB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_LATB.clearLATB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_LATB.setLATB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_LATB.getLATB3 : TBits_1; inline;
begin
  getLATB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_LATB.setLATB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_LATB.clearLATB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_LATB.setLATB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_LATB.getLATB4 : TBits_1; inline;
begin
  getLATB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_LATB.setLATB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_LATB.clearLATB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_LATB.setLATB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_LATB.getLATB5 : TBits_1; inline;
begin
  getLATB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_LATB.setLATB6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTB_LATB.clearLATB6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTB_LATB.setLATB6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTB_LATB.getLATB6 : TBits_1; inline;
begin
  getLATB6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTB_LATB.setLATB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_LATB.clearLATB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_LATB.setLATB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_LATB.getLATB7 : TBits_1; inline;
begin
  getLATB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_LATB.setLATB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_LATB.clearLATB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_LATB.setLATB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_LATB.getLATB8 : TBits_1; inline;
begin
  getLATB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_LATB.setLATB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_LATB.clearLATB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_LATB.setLATB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_LATB.getLATB9 : TBits_1; inline;
begin
  getLATB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_LATB.setLATB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_LATB.clearLATB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_LATB.setLATB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_LATB.getLATB10 : TBits_1; inline;
begin
  getLATB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_LATB.setLATB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_LATB.clearLATB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_LATB.setLATB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_LATB.getLATB11 : TBits_1; inline;
begin
  getLATB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_LATB.setLATB12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTB_LATB.clearLATB12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTB_LATB.setLATB12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTB_LATB.getLATB12 : TBits_1; inline;
begin
  getLATB12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTB_LATB.setLATB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_LATB.clearLATB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_LATB.setLATB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_LATB.getLATB13 : TBits_1; inline;
begin
  getLATB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_LATB.setLATB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_LATB.clearLATB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_LATB.setLATB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_LATB.getLATB14 : TBits_1; inline;
begin
  getLATB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_LATB.setLATB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_LATB.clearLATB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_LATB.setLATB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_LATB.getLATB15 : TBits_1; inline;
begin
  getLATB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_LATB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_LATB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_ODCB.setODCB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_ODCB.clearODCB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_ODCB.setODCB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_ODCB.getODCB0 : TBits_1; inline;
begin
  getODCB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_ODCB.setODCB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_ODCB.clearODCB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_ODCB.setODCB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_ODCB.getODCB1 : TBits_1; inline;
begin
  getODCB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_ODCB.setODCB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_ODCB.clearODCB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_ODCB.setODCB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_ODCB.getODCB2 : TBits_1; inline;
begin
  getODCB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_ODCB.setODCB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_ODCB.clearODCB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_ODCB.setODCB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_ODCB.getODCB3 : TBits_1; inline;
begin
  getODCB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_ODCB.setODCB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_ODCB.clearODCB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_ODCB.setODCB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_ODCB.getODCB4 : TBits_1; inline;
begin
  getODCB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_ODCB.setODCB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_ODCB.clearODCB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_ODCB.setODCB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_ODCB.getODCB5 : TBits_1; inline;
begin
  getODCB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_ODCB.setODCB6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTB_ODCB.clearODCB6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTB_ODCB.setODCB6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTB_ODCB.getODCB6 : TBits_1; inline;
begin
  getODCB6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTB_ODCB.setODCB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_ODCB.clearODCB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_ODCB.setODCB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_ODCB.getODCB7 : TBits_1; inline;
begin
  getODCB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_ODCB.setODCB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_ODCB.clearODCB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_ODCB.setODCB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_ODCB.getODCB8 : TBits_1; inline;
begin
  getODCB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_ODCB.setODCB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_ODCB.clearODCB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_ODCB.setODCB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_ODCB.getODCB9 : TBits_1; inline;
begin
  getODCB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_ODCB.setODCB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_ODCB.clearODCB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_ODCB.setODCB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_ODCB.getODCB10 : TBits_1; inline;
begin
  getODCB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_ODCB.setODCB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_ODCB.clearODCB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_ODCB.setODCB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_ODCB.getODCB11 : TBits_1; inline;
begin
  getODCB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_ODCB.setODCB12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTB_ODCB.clearODCB12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTB_ODCB.setODCB12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTB_ODCB.getODCB12 : TBits_1; inline;
begin
  getODCB12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTB_ODCB.setODCB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_ODCB.clearODCB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_ODCB.setODCB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_ODCB.getODCB13 : TBits_1; inline;
begin
  getODCB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_ODCB.setODCB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_ODCB.clearODCB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_ODCB.setODCB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_ODCB.getODCB14 : TBits_1; inline;
begin
  getODCB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_ODCB.setODCB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_ODCB.clearODCB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_ODCB.setODCB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_ODCB.getODCB15 : TBits_1; inline;
begin
  getODCB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_ODCB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_ODCB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_CNPUB.setCNPUB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_CNPUB.clearCNPUB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_CNPUB.setCNPUB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_CNPUB.getCNPUB0 : TBits_1; inline;
begin
  getCNPUB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_CNPUB.setCNPUB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_CNPUB.clearCNPUB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_CNPUB.setCNPUB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_CNPUB.getCNPUB1 : TBits_1; inline;
begin
  getCNPUB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_CNPUB.setCNPUB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_CNPUB.clearCNPUB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_CNPUB.setCNPUB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_CNPUB.getCNPUB2 : TBits_1; inline;
begin
  getCNPUB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_CNPUB.setCNPUB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_CNPUB.clearCNPUB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_CNPUB.setCNPUB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_CNPUB.getCNPUB3 : TBits_1; inline;
begin
  getCNPUB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_CNPUB.setCNPUB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_CNPUB.clearCNPUB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_CNPUB.setCNPUB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_CNPUB.getCNPUB4 : TBits_1; inline;
begin
  getCNPUB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_CNPUB.setCNPUB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_CNPUB.clearCNPUB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_CNPUB.setCNPUB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_CNPUB.getCNPUB5 : TBits_1; inline;
begin
  getCNPUB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_CNPUB.setCNPUB6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTB_CNPUB.clearCNPUB6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTB_CNPUB.setCNPUB6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTB_CNPUB.getCNPUB6 : TBits_1; inline;
begin
  getCNPUB6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTB_CNPUB.setCNPUB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_CNPUB.clearCNPUB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_CNPUB.setCNPUB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_CNPUB.getCNPUB7 : TBits_1; inline;
begin
  getCNPUB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_CNPUB.setCNPUB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_CNPUB.clearCNPUB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_CNPUB.setCNPUB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_CNPUB.getCNPUB8 : TBits_1; inline;
begin
  getCNPUB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_CNPUB.setCNPUB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_CNPUB.clearCNPUB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_CNPUB.setCNPUB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_CNPUB.getCNPUB9 : TBits_1; inline;
begin
  getCNPUB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_CNPUB.setCNPUB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_CNPUB.clearCNPUB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_CNPUB.setCNPUB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_CNPUB.getCNPUB10 : TBits_1; inline;
begin
  getCNPUB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_CNPUB.setCNPUB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_CNPUB.clearCNPUB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_CNPUB.setCNPUB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_CNPUB.getCNPUB11 : TBits_1; inline;
begin
  getCNPUB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_CNPUB.setCNPUB12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTB_CNPUB.clearCNPUB12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTB_CNPUB.setCNPUB12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTB_CNPUB.getCNPUB12 : TBits_1; inline;
begin
  getCNPUB12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTB_CNPUB.setCNPUB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_CNPUB.clearCNPUB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_CNPUB.setCNPUB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_CNPUB.getCNPUB13 : TBits_1; inline;
begin
  getCNPUB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_CNPUB.setCNPUB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_CNPUB.clearCNPUB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_CNPUB.setCNPUB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_CNPUB.getCNPUB14 : TBits_1; inline;
begin
  getCNPUB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_CNPUB.setCNPUB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_CNPUB.clearCNPUB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_CNPUB.setCNPUB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_CNPUB.getCNPUB15 : TBits_1; inline;
begin
  getCNPUB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_CNPUB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_CNPUB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_CNPDB.setCNPDB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_CNPDB.clearCNPDB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_CNPDB.setCNPDB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_CNPDB.getCNPDB0 : TBits_1; inline;
begin
  getCNPDB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_CNPDB.setCNPDB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_CNPDB.clearCNPDB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_CNPDB.setCNPDB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_CNPDB.getCNPDB1 : TBits_1; inline;
begin
  getCNPDB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_CNPDB.setCNPDB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_CNPDB.clearCNPDB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_CNPDB.setCNPDB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_CNPDB.getCNPDB2 : TBits_1; inline;
begin
  getCNPDB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_CNPDB.setCNPDB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_CNPDB.clearCNPDB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_CNPDB.setCNPDB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_CNPDB.getCNPDB3 : TBits_1; inline;
begin
  getCNPDB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_CNPDB.setCNPDB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_CNPDB.clearCNPDB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_CNPDB.setCNPDB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_CNPDB.getCNPDB4 : TBits_1; inline;
begin
  getCNPDB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_CNPDB.setCNPDB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_CNPDB.clearCNPDB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_CNPDB.setCNPDB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_CNPDB.getCNPDB5 : TBits_1; inline;
begin
  getCNPDB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_CNPDB.setCNPDB6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTB_CNPDB.clearCNPDB6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTB_CNPDB.setCNPDB6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTB_CNPDB.getCNPDB6 : TBits_1; inline;
begin
  getCNPDB6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTB_CNPDB.setCNPDB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_CNPDB.clearCNPDB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_CNPDB.setCNPDB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_CNPDB.getCNPDB7 : TBits_1; inline;
begin
  getCNPDB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_CNPDB.setCNPDB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_CNPDB.clearCNPDB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_CNPDB.setCNPDB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_CNPDB.getCNPDB8 : TBits_1; inline;
begin
  getCNPDB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_CNPDB.setCNPDB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_CNPDB.clearCNPDB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_CNPDB.setCNPDB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_CNPDB.getCNPDB9 : TBits_1; inline;
begin
  getCNPDB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_CNPDB.setCNPDB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_CNPDB.clearCNPDB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_CNPDB.setCNPDB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_CNPDB.getCNPDB10 : TBits_1; inline;
begin
  getCNPDB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_CNPDB.setCNPDB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_CNPDB.clearCNPDB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_CNPDB.setCNPDB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_CNPDB.getCNPDB11 : TBits_1; inline;
begin
  getCNPDB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_CNPDB.setCNPDB12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTB_CNPDB.clearCNPDB12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTB_CNPDB.setCNPDB12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTB_CNPDB.getCNPDB12 : TBits_1; inline;
begin
  getCNPDB12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTB_CNPDB.setCNPDB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_CNPDB.clearCNPDB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_CNPDB.setCNPDB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_CNPDB.getCNPDB13 : TBits_1; inline;
begin
  getCNPDB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_CNPDB.setCNPDB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_CNPDB.clearCNPDB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_CNPDB.setCNPDB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_CNPDB.getCNPDB14 : TBits_1; inline;
begin
  getCNPDB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_CNPDB.setCNPDB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_CNPDB.clearCNPDB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_CNPDB.setCNPDB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_CNPDB.getCNPDB15 : TBits_1; inline;
begin
  getCNPDB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_CNPDB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_CNPDB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_CNCONB.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_CNCONB.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_CNCONB.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_CNCONB.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_CNCONB.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_CNCONB.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_CNCONB.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_CNCONB.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_CNCONB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_CNCONB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_CNENB.setCNIEB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_CNENB.clearCNIEB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_CNENB.setCNIEB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_CNENB.getCNIEB0 : TBits_1; inline;
begin
  getCNIEB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_CNENB.setCNIEB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_CNENB.clearCNIEB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_CNENB.setCNIEB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_CNENB.getCNIEB1 : TBits_1; inline;
begin
  getCNIEB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_CNENB.setCNIEB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_CNENB.clearCNIEB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_CNENB.setCNIEB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_CNENB.getCNIEB2 : TBits_1; inline;
begin
  getCNIEB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_CNENB.setCNIEB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_CNENB.clearCNIEB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_CNENB.setCNIEB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_CNENB.getCNIEB3 : TBits_1; inline;
begin
  getCNIEB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_CNENB.setCNIEB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_CNENB.clearCNIEB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_CNENB.setCNIEB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_CNENB.getCNIEB4 : TBits_1; inline;
begin
  getCNIEB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_CNENB.setCNIEB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_CNENB.clearCNIEB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_CNENB.setCNIEB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_CNENB.getCNIEB5 : TBits_1; inline;
begin
  getCNIEB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_CNENB.setCNIEB6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTB_CNENB.clearCNIEB6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTB_CNENB.setCNIEB6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTB_CNENB.getCNIEB6 : TBits_1; inline;
begin
  getCNIEB6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTB_CNENB.setCNIEB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_CNENB.clearCNIEB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_CNENB.setCNIEB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_CNENB.getCNIEB7 : TBits_1; inline;
begin
  getCNIEB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_CNENB.setCNIEB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_CNENB.clearCNIEB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_CNENB.setCNIEB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_CNENB.getCNIEB8 : TBits_1; inline;
begin
  getCNIEB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_CNENB.setCNIEB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_CNENB.clearCNIEB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_CNENB.setCNIEB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_CNENB.getCNIEB9 : TBits_1; inline;
begin
  getCNIEB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_CNENB.setCNIEB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_CNENB.clearCNIEB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_CNENB.setCNIEB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_CNENB.getCNIEB10 : TBits_1; inline;
begin
  getCNIEB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_CNENB.setCNIEB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_CNENB.clearCNIEB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_CNENB.setCNIEB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_CNENB.getCNIEB11 : TBits_1; inline;
begin
  getCNIEB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_CNENB.setCNIEB12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTB_CNENB.clearCNIEB12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTB_CNENB.setCNIEB12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTB_CNENB.getCNIEB12 : TBits_1; inline;
begin
  getCNIEB12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTB_CNENB.setCNIEB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_CNENB.clearCNIEB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_CNENB.setCNIEB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_CNENB.getCNIEB13 : TBits_1; inline;
begin
  getCNIEB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_CNENB.setCNIEB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_CNENB.clearCNIEB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_CNENB.setCNIEB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_CNENB.getCNIEB14 : TBits_1; inline;
begin
  getCNIEB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_CNENB.setCNIEB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_CNENB.clearCNIEB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_CNENB.setCNIEB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_CNENB.getCNIEB15 : TBits_1; inline;
begin
  getCNIEB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_CNENB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_CNENB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_CNSTATB.setCNSTATB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_CNSTATB.clearCNSTATB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_CNSTATB.setCNSTATB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_CNSTATB.getCNSTATB0 : TBits_1; inline;
begin
  getCNSTATB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_CNSTATB.setCNSTATB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_CNSTATB.clearCNSTATB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_CNSTATB.setCNSTATB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_CNSTATB.getCNSTATB1 : TBits_1; inline;
begin
  getCNSTATB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_CNSTATB.setCNSTATB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_CNSTATB.clearCNSTATB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_CNSTATB.setCNSTATB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_CNSTATB.getCNSTATB2 : TBits_1; inline;
begin
  getCNSTATB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_CNSTATB.setCNSTATB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_CNSTATB.clearCNSTATB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_CNSTATB.setCNSTATB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_CNSTATB.getCNSTATB3 : TBits_1; inline;
begin
  getCNSTATB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_CNSTATB.setCNSTATB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_CNSTATB.clearCNSTATB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_CNSTATB.setCNSTATB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_CNSTATB.getCNSTATB4 : TBits_1; inline;
begin
  getCNSTATB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_CNSTATB.setCNSTATB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_CNSTATB.clearCNSTATB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_CNSTATB.setCNSTATB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_CNSTATB.getCNSTATB5 : TBits_1; inline;
begin
  getCNSTATB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_CNSTATB.setCNSTATB6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTB_CNSTATB.clearCNSTATB6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTB_CNSTATB.setCNSTATB6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTB_CNSTATB.getCNSTATB6 : TBits_1; inline;
begin
  getCNSTATB6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTB_CNSTATB.setCNSTATB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_CNSTATB.clearCNSTATB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_CNSTATB.setCNSTATB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_CNSTATB.getCNSTATB7 : TBits_1; inline;
begin
  getCNSTATB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_CNSTATB.setCNSTATB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_CNSTATB.clearCNSTATB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_CNSTATB.setCNSTATB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_CNSTATB.getCNSTATB8 : TBits_1; inline;
begin
  getCNSTATB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_CNSTATB.setCNSTATB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_CNSTATB.clearCNSTATB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_CNSTATB.setCNSTATB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_CNSTATB.getCNSTATB9 : TBits_1; inline;
begin
  getCNSTATB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_CNSTATB.setCNSTATB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_CNSTATB.clearCNSTATB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_CNSTATB.setCNSTATB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_CNSTATB.getCNSTATB10 : TBits_1; inline;
begin
  getCNSTATB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_CNSTATB.setCNSTATB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_CNSTATB.clearCNSTATB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_CNSTATB.setCNSTATB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_CNSTATB.getCNSTATB11 : TBits_1; inline;
begin
  getCNSTATB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_CNSTATB.setCNSTATB12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTB_CNSTATB.clearCNSTATB12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTB_CNSTATB.setCNSTATB12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTB_CNSTATB.getCNSTATB12 : TBits_1; inline;
begin
  getCNSTATB12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTB_CNSTATB.setCNSTATB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_CNSTATB.clearCNSTATB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_CNSTATB.setCNSTATB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_CNSTATB.getCNSTATB13 : TBits_1; inline;
begin
  getCNSTATB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_CNSTATB.setCNSTATB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_CNSTATB.clearCNSTATB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_CNSTATB.setCNSTATB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_CNSTATB.getCNSTATB14 : TBits_1; inline;
begin
  getCNSTATB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_CNSTATB.setCNSTATB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_CNSTATB.clearCNSTATB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_CNSTATB.setCNSTATB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_CNSTATB.getCNSTATB15 : TBits_1; inline;
begin
  getCNSTATB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_CNSTATB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_CNSTATB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_ANSELC.setANSC12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTB_ANSELC.clearANSC12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTB_ANSELC.setANSC12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTB_ANSELC.getANSC12 : TBits_1; inline;
begin
  getANSC12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTB_ANSELC.setANSC13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_ANSELC.clearANSC13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_ANSELC.setANSC13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_ANSELC.getANSC13 : TBits_1; inline;
begin
  getANSC13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_ANSELC.setANSC14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_ANSELC.clearANSC14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_ANSELC.setANSC14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_ANSELC.getANSC14 : TBits_1; inline;
begin
  getANSC14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_ANSELC.setANSC15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_ANSELC.clearANSC15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_ANSELC.setANSC15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_ANSELC.getANSC15 : TBits_1; inline;
begin
  getANSC15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_ANSELC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_ANSELC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_TRISC.setTRISC12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTB_TRISC.clearTRISC12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTB_TRISC.setTRISC12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTB_TRISC.getTRISC12 : TBits_1; inline;
begin
  getTRISC12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTB_TRISC.setTRISC13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_TRISC.clearTRISC13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_TRISC.setTRISC13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_TRISC.getTRISC13 : TBits_1; inline;
begin
  getTRISC13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_TRISC.setTRISC14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_TRISC.clearTRISC14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_TRISC.setTRISC14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_TRISC.getTRISC14 : TBits_1; inline;
begin
  getTRISC14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_TRISC.setTRISC15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_TRISC.clearTRISC15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_TRISC.setTRISC15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_TRISC.getTRISC15 : TBits_1; inline;
begin
  getTRISC15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_TRISC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_TRISC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_PORTC.setRC12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTC_PORTC.clearRC12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTC_PORTC.setRC12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTC_PORTC.getRC12 : TBits_1; inline;
begin
  getRC12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTC_PORTC.setRC13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTC_PORTC.clearRC13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTC_PORTC.setRC13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTC_PORTC.getRC13 : TBits_1; inline;
begin
  getRC13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTC_PORTC.setRC14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTC_PORTC.clearRC14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTC_PORTC.setRC14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTC_PORTC.getRC14 : TBits_1; inline;
begin
  getRC14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTC_PORTC.setRC15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTC_PORTC.clearRC15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTC_PORTC.setRC15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTC_PORTC.getRC15 : TBits_1; inline;
begin
  getRC15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTC_PORTC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_PORTC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_LATC.setLATC12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTC_LATC.clearLATC12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTC_LATC.setLATC12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTC_LATC.getLATC12 : TBits_1; inline;
begin
  getLATC12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTC_LATC.setLATC13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTC_LATC.clearLATC13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTC_LATC.setLATC13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTC_LATC.getLATC13 : TBits_1; inline;
begin
  getLATC13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTC_LATC.setLATC14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTC_LATC.clearLATC14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTC_LATC.setLATC14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTC_LATC.getLATC14 : TBits_1; inline;
begin
  getLATC14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTC_LATC.setLATC15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTC_LATC.clearLATC15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTC_LATC.setLATC15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTC_LATC.getLATC15 : TBits_1; inline;
begin
  getLATC15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTC_LATC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_LATC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_ODCC.setODCC12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTC_ODCC.clearODCC12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTC_ODCC.setODCC12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTC_ODCC.getODCC12 : TBits_1; inline;
begin
  getODCC12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTC_ODCC.setODCC13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTC_ODCC.clearODCC13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTC_ODCC.setODCC13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTC_ODCC.getODCC13 : TBits_1; inline;
begin
  getODCC13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTC_ODCC.setODCC14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTC_ODCC.clearODCC14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTC_ODCC.setODCC14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTC_ODCC.getODCC14 : TBits_1; inline;
begin
  getODCC14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTC_ODCC.setODCC15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTC_ODCC.clearODCC15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTC_ODCC.setODCC15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTC_ODCC.getODCC15 : TBits_1; inline;
begin
  getODCC15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTC_ODCC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_ODCC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_CNPUC.setCNPUC12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTC_CNPUC.clearCNPUC12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTC_CNPUC.setCNPUC12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTC_CNPUC.getCNPUC12 : TBits_1; inline;
begin
  getCNPUC12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTC_CNPUC.setCNPUC13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTC_CNPUC.clearCNPUC13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTC_CNPUC.setCNPUC13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTC_CNPUC.getCNPUC13 : TBits_1; inline;
begin
  getCNPUC13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTC_CNPUC.setCNPUC14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTC_CNPUC.clearCNPUC14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTC_CNPUC.setCNPUC14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTC_CNPUC.getCNPUC14 : TBits_1; inline;
begin
  getCNPUC14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTC_CNPUC.setCNPUC15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTC_CNPUC.clearCNPUC15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTC_CNPUC.setCNPUC15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTC_CNPUC.getCNPUC15 : TBits_1; inline;
begin
  getCNPUC15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTC_CNPUC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_CNPUC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_CNPDC.setCNPDC12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTC_CNPDC.clearCNPDC12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTC_CNPDC.setCNPDC12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTC_CNPDC.getCNPDC12 : TBits_1; inline;
begin
  getCNPDC12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTC_CNPDC.setCNPDC13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTC_CNPDC.clearCNPDC13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTC_CNPDC.setCNPDC13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTC_CNPDC.getCNPDC13 : TBits_1; inline;
begin
  getCNPDC13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTC_CNPDC.setCNPDC14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTC_CNPDC.clearCNPDC14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTC_CNPDC.setCNPDC14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTC_CNPDC.getCNPDC14 : TBits_1; inline;
begin
  getCNPDC14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTC_CNPDC.setCNPDC15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTC_CNPDC.clearCNPDC15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTC_CNPDC.setCNPDC15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTC_CNPDC.getCNPDC15 : TBits_1; inline;
begin
  getCNPDC15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTC_CNPDC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_CNPDC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_CNCONC.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTC_CNCONC.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTC_CNCONC.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTC_CNCONC.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTC_CNCONC.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTC_CNCONC.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTC_CNCONC.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTC_CNCONC.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTC_CNCONC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_CNCONC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_CNENC.setCNIEC12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTC_CNENC.clearCNIEC12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTC_CNENC.setCNIEC12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTC_CNENC.getCNIEC12 : TBits_1; inline;
begin
  getCNIEC12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTC_CNENC.setCNIEC13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTC_CNENC.clearCNIEC13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTC_CNENC.setCNIEC13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTC_CNENC.getCNIEC13 : TBits_1; inline;
begin
  getCNIEC13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTC_CNENC.setCNIEC14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTC_CNENC.clearCNIEC14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTC_CNENC.setCNIEC14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTC_CNENC.getCNIEC14 : TBits_1; inline;
begin
  getCNIEC14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTC_CNENC.setCNIEC15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTC_CNENC.clearCNIEC15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTC_CNENC.setCNIEC15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTC_CNENC.getCNIEC15 : TBits_1; inline;
begin
  getCNIEC15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTC_CNENC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_CNENC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_CNSTATC.setCNSTATC12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTC_CNSTATC.clearCNSTATC12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTC_CNSTATC.setCNSTATC12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTC_CNSTATC.getCNSTATC12 : TBits_1; inline;
begin
  getCNSTATC12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTC_CNSTATC.setCNSTATC13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTC_CNSTATC.clearCNSTATC13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTC_CNSTATC.setCNSTATC13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTC_CNSTATC.getCNSTATC13 : TBits_1; inline;
begin
  getCNSTATC13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTC_CNSTATC.setCNSTATC14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTC_CNSTATC.clearCNSTATC14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTC_CNSTATC.setCNSTATC14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTC_CNSTATC.getCNSTATC14 : TBits_1; inline;
begin
  getCNSTATC14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTC_CNSTATC.setCNSTATC15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTC_CNSTATC.clearCNSTATC15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTC_CNSTATC.setCNSTATC15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTC_CNSTATC.getCNSTATC15 : TBits_1; inline;
begin
  getCNSTATC15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTC_CNSTATC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_CNSTATC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_ANSELD.setANSD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTC_ANSELD.clearANSD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTC_ANSELD.setANSD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTC_ANSELD.getANSD1 : TBits_1; inline;
begin
  getANSD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTC_ANSELD.setANSD2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTC_ANSELD.clearANSD2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTC_ANSELD.setANSD2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTC_ANSELD.getANSD2 : TBits_1; inline;
begin
  getANSD2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTC_ANSELD.setANSD3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTC_ANSELD.clearANSD3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTC_ANSELD.setANSD3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTC_ANSELD.getANSD3 : TBits_1; inline;
begin
  getANSD3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTC_ANSELD.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_ANSELD.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_TRISD.setTRISD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTC_TRISD.clearTRISD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTC_TRISD.setTRISD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTC_TRISD.getTRISD0 : TBits_1; inline;
begin
  getTRISD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTC_TRISD.setTRISD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTC_TRISD.clearTRISD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTC_TRISD.setTRISD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTC_TRISD.getTRISD1 : TBits_1; inline;
begin
  getTRISD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTC_TRISD.setTRISD2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTC_TRISD.clearTRISD2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTC_TRISD.setTRISD2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTC_TRISD.getTRISD2 : TBits_1; inline;
begin
  getTRISD2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTC_TRISD.setTRISD3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTC_TRISD.clearTRISD3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTC_TRISD.setTRISD3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTC_TRISD.getTRISD3 : TBits_1; inline;
begin
  getTRISD3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTC_TRISD.setTRISD4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTC_TRISD.clearTRISD4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTC_TRISD.setTRISD4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTC_TRISD.getTRISD4 : TBits_1; inline;
begin
  getTRISD4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTC_TRISD.setTRISD5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTC_TRISD.clearTRISD5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTC_TRISD.setTRISD5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTC_TRISD.getTRISD5 : TBits_1; inline;
begin
  getTRISD5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTC_TRISD.setTRISD6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTC_TRISD.clearTRISD6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTC_TRISD.setTRISD6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTC_TRISD.getTRISD6 : TBits_1; inline;
begin
  getTRISD6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTC_TRISD.setTRISD7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTC_TRISD.clearTRISD7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTC_TRISD.setTRISD7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTC_TRISD.getTRISD7 : TBits_1; inline;
begin
  getTRISD7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTC_TRISD.setTRISD8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTC_TRISD.clearTRISD8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTC_TRISD.setTRISD8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTC_TRISD.getTRISD8 : TBits_1; inline;
begin
  getTRISD8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTC_TRISD.setTRISD9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTC_TRISD.clearTRISD9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTC_TRISD.setTRISD9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTC_TRISD.getTRISD9 : TBits_1; inline;
begin
  getTRISD9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTC_TRISD.setTRISD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTC_TRISD.clearTRISD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTC_TRISD.setTRISD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTC_TRISD.getTRISD10 : TBits_1; inline;
begin
  getTRISD10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTC_TRISD.setTRISD11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTC_TRISD.clearTRISD11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTC_TRISD.setTRISD11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTC_TRISD.getTRISD11 : TBits_1; inline;
begin
  getTRISD11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTC_TRISD.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_TRISD.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_PORTD.setRD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTD_PORTD.clearRD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTD_PORTD.setRD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTD_PORTD.getRD0 : TBits_1; inline;
begin
  getRD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTD_PORTD.setRD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTD_PORTD.clearRD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTD_PORTD.setRD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTD_PORTD.getRD1 : TBits_1; inline;
begin
  getRD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTD_PORTD.setRD2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTD_PORTD.clearRD2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTD_PORTD.setRD2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTD_PORTD.getRD2 : TBits_1; inline;
begin
  getRD2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTD_PORTD.setRD3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTD_PORTD.clearRD3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTD_PORTD.setRD3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTD_PORTD.getRD3 : TBits_1; inline;
begin
  getRD3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTD_PORTD.setRD4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTD_PORTD.clearRD4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTD_PORTD.setRD4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTD_PORTD.getRD4 : TBits_1; inline;
begin
  getRD4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTD_PORTD.setRD5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTD_PORTD.clearRD5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTD_PORTD.setRD5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTD_PORTD.getRD5 : TBits_1; inline;
begin
  getRD5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTD_PORTD.setRD6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTD_PORTD.clearRD6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTD_PORTD.setRD6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTD_PORTD.getRD6 : TBits_1; inline;
begin
  getRD6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTD_PORTD.setRD7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTD_PORTD.clearRD7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTD_PORTD.setRD7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTD_PORTD.getRD7 : TBits_1; inline;
begin
  getRD7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTD_PORTD.setRD8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTD_PORTD.clearRD8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTD_PORTD.setRD8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTD_PORTD.getRD8 : TBits_1; inline;
begin
  getRD8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTD_PORTD.setRD9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTD_PORTD.clearRD9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTD_PORTD.setRD9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTD_PORTD.getRD9 : TBits_1; inline;
begin
  getRD9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTD_PORTD.setRD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTD_PORTD.clearRD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTD_PORTD.setRD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTD_PORTD.getRD10 : TBits_1; inline;
begin
  getRD10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTD_PORTD.setRD11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTD_PORTD.clearRD11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTD_PORTD.setRD11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTD_PORTD.getRD11 : TBits_1; inline;
begin
  getRD11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTD_PORTD.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_PORTD.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_LATD.setLATD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTD_LATD.clearLATD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTD_LATD.setLATD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTD_LATD.getLATD0 : TBits_1; inline;
begin
  getLATD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTD_LATD.setLATD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTD_LATD.clearLATD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTD_LATD.setLATD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTD_LATD.getLATD1 : TBits_1; inline;
begin
  getLATD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTD_LATD.setLATD2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTD_LATD.clearLATD2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTD_LATD.setLATD2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTD_LATD.getLATD2 : TBits_1; inline;
begin
  getLATD2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTD_LATD.setLATD3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTD_LATD.clearLATD3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTD_LATD.setLATD3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTD_LATD.getLATD3 : TBits_1; inline;
begin
  getLATD3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTD_LATD.setLATD4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTD_LATD.clearLATD4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTD_LATD.setLATD4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTD_LATD.getLATD4 : TBits_1; inline;
begin
  getLATD4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTD_LATD.setLATD5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTD_LATD.clearLATD5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTD_LATD.setLATD5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTD_LATD.getLATD5 : TBits_1; inline;
begin
  getLATD5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTD_LATD.setLATD6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTD_LATD.clearLATD6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTD_LATD.setLATD6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTD_LATD.getLATD6 : TBits_1; inline;
begin
  getLATD6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTD_LATD.setLATD7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTD_LATD.clearLATD7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTD_LATD.setLATD7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTD_LATD.getLATD7 : TBits_1; inline;
begin
  getLATD7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTD_LATD.setLATD8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTD_LATD.clearLATD8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTD_LATD.setLATD8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTD_LATD.getLATD8 : TBits_1; inline;
begin
  getLATD8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTD_LATD.setLATD9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTD_LATD.clearLATD9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTD_LATD.setLATD9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTD_LATD.getLATD9 : TBits_1; inline;
begin
  getLATD9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTD_LATD.setLATD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTD_LATD.clearLATD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTD_LATD.setLATD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTD_LATD.getLATD10 : TBits_1; inline;
begin
  getLATD10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTD_LATD.setLATD11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTD_LATD.clearLATD11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTD_LATD.setLATD11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTD_LATD.getLATD11 : TBits_1; inline;
begin
  getLATD11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTD_LATD.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_LATD.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_ODCD.setODCD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTD_ODCD.clearODCD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTD_ODCD.setODCD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTD_ODCD.getODCD0 : TBits_1; inline;
begin
  getODCD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTD_ODCD.setODCD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTD_ODCD.clearODCD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTD_ODCD.setODCD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTD_ODCD.getODCD1 : TBits_1; inline;
begin
  getODCD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTD_ODCD.setODCD2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTD_ODCD.clearODCD2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTD_ODCD.setODCD2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTD_ODCD.getODCD2 : TBits_1; inline;
begin
  getODCD2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTD_ODCD.setODCD3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTD_ODCD.clearODCD3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTD_ODCD.setODCD3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTD_ODCD.getODCD3 : TBits_1; inline;
begin
  getODCD3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTD_ODCD.setODCD4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTD_ODCD.clearODCD4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTD_ODCD.setODCD4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTD_ODCD.getODCD4 : TBits_1; inline;
begin
  getODCD4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTD_ODCD.setODCD5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTD_ODCD.clearODCD5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTD_ODCD.setODCD5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTD_ODCD.getODCD5 : TBits_1; inline;
begin
  getODCD5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTD_ODCD.setODCD6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTD_ODCD.clearODCD6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTD_ODCD.setODCD6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTD_ODCD.getODCD6 : TBits_1; inline;
begin
  getODCD6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTD_ODCD.setODCD7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTD_ODCD.clearODCD7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTD_ODCD.setODCD7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTD_ODCD.getODCD7 : TBits_1; inline;
begin
  getODCD7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTD_ODCD.setODCD8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTD_ODCD.clearODCD8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTD_ODCD.setODCD8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTD_ODCD.getODCD8 : TBits_1; inline;
begin
  getODCD8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTD_ODCD.setODCD9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTD_ODCD.clearODCD9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTD_ODCD.setODCD9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTD_ODCD.getODCD9 : TBits_1; inline;
begin
  getODCD9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTD_ODCD.setODCD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTD_ODCD.clearODCD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTD_ODCD.setODCD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTD_ODCD.getODCD10 : TBits_1; inline;
begin
  getODCD10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTD_ODCD.setODCD11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTD_ODCD.clearODCD11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTD_ODCD.setODCD11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTD_ODCD.getODCD11 : TBits_1; inline;
begin
  getODCD11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTD_ODCD.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_ODCD.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_CNPUD.setCNPUD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTD_CNPUD.clearCNPUD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTD_CNPUD.setCNPUD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTD_CNPUD.getCNPUD0 : TBits_1; inline;
begin
  getCNPUD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTD_CNPUD.setCNPUD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTD_CNPUD.clearCNPUD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTD_CNPUD.setCNPUD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTD_CNPUD.getCNPUD1 : TBits_1; inline;
begin
  getCNPUD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTD_CNPUD.setCNPUD2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTD_CNPUD.clearCNPUD2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTD_CNPUD.setCNPUD2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTD_CNPUD.getCNPUD2 : TBits_1; inline;
begin
  getCNPUD2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTD_CNPUD.setCNPUD3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTD_CNPUD.clearCNPUD3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTD_CNPUD.setCNPUD3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTD_CNPUD.getCNPUD3 : TBits_1; inline;
begin
  getCNPUD3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTD_CNPUD.setCNPUD4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTD_CNPUD.clearCNPUD4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTD_CNPUD.setCNPUD4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTD_CNPUD.getCNPUD4 : TBits_1; inline;
begin
  getCNPUD4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTD_CNPUD.setCNPUD5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTD_CNPUD.clearCNPUD5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTD_CNPUD.setCNPUD5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTD_CNPUD.getCNPUD5 : TBits_1; inline;
begin
  getCNPUD5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTD_CNPUD.setCNPUD6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTD_CNPUD.clearCNPUD6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTD_CNPUD.setCNPUD6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTD_CNPUD.getCNPUD6 : TBits_1; inline;
begin
  getCNPUD6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTD_CNPUD.setCNPUD7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTD_CNPUD.clearCNPUD7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTD_CNPUD.setCNPUD7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTD_CNPUD.getCNPUD7 : TBits_1; inline;
begin
  getCNPUD7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTD_CNPUD.setCNPUD8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTD_CNPUD.clearCNPUD8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTD_CNPUD.setCNPUD8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTD_CNPUD.getCNPUD8 : TBits_1; inline;
begin
  getCNPUD8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTD_CNPUD.setCNPUD9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTD_CNPUD.clearCNPUD9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTD_CNPUD.setCNPUD9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTD_CNPUD.getCNPUD9 : TBits_1; inline;
begin
  getCNPUD9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTD_CNPUD.setCNPUD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTD_CNPUD.clearCNPUD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTD_CNPUD.setCNPUD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTD_CNPUD.getCNPUD10 : TBits_1; inline;
begin
  getCNPUD10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTD_CNPUD.setCNPUD11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTD_CNPUD.clearCNPUD11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTD_CNPUD.setCNPUD11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTD_CNPUD.getCNPUD11 : TBits_1; inline;
begin
  getCNPUD11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTD_CNPUD.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_CNPUD.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_CNPDD.setCNPDD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTD_CNPDD.clearCNPDD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTD_CNPDD.setCNPDD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTD_CNPDD.getCNPDD0 : TBits_1; inline;
begin
  getCNPDD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTD_CNPDD.setCNPDD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTD_CNPDD.clearCNPDD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTD_CNPDD.setCNPDD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTD_CNPDD.getCNPDD1 : TBits_1; inline;
begin
  getCNPDD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTD_CNPDD.setCNPDD2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTD_CNPDD.clearCNPDD2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTD_CNPDD.setCNPDD2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTD_CNPDD.getCNPDD2 : TBits_1; inline;
begin
  getCNPDD2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTD_CNPDD.setCNPDD3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTD_CNPDD.clearCNPDD3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTD_CNPDD.setCNPDD3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTD_CNPDD.getCNPDD3 : TBits_1; inline;
begin
  getCNPDD3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTD_CNPDD.setCNPDD4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTD_CNPDD.clearCNPDD4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTD_CNPDD.setCNPDD4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTD_CNPDD.getCNPDD4 : TBits_1; inline;
begin
  getCNPDD4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTD_CNPDD.setCNPDD5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTD_CNPDD.clearCNPDD5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTD_CNPDD.setCNPDD5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTD_CNPDD.getCNPDD5 : TBits_1; inline;
begin
  getCNPDD5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTD_CNPDD.setCNPDD6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTD_CNPDD.clearCNPDD6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTD_CNPDD.setCNPDD6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTD_CNPDD.getCNPDD6 : TBits_1; inline;
begin
  getCNPDD6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTD_CNPDD.setCNPDD7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTD_CNPDD.clearCNPDD7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTD_CNPDD.setCNPDD7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTD_CNPDD.getCNPDD7 : TBits_1; inline;
begin
  getCNPDD7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTD_CNPDD.setCNPDD8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTD_CNPDD.clearCNPDD8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTD_CNPDD.setCNPDD8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTD_CNPDD.getCNPDD8 : TBits_1; inline;
begin
  getCNPDD8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTD_CNPDD.setCNPDD9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTD_CNPDD.clearCNPDD9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTD_CNPDD.setCNPDD9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTD_CNPDD.getCNPDD9 : TBits_1; inline;
begin
  getCNPDD9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTD_CNPDD.setCNPDD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTD_CNPDD.clearCNPDD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTD_CNPDD.setCNPDD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTD_CNPDD.getCNPDD10 : TBits_1; inline;
begin
  getCNPDD10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTD_CNPDD.setCNPDD11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTD_CNPDD.clearCNPDD11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTD_CNPDD.setCNPDD11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTD_CNPDD.getCNPDD11 : TBits_1; inline;
begin
  getCNPDD11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTD_CNPDD.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_CNPDD.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_CNCOND.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTD_CNCOND.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTD_CNCOND.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTD_CNCOND.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTD_CNCOND.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTD_CNCOND.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTD_CNCOND.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTD_CNCOND.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTD_CNCOND.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_CNCOND.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_CNEND.setCNIED0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTD_CNEND.clearCNIED0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTD_CNEND.setCNIED0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTD_CNEND.getCNIED0 : TBits_1; inline;
begin
  getCNIED0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTD_CNEND.setCNIED1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTD_CNEND.clearCNIED1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTD_CNEND.setCNIED1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTD_CNEND.getCNIED1 : TBits_1; inline;
begin
  getCNIED1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTD_CNEND.setCNIED2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTD_CNEND.clearCNIED2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTD_CNEND.setCNIED2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTD_CNEND.getCNIED2 : TBits_1; inline;
begin
  getCNIED2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTD_CNEND.setCNIED3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTD_CNEND.clearCNIED3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTD_CNEND.setCNIED3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTD_CNEND.getCNIED3 : TBits_1; inline;
begin
  getCNIED3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTD_CNEND.setCNIED4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTD_CNEND.clearCNIED4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTD_CNEND.setCNIED4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTD_CNEND.getCNIED4 : TBits_1; inline;
begin
  getCNIED4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTD_CNEND.setCNIED5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTD_CNEND.clearCNIED5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTD_CNEND.setCNIED5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTD_CNEND.getCNIED5 : TBits_1; inline;
begin
  getCNIED5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTD_CNEND.setCNIED6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTD_CNEND.clearCNIED6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTD_CNEND.setCNIED6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTD_CNEND.getCNIED6 : TBits_1; inline;
begin
  getCNIED6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTD_CNEND.setCNIED7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTD_CNEND.clearCNIED7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTD_CNEND.setCNIED7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTD_CNEND.getCNIED7 : TBits_1; inline;
begin
  getCNIED7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTD_CNEND.setCNIED8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTD_CNEND.clearCNIED8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTD_CNEND.setCNIED8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTD_CNEND.getCNIED8 : TBits_1; inline;
begin
  getCNIED8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTD_CNEND.setCNIED9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTD_CNEND.clearCNIED9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTD_CNEND.setCNIED9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTD_CNEND.getCNIED9 : TBits_1; inline;
begin
  getCNIED9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTD_CNEND.setCNIED10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTD_CNEND.clearCNIED10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTD_CNEND.setCNIED10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTD_CNEND.getCNIED10 : TBits_1; inline;
begin
  getCNIED10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTD_CNEND.setCNIED11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTD_CNEND.clearCNIED11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTD_CNEND.setCNIED11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTD_CNEND.getCNIED11 : TBits_1; inline;
begin
  getCNIED11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTD_CNEND.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_CNEND.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_CNSTATD.setCNSTATD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTD_CNSTATD.clearCNSTATD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTD_CNSTATD.setCNSTATD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTD_CNSTATD.getCNSTATD0 : TBits_1; inline;
begin
  getCNSTATD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTD_CNSTATD.setCNSTATD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTD_CNSTATD.clearCNSTATD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTD_CNSTATD.setCNSTATD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTD_CNSTATD.getCNSTATD1 : TBits_1; inline;
begin
  getCNSTATD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTD_CNSTATD.setCNSTATD2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTD_CNSTATD.clearCNSTATD2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTD_CNSTATD.setCNSTATD2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTD_CNSTATD.getCNSTATD2 : TBits_1; inline;
begin
  getCNSTATD2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTD_CNSTATD.setCNSTATD3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTD_CNSTATD.clearCNSTATD3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTD_CNSTATD.setCNSTATD3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTD_CNSTATD.getCNSTATD3 : TBits_1; inline;
begin
  getCNSTATD3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTD_CNSTATD.setCNSTATD4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTD_CNSTATD.clearCNSTATD4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTD_CNSTATD.setCNSTATD4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTD_CNSTATD.getCNSTATD4 : TBits_1; inline;
begin
  getCNSTATD4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTD_CNSTATD.setCNSTATD5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTD_CNSTATD.clearCNSTATD5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTD_CNSTATD.setCNSTATD5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTD_CNSTATD.getCNSTATD5 : TBits_1; inline;
begin
  getCNSTATD5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTD_CNSTATD.setCNSTATD6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTD_CNSTATD.clearCNSTATD6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTD_CNSTATD.setCNSTATD6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTD_CNSTATD.getCNSTATD6 : TBits_1; inline;
begin
  getCNSTATD6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTD_CNSTATD.setCNSTATD7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTD_CNSTATD.clearCNSTATD7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTD_CNSTATD.setCNSTATD7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTD_CNSTATD.getCNSTATD7 : TBits_1; inline;
begin
  getCNSTATD7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTD_CNSTATD.setCNSTATD8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTD_CNSTATD.clearCNSTATD8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTD_CNSTATD.setCNSTATD8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTD_CNSTATD.getCNSTATD8 : TBits_1; inline;
begin
  getCNSTATD8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTD_CNSTATD.setCNSTATD9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTD_CNSTATD.clearCNSTATD9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTD_CNSTATD.setCNSTATD9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTD_CNSTATD.getCNSTATD9 : TBits_1; inline;
begin
  getCNSTATD9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTD_CNSTATD.setCNSTATD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTD_CNSTATD.clearCNSTATD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTD_CNSTATD.setCNSTATD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTD_CNSTATD.getCNSTATD10 : TBits_1; inline;
begin
  getCNSTATD10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTD_CNSTATD.setCNSTATD11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTD_CNSTATD.clearCNSTATD11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTD_CNSTATD.setCNSTATD11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTD_CNSTATD.getCNSTATD11 : TBits_1; inline;
begin
  getCNSTATD11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTD_CNSTATD.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_CNSTATD.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_ANSELE.setANSE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTD_ANSELE.clearANSE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTD_ANSELE.setANSE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTD_ANSELE.getANSE2 : TBits_1; inline;
begin
  getANSE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTD_ANSELE.setANSE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTD_ANSELE.clearANSE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTD_ANSELE.setANSE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTD_ANSELE.getANSE4 : TBits_1; inline;
begin
  getANSE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTD_ANSELE.setANSE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTD_ANSELE.clearANSE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTD_ANSELE.setANSE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTD_ANSELE.getANSE5 : TBits_1; inline;
begin
  getANSE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTD_ANSELE.setANSE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTD_ANSELE.clearANSE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTD_ANSELE.setANSE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTD_ANSELE.getANSE6 : TBits_1; inline;
begin
  getANSE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTD_ANSELE.setANSE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTD_ANSELE.clearANSE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTD_ANSELE.setANSE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTD_ANSELE.getANSE7 : TBits_1; inline;
begin
  getANSE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTD_ANSELE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_ANSELE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_TRISE.setTRISE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTD_TRISE.clearTRISE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTD_TRISE.setTRISE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTD_TRISE.getTRISE0 : TBits_1; inline;
begin
  getTRISE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTD_TRISE.setTRISE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTD_TRISE.clearTRISE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTD_TRISE.setTRISE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTD_TRISE.getTRISE1 : TBits_1; inline;
begin
  getTRISE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTD_TRISE.setTRISE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTD_TRISE.clearTRISE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTD_TRISE.setTRISE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTD_TRISE.getTRISE2 : TBits_1; inline;
begin
  getTRISE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTD_TRISE.setTRISE3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTD_TRISE.clearTRISE3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTD_TRISE.setTRISE3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTD_TRISE.getTRISE3 : TBits_1; inline;
begin
  getTRISE3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTD_TRISE.setTRISE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTD_TRISE.clearTRISE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTD_TRISE.setTRISE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTD_TRISE.getTRISE4 : TBits_1; inline;
begin
  getTRISE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTD_TRISE.setTRISE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTD_TRISE.clearTRISE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTD_TRISE.setTRISE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTD_TRISE.getTRISE5 : TBits_1; inline;
begin
  getTRISE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTD_TRISE.setTRISE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTD_TRISE.clearTRISE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTD_TRISE.setTRISE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTD_TRISE.getTRISE6 : TBits_1; inline;
begin
  getTRISE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTD_TRISE.setTRISE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTD_TRISE.clearTRISE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTD_TRISE.setTRISE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTD_TRISE.getTRISE7 : TBits_1; inline;
begin
  getTRISE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTD_TRISE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_TRISE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_PORTE.setRE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTE_PORTE.clearRE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTE_PORTE.setRE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTE_PORTE.getRE0 : TBits_1; inline;
begin
  getRE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTE_PORTE.setRE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTE_PORTE.clearRE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTE_PORTE.setRE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTE_PORTE.getRE1 : TBits_1; inline;
begin
  getRE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTE_PORTE.setRE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTE_PORTE.clearRE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTE_PORTE.setRE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTE_PORTE.getRE2 : TBits_1; inline;
begin
  getRE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTE_PORTE.setRE3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTE_PORTE.clearRE3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTE_PORTE.setRE3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTE_PORTE.getRE3 : TBits_1; inline;
begin
  getRE3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTE_PORTE.setRE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTE_PORTE.clearRE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTE_PORTE.setRE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTE_PORTE.getRE4 : TBits_1; inline;
begin
  getRE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTE_PORTE.setRE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTE_PORTE.clearRE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTE_PORTE.setRE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTE_PORTE.getRE5 : TBits_1; inline;
begin
  getRE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTE_PORTE.setRE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTE_PORTE.clearRE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTE_PORTE.setRE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTE_PORTE.getRE6 : TBits_1; inline;
begin
  getRE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTE_PORTE.setRE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTE_PORTE.clearRE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTE_PORTE.setRE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTE_PORTE.getRE7 : TBits_1; inline;
begin
  getRE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTE_PORTE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_PORTE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_LATE.setLATE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTE_LATE.clearLATE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTE_LATE.setLATE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTE_LATE.getLATE0 : TBits_1; inline;
begin
  getLATE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTE_LATE.setLATE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTE_LATE.clearLATE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTE_LATE.setLATE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTE_LATE.getLATE1 : TBits_1; inline;
begin
  getLATE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTE_LATE.setLATE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTE_LATE.clearLATE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTE_LATE.setLATE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTE_LATE.getLATE2 : TBits_1; inline;
begin
  getLATE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTE_LATE.setLATE3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTE_LATE.clearLATE3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTE_LATE.setLATE3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTE_LATE.getLATE3 : TBits_1; inline;
begin
  getLATE3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTE_LATE.setLATE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTE_LATE.clearLATE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTE_LATE.setLATE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTE_LATE.getLATE4 : TBits_1; inline;
begin
  getLATE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTE_LATE.setLATE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTE_LATE.clearLATE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTE_LATE.setLATE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTE_LATE.getLATE5 : TBits_1; inline;
begin
  getLATE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTE_LATE.setLATE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTE_LATE.clearLATE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTE_LATE.setLATE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTE_LATE.getLATE6 : TBits_1; inline;
begin
  getLATE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTE_LATE.setLATE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTE_LATE.clearLATE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTE_LATE.setLATE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTE_LATE.getLATE7 : TBits_1; inline;
begin
  getLATE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTE_LATE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_LATE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_ODCE.setODCE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTE_ODCE.clearODCE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTE_ODCE.setODCE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTE_ODCE.getODCE0 : TBits_1; inline;
begin
  getODCE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTE_ODCE.setODCE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTE_ODCE.clearODCE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTE_ODCE.setODCE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTE_ODCE.getODCE1 : TBits_1; inline;
begin
  getODCE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTE_ODCE.setODCE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTE_ODCE.clearODCE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTE_ODCE.setODCE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTE_ODCE.getODCE2 : TBits_1; inline;
begin
  getODCE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTE_ODCE.setODCE3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTE_ODCE.clearODCE3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTE_ODCE.setODCE3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTE_ODCE.getODCE3 : TBits_1; inline;
begin
  getODCE3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTE_ODCE.setODCE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTE_ODCE.clearODCE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTE_ODCE.setODCE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTE_ODCE.getODCE4 : TBits_1; inline;
begin
  getODCE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTE_ODCE.setODCE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTE_ODCE.clearODCE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTE_ODCE.setODCE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTE_ODCE.getODCE5 : TBits_1; inline;
begin
  getODCE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTE_ODCE.setODCE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTE_ODCE.clearODCE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTE_ODCE.setODCE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTE_ODCE.getODCE6 : TBits_1; inline;
begin
  getODCE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTE_ODCE.setODCE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTE_ODCE.clearODCE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTE_ODCE.setODCE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTE_ODCE.getODCE7 : TBits_1; inline;
begin
  getODCE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTE_ODCE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_ODCE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_CNPUE.setCNPUE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTE_CNPUE.clearCNPUE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTE_CNPUE.setCNPUE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTE_CNPUE.getCNPUE0 : TBits_1; inline;
begin
  getCNPUE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTE_CNPUE.setCNPUE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTE_CNPUE.clearCNPUE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTE_CNPUE.setCNPUE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTE_CNPUE.getCNPUE1 : TBits_1; inline;
begin
  getCNPUE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTE_CNPUE.setCNPUE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTE_CNPUE.clearCNPUE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTE_CNPUE.setCNPUE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTE_CNPUE.getCNPUE2 : TBits_1; inline;
begin
  getCNPUE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTE_CNPUE.setCNPUE3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTE_CNPUE.clearCNPUE3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTE_CNPUE.setCNPUE3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTE_CNPUE.getCNPUE3 : TBits_1; inline;
begin
  getCNPUE3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTE_CNPUE.setCNPUE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTE_CNPUE.clearCNPUE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTE_CNPUE.setCNPUE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTE_CNPUE.getCNPUE4 : TBits_1; inline;
begin
  getCNPUE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTE_CNPUE.setCNPUE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTE_CNPUE.clearCNPUE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTE_CNPUE.setCNPUE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTE_CNPUE.getCNPUE5 : TBits_1; inline;
begin
  getCNPUE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTE_CNPUE.setCNPUE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTE_CNPUE.clearCNPUE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTE_CNPUE.setCNPUE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTE_CNPUE.getCNPUE6 : TBits_1; inline;
begin
  getCNPUE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTE_CNPUE.setCNPUE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTE_CNPUE.clearCNPUE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTE_CNPUE.setCNPUE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTE_CNPUE.getCNPUE7 : TBits_1; inline;
begin
  getCNPUE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTE_CNPUE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_CNPUE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_CNPDE.setCNPDE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTE_CNPDE.clearCNPDE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTE_CNPDE.setCNPDE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTE_CNPDE.getCNPDE0 : TBits_1; inline;
begin
  getCNPDE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTE_CNPDE.setCNPDE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTE_CNPDE.clearCNPDE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTE_CNPDE.setCNPDE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTE_CNPDE.getCNPDE1 : TBits_1; inline;
begin
  getCNPDE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTE_CNPDE.setCNPDE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTE_CNPDE.clearCNPDE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTE_CNPDE.setCNPDE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTE_CNPDE.getCNPDE2 : TBits_1; inline;
begin
  getCNPDE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTE_CNPDE.setCNPDE3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTE_CNPDE.clearCNPDE3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTE_CNPDE.setCNPDE3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTE_CNPDE.getCNPDE3 : TBits_1; inline;
begin
  getCNPDE3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTE_CNPDE.setCNPDE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTE_CNPDE.clearCNPDE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTE_CNPDE.setCNPDE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTE_CNPDE.getCNPDE4 : TBits_1; inline;
begin
  getCNPDE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTE_CNPDE.setCNPDE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTE_CNPDE.clearCNPDE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTE_CNPDE.setCNPDE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTE_CNPDE.getCNPDE5 : TBits_1; inline;
begin
  getCNPDE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTE_CNPDE.setCNPDE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTE_CNPDE.clearCNPDE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTE_CNPDE.setCNPDE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTE_CNPDE.getCNPDE6 : TBits_1; inline;
begin
  getCNPDE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTE_CNPDE.setCNPDE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTE_CNPDE.clearCNPDE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTE_CNPDE.setCNPDE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTE_CNPDE.getCNPDE7 : TBits_1; inline;
begin
  getCNPDE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTE_CNPDE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_CNPDE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_CNCONE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTE_CNCONE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTE_CNCONE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTE_CNCONE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTE_CNCONE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTE_CNCONE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTE_CNCONE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTE_CNCONE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTE_CNCONE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_CNCONE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_CNENE.setCNIEE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTE_CNENE.clearCNIEE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTE_CNENE.setCNIEE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTE_CNENE.getCNIEE0 : TBits_1; inline;
begin
  getCNIEE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTE_CNENE.setCNIEE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTE_CNENE.clearCNIEE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTE_CNENE.setCNIEE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTE_CNENE.getCNIEE1 : TBits_1; inline;
begin
  getCNIEE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTE_CNENE.setCNIEE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTE_CNENE.clearCNIEE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTE_CNENE.setCNIEE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTE_CNENE.getCNIEE2 : TBits_1; inline;
begin
  getCNIEE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTE_CNENE.setCNIEE3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTE_CNENE.clearCNIEE3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTE_CNENE.setCNIEE3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTE_CNENE.getCNIEE3 : TBits_1; inline;
begin
  getCNIEE3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTE_CNENE.setCNIEE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTE_CNENE.clearCNIEE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTE_CNENE.setCNIEE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTE_CNENE.getCNIEE4 : TBits_1; inline;
begin
  getCNIEE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTE_CNENE.setCNIEE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTE_CNENE.clearCNIEE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTE_CNENE.setCNIEE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTE_CNENE.getCNIEE5 : TBits_1; inline;
begin
  getCNIEE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTE_CNENE.setCNIEE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTE_CNENE.clearCNIEE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTE_CNENE.setCNIEE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTE_CNENE.getCNIEE6 : TBits_1; inline;
begin
  getCNIEE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTE_CNENE.setCNIEE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTE_CNENE.clearCNIEE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTE_CNENE.setCNIEE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTE_CNENE.getCNIEE7 : TBits_1; inline;
begin
  getCNIEE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTE_CNENE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_CNENE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_CNSTATE.setCNSTATE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTE_CNSTATE.clearCNSTATE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTE_CNSTATE.setCNSTATE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTE_CNSTATE.getCNSTATE0 : TBits_1; inline;
begin
  getCNSTATE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTE_CNSTATE.setCNSTATE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTE_CNSTATE.clearCNSTATE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTE_CNSTATE.setCNSTATE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTE_CNSTATE.getCNSTATE1 : TBits_1; inline;
begin
  getCNSTATE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTE_CNSTATE.setCNSTATE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTE_CNSTATE.clearCNSTATE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTE_CNSTATE.setCNSTATE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTE_CNSTATE.getCNSTATE2 : TBits_1; inline;
begin
  getCNSTATE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTE_CNSTATE.setCNSTATE3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTE_CNSTATE.clearCNSTATE3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTE_CNSTATE.setCNSTATE3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTE_CNSTATE.getCNSTATE3 : TBits_1; inline;
begin
  getCNSTATE3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTE_CNSTATE.setCNSTATE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTE_CNSTATE.clearCNSTATE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTE_CNSTATE.setCNSTATE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTE_CNSTATE.getCNSTATE4 : TBits_1; inline;
begin
  getCNSTATE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTE_CNSTATE.setCNSTATE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTE_CNSTATE.clearCNSTATE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTE_CNSTATE.setCNSTATE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTE_CNSTATE.getCNSTATE5 : TBits_1; inline;
begin
  getCNSTATE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTE_CNSTATE.setCNSTATE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTE_CNSTATE.clearCNSTATE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTE_CNSTATE.setCNSTATE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTE_CNSTATE.getCNSTATE6 : TBits_1; inline;
begin
  getCNSTATE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTE_CNSTATE.setCNSTATE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTE_CNSTATE.clearCNSTATE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTE_CNSTATE.setCNSTATE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTE_CNSTATE.getCNSTATE7 : TBits_1; inline;
begin
  getCNSTATE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTE_CNSTATE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_CNSTATE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_ANSELF.setANSF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTE_ANSELF.clearANSF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTE_ANSELF.setANSF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTE_ANSELF.getANSF0 : TBits_1; inline;
begin
  getANSF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTE_ANSELF.setANSF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTE_ANSELF.clearANSF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTE_ANSELF.setANSF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTE_ANSELF.getANSF1 : TBits_1; inline;
begin
  getANSF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTE_ANSELF.setANSF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTE_ANSELF.clearANSF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTE_ANSELF.setANSF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTE_ANSELF.getANSF2 : TBits_1; inline;
begin
  getANSF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTE_ANSELF.setANSF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTE_ANSELF.clearANSF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTE_ANSELF.setANSF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTE_ANSELF.getANSF3 : TBits_1; inline;
begin
  getANSF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTE_ANSELF.setANSF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTE_ANSELF.clearANSF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTE_ANSELF.setANSF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTE_ANSELF.getANSF4 : TBits_1; inline;
begin
  getANSF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTE_ANSELF.setANSF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTE_ANSELF.clearANSF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTE_ANSELF.setANSF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTE_ANSELF.getANSF5 : TBits_1; inline;
begin
  getANSF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTE_ANSELF.setANSF6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTE_ANSELF.clearANSF6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTE_ANSELF.setANSF6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTE_ANSELF.getANSF6 : TBits_1; inline;
begin
  getANSF6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTE_ANSELF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_ANSELF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_TRISF.setTRISF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTE_TRISF.clearTRISF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTE_TRISF.setTRISF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTE_TRISF.getTRISF0 : TBits_1; inline;
begin
  getTRISF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTE_TRISF.setTRISF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTE_TRISF.clearTRISF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTE_TRISF.setTRISF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTE_TRISF.getTRISF1 : TBits_1; inline;
begin
  getTRISF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTE_TRISF.setTRISF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTE_TRISF.clearTRISF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTE_TRISF.setTRISF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTE_TRISF.getTRISF2 : TBits_1; inline;
begin
  getTRISF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTE_TRISF.setTRISF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTE_TRISF.clearTRISF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTE_TRISF.setTRISF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTE_TRISF.getTRISF3 : TBits_1; inline;
begin
  getTRISF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTE_TRISF.setTRISF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTE_TRISF.clearTRISF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTE_TRISF.setTRISF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTE_TRISF.getTRISF4 : TBits_1; inline;
begin
  getTRISF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTE_TRISF.setTRISF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTE_TRISF.clearTRISF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTE_TRISF.setTRISF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTE_TRISF.getTRISF5 : TBits_1; inline;
begin
  getTRISF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTE_TRISF.setTRISF6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTE_TRISF.clearTRISF6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTE_TRISF.setTRISF6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTE_TRISF.getTRISF6 : TBits_1; inline;
begin
  getTRISF6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTE_TRISF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_TRISF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_PORTF.setRF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTF_PORTF.clearRF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTF_PORTF.setRF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTF_PORTF.getRF0 : TBits_1; inline;
begin
  getRF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTF_PORTF.setRF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTF_PORTF.clearRF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTF_PORTF.setRF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTF_PORTF.getRF1 : TBits_1; inline;
begin
  getRF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTF_PORTF.setRF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTF_PORTF.clearRF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTF_PORTF.setRF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTF_PORTF.getRF2 : TBits_1; inline;
begin
  getRF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTF_PORTF.setRF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTF_PORTF.clearRF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTF_PORTF.setRF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTF_PORTF.getRF3 : TBits_1; inline;
begin
  getRF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTF_PORTF.setRF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTF_PORTF.clearRF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTF_PORTF.setRF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTF_PORTF.getRF4 : TBits_1; inline;
begin
  getRF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTF_PORTF.setRF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTF_PORTF.clearRF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTF_PORTF.setRF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTF_PORTF.getRF5 : TBits_1; inline;
begin
  getRF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTF_PORTF.setRF6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTF_PORTF.clearRF6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTF_PORTF.setRF6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTF_PORTF.getRF6 : TBits_1; inline;
begin
  getRF6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTF_PORTF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_PORTF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_LATF.setLATF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTF_LATF.clearLATF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTF_LATF.setLATF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTF_LATF.getLATF0 : TBits_1; inline;
begin
  getLATF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTF_LATF.setLATF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTF_LATF.clearLATF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTF_LATF.setLATF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTF_LATF.getLATF1 : TBits_1; inline;
begin
  getLATF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTF_LATF.setLATF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTF_LATF.clearLATF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTF_LATF.setLATF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTF_LATF.getLATF2 : TBits_1; inline;
begin
  getLATF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTF_LATF.setLATF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTF_LATF.clearLATF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTF_LATF.setLATF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTF_LATF.getLATF3 : TBits_1; inline;
begin
  getLATF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTF_LATF.setLATF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTF_LATF.clearLATF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTF_LATF.setLATF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTF_LATF.getLATF4 : TBits_1; inline;
begin
  getLATF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTF_LATF.setLATF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTF_LATF.clearLATF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTF_LATF.setLATF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTF_LATF.getLATF5 : TBits_1; inline;
begin
  getLATF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTF_LATF.setLATF6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTF_LATF.clearLATF6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTF_LATF.setLATF6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTF_LATF.getLATF6 : TBits_1; inline;
begin
  getLATF6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTF_LATF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_LATF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_ODCF.setODCF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTF_ODCF.clearODCF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTF_ODCF.setODCF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTF_ODCF.getODCF0 : TBits_1; inline;
begin
  getODCF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTF_ODCF.setODCF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTF_ODCF.clearODCF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTF_ODCF.setODCF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTF_ODCF.getODCF1 : TBits_1; inline;
begin
  getODCF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTF_ODCF.setODCF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTF_ODCF.clearODCF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTF_ODCF.setODCF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTF_ODCF.getODCF2 : TBits_1; inline;
begin
  getODCF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTF_ODCF.setODCF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTF_ODCF.clearODCF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTF_ODCF.setODCF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTF_ODCF.getODCF3 : TBits_1; inline;
begin
  getODCF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTF_ODCF.setODCF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTF_ODCF.clearODCF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTF_ODCF.setODCF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTF_ODCF.getODCF4 : TBits_1; inline;
begin
  getODCF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTF_ODCF.setODCF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTF_ODCF.clearODCF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTF_ODCF.setODCF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTF_ODCF.getODCF5 : TBits_1; inline;
begin
  getODCF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTF_ODCF.setODCF6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTF_ODCF.clearODCF6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTF_ODCF.setODCF6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTF_ODCF.getODCF6 : TBits_1; inline;
begin
  getODCF6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTF_ODCF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_ODCF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_CNPUF.setCNPUF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTF_CNPUF.clearCNPUF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTF_CNPUF.setCNPUF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTF_CNPUF.getCNPUF0 : TBits_1; inline;
begin
  getCNPUF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTF_CNPUF.setCNPUF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTF_CNPUF.clearCNPUF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTF_CNPUF.setCNPUF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTF_CNPUF.getCNPUF1 : TBits_1; inline;
begin
  getCNPUF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTF_CNPUF.setCNPUF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTF_CNPUF.clearCNPUF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTF_CNPUF.setCNPUF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTF_CNPUF.getCNPUF2 : TBits_1; inline;
begin
  getCNPUF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTF_CNPUF.setCNPUF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTF_CNPUF.clearCNPUF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTF_CNPUF.setCNPUF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTF_CNPUF.getCNPUF3 : TBits_1; inline;
begin
  getCNPUF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTF_CNPUF.setCNPUF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTF_CNPUF.clearCNPUF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTF_CNPUF.setCNPUF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTF_CNPUF.getCNPUF4 : TBits_1; inline;
begin
  getCNPUF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTF_CNPUF.setCNPUF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTF_CNPUF.clearCNPUF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTF_CNPUF.setCNPUF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTF_CNPUF.getCNPUF5 : TBits_1; inline;
begin
  getCNPUF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTF_CNPUF.setCNPUF6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTF_CNPUF.clearCNPUF6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTF_CNPUF.setCNPUF6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTF_CNPUF.getCNPUF6 : TBits_1; inline;
begin
  getCNPUF6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTF_CNPUF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_CNPUF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_CNPDF.setCNPDF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTF_CNPDF.clearCNPDF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTF_CNPDF.setCNPDF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTF_CNPDF.getCNPDF0 : TBits_1; inline;
begin
  getCNPDF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTF_CNPDF.setCNPDF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTF_CNPDF.clearCNPDF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTF_CNPDF.setCNPDF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTF_CNPDF.getCNPDF1 : TBits_1; inline;
begin
  getCNPDF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTF_CNPDF.setCNPDF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTF_CNPDF.clearCNPDF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTF_CNPDF.setCNPDF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTF_CNPDF.getCNPDF2 : TBits_1; inline;
begin
  getCNPDF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTF_CNPDF.setCNPDF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTF_CNPDF.clearCNPDF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTF_CNPDF.setCNPDF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTF_CNPDF.getCNPDF3 : TBits_1; inline;
begin
  getCNPDF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTF_CNPDF.setCNPDF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTF_CNPDF.clearCNPDF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTF_CNPDF.setCNPDF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTF_CNPDF.getCNPDF4 : TBits_1; inline;
begin
  getCNPDF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTF_CNPDF.setCNPDF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTF_CNPDF.clearCNPDF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTF_CNPDF.setCNPDF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTF_CNPDF.getCNPDF5 : TBits_1; inline;
begin
  getCNPDF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTF_CNPDF.setCNPDF6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTF_CNPDF.clearCNPDF6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTF_CNPDF.setCNPDF6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTF_CNPDF.getCNPDF6 : TBits_1; inline;
begin
  getCNPDF6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTF_CNPDF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_CNPDF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_CNCONF.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTF_CNCONF.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTF_CNCONF.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTF_CNCONF.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTF_CNCONF.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTF_CNCONF.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTF_CNCONF.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTF_CNCONF.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTF_CNCONF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_CNCONF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_CNENF.setCNIEF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTF_CNENF.clearCNIEF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTF_CNENF.setCNIEF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTF_CNENF.getCNIEF0 : TBits_1; inline;
begin
  getCNIEF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTF_CNENF.setCNIEF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTF_CNENF.clearCNIEF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTF_CNENF.setCNIEF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTF_CNENF.getCNIEF1 : TBits_1; inline;
begin
  getCNIEF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTF_CNENF.setCNIEF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTF_CNENF.clearCNIEF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTF_CNENF.setCNIEF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTF_CNENF.getCNIEF2 : TBits_1; inline;
begin
  getCNIEF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTF_CNENF.setCNIEF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTF_CNENF.clearCNIEF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTF_CNENF.setCNIEF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTF_CNENF.getCNIEF3 : TBits_1; inline;
begin
  getCNIEF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTF_CNENF.setCNIEF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTF_CNENF.clearCNIEF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTF_CNENF.setCNIEF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTF_CNENF.getCNIEF4 : TBits_1; inline;
begin
  getCNIEF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTF_CNENF.setCNIEF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTF_CNENF.clearCNIEF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTF_CNENF.setCNIEF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTF_CNENF.getCNIEF5 : TBits_1; inline;
begin
  getCNIEF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTF_CNENF.setCNIEF6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTF_CNENF.clearCNIEF6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTF_CNENF.setCNIEF6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTF_CNENF.getCNIEF6 : TBits_1; inline;
begin
  getCNIEF6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTF_CNENF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_CNENF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_CNSTATF.setCNSTATF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTF_CNSTATF.clearCNSTATF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTF_CNSTATF.setCNSTATF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTF_CNSTATF.getCNSTATF0 : TBits_1; inline;
begin
  getCNSTATF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTF_CNSTATF.setCNSTATF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTF_CNSTATF.clearCNSTATF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTF_CNSTATF.setCNSTATF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTF_CNSTATF.getCNSTATF1 : TBits_1; inline;
begin
  getCNSTATF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTF_CNSTATF.setCNSTATF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTF_CNSTATF.clearCNSTATF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTF_CNSTATF.setCNSTATF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTF_CNSTATF.getCNSTATF2 : TBits_1; inline;
begin
  getCNSTATF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTF_CNSTATF.setCNSTATF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTF_CNSTATF.clearCNSTATF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTF_CNSTATF.setCNSTATF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTF_CNSTATF.getCNSTATF3 : TBits_1; inline;
begin
  getCNSTATF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTF_CNSTATF.setCNSTATF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTF_CNSTATF.clearCNSTATF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTF_CNSTATF.setCNSTATF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTF_CNSTATF.getCNSTATF4 : TBits_1; inline;
begin
  getCNSTATF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTF_CNSTATF.setCNSTATF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTF_CNSTATF.clearCNSTATF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTF_CNSTATF.setCNSTATF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTF_CNSTATF.getCNSTATF5 : TBits_1; inline;
begin
  getCNSTATF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTF_CNSTATF.setCNSTATF6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTF_CNSTATF.clearCNSTATF6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTF_CNSTATF.setCNSTATF6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTF_CNSTATF.getCNSTATF6 : TBits_1; inline;
begin
  getCNSTATF6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTF_CNSTATF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_CNSTATF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_ANSELG.setANSG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTF_ANSELG.clearANSG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTF_ANSELG.setANSG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTF_ANSELG.getANSG6 : TBits_1; inline;
begin
  getANSG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTF_ANSELG.setANSG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTF_ANSELG.clearANSG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTF_ANSELG.setANSG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTF_ANSELG.getANSG7 : TBits_1; inline;
begin
  getANSG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTF_ANSELG.setANSG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTF_ANSELG.clearANSG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTF_ANSELG.setANSG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTF_ANSELG.getANSG8 : TBits_1; inline;
begin
  getANSG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTF_ANSELG.setANSG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTF_ANSELG.clearANSG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTF_ANSELG.setANSG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTF_ANSELG.getANSG9 : TBits_1; inline;
begin
  getANSG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTF_ANSELG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_ANSELG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_TRISG.setTRISG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTF_TRISG.clearTRISG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTF_TRISG.setTRISG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTF_TRISG.getTRISG2 : TBits_1; inline;
begin
  getTRISG2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTF_TRISG.setTRISG3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTF_TRISG.clearTRISG3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTF_TRISG.setTRISG3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTF_TRISG.getTRISG3 : TBits_1; inline;
begin
  getTRISG3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTF_TRISG.setTRISG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTF_TRISG.clearTRISG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTF_TRISG.setTRISG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTF_TRISG.getTRISG6 : TBits_1; inline;
begin
  getTRISG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTF_TRISG.setTRISG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTF_TRISG.clearTRISG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTF_TRISG.setTRISG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTF_TRISG.getTRISG7 : TBits_1; inline;
begin
  getTRISG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTF_TRISG.setTRISG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTF_TRISG.clearTRISG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTF_TRISG.setTRISG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTF_TRISG.getTRISG8 : TBits_1; inline;
begin
  getTRISG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTF_TRISG.setTRISG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTF_TRISG.clearTRISG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTF_TRISG.setTRISG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTF_TRISG.getTRISG9 : TBits_1; inline;
begin
  getTRISG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTF_TRISG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_TRISG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_PORTG.setRG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTG_PORTG.clearRG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTG_PORTG.setRG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTG_PORTG.getRG2 : TBits_1; inline;
begin
  getRG2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTG_PORTG.setRG3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTG_PORTG.clearRG3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTG_PORTG.setRG3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTG_PORTG.getRG3 : TBits_1; inline;
begin
  getRG3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTG_PORTG.setRG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTG_PORTG.clearRG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTG_PORTG.setRG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTG_PORTG.getRG6 : TBits_1; inline;
begin
  getRG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTG_PORTG.setRG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTG_PORTG.clearRG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTG_PORTG.setRG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTG_PORTG.getRG7 : TBits_1; inline;
begin
  getRG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTG_PORTG.setRG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTG_PORTG.clearRG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTG_PORTG.setRG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTG_PORTG.getRG8 : TBits_1; inline;
begin
  getRG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTG_PORTG.setRG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTG_PORTG.clearRG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTG_PORTG.setRG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTG_PORTG.getRG9 : TBits_1; inline;
begin
  getRG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTG_PORTG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_PORTG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_LATG.setLATG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTG_LATG.clearLATG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTG_LATG.setLATG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTG_LATG.getLATG2 : TBits_1; inline;
begin
  getLATG2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTG_LATG.setLATG3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTG_LATG.clearLATG3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTG_LATG.setLATG3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTG_LATG.getLATG3 : TBits_1; inline;
begin
  getLATG3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTG_LATG.setLATG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTG_LATG.clearLATG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTG_LATG.setLATG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTG_LATG.getLATG6 : TBits_1; inline;
begin
  getLATG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTG_LATG.setLATG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTG_LATG.clearLATG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTG_LATG.setLATG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTG_LATG.getLATG7 : TBits_1; inline;
begin
  getLATG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTG_LATG.setLATG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTG_LATG.clearLATG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTG_LATG.setLATG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTG_LATG.getLATG8 : TBits_1; inline;
begin
  getLATG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTG_LATG.setLATG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTG_LATG.clearLATG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTG_LATG.setLATG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTG_LATG.getLATG9 : TBits_1; inline;
begin
  getLATG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTG_LATG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_LATG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_ODCG.setODCG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTG_ODCG.clearODCG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTG_ODCG.setODCG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTG_ODCG.getODCG2 : TBits_1; inline;
begin
  getODCG2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTG_ODCG.setODCG3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTG_ODCG.clearODCG3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTG_ODCG.setODCG3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTG_ODCG.getODCG3 : TBits_1; inline;
begin
  getODCG3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTG_ODCG.setODCG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTG_ODCG.clearODCG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTG_ODCG.setODCG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTG_ODCG.getODCG6 : TBits_1; inline;
begin
  getODCG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTG_ODCG.setODCG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTG_ODCG.clearODCG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTG_ODCG.setODCG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTG_ODCG.getODCG7 : TBits_1; inline;
begin
  getODCG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTG_ODCG.setODCG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTG_ODCG.clearODCG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTG_ODCG.setODCG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTG_ODCG.getODCG8 : TBits_1; inline;
begin
  getODCG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTG_ODCG.setODCG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTG_ODCG.clearODCG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTG_ODCG.setODCG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTG_ODCG.getODCG9 : TBits_1; inline;
begin
  getODCG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTG_ODCG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_ODCG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_CNPUG.setCNPUG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTG_CNPUG.clearCNPUG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTG_CNPUG.setCNPUG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTG_CNPUG.getCNPUG2 : TBits_1; inline;
begin
  getCNPUG2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTG_CNPUG.setCNPUG3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTG_CNPUG.clearCNPUG3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTG_CNPUG.setCNPUG3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTG_CNPUG.getCNPUG3 : TBits_1; inline;
begin
  getCNPUG3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTG_CNPUG.setCNPUG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTG_CNPUG.clearCNPUG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTG_CNPUG.setCNPUG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTG_CNPUG.getCNPUG6 : TBits_1; inline;
begin
  getCNPUG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTG_CNPUG.setCNPUG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTG_CNPUG.clearCNPUG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTG_CNPUG.setCNPUG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTG_CNPUG.getCNPUG7 : TBits_1; inline;
begin
  getCNPUG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTG_CNPUG.setCNPUG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTG_CNPUG.clearCNPUG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTG_CNPUG.setCNPUG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTG_CNPUG.getCNPUG8 : TBits_1; inline;
begin
  getCNPUG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTG_CNPUG.setCNPUG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTG_CNPUG.clearCNPUG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTG_CNPUG.setCNPUG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTG_CNPUG.getCNPUG9 : TBits_1; inline;
begin
  getCNPUG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTG_CNPUG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_CNPUG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_CNPDG.setCNPDG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTG_CNPDG.clearCNPDG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTG_CNPDG.setCNPDG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTG_CNPDG.getCNPDG2 : TBits_1; inline;
begin
  getCNPDG2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTG_CNPDG.setCNPDG3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTG_CNPDG.clearCNPDG3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTG_CNPDG.setCNPDG3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTG_CNPDG.getCNPDG3 : TBits_1; inline;
begin
  getCNPDG3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTG_CNPDG.setCNPDG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTG_CNPDG.clearCNPDG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTG_CNPDG.setCNPDG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTG_CNPDG.getCNPDG6 : TBits_1; inline;
begin
  getCNPDG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTG_CNPDG.setCNPDG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTG_CNPDG.clearCNPDG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTG_CNPDG.setCNPDG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTG_CNPDG.getCNPDG7 : TBits_1; inline;
begin
  getCNPDG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTG_CNPDG.setCNPDG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTG_CNPDG.clearCNPDG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTG_CNPDG.setCNPDG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTG_CNPDG.getCNPDG8 : TBits_1; inline;
begin
  getCNPDG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTG_CNPDG.setCNPDG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTG_CNPDG.clearCNPDG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTG_CNPDG.setCNPDG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTG_CNPDG.getCNPDG9 : TBits_1; inline;
begin
  getCNPDG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTG_CNPDG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_CNPDG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_CNCONG.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTG_CNCONG.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTG_CNCONG.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTG_CNCONG.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTG_CNCONG.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTG_CNCONG.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTG_CNCONG.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTG_CNCONG.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTG_CNCONG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_CNCONG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_CNENG.setCNIEG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTG_CNENG.clearCNIEG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTG_CNENG.setCNIEG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTG_CNENG.getCNIEG2 : TBits_1; inline;
begin
  getCNIEG2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTG_CNENG.setCNIEG3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTG_CNENG.clearCNIEG3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTG_CNENG.setCNIEG3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTG_CNENG.getCNIEG3 : TBits_1; inline;
begin
  getCNIEG3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTG_CNENG.setCNIEG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTG_CNENG.clearCNIEG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTG_CNENG.setCNIEG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTG_CNENG.getCNIEG6 : TBits_1; inline;
begin
  getCNIEG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTG_CNENG.setCNIEG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTG_CNENG.clearCNIEG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTG_CNENG.setCNIEG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTG_CNENG.getCNIEG7 : TBits_1; inline;
begin
  getCNIEG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTG_CNENG.setCNIEG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTG_CNENG.clearCNIEG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTG_CNENG.setCNIEG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTG_CNENG.getCNIEG8 : TBits_1; inline;
begin
  getCNIEG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTG_CNENG.setCNIEG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTG_CNENG.clearCNIEG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTG_CNENG.setCNIEG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTG_CNENG.getCNIEG9 : TBits_1; inline;
begin
  getCNIEG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTG_CNENG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_CNENG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_CNSTATG.setCNSTATG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTG_CNSTATG.clearCNSTATG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTG_CNSTATG.setCNSTATG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTG_CNSTATG.getCNSTATG2 : TBits_1; inline;
begin
  getCNSTATG2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTG_CNSTATG.setCNSTATG3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTG_CNSTATG.clearCNSTATG3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTG_CNSTATG.setCNSTATG3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTG_CNSTATG.getCNSTATG3 : TBits_1; inline;
begin
  getCNSTATG3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTG_CNSTATG.setCNSTATG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTG_CNSTATG.clearCNSTATG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTG_CNSTATG.setCNSTATG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTG_CNSTATG.getCNSTATG6 : TBits_1; inline;
begin
  getCNSTATG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTG_CNSTATG.setCNSTATG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTG_CNSTATG.clearCNSTATG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTG_CNSTATG.setCNSTATG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTG_CNSTATG.getCNSTATG7 : TBits_1; inline;
begin
  getCNSTATG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTG_CNSTATG.setCNSTATG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTG_CNSTATG.clearCNSTATG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTG_CNSTATG.setCNSTATG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTG_CNSTATG.getCNSTATG8 : TBits_1; inline;
begin
  getCNSTATG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTG_CNSTATG.setCNSTATG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTG_CNSTATG.clearCNSTATG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTG_CNSTATG.setCNSTATG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTG_CNSTATG.getCNSTATG9 : TBits_1; inline;
begin
  getCNSTATG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTG_CNSTATG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_CNSTATG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG3.setUSERID(thebits : TBits_16); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0000 or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG3.getUSERID : TBits_16; inline;
begin
  getUSERID := (pTDefRegMap(@Self)^.val and $0000FFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG3.setFSRSSEL(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF8FFFF or ( thebits shl 16 );
end;
function  TDEVCFG_DEVCFG3.getFSRSSEL : TBits_3; inline;
begin
  getFSRSSEL := (pTDefRegMap(@Self)^.val and $00070000) shr 16;
end;
procedure TDEVCFG_DEVCFG3.setPMDL1WAY; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TDEVCFG_DEVCFG3.clearPMDL1WAY; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TDEVCFG_DEVCFG3.setPMDL1WAY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TDEVCFG_DEVCFG3.getPMDL1WAY : TBits_1; inline;
begin
  getPMDL1WAY := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TDEVCFG_DEVCFG3.setIOL1WAY; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TDEVCFG_DEVCFG3.clearIOL1WAY; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TDEVCFG_DEVCFG3.setIOL1WAY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TDEVCFG_DEVCFG3.getIOL1WAY : TBits_1; inline;
begin
  getIOL1WAY := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TDEVCFG_DEVCFG3.setFUSBIDIO; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TDEVCFG_DEVCFG3.clearFUSBIDIO; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TDEVCFG_DEVCFG3.setFUSBIDIO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TDEVCFG_DEVCFG3.getFUSBIDIO : TBits_1; inline;
begin
  getFUSBIDIO := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TDEVCFG_DEVCFG3.setFVBUSONIO; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TDEVCFG_DEVCFG3.clearFVBUSONIO; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TDEVCFG_DEVCFG3.setFVBUSONIO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TDEVCFG_DEVCFG3.getFVBUSONIO : TBits_1; inline;
begin
  getFVBUSONIO := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TDEVCFG_DEVCFG3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDEVCFG_DEVCFG3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG2.setFPLLIDIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG2.getFPLLIDIV : TBits_3; inline;
begin
  getFPLLIDIV := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TDEVCFG_DEVCFG2.setFPLLMUL(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TDEVCFG_DEVCFG2.getFPLLMUL : TBits_3; inline;
begin
  getFPLLMUL := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TDEVCFG_DEVCFG2.setUPLLIDIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF8FF or ( thebits shl 8 );
end;
function  TDEVCFG_DEVCFG2.getUPLLIDIV : TBits_3; inline;
begin
  getUPLLIDIV := (pTDefRegMap(@Self)^.val and $00000700) shr 8;
end;
procedure TDEVCFG_DEVCFG2.setUPLLEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDEVCFG_DEVCFG2.clearUPLLEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDEVCFG_DEVCFG2.setUPLLEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDEVCFG_DEVCFG2.getUPLLEN : TBits_1; inline;
begin
  getUPLLEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDEVCFG_DEVCFG2.setFPLLODIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF8FFFF or ( thebits shl 16 );
end;
function  TDEVCFG_DEVCFG2.getFPLLODIV : TBits_3; inline;
begin
  getFPLLODIV := (pTDefRegMap(@Self)^.val and $00070000) shr 16;
end;
procedure TDEVCFG_DEVCFG2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDEVCFG_DEVCFG2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG1.setFNOSC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG1.getFNOSC : TBits_3; inline;
begin
  getFNOSC := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TDEVCFG_DEVCFG1.setFSOSCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDEVCFG_DEVCFG1.clearFSOSCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDEVCFG_DEVCFG1.setFSOSCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDEVCFG_DEVCFG1.getFSOSCEN : TBits_1; inline;
begin
  getFSOSCEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDEVCFG_DEVCFG1.setIESO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDEVCFG_DEVCFG1.clearIESO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDEVCFG_DEVCFG1.setIESO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDEVCFG_DEVCFG1.getIESO : TBits_1; inline;
begin
  getIESO := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDEVCFG_DEVCFG1.setPOSCMOD(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TDEVCFG_DEVCFG1.getPOSCMOD : TBits_2; inline;
begin
  getPOSCMOD := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TDEVCFG_DEVCFG1.setOSCIOFNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TDEVCFG_DEVCFG1.clearOSCIOFNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TDEVCFG_DEVCFG1.setOSCIOFNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TDEVCFG_DEVCFG1.getOSCIOFNC : TBits_1; inline;
begin
  getOSCIOFNC := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TDEVCFG_DEVCFG1.setFPBDIV(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFCFFF or ( thebits shl 12 );
end;
function  TDEVCFG_DEVCFG1.getFPBDIV : TBits_2; inline;
begin
  getFPBDIV := (pTDefRegMap(@Self)^.val and $00003000) shr 12;
end;
procedure TDEVCFG_DEVCFG1.setFCKSM(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TDEVCFG_DEVCFG1.getFCKSM : TBits_2; inline;
begin
  getFCKSM := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TDEVCFG_DEVCFG1.setWDTPS(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TDEVCFG_DEVCFG1.getWDTPS : TBits_5; inline;
begin
  getWDTPS := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TDEVCFG_DEVCFG1.setWINDIS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDEVCFG_DEVCFG1.clearWINDIS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDEVCFG_DEVCFG1.setWINDIS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDEVCFG_DEVCFG1.getWINDIS : TBits_1; inline;
begin
  getWINDIS := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDEVCFG_DEVCFG1.setFWDTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDEVCFG_DEVCFG1.clearFWDTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDEVCFG_DEVCFG1.setFWDTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDEVCFG_DEVCFG1.getFWDTEN : TBits_1; inline;
begin
  getFWDTEN := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDEVCFG_DEVCFG1.setFWDTWINSZ(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TDEVCFG_DEVCFG1.getFWDTWINSZ : TBits_2; inline;
begin
  getFWDTWINSZ := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TDEVCFG_DEVCFG1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDEVCFG_DEVCFG1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG0.setDEBUG(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG0.getDEBUG : TBits_2; inline;
begin
  getDEBUG := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDEVCFG_DEVCFG0.setJTAGEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDEVCFG_DEVCFG0.clearJTAGEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDEVCFG_DEVCFG0.setJTAGEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDEVCFG_DEVCFG0.getJTAGEN : TBits_1; inline;
begin
  getJTAGEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDEVCFG_DEVCFG0.setICESEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE7 or ( thebits shl 3 );
end;
function  TDEVCFG_DEVCFG0.getICESEL : TBits_2; inline;
begin
  getICESEL := (pTDefRegMap(@Self)^.val and $00000018) shr 3;
end;
procedure TDEVCFG_DEVCFG0.setPWP(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF00FFF or ( thebits shl 12 );
end;
function  TDEVCFG_DEVCFG0.getPWP : TBits_8; inline;
begin
  getPWP := (pTDefRegMap(@Self)^.val and $000FF000) shr 12;
end;
procedure TDEVCFG_DEVCFG0.setBWP; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TDEVCFG_DEVCFG0.clearBWP; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TDEVCFG_DEVCFG0.setBWP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TDEVCFG_DEVCFG0.getBWP : TBits_1; inline;
begin
  getBWP := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TDEVCFG_DEVCFG0.setCP; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TDEVCFG_DEVCFG0.clearCP; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TDEVCFG_DEVCFG0.setCP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TDEVCFG_DEVCFG0.getCP : TBits_1; inline;
begin
  getCP := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TDEVCFG_DEVCFG0.setFDEBUG(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG0.getFDEBUG : TBits_2; inline;
begin
  getFDEBUG := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDEVCFG_DEVCFG0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDEVCFG_DEVCFG0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
  procedure _CORE_TIMER_VECTOR_interrupt; external name '_CORE_TIMER_VECTOR_interrupt';
  procedure _CORE_SOFTWARE_0_VECTOR_interrupt; external name '_CORE_SOFTWARE_0_VECTOR_interrupt';
  procedure _CORE_SOFTWARE_1_VECTOR_interrupt; external name '_CORE_SOFTWARE_1_VECTOR_interrupt';
  procedure _EXTERNAL_0_VECTOR_interrupt; external name '_EXTERNAL_0_VECTOR_interrupt';
  procedure _TIMER_1_VECTOR_interrupt; external name '_TIMER_1_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_1_VECTOR_interrupt; external name '_INPUT_CAPTURE_1_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_1_VECTOR_interrupt; external name '_OUTPUT_COMPARE_1_VECTOR_interrupt';
  procedure _EXTERNAL_1_VECTOR_interrupt; external name '_EXTERNAL_1_VECTOR_interrupt';
  procedure _TIMER_2_VECTOR_interrupt; external name '_TIMER_2_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_2_VECTOR_interrupt; external name '_INPUT_CAPTURE_2_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_2_VECTOR_interrupt; external name '_OUTPUT_COMPARE_2_VECTOR_interrupt';
  procedure _EXTERNAL_2_VECTOR_interrupt; external name '_EXTERNAL_2_VECTOR_interrupt';
  procedure _TIMER_3_VECTOR_interrupt; external name '_TIMER_3_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_3_VECTOR_interrupt; external name '_INPUT_CAPTURE_3_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_3_VECTOR_interrupt; external name '_OUTPUT_COMPARE_3_VECTOR_interrupt';
  procedure _EXTERNAL_3_VECTOR_interrupt; external name '_EXTERNAL_3_VECTOR_interrupt';
  procedure _TIMER_4_VECTOR_interrupt; external name '_TIMER_4_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_4_VECTOR_interrupt; external name '_INPUT_CAPTURE_4_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_4_VECTOR_interrupt; external name '_OUTPUT_COMPARE_4_VECTOR_interrupt';
  procedure _EXTERNAL_4_VECTOR_interrupt; external name '_EXTERNAL_4_VECTOR_interrupt';
  procedure _TIMER_5_VECTOR_interrupt; external name '_TIMER_5_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_5_VECTOR_interrupt; external name '_INPUT_CAPTURE_5_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_5_VECTOR_interrupt; external name '_OUTPUT_COMPARE_5_VECTOR_interrupt';
  procedure _ADC_VECTOR_interrupt; external name '_ADC_VECTOR_interrupt';
  procedure _FAIL_SAFE_MONITOR_VECTOR_interrupt; external name '_FAIL_SAFE_MONITOR_VECTOR_interrupt';
  procedure _RTCC_VECTOR_interrupt; external name '_RTCC_VECTOR_interrupt';
  procedure _FCE_VECTOR_interrupt; external name '_FCE_VECTOR_interrupt';
  procedure _COMPARATOR_1_VECTOR_interrupt; external name '_COMPARATOR_1_VECTOR_interrupt';
  procedure _COMPARATOR_2_VECTOR_interrupt; external name '_COMPARATOR_2_VECTOR_interrupt';
  procedure _USB_1_VECTOR_interrupt; external name '_USB_1_VECTOR_interrupt';
  procedure _SPI_1_VECTOR_interrupt; external name '_SPI_1_VECTOR_interrupt';
  procedure _UART_1_VECTOR_interrupt; external name '_UART_1_VECTOR_interrupt';
  procedure _I2C_1_VECTOR_interrupt; external name '_I2C_1_VECTOR_interrupt';
  procedure _CHANGE_NOTICE_VECTOR_interrupt; external name '_CHANGE_NOTICE_VECTOR_interrupt';
  procedure _PMP_VECTOR_interrupt; external name '_PMP_VECTOR_interrupt';
  procedure _SPI_2_VECTOR_interrupt; external name '_SPI_2_VECTOR_interrupt';
  procedure _UART_2_VECTOR_interrupt; external name '_UART_2_VECTOR_interrupt';
  procedure _I2C_2_VECTOR_interrupt; external name '_I2C_2_VECTOR_interrupt';
  procedure _UART_3_VECTOR_interrupt; external name '_UART_3_VECTOR_interrupt';
  procedure _UART_4_VECTOR_interrupt; external name '_UART_4_VECTOR_interrupt';
  procedure _CTMU_VECTOR_interrupt; external name '_CTMU_VECTOR_interrupt';
  procedure _DMA_0_VECTOR_interrupt; external name '_DMA_0_VECTOR_interrupt';
  procedure _DMA_1_VECTOR_interrupt; external name '_DMA_1_VECTOR_interrupt';
  procedure _DMA_2_VECTOR_interrupt; external name '_DMA_2_VECTOR_interrupt';
  procedure _DMA_3_VECTOR_interrupt; external name '_DMA_3_VECTOR_interrupt';

  procedure Vectors; assembler; nostackframe;
  label interrupt_vectors;
  asm
    .section ".init.interrupt_vectors,\"ax\",@progbits"
  interrupt_vectors:

    j _CORE_TIMER_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _CORE_SOFTWARE_0_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _CORE_SOFTWARE_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_0_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_4_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_4_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_4_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_4_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_5_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_5_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_5_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _ADC_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _FAIL_SAFE_MONITOR_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _RTCC_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _FCE_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _COMPARATOR_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _COMPARATOR_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _USB_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _SPI_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _UART_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _I2C_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _CHANGE_NOTICE_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _PMP_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _SPI_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _UART_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _I2C_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _UART_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _UART_4_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _CTMU_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _DMA_0_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _DMA_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _DMA_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _DMA_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    .weak _CORE_TIMER_VECTOR_interrupt
    .weak _CORE_SOFTWARE_0_VECTOR_interrupt
    .weak _CORE_SOFTWARE_1_VECTOR_interrupt
    .weak _EXTERNAL_0_VECTOR_interrupt
    .weak _TIMER_1_VECTOR_interrupt
    .weak _INPUT_CAPTURE_1_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_1_VECTOR_interrupt
    .weak _EXTERNAL_1_VECTOR_interrupt
    .weak _TIMER_2_VECTOR_interrupt
    .weak _INPUT_CAPTURE_2_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_2_VECTOR_interrupt
    .weak _EXTERNAL_2_VECTOR_interrupt
    .weak _TIMER_3_VECTOR_interrupt
    .weak _INPUT_CAPTURE_3_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_3_VECTOR_interrupt
    .weak _EXTERNAL_3_VECTOR_interrupt
    .weak _TIMER_4_VECTOR_interrupt
    .weak _INPUT_CAPTURE_4_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_4_VECTOR_interrupt
    .weak _EXTERNAL_4_VECTOR_interrupt
    .weak _TIMER_5_VECTOR_interrupt
    .weak _INPUT_CAPTURE_5_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_5_VECTOR_interrupt
    .weak _ADC_VECTOR_interrupt
    .weak _FAIL_SAFE_MONITOR_VECTOR_interrupt
    .weak _RTCC_VECTOR_interrupt
    .weak _FCE_VECTOR_interrupt
    .weak _COMPARATOR_1_VECTOR_interrupt
    .weak _COMPARATOR_2_VECTOR_interrupt
    .weak _USB_1_VECTOR_interrupt
    .weak _SPI_1_VECTOR_interrupt
    .weak _UART_1_VECTOR_interrupt
    .weak _I2C_1_VECTOR_interrupt
    .weak _CHANGE_NOTICE_VECTOR_interrupt
    .weak _PMP_VECTOR_interrupt
    .weak _SPI_2_VECTOR_interrupt
    .weak _UART_2_VECTOR_interrupt
    .weak _I2C_2_VECTOR_interrupt
    .weak _UART_3_VECTOR_interrupt
    .weak _UART_4_VECTOR_interrupt
    .weak _CTMU_VECTOR_interrupt
    .weak _DMA_0_VECTOR_interrupt
    .weak _DMA_1_VECTOR_interrupt
    .weak _DMA_2_VECTOR_interrupt
    .weak _DMA_3_VECTOR_interrupt

    .text
  end;
end.
