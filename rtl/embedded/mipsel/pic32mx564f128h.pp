unit pic32mx564f128h;
interface
{$goto on}
{$modeswitch advancedrecords}
{$INLINE ON}
{$OPTIMIZATION STACKFRAME}
{$L startup.o}
{$PACKRECORDS 2}
type
  TBits_1 = 0..1;
  TBits_2 = 0..3;
  TBits_3 = 0..7;
  TBits_4 = 0..15;
  TBits_5 = 0..31;
  TBits_6 = 0..63;
  TBits_7 = 0..127;
  TBits_8 = 0..255;
  TBits_9 = 0..511;
  TBits_10 = 0..1023;
  TBits_11 = 0..2047;
  TBits_12 = 0..4095;
  TBits_13 = 0..8191;
  TBits_14 = 0..16383;
  TBits_15 = 0..32767;
  TBits_16 = 0..65535;
  TBits_17 = 0..131071;
  TBits_18 = 0..262143;
  TBits_19 = 0..524287;
  TBits_20 = 0..1048575;
  TBits_21 = 0..2097151;
  TBits_22 = 0..4194303;
  TBits_23 = 0..8388607;
  TBits_24 = 0..16777215;
  TBits_25 = 0..33554431;
  TBits_26 = 0..67108863;
  TBits_27 = 0..134217727;
  TBits_28 = 0..268435455;
  TBits_29 = 0..536870911;
  TBits_30 = 0..1073741823;
  TBits_31 = 0..2147483647;
  TBits_32 = 0..4294967295;
  TWDT_WDTCON = record
  private
    function  getON : TBits_1; inline;
    function  getSWDTPS : TBits_5; inline;
    function  getSWDTPS0 : TBits_1; inline;
    function  getSWDTPS1 : TBits_1; inline;
    function  getSWDTPS2 : TBits_1; inline;
    function  getSWDTPS3 : TBits_1; inline;
    function  getSWDTPS4 : TBits_1; inline;
    function  getWDTCLR : TBits_1; inline;
    function  getWDTPS : TBits_5; inline;
    function  getWDTPSTA : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSWDTPS(thebits : TBits_5); inline;
    procedure setSWDTPS0(thebits : TBits_1); inline;
    procedure setSWDTPS1(thebits : TBits_1); inline;
    procedure setSWDTPS2(thebits : TBits_1); inline;
    procedure setSWDTPS3(thebits : TBits_1); inline;
    procedure setSWDTPS4(thebits : TBits_1); inline;
    procedure setWDTCLR(thebits : TBits_1); inline;
    procedure setWDTPS(thebits : TBits_5); inline;
    procedure setWDTPSTA(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSWDTPS0; inline;
    procedure clearSWDTPS1; inline;
    procedure clearSWDTPS2; inline;
    procedure clearSWDTPS3; inline;
    procedure clearSWDTPS4; inline;
    procedure clearWDTCLR; inline;
    procedure setON; inline;
    procedure setSWDTPS0; inline;
    procedure setSWDTPS1; inline;
    procedure setSWDTPS2; inline;
    procedure setSWDTPS3; inline;
    procedure setSWDTPS4; inline;
    procedure setWDTCLR; inline;
    property ON : TBits_1 read getON write setON;
    property SWDTPS : TBits_5 read getSWDTPS write setSWDTPS;
    property SWDTPS0 : TBits_1 read getSWDTPS0 write setSWDTPS0;
    property SWDTPS1 : TBits_1 read getSWDTPS1 write setSWDTPS1;
    property SWDTPS2 : TBits_1 read getSWDTPS2 write setSWDTPS2;
    property SWDTPS3 : TBits_1 read getSWDTPS3 write setSWDTPS3;
    property SWDTPS4 : TBits_1 read getSWDTPS4 write setSWDTPS4;
    property WDTCLR : TBits_1 read getWDTCLR write setWDTCLR;
    property WDTPS : TBits_5 read getWDTPS write setWDTPS;
    property WDTPSTA : TBits_5 read getWDTPSTA write setWDTPSTA;
    property w : TBits_32 read getw write setw;
  end;
type
  TWDTRegisters = record
    WDTCONbits : TWDT_WDTCON;
    WDTCON : longWord;
    WDTCONCLR : longWord;
    WDTCONSET : longWord;
    WDTCONINV : longWord;
  end;
  TRTCC_RTCCON = record
  private
    function  getCAL : TBits_10; inline;
    function  getHALFSEC : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getRTCCLKON : TBits_1; inline;
    function  getRTCOE : TBits_1; inline;
    function  getRTCSYNC : TBits_1; inline;
    function  getRTCWREN : TBits_1; inline;
    function  getRTSECSEL : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCAL(thebits : TBits_10); inline;
    procedure setHALFSEC(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setRTCCLKON(thebits : TBits_1); inline;
    procedure setRTCOE(thebits : TBits_1); inline;
    procedure setRTCSYNC(thebits : TBits_1); inline;
    procedure setRTCWREN(thebits : TBits_1); inline;
    procedure setRTSECSEL(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearHALFSEC; inline;
    procedure clearON; inline;
    procedure clearRTCCLKON; inline;
    procedure clearRTCOE; inline;
    procedure clearRTCSYNC; inline;
    procedure clearRTCWREN; inline;
    procedure clearRTSECSEL; inline;
    procedure clearSIDL; inline;
    procedure setHALFSEC; inline;
    procedure setON; inline;
    procedure setRTCCLKON; inline;
    procedure setRTCOE; inline;
    procedure setRTCSYNC; inline;
    procedure setRTCWREN; inline;
    procedure setRTSECSEL; inline;
    procedure setSIDL; inline;
    property CAL : TBits_10 read getCAL write setCAL;
    property HALFSEC : TBits_1 read getHALFSEC write setHALFSEC;
    property ON : TBits_1 read getON write setON;
    property RTCCLKON : TBits_1 read getRTCCLKON write setRTCCLKON;
    property RTCOE : TBits_1 read getRTCOE write setRTCOE;
    property RTCSYNC : TBits_1 read getRTCSYNC write setRTCSYNC;
    property RTCWREN : TBits_1 read getRTCWREN write setRTCWREN;
    property RTSECSEL : TBits_1 read getRTSECSEL write setRTSECSEL;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_RTCALRM = record
  private
    function  getALRMEN : TBits_1; inline;
    function  getALRMSYNC : TBits_1; inline;
    function  getAMASK : TBits_4; inline;
    function  getARPT : TBits_8; inline;
    function  getCHIME : TBits_1; inline;
    function  getPIV : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setALRMEN(thebits : TBits_1); inline;
    procedure setALRMSYNC(thebits : TBits_1); inline;
    procedure setAMASK(thebits : TBits_4); inline;
    procedure setARPT(thebits : TBits_8); inline;
    procedure setCHIME(thebits : TBits_1); inline;
    procedure setPIV(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearALRMEN; inline;
    procedure clearALRMSYNC; inline;
    procedure clearCHIME; inline;
    procedure clearPIV; inline;
    procedure setALRMEN; inline;
    procedure setALRMSYNC; inline;
    procedure setCHIME; inline;
    procedure setPIV; inline;
    property ALRMEN : TBits_1 read getALRMEN write setALRMEN;
    property ALRMSYNC : TBits_1 read getALRMSYNC write setALRMSYNC;
    property AMASK : TBits_4 read getAMASK write setAMASK;
    property ARPT : TBits_8 read getARPT write setARPT;
    property CHIME : TBits_1 read getCHIME write setCHIME;
    property PIV : TBits_1 read getPIV write setPIV;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_RTCTIME = record
  private
    function  getHR01 : TBits_4; inline;
    function  getHR10 : TBits_4; inline;
    function  getMIN01 : TBits_4; inline;
    function  getMIN10 : TBits_4; inline;
    function  getSEC01 : TBits_4; inline;
    function  getSEC10 : TBits_4; inline;
    function  getw : TBits_32; inline;
    procedure setHR01(thebits : TBits_4); inline;
    procedure setHR10(thebits : TBits_4); inline;
    procedure setMIN01(thebits : TBits_4); inline;
    procedure setMIN10(thebits : TBits_4); inline;
    procedure setSEC01(thebits : TBits_4); inline;
    procedure setSEC10(thebits : TBits_4); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property HR01 : TBits_4 read getHR01 write setHR01;
    property HR10 : TBits_4 read getHR10 write setHR10;
    property MIN01 : TBits_4 read getMIN01 write setMIN01;
    property MIN10 : TBits_4 read getMIN10 write setMIN10;
    property SEC01 : TBits_4 read getSEC01 write setSEC01;
    property SEC10 : TBits_4 read getSEC10 write setSEC10;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_RTCDATE = record
  private
    function  getDAY01 : TBits_4; inline;
    function  getDAY10 : TBits_4; inline;
    function  getMONTH01 : TBits_4; inline;
    function  getMONTH10 : TBits_4; inline;
    function  getWDAY01 : TBits_4; inline;
    function  getYEAR01 : TBits_4; inline;
    function  getYEAR10 : TBits_4; inline;
    function  getw : TBits_32; inline;
    procedure setDAY01(thebits : TBits_4); inline;
    procedure setDAY10(thebits : TBits_4); inline;
    procedure setMONTH01(thebits : TBits_4); inline;
    procedure setMONTH10(thebits : TBits_4); inline;
    procedure setWDAY01(thebits : TBits_4); inline;
    procedure setYEAR01(thebits : TBits_4); inline;
    procedure setYEAR10(thebits : TBits_4); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DAY01 : TBits_4 read getDAY01 write setDAY01;
    property DAY10 : TBits_4 read getDAY10 write setDAY10;
    property MONTH01 : TBits_4 read getMONTH01 write setMONTH01;
    property MONTH10 : TBits_4 read getMONTH10 write setMONTH10;
    property WDAY01 : TBits_4 read getWDAY01 write setWDAY01;
    property YEAR01 : TBits_4 read getYEAR01 write setYEAR01;
    property YEAR10 : TBits_4 read getYEAR10 write setYEAR10;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_ALRMTIME = record
  private
    function  getHR01 : TBits_4; inline;
    function  getHR10 : TBits_4; inline;
    function  getMIN01 : TBits_4; inline;
    function  getMIN10 : TBits_4; inline;
    function  getSEC01 : TBits_4; inline;
    function  getSEC10 : TBits_4; inline;
    function  getw : TBits_32; inline;
    procedure setHR01(thebits : TBits_4); inline;
    procedure setHR10(thebits : TBits_4); inline;
    procedure setMIN01(thebits : TBits_4); inline;
    procedure setMIN10(thebits : TBits_4); inline;
    procedure setSEC01(thebits : TBits_4); inline;
    procedure setSEC10(thebits : TBits_4); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property HR01 : TBits_4 read getHR01 write setHR01;
    property HR10 : TBits_4 read getHR10 write setHR10;
    property MIN01 : TBits_4 read getMIN01 write setMIN01;
    property MIN10 : TBits_4 read getMIN10 write setMIN10;
    property SEC01 : TBits_4 read getSEC01 write setSEC01;
    property SEC10 : TBits_4 read getSEC10 write setSEC10;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_ALRMDATE = record
  private
    function  getDAY01 : TBits_4; inline;
    function  getDAY10 : TBits_4; inline;
    function  getMONTH01 : TBits_4; inline;
    function  getMONTH10 : TBits_4; inline;
    function  getWDAY01 : TBits_4; inline;
    function  getw : TBits_32; inline;
    procedure setDAY01(thebits : TBits_4); inline;
    procedure setDAY10(thebits : TBits_4); inline;
    procedure setMONTH01(thebits : TBits_4); inline;
    procedure setMONTH10(thebits : TBits_4); inline;
    procedure setWDAY01(thebits : TBits_4); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DAY01 : TBits_4 read getDAY01 write setDAY01;
    property DAY10 : TBits_4 read getDAY10 write setDAY10;
    property MONTH01 : TBits_4 read getMONTH01 write setMONTH01;
    property MONTH10 : TBits_4 read getMONTH10 write setMONTH10;
    property WDAY01 : TBits_4 read getWDAY01 write setWDAY01;
    property w : TBits_32 read getw write setw;
  end;
type
  TRTCCRegisters = record
    RTCCONbits : TRTCC_RTCCON;
    RTCCON : longWord;
    RTCCONCLR : longWord;
    RTCCONSET : longWord;
    RTCCONINV : longWord;
    RTCALRMbits : TRTCC_RTCALRM;
    RTCALRM : longWord;
    RTCALRMCLR : longWord;
    RTCALRMSET : longWord;
    RTCALRMINV : longWord;
    RTCTIMEbits : TRTCC_RTCTIME;
    RTCTIME : longWord;
    RTCTIMECLR : longWord;
    RTCTIMESET : longWord;
    RTCTIMEINV : longWord;
    RTCDATEbits : TRTCC_RTCDATE;
    RTCDATE : longWord;
    RTCDATECLR : longWord;
    RTCDATESET : longWord;
    RTCDATEINV : longWord;
    ALRMTIMEbits : TRTCC_ALRMTIME;
    ALRMTIME : longWord;
    ALRMTIMECLR : longWord;
    ALRMTIMESET : longWord;
    ALRMTIMEINV : longWord;
    ALRMDATEbits : TRTCC_ALRMDATE;
    ALRMDATE : longWord;
    ALRMDATECLR : longWord;
    ALRMDATESET : longWord;
    ALRMDATEINV : longWord;
  end;
  TTMR1_T1CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getTCKPS : TBits_2; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCS : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getTSYNC : TBits_1; inline;
    function  getTWDIS : TBits_1; inline;
    function  getTWIP : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_2); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCS(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setTSYNC(thebits : TBits_1); inline;
    procedure setTWDIS(thebits : TBits_1); inline;
    procedure setTWIP(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCS; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure clearTSYNC; inline;
    procedure clearTWDIS; inline;
    procedure clearTWIP; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCS; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    procedure setTSYNC; inline;
    procedure setTWDIS; inline;
    procedure setTWIP; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property TCKPS : TBits_2 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCS : TBits_1 read getTCS write setTCS;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property TSYNC : TBits_1 read getTSYNC write setTSYNC;
    property TWDIS : TBits_1 read getTWDIS write setTWDIS;
    property TWIP : TBits_1 read getTWIP write setTWIP;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR1Registers = record
    T1CONbits : TTMR1_T1CON;
    T1CON : longWord;
    T1CONCLR : longWord;
    T1CONSET : longWord;
    T1CONINV : longWord;
    TMR1 : longWord;
    TMR1CLR : longWord;
    TMR1SET : longWord;
    TMR1INV : longWord;
    PR1 : longWord;
    PR1CLR : longWord;
    PR1SET : longWord;
    PR1INV : longWord;
  end;
  TTMR2_T2CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getT32 : TBits_1; inline;
    function  getTCKPS : TBits_3; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCKPS2 : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setT32(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_3); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCKPS2(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearT32; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCKPS2; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setT32; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCKPS2; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property T32 : TBits_1 read getT32 write setT32;
    property TCKPS : TBits_3 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCKPS2 : TBits_1 read getTCKPS2 write setTCKPS2;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR2Registers = record
    T2CONbits : TTMR2_T2CON;
    T2CON : longWord;
    T2CONCLR : longWord;
    T2CONSET : longWord;
    T2CONINV : longWord;
    TMR2 : longWord;
    TMR2CLR : longWord;
    TMR2SET : longWord;
    TMR2INV : longWord;
    PR2 : longWord;
    PR2CLR : longWord;
    PR2SET : longWord;
    PR2INV : longWord;
  end;
  TTMR3_T3CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getTCKPS : TBits_3; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCKPS2 : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_3); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCKPS2(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCKPS2; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCKPS2; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property TCKPS : TBits_3 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCKPS2 : TBits_1 read getTCKPS2 write setTCKPS2;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR3Registers = record
    T3CONbits : TTMR3_T3CON;
    T3CON : longWord;
    T3CONCLR : longWord;
    T3CONSET : longWord;
    T3CONINV : longWord;
    TMR3 : longWord;
    TMR3CLR : longWord;
    TMR3SET : longWord;
    TMR3INV : longWord;
    PR3 : longWord;
    PR3CLR : longWord;
    PR3SET : longWord;
    PR3INV : longWord;
  end;
  TTMR4_T4CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getT32 : TBits_1; inline;
    function  getTCKPS : TBits_3; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCKPS2 : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setT32(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_3); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCKPS2(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearT32; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCKPS2; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setT32; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCKPS2; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property T32 : TBits_1 read getT32 write setT32;
    property TCKPS : TBits_3 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCKPS2 : TBits_1 read getTCKPS2 write setTCKPS2;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR4Registers = record
    T4CONbits : TTMR4_T4CON;
    T4CON : longWord;
    T4CONCLR : longWord;
    T4CONSET : longWord;
    T4CONINV : longWord;
    TMR4 : longWord;
    TMR4CLR : longWord;
    TMR4SET : longWord;
    TMR4INV : longWord;
    PR4 : longWord;
    PR4CLR : longWord;
    PR4SET : longWord;
    PR4INV : longWord;
  end;
  TTMR5_T5CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getTCKPS : TBits_3; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCKPS2 : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_3); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCKPS2(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCKPS2; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCKPS2; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property TCKPS : TBits_3 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCKPS2 : TBits_1 read getTCKPS2 write setTCKPS2;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR5Registers = record
    T5CONbits : TTMR5_T5CON;
    T5CON : longWord;
    T5CONCLR : longWord;
    T5CONSET : longWord;
    T5CONINV : longWord;
    TMR5 : longWord;
    TMR5CLR : longWord;
    TMR5SET : longWord;
    TMR5INV : longWord;
    PR5 : longWord;
    PR5CLR : longWord;
    PR5SET : longWord;
    PR5INV : longWord;
  end;
  TICAP1_IC1CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP1Registers = record
    IC1CONbits : TICAP1_IC1CON;
    IC1CON : longWord;
    IC1CONCLR : longWord;
    IC1CONSET : longWord;
    IC1CONINV : longWord;
    IC1BUF : longWord;
  end;
  TICAP2_IC2CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP2Registers = record
    IC2CONbits : TICAP2_IC2CON;
    IC2CON : longWord;
    IC2CONCLR : longWord;
    IC2CONSET : longWord;
    IC2CONINV : longWord;
    IC2BUF : longWord;
  end;
  TICAP3_IC3CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP3Registers = record
    IC3CONbits : TICAP3_IC3CON;
    IC3CON : longWord;
    IC3CONCLR : longWord;
    IC3CONSET : longWord;
    IC3CONINV : longWord;
    IC3BUF : longWord;
  end;
  TICAP4_IC4CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP4Registers = record
    IC4CONbits : TICAP4_IC4CON;
    IC4CON : longWord;
    IC4CONCLR : longWord;
    IC4CONSET : longWord;
    IC4CONINV : longWord;
    IC4BUF : longWord;
  end;
  TICAP5_IC5CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP5Registers = record
    IC5CONbits : TICAP5_IC5CON;
    IC5CON : longWord;
    IC5CONCLR : longWord;
    IC5CONSET : longWord;
    IC5CONINV : longWord;
    IC5BUF : longWord;
  end;
  TOCMP1_OC1CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP1Registers = record
    OC1CONbits : TOCMP1_OC1CON;
    OC1CON : longWord;
    OC1CONCLR : longWord;
    OC1CONSET : longWord;
    OC1CONINV : longWord;
    OC1R : longWord;
    OC1RCLR : longWord;
    OC1RSET : longWord;
    OC1RINV : longWord;
    OC1RS : longWord;
    OC1RSCLR : longWord;
    OC1RSSET : longWord;
    OC1RSINV : longWord;
  end;
  TOCMP2_OC2CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP2Registers = record
    OC2CONbits : TOCMP2_OC2CON;
    OC2CON : longWord;
    OC2CONCLR : longWord;
    OC2CONSET : longWord;
    OC2CONINV : longWord;
    OC2R : longWord;
    OC2RCLR : longWord;
    OC2RSET : longWord;
    OC2RINV : longWord;
    OC2RS : longWord;
    OC2RSCLR : longWord;
    OC2RSSET : longWord;
    OC2RSINV : longWord;
  end;
  TOCMP3_OC3CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP3Registers = record
    OC3CONbits : TOCMP3_OC3CON;
    OC3CON : longWord;
    OC3CONCLR : longWord;
    OC3CONSET : longWord;
    OC3CONINV : longWord;
    OC3R : longWord;
    OC3RCLR : longWord;
    OC3RSET : longWord;
    OC3RINV : longWord;
    OC3RS : longWord;
    OC3RSCLR : longWord;
    OC3RSSET : longWord;
    OC3RSINV : longWord;
  end;
  TOCMP4_OC4CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP4Registers = record
    OC4CONbits : TOCMP4_OC4CON;
    OC4CON : longWord;
    OC4CONCLR : longWord;
    OC4CONSET : longWord;
    OC4CONINV : longWord;
    OC4R : longWord;
    OC4RCLR : longWord;
    OC4RSET : longWord;
    OC4RINV : longWord;
    OC4RS : longWord;
    OC4RSCLR : longWord;
    OC4RSSET : longWord;
    OC4RSINV : longWord;
  end;
  TOCMP5_OC5CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP5Registers = record
    OC5CONbits : TOCMP5_OC5CON;
    OC5CON : longWord;
    OC5CONCLR : longWord;
    OC5CONSET : longWord;
    OC5CONINV : longWord;
    OC5R : longWord;
    OC5RCLR : longWord;
    OC5RSET : longWord;
    OC5RINV : longWord;
    OC5RS : longWord;
    OC5RSCLR : longWord;
    OC5RSSET : longWord;
    OC5RSINV : longWord;
  end;
  TI2C1A_I2C1ACON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C1A_I2C3CON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C1A_I2C1ASTAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C1A_I2C3STAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
type
  TI2C1ARegisters = record
    I2C1ACONbits : TI2C1A_I2C1ACON;
    I2C1ACON : longWord;
    I2C3CONbits : TI2C1A_I2C3CON;
    I2C3CON : longWord;
    I2C1ACONCLR : longWord;
    I2C3CONCLR : longWord;
    I2C1ACONSET : longWord;
    I2C3CONSET : longWord;
    I2C1ACONINV : longWord;
    I2C3CONINV : longWord;
    I2C1ASTATbits : TI2C1A_I2C1ASTAT;
    I2C1ASTAT : longWord;
    I2C3STATbits : TI2C1A_I2C3STAT;
    I2C3STAT : longWord;
    I2C1ASTATCLR : longWord;
    I2C3STATCLR : longWord;
    I2C1ASTATSET : longWord;
    I2C3STATSET : longWord;
    I2C1ASTATINV : longWord;
    I2C3STATINV : longWord;
    I2C1AADD : longWord;
    I2C3ADD : longWord;
    I2C1AADDCLR : longWord;
    I2C3ADDCLR : longWord;
    I2C1AADDSET : longWord;
    I2C3ADDSET : longWord;
    I2C1AADDINV : longWord;
    I2C3ADDINV : longWord;
    I2C1AMSK : longWord;
    I2C3MSK : longWord;
    I2C1AMSKCLR : longWord;
    I2C3MSKCLR : longWord;
    I2C1AMSKSET : longWord;
    I2C3MSKSET : longWord;
    I2C1AMSKINV : longWord;
    I2C3MSKINV : longWord;
    I2C1ABRG : longWord;
    I2C3BRG : longWord;
    I2C1ABRGCLR : longWord;
    I2C3BRGCLR : longWord;
    I2C1ABRGSET : longWord;
    I2C3BRGSET : longWord;
    I2C1ABRGINV : longWord;
    I2C3BRGINV : longWord;
    I2C1ATRN : longWord;
    I2C3TRN : longWord;
    I2C1ATRNCLR : longWord;
    I2C3TRNCLR : longWord;
    I2C1ATRNSET : longWord;
    I2C3TRNSET : longWord;
    I2C1ATRNINV : longWord;
    I2C3TRNINV : longWord;
    I2C1ARCV : longWord;
    I2C3RCV : longWord;
  end;
  TI2C2A_I2C2ACON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C2A_I2C4CON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C2A_I2C2ASTAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C2A_I2C4STAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
type
  TI2C2ARegisters = record
    I2C2ACONbits : TI2C2A_I2C2ACON;
    I2C2ACON : longWord;
    I2C4CONbits : TI2C2A_I2C4CON;
    I2C4CON : longWord;
    I2C2ACONCLR : longWord;
    I2C4CONCLR : longWord;
    I2C2ACONSET : longWord;
    I2C4CONSET : longWord;
    I2C2ACONINV : longWord;
    I2C4CONINV : longWord;
    I2C2ASTATbits : TI2C2A_I2C2ASTAT;
    I2C2ASTAT : longWord;
    I2C4STATbits : TI2C2A_I2C4STAT;
    I2C4STAT : longWord;
    I2C2ASTATCLR : longWord;
    I2C4STATCLR : longWord;
    I2C2ASTATSET : longWord;
    I2C4STATSET : longWord;
    I2C2ASTATINV : longWord;
    I2C4STATINV : longWord;
    I2C2AADD : longWord;
    I2C4ADD : longWord;
    I2C2AADDCLR : longWord;
    I2C4ADDCLR : longWord;
    I2C2AADDSET : longWord;
    I2C4ADDSET : longWord;
    I2C2AADDINV : longWord;
    I2C4ADDINV : longWord;
    I2C2AMSK : longWord;
    I2C4MSK : longWord;
    I2C2AMSKCLR : longWord;
    I2C4MSKCLR : longWord;
    I2C2AMSKSET : longWord;
    I2C4MSKSET : longWord;
    I2C2AMSKINV : longWord;
    I2C4MSKINV : longWord;
    I2C2ABRG : longWord;
    I2C4BRG : longWord;
    I2C2ABRGCLR : longWord;
    I2C4BRGCLR : longWord;
    I2C2ABRGSET : longWord;
    I2C4BRGSET : longWord;
    I2C2ABRGINV : longWord;
    I2C4BRGINV : longWord;
    I2C2ATRN : longWord;
    I2C4TRN : longWord;
    I2C2ATRNCLR : longWord;
    I2C4TRNCLR : longWord;
    I2C2ATRNSET : longWord;
    I2C4TRNSET : longWord;
    I2C2ATRNINV : longWord;
    I2C4TRNINV : longWord;
    I2C2ARCV : longWord;
    I2C4RCV : longWord;
  end;
  TI2C5_I2C3ACON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C5_I2C5CON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C5_I2C3ASTAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C5_I2C5STAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
type
  TI2C5Registers = record
    I2C3ACONbits : TI2C5_I2C3ACON;
    I2C3ACON : longWord;
    I2C5CONbits : TI2C5_I2C5CON;
    I2C5CON : longWord;
    I2C3ACONCLR : longWord;
    I2C5CONCLR : longWord;
    I2C3ACONSET : longWord;
    I2C5CONSET : longWord;
    I2C3ACONINV : longWord;
    I2C5CONINV : longWord;
    I2C3ASTATbits : TI2C5_I2C3ASTAT;
    I2C3ASTAT : longWord;
    I2C5STATbits : TI2C5_I2C5STAT;
    I2C5STAT : longWord;
    I2C3ASTATCLR : longWord;
    I2C5STATCLR : longWord;
    I2C3ASTATSET : longWord;
    I2C5STATSET : longWord;
    I2C3ASTATINV : longWord;
    I2C5STATINV : longWord;
    I2C3AADD : longWord;
    I2C5ADD : longWord;
    I2C3AADDCLR : longWord;
    I2C5ADDCLR : longWord;
    I2C3AADDSET : longWord;
    I2C5ADDSET : longWord;
    I2C3AADDINV : longWord;
    I2C5ADDINV : longWord;
    I2C3AMSK : longWord;
    I2C5MSK : longWord;
    I2C3AMSKCLR : longWord;
    I2C5MSKCLR : longWord;
    I2C3AMSKSET : longWord;
    I2C5MSKSET : longWord;
    I2C3AMSKINV : longWord;
    I2C5MSKINV : longWord;
    I2C3ABRG : longWord;
    I2C5BRG : longWord;
    I2C3ABRGCLR : longWord;
    I2C5BRGCLR : longWord;
    I2C3ABRGSET : longWord;
    I2C5BRGSET : longWord;
    I2C3ABRGINV : longWord;
    I2C5BRGINV : longWord;
    I2C3ATRN : longWord;
    I2C5TRN : longWord;
    I2C3ATRNCLR : longWord;
    I2C5TRNCLR : longWord;
    I2C3ATRNSET : longWord;
    I2C5TRNSET : longWord;
    I2C3ATRNINV : longWord;
    I2C5TRNINV : longWord;
    I2C3ARCV : longWord;
    I2C5RCV : longWord;
  end;
  TI2C1_I2C1CON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C1_I2C1STAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
type
  TI2C1Registers = record
    I2C1CONbits : TI2C1_I2C1CON;
    I2C1CON : longWord;
    I2C1CONCLR : longWord;
    I2C1CONSET : longWord;
    I2C1CONINV : longWord;
    I2C1STATbits : TI2C1_I2C1STAT;
    I2C1STAT : longWord;
    I2C1STATCLR : longWord;
    I2C1STATSET : longWord;
    I2C1STATINV : longWord;
    I2C1ADD : longWord;
    I2C1ADDCLR : longWord;
    I2C1ADDSET : longWord;
    I2C1ADDINV : longWord;
    I2C1MSK : longWord;
    I2C1MSKCLR : longWord;
    I2C1MSKSET : longWord;
    I2C1MSKINV : longWord;
    I2C1BRG : longWord;
    I2C1BRGCLR : longWord;
    I2C1BRGSET : longWord;
    I2C1BRGINV : longWord;
    I2C1TRN : longWord;
    I2C1TRNCLR : longWord;
    I2C1TRNSET : longWord;
    I2C1TRNINV : longWord;
    I2C1RCV : longWord;
  end;
  TSPI3_SPI1ACON = record
  private
    function  getCKE : TBits_1; inline;
    function  getCKP : TBits_1; inline;
    function  getDISSDO : TBits_1; inline;
    function  getENHBUF : TBits_1; inline;
    function  getFRMCNT : TBits_3; inline;
    function  getFRMEN : TBits_1; inline;
    function  getFRMPOL : TBits_1; inline;
    function  getFRMSYNC : TBits_1; inline;
    function  getFRMSYPW : TBits_1; inline;
    function  getMODE16 : TBits_1; inline;
    function  getMODE32 : TBits_1; inline;
    function  getMSSEN : TBits_1; inline;
    function  getMSTEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMP : TBits_1; inline;
    function  getSPIFE : TBits_1; inline;
    function  getSRXISEL : TBits_2; inline;
    function  getSSEN : TBits_1; inline;
    function  getSTXISEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCKE(thebits : TBits_1); inline;
    procedure setCKP(thebits : TBits_1); inline;
    procedure setDISSDO(thebits : TBits_1); inline;
    procedure setENHBUF(thebits : TBits_1); inline;
    procedure setFRMCNT(thebits : TBits_3); inline;
    procedure setFRMEN(thebits : TBits_1); inline;
    procedure setFRMPOL(thebits : TBits_1); inline;
    procedure setFRMSYNC(thebits : TBits_1); inline;
    procedure setFRMSYPW(thebits : TBits_1); inline;
    procedure setMODE16(thebits : TBits_1); inline;
    procedure setMODE32(thebits : TBits_1); inline;
    procedure setMSSEN(thebits : TBits_1); inline;
    procedure setMSTEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMP(thebits : TBits_1); inline;
    procedure setSPIFE(thebits : TBits_1); inline;
    procedure setSRXISEL(thebits : TBits_2); inline;
    procedure setSSEN(thebits : TBits_1); inline;
    procedure setSTXISEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCKE; inline;
    procedure clearCKP; inline;
    procedure clearDISSDO; inline;
    procedure clearENHBUF; inline;
    procedure clearFRMEN; inline;
    procedure clearFRMPOL; inline;
    procedure clearFRMSYNC; inline;
    procedure clearFRMSYPW; inline;
    procedure clearMODE16; inline;
    procedure clearMODE32; inline;
    procedure clearMSSEN; inline;
    procedure clearMSTEN; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearSMP; inline;
    procedure clearSPIFE; inline;
    procedure clearSSEN; inline;
    procedure setCKE; inline;
    procedure setCKP; inline;
    procedure setDISSDO; inline;
    procedure setENHBUF; inline;
    procedure setFRMEN; inline;
    procedure setFRMPOL; inline;
    procedure setFRMSYNC; inline;
    procedure setFRMSYPW; inline;
    procedure setMODE16; inline;
    procedure setMODE32; inline;
    procedure setMSSEN; inline;
    procedure setMSTEN; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setSMP; inline;
    procedure setSPIFE; inline;
    procedure setSSEN; inline;
    property CKE : TBits_1 read getCKE write setCKE;
    property CKP : TBits_1 read getCKP write setCKP;
    property DISSDO : TBits_1 read getDISSDO write setDISSDO;
    property ENHBUF : TBits_1 read getENHBUF write setENHBUF;
    property FRMCNT : TBits_3 read getFRMCNT write setFRMCNT;
    property FRMEN : TBits_1 read getFRMEN write setFRMEN;
    property FRMPOL : TBits_1 read getFRMPOL write setFRMPOL;
    property FRMSYNC : TBits_1 read getFRMSYNC write setFRMSYNC;
    property FRMSYPW : TBits_1 read getFRMSYPW write setFRMSYPW;
    property MODE16 : TBits_1 read getMODE16 write setMODE16;
    property MODE32 : TBits_1 read getMODE32 write setMODE32;
    property MSSEN : TBits_1 read getMSSEN write setMSSEN;
    property MSTEN : TBits_1 read getMSTEN write setMSTEN;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMP : TBits_1 read getSMP write setSMP;
    property SPIFE : TBits_1 read getSPIFE write setSPIFE;
    property SRXISEL : TBits_2 read getSRXISEL write setSRXISEL;
    property SSEN : TBits_1 read getSSEN write setSSEN;
    property STXISEL : TBits_2 read getSTXISEL write setSTXISEL;
    property w : TBits_32 read getw write setw;
  end;
  TSPI3_SPI3CON = record
  private
    function  getCKE : TBits_1; inline;
    function  getCKP : TBits_1; inline;
    function  getDISSDO : TBits_1; inline;
    function  getENHBUF : TBits_1; inline;
    function  getFRMCNT : TBits_3; inline;
    function  getFRMEN : TBits_1; inline;
    function  getFRMPOL : TBits_1; inline;
    function  getFRMSYNC : TBits_1; inline;
    function  getFRMSYPW : TBits_1; inline;
    function  getMODE16 : TBits_1; inline;
    function  getMODE32 : TBits_1; inline;
    function  getMSSEN : TBits_1; inline;
    function  getMSTEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMP : TBits_1; inline;
    function  getSPIFE : TBits_1; inline;
    function  getSRXISEL : TBits_2; inline;
    function  getSSEN : TBits_1; inline;
    function  getSTXISEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCKE(thebits : TBits_1); inline;
    procedure setCKP(thebits : TBits_1); inline;
    procedure setDISSDO(thebits : TBits_1); inline;
    procedure setENHBUF(thebits : TBits_1); inline;
    procedure setFRMCNT(thebits : TBits_3); inline;
    procedure setFRMEN(thebits : TBits_1); inline;
    procedure setFRMPOL(thebits : TBits_1); inline;
    procedure setFRMSYNC(thebits : TBits_1); inline;
    procedure setFRMSYPW(thebits : TBits_1); inline;
    procedure setMODE16(thebits : TBits_1); inline;
    procedure setMODE32(thebits : TBits_1); inline;
    procedure setMSSEN(thebits : TBits_1); inline;
    procedure setMSTEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMP(thebits : TBits_1); inline;
    procedure setSPIFE(thebits : TBits_1); inline;
    procedure setSRXISEL(thebits : TBits_2); inline;
    procedure setSSEN(thebits : TBits_1); inline;
    procedure setSTXISEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCKE; inline;
    procedure clearCKP; inline;
    procedure clearDISSDO; inline;
    procedure clearENHBUF; inline;
    procedure clearFRMEN; inline;
    procedure clearFRMPOL; inline;
    procedure clearFRMSYNC; inline;
    procedure clearFRMSYPW; inline;
    procedure clearMODE16; inline;
    procedure clearMODE32; inline;
    procedure clearMSSEN; inline;
    procedure clearMSTEN; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearSMP; inline;
    procedure clearSPIFE; inline;
    procedure clearSSEN; inline;
    procedure setCKE; inline;
    procedure setCKP; inline;
    procedure setDISSDO; inline;
    procedure setENHBUF; inline;
    procedure setFRMEN; inline;
    procedure setFRMPOL; inline;
    procedure setFRMSYNC; inline;
    procedure setFRMSYPW; inline;
    procedure setMODE16; inline;
    procedure setMODE32; inline;
    procedure setMSSEN; inline;
    procedure setMSTEN; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setSMP; inline;
    procedure setSPIFE; inline;
    procedure setSSEN; inline;
    property CKE : TBits_1 read getCKE write setCKE;
    property CKP : TBits_1 read getCKP write setCKP;
    property DISSDO : TBits_1 read getDISSDO write setDISSDO;
    property ENHBUF : TBits_1 read getENHBUF write setENHBUF;
    property FRMCNT : TBits_3 read getFRMCNT write setFRMCNT;
    property FRMEN : TBits_1 read getFRMEN write setFRMEN;
    property FRMPOL : TBits_1 read getFRMPOL write setFRMPOL;
    property FRMSYNC : TBits_1 read getFRMSYNC write setFRMSYNC;
    property FRMSYPW : TBits_1 read getFRMSYPW write setFRMSYPW;
    property MODE16 : TBits_1 read getMODE16 write setMODE16;
    property MODE32 : TBits_1 read getMODE32 write setMODE32;
    property MSSEN : TBits_1 read getMSSEN write setMSSEN;
    property MSTEN : TBits_1 read getMSTEN write setMSTEN;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMP : TBits_1 read getSMP write setSMP;
    property SPIFE : TBits_1 read getSPIFE write setSPIFE;
    property SRXISEL : TBits_2 read getSRXISEL write setSRXISEL;
    property SSEN : TBits_1 read getSSEN write setSSEN;
    property STXISEL : TBits_2 read getSTXISEL write setSTXISEL;
    property w : TBits_32 read getw write setw;
  end;
  TSPI3_SPI1ASTAT = record
  private
    function  getRXBUFELM : TBits_5; inline;
    function  getSPIBUSY : TBits_1; inline;
    function  getSPIRBE : TBits_1; inline;
    function  getSPIRBF : TBits_1; inline;
    function  getSPIROV : TBits_1; inline;
    function  getSPITBE : TBits_1; inline;
    function  getSPITBF : TBits_1; inline;
    function  getSPITUR : TBits_1; inline;
    function  getSRMT : TBits_1; inline;
    function  getTXBUFELM : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setRXBUFELM(thebits : TBits_5); inline;
    procedure setSPIBUSY(thebits : TBits_1); inline;
    procedure setSPIRBE(thebits : TBits_1); inline;
    procedure setSPIRBF(thebits : TBits_1); inline;
    procedure setSPIROV(thebits : TBits_1); inline;
    procedure setSPITBE(thebits : TBits_1); inline;
    procedure setSPITBF(thebits : TBits_1); inline;
    procedure setSPITUR(thebits : TBits_1); inline;
    procedure setSRMT(thebits : TBits_1); inline;
    procedure setTXBUFELM(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearSPIBUSY; inline;
    procedure clearSPIRBE; inline;
    procedure clearSPIRBF; inline;
    procedure clearSPIROV; inline;
    procedure clearSPITBE; inline;
    procedure clearSPITBF; inline;
    procedure clearSPITUR; inline;
    procedure clearSRMT; inline;
    procedure setSPIBUSY; inline;
    procedure setSPIRBE; inline;
    procedure setSPIRBF; inline;
    procedure setSPIROV; inline;
    procedure setSPITBE; inline;
    procedure setSPITBF; inline;
    procedure setSPITUR; inline;
    procedure setSRMT; inline;
    property RXBUFELM : TBits_5 read getRXBUFELM write setRXBUFELM;
    property SPIBUSY : TBits_1 read getSPIBUSY write setSPIBUSY;
    property SPIRBE : TBits_1 read getSPIRBE write setSPIRBE;
    property SPIRBF : TBits_1 read getSPIRBF write setSPIRBF;
    property SPIROV : TBits_1 read getSPIROV write setSPIROV;
    property SPITBE : TBits_1 read getSPITBE write setSPITBE;
    property SPITBF : TBits_1 read getSPITBF write setSPITBF;
    property SPITUR : TBits_1 read getSPITUR write setSPITUR;
    property SRMT : TBits_1 read getSRMT write setSRMT;
    property TXBUFELM : TBits_5 read getTXBUFELM write setTXBUFELM;
    property w : TBits_32 read getw write setw;
  end;
  TSPI3_SPI3STAT = record
  private
    function  getRXBUFELM : TBits_5; inline;
    function  getSPIBUSY : TBits_1; inline;
    function  getSPIRBE : TBits_1; inline;
    function  getSPIRBF : TBits_1; inline;
    function  getSPIROV : TBits_1; inline;
    function  getSPITBE : TBits_1; inline;
    function  getSPITBF : TBits_1; inline;
    function  getSPITUR : TBits_1; inline;
    function  getSRMT : TBits_1; inline;
    function  getTXBUFELM : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setRXBUFELM(thebits : TBits_5); inline;
    procedure setSPIBUSY(thebits : TBits_1); inline;
    procedure setSPIRBE(thebits : TBits_1); inline;
    procedure setSPIRBF(thebits : TBits_1); inline;
    procedure setSPIROV(thebits : TBits_1); inline;
    procedure setSPITBE(thebits : TBits_1); inline;
    procedure setSPITBF(thebits : TBits_1); inline;
    procedure setSPITUR(thebits : TBits_1); inline;
    procedure setSRMT(thebits : TBits_1); inline;
    procedure setTXBUFELM(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearSPIBUSY; inline;
    procedure clearSPIRBE; inline;
    procedure clearSPIRBF; inline;
    procedure clearSPIROV; inline;
    procedure clearSPITBE; inline;
    procedure clearSPITBF; inline;
    procedure clearSPITUR; inline;
    procedure clearSRMT; inline;
    procedure setSPIBUSY; inline;
    procedure setSPIRBE; inline;
    procedure setSPIRBF; inline;
    procedure setSPIROV; inline;
    procedure setSPITBE; inline;
    procedure setSPITBF; inline;
    procedure setSPITUR; inline;
    procedure setSRMT; inline;
    property RXBUFELM : TBits_5 read getRXBUFELM write setRXBUFELM;
    property SPIBUSY : TBits_1 read getSPIBUSY write setSPIBUSY;
    property SPIRBE : TBits_1 read getSPIRBE write setSPIRBE;
    property SPIRBF : TBits_1 read getSPIRBF write setSPIRBF;
    property SPIROV : TBits_1 read getSPIROV write setSPIROV;
    property SPITBE : TBits_1 read getSPITBE write setSPITBE;
    property SPITBF : TBits_1 read getSPITBF write setSPITBF;
    property SPITUR : TBits_1 read getSPITUR write setSPITUR;
    property SRMT : TBits_1 read getSRMT write setSRMT;
    property TXBUFELM : TBits_5 read getTXBUFELM write setTXBUFELM;
    property w : TBits_32 read getw write setw;
  end;
type
  TSPI3Registers = record
    SPI1ACONbits : TSPI3_SPI1ACON;
    SPI1ACON : longWord;
    SPI3CONbits : TSPI3_SPI3CON;
    SPI3CON : longWord;
    SPI1ACONCLR : longWord;
    SPI3CONCLR : longWord;
    SPI1ACONSET : longWord;
    SPI3CONSET : longWord;
    SPI1ACONINV : longWord;
    SPI3CONINV : longWord;
    SPI1ASTATbits : TSPI3_SPI1ASTAT;
    SPI1ASTAT : longWord;
    SPI3STATbits : TSPI3_SPI3STAT;
    SPI3STAT : longWord;
    SPI1ASTATCLR : longWord;
    SPI3STATCLR : longWord;
    SPI1ASTATSET : longWord;
    SPI3STATSET : longWord;
    SPI1ASTATINV : longWord;
    SPI3STATINV : longWord;
    SPI1ABUF : longWord;
    SPI3BUF : longWord;
    SPI1ABRG : longWord;
    SPI3BRG : longWord;
    SPI1ABRGCLR : longWord;
    SPI3BRGCLR : longWord;
    SPI1ABRGSET : longWord;
    SPI3BRGSET : longWord;
    SPI1ABRGINV : longWord;
    SPI3BRGINV : longWord;
  end;
  TSPI2A_SPI2ACON = record
  private
    function  getCKE : TBits_1; inline;
    function  getCKP : TBits_1; inline;
    function  getDISSDO : TBits_1; inline;
    function  getENHBUF : TBits_1; inline;
    function  getFRMCNT : TBits_3; inline;
    function  getFRMEN : TBits_1; inline;
    function  getFRMPOL : TBits_1; inline;
    function  getFRMSYNC : TBits_1; inline;
    function  getFRMSYPW : TBits_1; inline;
    function  getMODE16 : TBits_1; inline;
    function  getMODE32 : TBits_1; inline;
    function  getMSSEN : TBits_1; inline;
    function  getMSTEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMP : TBits_1; inline;
    function  getSPIFE : TBits_1; inline;
    function  getSRXISEL : TBits_2; inline;
    function  getSSEN : TBits_1; inline;
    function  getSTXISEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCKE(thebits : TBits_1); inline;
    procedure setCKP(thebits : TBits_1); inline;
    procedure setDISSDO(thebits : TBits_1); inline;
    procedure setENHBUF(thebits : TBits_1); inline;
    procedure setFRMCNT(thebits : TBits_3); inline;
    procedure setFRMEN(thebits : TBits_1); inline;
    procedure setFRMPOL(thebits : TBits_1); inline;
    procedure setFRMSYNC(thebits : TBits_1); inline;
    procedure setFRMSYPW(thebits : TBits_1); inline;
    procedure setMODE16(thebits : TBits_1); inline;
    procedure setMODE32(thebits : TBits_1); inline;
    procedure setMSSEN(thebits : TBits_1); inline;
    procedure setMSTEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMP(thebits : TBits_1); inline;
    procedure setSPIFE(thebits : TBits_1); inline;
    procedure setSRXISEL(thebits : TBits_2); inline;
    procedure setSSEN(thebits : TBits_1); inline;
    procedure setSTXISEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCKE; inline;
    procedure clearCKP; inline;
    procedure clearDISSDO; inline;
    procedure clearENHBUF; inline;
    procedure clearFRMEN; inline;
    procedure clearFRMPOL; inline;
    procedure clearFRMSYNC; inline;
    procedure clearFRMSYPW; inline;
    procedure clearMODE16; inline;
    procedure clearMODE32; inline;
    procedure clearMSSEN; inline;
    procedure clearMSTEN; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearSMP; inline;
    procedure clearSPIFE; inline;
    procedure clearSSEN; inline;
    procedure setCKE; inline;
    procedure setCKP; inline;
    procedure setDISSDO; inline;
    procedure setENHBUF; inline;
    procedure setFRMEN; inline;
    procedure setFRMPOL; inline;
    procedure setFRMSYNC; inline;
    procedure setFRMSYPW; inline;
    procedure setMODE16; inline;
    procedure setMODE32; inline;
    procedure setMSSEN; inline;
    procedure setMSTEN; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setSMP; inline;
    procedure setSPIFE; inline;
    procedure setSSEN; inline;
    property CKE : TBits_1 read getCKE write setCKE;
    property CKP : TBits_1 read getCKP write setCKP;
    property DISSDO : TBits_1 read getDISSDO write setDISSDO;
    property ENHBUF : TBits_1 read getENHBUF write setENHBUF;
    property FRMCNT : TBits_3 read getFRMCNT write setFRMCNT;
    property FRMEN : TBits_1 read getFRMEN write setFRMEN;
    property FRMPOL : TBits_1 read getFRMPOL write setFRMPOL;
    property FRMSYNC : TBits_1 read getFRMSYNC write setFRMSYNC;
    property FRMSYPW : TBits_1 read getFRMSYPW write setFRMSYPW;
    property MODE16 : TBits_1 read getMODE16 write setMODE16;
    property MODE32 : TBits_1 read getMODE32 write setMODE32;
    property MSSEN : TBits_1 read getMSSEN write setMSSEN;
    property MSTEN : TBits_1 read getMSTEN write setMSTEN;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMP : TBits_1 read getSMP write setSMP;
    property SPIFE : TBits_1 read getSPIFE write setSPIFE;
    property SRXISEL : TBits_2 read getSRXISEL write setSRXISEL;
    property SSEN : TBits_1 read getSSEN write setSSEN;
    property STXISEL : TBits_2 read getSTXISEL write setSTXISEL;
    property w : TBits_32 read getw write setw;
  end;
  TSPI2A_SPI2CON = record
  private
    function  getCKE : TBits_1; inline;
    function  getCKP : TBits_1; inline;
    function  getDISSDO : TBits_1; inline;
    function  getENHBUF : TBits_1; inline;
    function  getFRMCNT : TBits_3; inline;
    function  getFRMEN : TBits_1; inline;
    function  getFRMPOL : TBits_1; inline;
    function  getFRMSYNC : TBits_1; inline;
    function  getFRMSYPW : TBits_1; inline;
    function  getMODE16 : TBits_1; inline;
    function  getMODE32 : TBits_1; inline;
    function  getMSSEN : TBits_1; inline;
    function  getMSTEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMP : TBits_1; inline;
    function  getSPIFE : TBits_1; inline;
    function  getSRXISEL : TBits_2; inline;
    function  getSSEN : TBits_1; inline;
    function  getSTXISEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCKE(thebits : TBits_1); inline;
    procedure setCKP(thebits : TBits_1); inline;
    procedure setDISSDO(thebits : TBits_1); inline;
    procedure setENHBUF(thebits : TBits_1); inline;
    procedure setFRMCNT(thebits : TBits_3); inline;
    procedure setFRMEN(thebits : TBits_1); inline;
    procedure setFRMPOL(thebits : TBits_1); inline;
    procedure setFRMSYNC(thebits : TBits_1); inline;
    procedure setFRMSYPW(thebits : TBits_1); inline;
    procedure setMODE16(thebits : TBits_1); inline;
    procedure setMODE32(thebits : TBits_1); inline;
    procedure setMSSEN(thebits : TBits_1); inline;
    procedure setMSTEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMP(thebits : TBits_1); inline;
    procedure setSPIFE(thebits : TBits_1); inline;
    procedure setSRXISEL(thebits : TBits_2); inline;
    procedure setSSEN(thebits : TBits_1); inline;
    procedure setSTXISEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCKE; inline;
    procedure clearCKP; inline;
    procedure clearDISSDO; inline;
    procedure clearENHBUF; inline;
    procedure clearFRMEN; inline;
    procedure clearFRMPOL; inline;
    procedure clearFRMSYNC; inline;
    procedure clearFRMSYPW; inline;
    procedure clearMODE16; inline;
    procedure clearMODE32; inline;
    procedure clearMSSEN; inline;
    procedure clearMSTEN; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearSMP; inline;
    procedure clearSPIFE; inline;
    procedure clearSSEN; inline;
    procedure setCKE; inline;
    procedure setCKP; inline;
    procedure setDISSDO; inline;
    procedure setENHBUF; inline;
    procedure setFRMEN; inline;
    procedure setFRMPOL; inline;
    procedure setFRMSYNC; inline;
    procedure setFRMSYPW; inline;
    procedure setMODE16; inline;
    procedure setMODE32; inline;
    procedure setMSSEN; inline;
    procedure setMSTEN; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setSMP; inline;
    procedure setSPIFE; inline;
    procedure setSSEN; inline;
    property CKE : TBits_1 read getCKE write setCKE;
    property CKP : TBits_1 read getCKP write setCKP;
    property DISSDO : TBits_1 read getDISSDO write setDISSDO;
    property ENHBUF : TBits_1 read getENHBUF write setENHBUF;
    property FRMCNT : TBits_3 read getFRMCNT write setFRMCNT;
    property FRMEN : TBits_1 read getFRMEN write setFRMEN;
    property FRMPOL : TBits_1 read getFRMPOL write setFRMPOL;
    property FRMSYNC : TBits_1 read getFRMSYNC write setFRMSYNC;
    property FRMSYPW : TBits_1 read getFRMSYPW write setFRMSYPW;
    property MODE16 : TBits_1 read getMODE16 write setMODE16;
    property MODE32 : TBits_1 read getMODE32 write setMODE32;
    property MSSEN : TBits_1 read getMSSEN write setMSSEN;
    property MSTEN : TBits_1 read getMSTEN write setMSTEN;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMP : TBits_1 read getSMP write setSMP;
    property SPIFE : TBits_1 read getSPIFE write setSPIFE;
    property SRXISEL : TBits_2 read getSRXISEL write setSRXISEL;
    property SSEN : TBits_1 read getSSEN write setSSEN;
    property STXISEL : TBits_2 read getSTXISEL write setSTXISEL;
    property w : TBits_32 read getw write setw;
  end;
  TSPI2A_SPI2ASTAT = record
  private
    function  getRXBUFELM : TBits_5; inline;
    function  getSPIBUSY : TBits_1; inline;
    function  getSPIRBE : TBits_1; inline;
    function  getSPIRBF : TBits_1; inline;
    function  getSPIROV : TBits_1; inline;
    function  getSPITBE : TBits_1; inline;
    function  getSPITBF : TBits_1; inline;
    function  getSPITUR : TBits_1; inline;
    function  getSRMT : TBits_1; inline;
    function  getTXBUFELM : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setRXBUFELM(thebits : TBits_5); inline;
    procedure setSPIBUSY(thebits : TBits_1); inline;
    procedure setSPIRBE(thebits : TBits_1); inline;
    procedure setSPIRBF(thebits : TBits_1); inline;
    procedure setSPIROV(thebits : TBits_1); inline;
    procedure setSPITBE(thebits : TBits_1); inline;
    procedure setSPITBF(thebits : TBits_1); inline;
    procedure setSPITUR(thebits : TBits_1); inline;
    procedure setSRMT(thebits : TBits_1); inline;
    procedure setTXBUFELM(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearSPIBUSY; inline;
    procedure clearSPIRBE; inline;
    procedure clearSPIRBF; inline;
    procedure clearSPIROV; inline;
    procedure clearSPITBE; inline;
    procedure clearSPITBF; inline;
    procedure clearSPITUR; inline;
    procedure clearSRMT; inline;
    procedure setSPIBUSY; inline;
    procedure setSPIRBE; inline;
    procedure setSPIRBF; inline;
    procedure setSPIROV; inline;
    procedure setSPITBE; inline;
    procedure setSPITBF; inline;
    procedure setSPITUR; inline;
    procedure setSRMT; inline;
    property RXBUFELM : TBits_5 read getRXBUFELM write setRXBUFELM;
    property SPIBUSY : TBits_1 read getSPIBUSY write setSPIBUSY;
    property SPIRBE : TBits_1 read getSPIRBE write setSPIRBE;
    property SPIRBF : TBits_1 read getSPIRBF write setSPIRBF;
    property SPIROV : TBits_1 read getSPIROV write setSPIROV;
    property SPITBE : TBits_1 read getSPITBE write setSPITBE;
    property SPITBF : TBits_1 read getSPITBF write setSPITBF;
    property SPITUR : TBits_1 read getSPITUR write setSPITUR;
    property SRMT : TBits_1 read getSRMT write setSRMT;
    property TXBUFELM : TBits_5 read getTXBUFELM write setTXBUFELM;
    property w : TBits_32 read getw write setw;
  end;
  TSPI2A_SPI2STAT = record
  private
    function  getRXBUFELM : TBits_5; inline;
    function  getSPIBUSY : TBits_1; inline;
    function  getSPIRBE : TBits_1; inline;
    function  getSPIRBF : TBits_1; inline;
    function  getSPIROV : TBits_1; inline;
    function  getSPITBE : TBits_1; inline;
    function  getSPITBF : TBits_1; inline;
    function  getSPITUR : TBits_1; inline;
    function  getSRMT : TBits_1; inline;
    function  getTXBUFELM : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setRXBUFELM(thebits : TBits_5); inline;
    procedure setSPIBUSY(thebits : TBits_1); inline;
    procedure setSPIRBE(thebits : TBits_1); inline;
    procedure setSPIRBF(thebits : TBits_1); inline;
    procedure setSPIROV(thebits : TBits_1); inline;
    procedure setSPITBE(thebits : TBits_1); inline;
    procedure setSPITBF(thebits : TBits_1); inline;
    procedure setSPITUR(thebits : TBits_1); inline;
    procedure setSRMT(thebits : TBits_1); inline;
    procedure setTXBUFELM(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearSPIBUSY; inline;
    procedure clearSPIRBE; inline;
    procedure clearSPIRBF; inline;
    procedure clearSPIROV; inline;
    procedure clearSPITBE; inline;
    procedure clearSPITBF; inline;
    procedure clearSPITUR; inline;
    procedure clearSRMT; inline;
    procedure setSPIBUSY; inline;
    procedure setSPIRBE; inline;
    procedure setSPIRBF; inline;
    procedure setSPIROV; inline;
    procedure setSPITBE; inline;
    procedure setSPITBF; inline;
    procedure setSPITUR; inline;
    procedure setSRMT; inline;
    property RXBUFELM : TBits_5 read getRXBUFELM write setRXBUFELM;
    property SPIBUSY : TBits_1 read getSPIBUSY write setSPIBUSY;
    property SPIRBE : TBits_1 read getSPIRBE write setSPIRBE;
    property SPIRBF : TBits_1 read getSPIRBF write setSPIRBF;
    property SPIROV : TBits_1 read getSPIROV write setSPIROV;
    property SPITBE : TBits_1 read getSPITBE write setSPITBE;
    property SPITBF : TBits_1 read getSPITBF write setSPITBF;
    property SPITUR : TBits_1 read getSPITUR write setSPITUR;
    property SRMT : TBits_1 read getSRMT write setSRMT;
    property TXBUFELM : TBits_5 read getTXBUFELM write setTXBUFELM;
    property w : TBits_32 read getw write setw;
  end;
type
  TSPI2ARegisters = record
    SPI2ACONbits : TSPI2A_SPI2ACON;
    SPI2ACON : longWord;
    SPI2CONbits : TSPI2A_SPI2CON;
    SPI2CON : longWord;
    SPI2ACONCLR : longWord;
    SPI2CONCLR : longWord;
    SPI2ACONSET : longWord;
    SPI2CONSET : longWord;
    SPI2ACONINV : longWord;
    SPI2CONINV : longWord;
    SPI2ASTATbits : TSPI2A_SPI2ASTAT;
    SPI2ASTAT : longWord;
    SPI2STATbits : TSPI2A_SPI2STAT;
    SPI2STAT : longWord;
    SPI2ASTATCLR : longWord;
    SPI2STATCLR : longWord;
    SPI2ASTATSET : longWord;
    SPI2STATSET : longWord;
    SPI2ASTATINV : longWord;
    SPI2STATINV : longWord;
    SPI2ABUF : longWord;
    SPI2BUF : longWord;
    SPI2ABRG : longWord;
    SPI2BRG : longWord;
    SPI2ABRGCLR : longWord;
    SPI2BRGCLR : longWord;
    SPI2ABRGSET : longWord;
    SPI2BRGSET : longWord;
    SPI2ABRGINV : longWord;
    SPI2BRGINV : longWord;
  end;
  TSPI3A_SPI3ACON = record
  private
    function  getCKE : TBits_1; inline;
    function  getCKP : TBits_1; inline;
    function  getDISSDO : TBits_1; inline;
    function  getENHBUF : TBits_1; inline;
    function  getFRMCNT : TBits_3; inline;
    function  getFRMEN : TBits_1; inline;
    function  getFRMPOL : TBits_1; inline;
    function  getFRMSYNC : TBits_1; inline;
    function  getFRMSYPW : TBits_1; inline;
    function  getMODE16 : TBits_1; inline;
    function  getMODE32 : TBits_1; inline;
    function  getMSSEN : TBits_1; inline;
    function  getMSTEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMP : TBits_1; inline;
    function  getSPIFE : TBits_1; inline;
    function  getSRXISEL : TBits_2; inline;
    function  getSSEN : TBits_1; inline;
    function  getSTXISEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCKE(thebits : TBits_1); inline;
    procedure setCKP(thebits : TBits_1); inline;
    procedure setDISSDO(thebits : TBits_1); inline;
    procedure setENHBUF(thebits : TBits_1); inline;
    procedure setFRMCNT(thebits : TBits_3); inline;
    procedure setFRMEN(thebits : TBits_1); inline;
    procedure setFRMPOL(thebits : TBits_1); inline;
    procedure setFRMSYNC(thebits : TBits_1); inline;
    procedure setFRMSYPW(thebits : TBits_1); inline;
    procedure setMODE16(thebits : TBits_1); inline;
    procedure setMODE32(thebits : TBits_1); inline;
    procedure setMSSEN(thebits : TBits_1); inline;
    procedure setMSTEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMP(thebits : TBits_1); inline;
    procedure setSPIFE(thebits : TBits_1); inline;
    procedure setSRXISEL(thebits : TBits_2); inline;
    procedure setSSEN(thebits : TBits_1); inline;
    procedure setSTXISEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCKE; inline;
    procedure clearCKP; inline;
    procedure clearDISSDO; inline;
    procedure clearENHBUF; inline;
    procedure clearFRMEN; inline;
    procedure clearFRMPOL; inline;
    procedure clearFRMSYNC; inline;
    procedure clearFRMSYPW; inline;
    procedure clearMODE16; inline;
    procedure clearMODE32; inline;
    procedure clearMSSEN; inline;
    procedure clearMSTEN; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearSMP; inline;
    procedure clearSPIFE; inline;
    procedure clearSSEN; inline;
    procedure setCKE; inline;
    procedure setCKP; inline;
    procedure setDISSDO; inline;
    procedure setENHBUF; inline;
    procedure setFRMEN; inline;
    procedure setFRMPOL; inline;
    procedure setFRMSYNC; inline;
    procedure setFRMSYPW; inline;
    procedure setMODE16; inline;
    procedure setMODE32; inline;
    procedure setMSSEN; inline;
    procedure setMSTEN; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setSMP; inline;
    procedure setSPIFE; inline;
    procedure setSSEN; inline;
    property CKE : TBits_1 read getCKE write setCKE;
    property CKP : TBits_1 read getCKP write setCKP;
    property DISSDO : TBits_1 read getDISSDO write setDISSDO;
    property ENHBUF : TBits_1 read getENHBUF write setENHBUF;
    property FRMCNT : TBits_3 read getFRMCNT write setFRMCNT;
    property FRMEN : TBits_1 read getFRMEN write setFRMEN;
    property FRMPOL : TBits_1 read getFRMPOL write setFRMPOL;
    property FRMSYNC : TBits_1 read getFRMSYNC write setFRMSYNC;
    property FRMSYPW : TBits_1 read getFRMSYPW write setFRMSYPW;
    property MODE16 : TBits_1 read getMODE16 write setMODE16;
    property MODE32 : TBits_1 read getMODE32 write setMODE32;
    property MSSEN : TBits_1 read getMSSEN write setMSSEN;
    property MSTEN : TBits_1 read getMSTEN write setMSTEN;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMP : TBits_1 read getSMP write setSMP;
    property SPIFE : TBits_1 read getSPIFE write setSPIFE;
    property SRXISEL : TBits_2 read getSRXISEL write setSRXISEL;
    property SSEN : TBits_1 read getSSEN write setSSEN;
    property STXISEL : TBits_2 read getSTXISEL write setSTXISEL;
    property w : TBits_32 read getw write setw;
  end;
  TSPI3A_SPI4CON = record
  private
    function  getCKE : TBits_1; inline;
    function  getCKP : TBits_1; inline;
    function  getDISSDO : TBits_1; inline;
    function  getENHBUF : TBits_1; inline;
    function  getFRMCNT : TBits_3; inline;
    function  getFRMEN : TBits_1; inline;
    function  getFRMPOL : TBits_1; inline;
    function  getFRMSYNC : TBits_1; inline;
    function  getFRMSYPW : TBits_1; inline;
    function  getMODE16 : TBits_1; inline;
    function  getMODE32 : TBits_1; inline;
    function  getMSSEN : TBits_1; inline;
    function  getMSTEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMP : TBits_1; inline;
    function  getSPIFE : TBits_1; inline;
    function  getSRXISEL : TBits_2; inline;
    function  getSSEN : TBits_1; inline;
    function  getSTXISEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCKE(thebits : TBits_1); inline;
    procedure setCKP(thebits : TBits_1); inline;
    procedure setDISSDO(thebits : TBits_1); inline;
    procedure setENHBUF(thebits : TBits_1); inline;
    procedure setFRMCNT(thebits : TBits_3); inline;
    procedure setFRMEN(thebits : TBits_1); inline;
    procedure setFRMPOL(thebits : TBits_1); inline;
    procedure setFRMSYNC(thebits : TBits_1); inline;
    procedure setFRMSYPW(thebits : TBits_1); inline;
    procedure setMODE16(thebits : TBits_1); inline;
    procedure setMODE32(thebits : TBits_1); inline;
    procedure setMSSEN(thebits : TBits_1); inline;
    procedure setMSTEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMP(thebits : TBits_1); inline;
    procedure setSPIFE(thebits : TBits_1); inline;
    procedure setSRXISEL(thebits : TBits_2); inline;
    procedure setSSEN(thebits : TBits_1); inline;
    procedure setSTXISEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCKE; inline;
    procedure clearCKP; inline;
    procedure clearDISSDO; inline;
    procedure clearENHBUF; inline;
    procedure clearFRMEN; inline;
    procedure clearFRMPOL; inline;
    procedure clearFRMSYNC; inline;
    procedure clearFRMSYPW; inline;
    procedure clearMODE16; inline;
    procedure clearMODE32; inline;
    procedure clearMSSEN; inline;
    procedure clearMSTEN; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearSMP; inline;
    procedure clearSPIFE; inline;
    procedure clearSSEN; inline;
    procedure setCKE; inline;
    procedure setCKP; inline;
    procedure setDISSDO; inline;
    procedure setENHBUF; inline;
    procedure setFRMEN; inline;
    procedure setFRMPOL; inline;
    procedure setFRMSYNC; inline;
    procedure setFRMSYPW; inline;
    procedure setMODE16; inline;
    procedure setMODE32; inline;
    procedure setMSSEN; inline;
    procedure setMSTEN; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setSMP; inline;
    procedure setSPIFE; inline;
    procedure setSSEN; inline;
    property CKE : TBits_1 read getCKE write setCKE;
    property CKP : TBits_1 read getCKP write setCKP;
    property DISSDO : TBits_1 read getDISSDO write setDISSDO;
    property ENHBUF : TBits_1 read getENHBUF write setENHBUF;
    property FRMCNT : TBits_3 read getFRMCNT write setFRMCNT;
    property FRMEN : TBits_1 read getFRMEN write setFRMEN;
    property FRMPOL : TBits_1 read getFRMPOL write setFRMPOL;
    property FRMSYNC : TBits_1 read getFRMSYNC write setFRMSYNC;
    property FRMSYPW : TBits_1 read getFRMSYPW write setFRMSYPW;
    property MODE16 : TBits_1 read getMODE16 write setMODE16;
    property MODE32 : TBits_1 read getMODE32 write setMODE32;
    property MSSEN : TBits_1 read getMSSEN write setMSSEN;
    property MSTEN : TBits_1 read getMSTEN write setMSTEN;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMP : TBits_1 read getSMP write setSMP;
    property SPIFE : TBits_1 read getSPIFE write setSPIFE;
    property SRXISEL : TBits_2 read getSRXISEL write setSRXISEL;
    property SSEN : TBits_1 read getSSEN write setSSEN;
    property STXISEL : TBits_2 read getSTXISEL write setSTXISEL;
    property w : TBits_32 read getw write setw;
  end;
  TSPI3A_SPI3ASTAT = record
  private
    function  getRXBUFELM : TBits_5; inline;
    function  getSPIBUSY : TBits_1; inline;
    function  getSPIRBE : TBits_1; inline;
    function  getSPIRBF : TBits_1; inline;
    function  getSPIROV : TBits_1; inline;
    function  getSPITBE : TBits_1; inline;
    function  getSPITBF : TBits_1; inline;
    function  getSPITUR : TBits_1; inline;
    function  getSRMT : TBits_1; inline;
    function  getTXBUFELM : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setRXBUFELM(thebits : TBits_5); inline;
    procedure setSPIBUSY(thebits : TBits_1); inline;
    procedure setSPIRBE(thebits : TBits_1); inline;
    procedure setSPIRBF(thebits : TBits_1); inline;
    procedure setSPIROV(thebits : TBits_1); inline;
    procedure setSPITBE(thebits : TBits_1); inline;
    procedure setSPITBF(thebits : TBits_1); inline;
    procedure setSPITUR(thebits : TBits_1); inline;
    procedure setSRMT(thebits : TBits_1); inline;
    procedure setTXBUFELM(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearSPIBUSY; inline;
    procedure clearSPIRBE; inline;
    procedure clearSPIRBF; inline;
    procedure clearSPIROV; inline;
    procedure clearSPITBE; inline;
    procedure clearSPITBF; inline;
    procedure clearSPITUR; inline;
    procedure clearSRMT; inline;
    procedure setSPIBUSY; inline;
    procedure setSPIRBE; inline;
    procedure setSPIRBF; inline;
    procedure setSPIROV; inline;
    procedure setSPITBE; inline;
    procedure setSPITBF; inline;
    procedure setSPITUR; inline;
    procedure setSRMT; inline;
    property RXBUFELM : TBits_5 read getRXBUFELM write setRXBUFELM;
    property SPIBUSY : TBits_1 read getSPIBUSY write setSPIBUSY;
    property SPIRBE : TBits_1 read getSPIRBE write setSPIRBE;
    property SPIRBF : TBits_1 read getSPIRBF write setSPIRBF;
    property SPIROV : TBits_1 read getSPIROV write setSPIROV;
    property SPITBE : TBits_1 read getSPITBE write setSPITBE;
    property SPITBF : TBits_1 read getSPITBF write setSPITBF;
    property SPITUR : TBits_1 read getSPITUR write setSPITUR;
    property SRMT : TBits_1 read getSRMT write setSRMT;
    property TXBUFELM : TBits_5 read getTXBUFELM write setTXBUFELM;
    property w : TBits_32 read getw write setw;
  end;
  TSPI3A_SPI4STAT = record
  private
    function  getRXBUFELM : TBits_5; inline;
    function  getSPIBUSY : TBits_1; inline;
    function  getSPIRBE : TBits_1; inline;
    function  getSPIRBF : TBits_1; inline;
    function  getSPIROV : TBits_1; inline;
    function  getSPITBE : TBits_1; inline;
    function  getSPITBF : TBits_1; inline;
    function  getSPITUR : TBits_1; inline;
    function  getSRMT : TBits_1; inline;
    function  getTXBUFELM : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setRXBUFELM(thebits : TBits_5); inline;
    procedure setSPIBUSY(thebits : TBits_1); inline;
    procedure setSPIRBE(thebits : TBits_1); inline;
    procedure setSPIRBF(thebits : TBits_1); inline;
    procedure setSPIROV(thebits : TBits_1); inline;
    procedure setSPITBE(thebits : TBits_1); inline;
    procedure setSPITBF(thebits : TBits_1); inline;
    procedure setSPITUR(thebits : TBits_1); inline;
    procedure setSRMT(thebits : TBits_1); inline;
    procedure setTXBUFELM(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearSPIBUSY; inline;
    procedure clearSPIRBE; inline;
    procedure clearSPIRBF; inline;
    procedure clearSPIROV; inline;
    procedure clearSPITBE; inline;
    procedure clearSPITBF; inline;
    procedure clearSPITUR; inline;
    procedure clearSRMT; inline;
    procedure setSPIBUSY; inline;
    procedure setSPIRBE; inline;
    procedure setSPIRBF; inline;
    procedure setSPIROV; inline;
    procedure setSPITBE; inline;
    procedure setSPITBF; inline;
    procedure setSPITUR; inline;
    procedure setSRMT; inline;
    property RXBUFELM : TBits_5 read getRXBUFELM write setRXBUFELM;
    property SPIBUSY : TBits_1 read getSPIBUSY write setSPIBUSY;
    property SPIRBE : TBits_1 read getSPIRBE write setSPIRBE;
    property SPIRBF : TBits_1 read getSPIRBF write setSPIRBF;
    property SPIROV : TBits_1 read getSPIROV write setSPIROV;
    property SPITBE : TBits_1 read getSPITBE write setSPITBE;
    property SPITBF : TBits_1 read getSPITBF write setSPITBF;
    property SPITUR : TBits_1 read getSPITUR write setSPITUR;
    property SRMT : TBits_1 read getSRMT write setSRMT;
    property TXBUFELM : TBits_5 read getTXBUFELM write setTXBUFELM;
    property w : TBits_32 read getw write setw;
  end;
type
  TSPI3ARegisters = record
    SPI3ACONbits : TSPI3A_SPI3ACON;
    SPI3ACON : longWord;
    SPI4CONbits : TSPI3A_SPI4CON;
    SPI4CON : longWord;
    SPI3ACONCLR : longWord;
    SPI4CONCLR : longWord;
    SPI3ACONSET : longWord;
    SPI4CONSET : longWord;
    SPI3ACONINV : longWord;
    SPI4CONINV : longWord;
    SPI3ASTATbits : TSPI3A_SPI3ASTAT;
    SPI3ASTAT : longWord;
    SPI4STATbits : TSPI3A_SPI4STAT;
    SPI4STAT : longWord;
    SPI3ASTATCLR : longWord;
    SPI4STATCLR : longWord;
    SPI3ASTATSET : longWord;
    SPI4STATSET : longWord;
    SPI3ASTATINV : longWord;
    SPI4STATINV : longWord;
    SPI3ABUF : longWord;
    SPI4BUF : longWord;
    SPI3ABRG : longWord;
    SPI4BRG : longWord;
    SPI3ABRGCLR : longWord;
    SPI4BRGCLR : longWord;
    SPI3ABRGSET : longWord;
    SPI4BRGSET : longWord;
    SPI3ABRGINV : longWord;
    SPI4BRGINV : longWord;
  end;
  TUART1A_U1AMODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART1A_U1MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART1A_U1ASTA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
  TUART1A_U1STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
type
  TUART1ARegisters = record
    U1AMODEbits : TUART1A_U1AMODE;
    U1AMODE : longWord;
    U1MODEbits : TUART1A_U1MODE;
    U1MODE : longWord;
    U1AMODECLR : longWord;
    U1MODECLR : longWord;
    U1AMODESET : longWord;
    U1MODESET : longWord;
    U1AMODEINV : longWord;
    U1MODEINV : longWord;
    U1ASTAbits : TUART1A_U1ASTA;
    U1ASTA : longWord;
    U1STAbits : TUART1A_U1STA;
    U1STA : longWord;
    U1ASTACLR : longWord;
    U1STACLR : longWord;
    U1ASTASET : longWord;
    U1STASET : longWord;
    U1ASTAINV : longWord;
    U1STAINV : longWord;
    U1ATXREG : longWord;
    U1TXREG : longWord;
    U1ARXREG : longWord;
    U1RXREG : longWord;
    U1ABRG : longWord;
    U1BRG : longWord;
    U1ABRGCLR : longWord;
    U1BRGCLR : longWord;
    U1ABRGSET : longWord;
    U1BRGSET : longWord;
    U1ABRGINV : longWord;
    U1BRGINV : longWord;
  end;
  TUART4_U1BMODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART4_U4MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART4_U1BSTA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
  TUART4_U4STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
type
  TUART4Registers = record
    U1BMODEbits : TUART4_U1BMODE;
    U1BMODE : longWord;
    U4MODEbits : TUART4_U4MODE;
    U4MODE : longWord;
    U1BMODECLR : longWord;
    U4MODECLR : longWord;
    U1BMODESET : longWord;
    U4MODESET : longWord;
    U1BMODEINV : longWord;
    U4MODEINV : longWord;
    U1BSTAbits : TUART4_U1BSTA;
    U1BSTA : longWord;
    U4STAbits : TUART4_U4STA;
    U4STA : longWord;
    U1BSTACLR : longWord;
    U4STACLR : longWord;
    U1BSTASET : longWord;
    U4STASET : longWord;
    U1BSTAINV : longWord;
    U4STAINV : longWord;
    U1BTXREG : longWord;
    U4TXREG : longWord;
    U1BRXREG : longWord;
    U4RXREG : longWord;
    U1BBRG : longWord;
    U4BRG : longWord;
    U1BBRGCLR : longWord;
    U4BRGCLR : longWord;
    U1BBRGSET : longWord;
    U4BRGSET : longWord;
    U1BBRGINV : longWord;
    U4BRGINV : longWord;
  end;
  TUART2A_U2AMODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART2A_U3MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART2A_U2ASTA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
  TUART2A_U3STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
type
  TUART2ARegisters = record
    U2AMODEbits : TUART2A_U2AMODE;
    U2AMODE : longWord;
    U3MODEbits : TUART2A_U3MODE;
    U3MODE : longWord;
    U2AMODECLR : longWord;
    U3MODECLR : longWord;
    U2AMODESET : longWord;
    U3MODESET : longWord;
    U2AMODEINV : longWord;
    U3MODEINV : longWord;
    U2ASTAbits : TUART2A_U2ASTA;
    U2ASTA : longWord;
    U3STAbits : TUART2A_U3STA;
    U3STA : longWord;
    U2ASTACLR : longWord;
    U3STACLR : longWord;
    U2ASTASET : longWord;
    U3STASET : longWord;
    U2ASTAINV : longWord;
    U3STAINV : longWord;
    U2ATXREG : longWord;
    U3TXREG : longWord;
    U2ARXREG : longWord;
    U3RXREG : longWord;
    U2ABRG : longWord;
    U3BRG : longWord;
    U2ABRGCLR : longWord;
    U3BRGCLR : longWord;
    U2ABRGSET : longWord;
    U3BRGSET : longWord;
    U2ABRGINV : longWord;
    U3BRGINV : longWord;
  end;
  TUART6_U2BMODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART6_U6MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART6_U2BSTA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
  TUART6_U6STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
type
  TUART6Registers = record
    U2BMODEbits : TUART6_U2BMODE;
    U2BMODE : longWord;
    U6MODEbits : TUART6_U6MODE;
    U6MODE : longWord;
    U2BMODECLR : longWord;
    U6MODECLR : longWord;
    U2BMODESET : longWord;
    U6MODESET : longWord;
    U2BMODEINV : longWord;
    U6MODEINV : longWord;
    U2BSTAbits : TUART6_U2BSTA;
    U2BSTA : longWord;
    U6STAbits : TUART6_U6STA;
    U6STA : longWord;
    U2BSTACLR : longWord;
    U6STACLR : longWord;
    U2BSTASET : longWord;
    U6STASET : longWord;
    U2BSTAINV : longWord;
    U6STAINV : longWord;
    U2BTXREG : longWord;
    U6TXREG : longWord;
    U2BRXREG : longWord;
    U6RXREG : longWord;
    U2BBRG : longWord;
    U6BRG : longWord;
    U2BBRGCLR : longWord;
    U6BRGCLR : longWord;
    U2BBRGSET : longWord;
    U6BRGSET : longWord;
    U2BBRGINV : longWord;
    U6BRGINV : longWord;
  end;
  TUART2_U2MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART2_U3AMODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART2_U2STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
  TUART2_U3ASTA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
type
  TUART2Registers = record
    U2MODEbits : TUART2_U2MODE;
    U2MODE : longWord;
    U3AMODEbits : TUART2_U3AMODE;
    U3AMODE : longWord;
    U2MODECLR : longWord;
    U3AMODECLR : longWord;
    U2MODESET : longWord;
    U3AMODESET : longWord;
    U2MODEINV : longWord;
    U3AMODEINV : longWord;
    U2STAbits : TUART2_U2STA;
    U2STA : longWord;
    U3ASTAbits : TUART2_U3ASTA;
    U3ASTA : longWord;
    U2STACLR : longWord;
    U3ASTACLR : longWord;
    U2STASET : longWord;
    U3ASTASET : longWord;
    U2STAINV : longWord;
    U3ASTAINV : longWord;
    U2TXREG : longWord;
    U3ATXREG : longWord;
    U2RXREG : longWord;
    U3ARXREG : longWord;
    U2BRG : longWord;
    U3ABRG : longWord;
    U2BRGCLR : longWord;
    U3ABRGCLR : longWord;
    U2BRGSET : longWord;
    U3ABRGSET : longWord;
    U2BRGINV : longWord;
    U3ABRGINV : longWord;
  end;
  TUART5_U3BMODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART5_U5MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART5_U3BSTA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
  TUART5_U5STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
type
  TUART5Registers = record
    U3BMODEbits : TUART5_U3BMODE;
    U3BMODE : longWord;
    U5MODEbits : TUART5_U5MODE;
    U5MODE : longWord;
    U3BMODECLR : longWord;
    U5MODECLR : longWord;
    U3BMODESET : longWord;
    U5MODESET : longWord;
    U3BMODEINV : longWord;
    U5MODEINV : longWord;
    U3BSTAbits : TUART5_U3BSTA;
    U3BSTA : longWord;
    U5STAbits : TUART5_U5STA;
    U5STA : longWord;
    U3BSTACLR : longWord;
    U5STACLR : longWord;
    U3BSTASET : longWord;
    U5STASET : longWord;
    U3BSTAINV : longWord;
    U5STAINV : longWord;
    U3BTXREG : longWord;
    U5TXREG : longWord;
    U3BRXREG : longWord;
    U5RXREG : longWord;
    U3BBRG : longWord;
    U5BRG : longWord;
    U3BBRGCLR : longWord;
    U5BRGCLR : longWord;
    U3BBRGSET : longWord;
    U5BRGSET : longWord;
    U3BBRGINV : longWord;
    U5BRGINV : longWord;
  end;
  TPMP_PMCON = record
  private
    function  getADRMUX : TBits_2; inline;
    function  getADRMUX0 : TBits_1; inline;
    function  getADRMUX1 : TBits_1; inline;
    function  getALP : TBits_1; inline;
    function  getCS1P : TBits_1; inline;
    function  getCS2P : TBits_1; inline;
    function  getCSF : TBits_2; inline;
    function  getCSF0 : TBits_1; inline;
    function  getCSF1 : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPMPEN : TBits_1; inline;
    function  getPMPTTL : TBits_1; inline;
    function  getPSIDL : TBits_1; inline;
    function  getPTRDEN : TBits_1; inline;
    function  getPTWREN : TBits_1; inline;
    function  getRDSP : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getWRSP : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setADRMUX(thebits : TBits_2); inline;
    procedure setADRMUX0(thebits : TBits_1); inline;
    procedure setADRMUX1(thebits : TBits_1); inline;
    procedure setALP(thebits : TBits_1); inline;
    procedure setCS1P(thebits : TBits_1); inline;
    procedure setCS2P(thebits : TBits_1); inline;
    procedure setCSF(thebits : TBits_2); inline;
    procedure setCSF0(thebits : TBits_1); inline;
    procedure setCSF1(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPMPEN(thebits : TBits_1); inline;
    procedure setPMPTTL(thebits : TBits_1); inline;
    procedure setPSIDL(thebits : TBits_1); inline;
    procedure setPTRDEN(thebits : TBits_1); inline;
    procedure setPTWREN(thebits : TBits_1); inline;
    procedure setRDSP(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setWRSP(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADRMUX0; inline;
    procedure clearADRMUX1; inline;
    procedure clearALP; inline;
    procedure clearCS1P; inline;
    procedure clearCS2P; inline;
    procedure clearCSF0; inline;
    procedure clearCSF1; inline;
    procedure clearON; inline;
    procedure clearPMPEN; inline;
    procedure clearPMPTTL; inline;
    procedure clearPSIDL; inline;
    procedure clearPTRDEN; inline;
    procedure clearPTWREN; inline;
    procedure clearRDSP; inline;
    procedure clearSIDL; inline;
    procedure clearWRSP; inline;
    procedure setADRMUX0; inline;
    procedure setADRMUX1; inline;
    procedure setALP; inline;
    procedure setCS1P; inline;
    procedure setCS2P; inline;
    procedure setCSF0; inline;
    procedure setCSF1; inline;
    procedure setON; inline;
    procedure setPMPEN; inline;
    procedure setPMPTTL; inline;
    procedure setPSIDL; inline;
    procedure setPTRDEN; inline;
    procedure setPTWREN; inline;
    procedure setRDSP; inline;
    procedure setSIDL; inline;
    procedure setWRSP; inline;
    property ADRMUX : TBits_2 read getADRMUX write setADRMUX;
    property ADRMUX0 : TBits_1 read getADRMUX0 write setADRMUX0;
    property ADRMUX1 : TBits_1 read getADRMUX1 write setADRMUX1;
    property ALP : TBits_1 read getALP write setALP;
    property CS1P : TBits_1 read getCS1P write setCS1P;
    property CS2P : TBits_1 read getCS2P write setCS2P;
    property CSF : TBits_2 read getCSF write setCSF;
    property CSF0 : TBits_1 read getCSF0 write setCSF0;
    property CSF1 : TBits_1 read getCSF1 write setCSF1;
    property ON : TBits_1 read getON write setON;
    property PMPEN : TBits_1 read getPMPEN write setPMPEN;
    property PMPTTL : TBits_1 read getPMPTTL write setPMPTTL;
    property PSIDL : TBits_1 read getPSIDL write setPSIDL;
    property PTRDEN : TBits_1 read getPTRDEN write setPTRDEN;
    property PTWREN : TBits_1 read getPTWREN write setPTWREN;
    property RDSP : TBits_1 read getRDSP write setRDSP;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property WRSP : TBits_1 read getWRSP write setWRSP;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMMODE = record
  private
    function  getBUSY : TBits_1; inline;
    function  getINCM : TBits_2; inline;
    function  getINCM0 : TBits_1; inline;
    function  getINCM1 : TBits_1; inline;
    function  getIRQM : TBits_2; inline;
    function  getIRQM0 : TBits_1; inline;
    function  getIRQM1 : TBits_1; inline;
    function  getMODE : TBits_2; inline;
    function  getMODE0 : TBits_1; inline;
    function  getMODE1 : TBits_1; inline;
    function  getMODE16 : TBits_1; inline;
    function  getWAITB : TBits_2; inline;
    function  getWAITB0 : TBits_1; inline;
    function  getWAITB1 : TBits_1; inline;
    function  getWAITE : TBits_2; inline;
    function  getWAITE0 : TBits_1; inline;
    function  getWAITE1 : TBits_1; inline;
    function  getWAITM : TBits_4; inline;
    function  getWAITM0 : TBits_1; inline;
    function  getWAITM1 : TBits_1; inline;
    function  getWAITM2 : TBits_1; inline;
    function  getWAITM3 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBUSY(thebits : TBits_1); inline;
    procedure setINCM(thebits : TBits_2); inline;
    procedure setINCM0(thebits : TBits_1); inline;
    procedure setINCM1(thebits : TBits_1); inline;
    procedure setIRQM(thebits : TBits_2); inline;
    procedure setIRQM0(thebits : TBits_1); inline;
    procedure setIRQM1(thebits : TBits_1); inline;
    procedure setMODE(thebits : TBits_2); inline;
    procedure setMODE0(thebits : TBits_1); inline;
    procedure setMODE1(thebits : TBits_1); inline;
    procedure setMODE16(thebits : TBits_1); inline;
    procedure setWAITB(thebits : TBits_2); inline;
    procedure setWAITB0(thebits : TBits_1); inline;
    procedure setWAITB1(thebits : TBits_1); inline;
    procedure setWAITE(thebits : TBits_2); inline;
    procedure setWAITE0(thebits : TBits_1); inline;
    procedure setWAITE1(thebits : TBits_1); inline;
    procedure setWAITM(thebits : TBits_4); inline;
    procedure setWAITM0(thebits : TBits_1); inline;
    procedure setWAITM1(thebits : TBits_1); inline;
    procedure setWAITM2(thebits : TBits_1); inline;
    procedure setWAITM3(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBUSY; inline;
    procedure clearINCM0; inline;
    procedure clearINCM1; inline;
    procedure clearIRQM0; inline;
    procedure clearIRQM1; inline;
    procedure clearMODE0; inline;
    procedure clearMODE16; inline;
    procedure clearMODE1; inline;
    procedure clearWAITB0; inline;
    procedure clearWAITB1; inline;
    procedure clearWAITE0; inline;
    procedure clearWAITE1; inline;
    procedure clearWAITM0; inline;
    procedure clearWAITM1; inline;
    procedure clearWAITM2; inline;
    procedure clearWAITM3; inline;
    procedure setBUSY; inline;
    procedure setINCM0; inline;
    procedure setINCM1; inline;
    procedure setIRQM0; inline;
    procedure setIRQM1; inline;
    procedure setMODE0; inline;
    procedure setMODE16; inline;
    procedure setMODE1; inline;
    procedure setWAITB0; inline;
    procedure setWAITB1; inline;
    procedure setWAITE0; inline;
    procedure setWAITE1; inline;
    procedure setWAITM0; inline;
    procedure setWAITM1; inline;
    procedure setWAITM2; inline;
    procedure setWAITM3; inline;
    property BUSY : TBits_1 read getBUSY write setBUSY;
    property INCM : TBits_2 read getINCM write setINCM;
    property INCM0 : TBits_1 read getINCM0 write setINCM0;
    property INCM1 : TBits_1 read getINCM1 write setINCM1;
    property IRQM : TBits_2 read getIRQM write setIRQM;
    property IRQM0 : TBits_1 read getIRQM0 write setIRQM0;
    property IRQM1 : TBits_1 read getIRQM1 write setIRQM1;
    property MODE : TBits_2 read getMODE write setMODE;
    property MODE0 : TBits_1 read getMODE0 write setMODE0;
    property MODE1 : TBits_1 read getMODE1 write setMODE1;
    property MODE16 : TBits_1 read getMODE16 write setMODE16;
    property WAITB : TBits_2 read getWAITB write setWAITB;
    property WAITB0 : TBits_1 read getWAITB0 write setWAITB0;
    property WAITB1 : TBits_1 read getWAITB1 write setWAITB1;
    property WAITE : TBits_2 read getWAITE write setWAITE;
    property WAITE0 : TBits_1 read getWAITE0 write setWAITE0;
    property WAITE1 : TBits_1 read getWAITE1 write setWAITE1;
    property WAITM : TBits_4 read getWAITM write setWAITM;
    property WAITM0 : TBits_1 read getWAITM0 write setWAITM0;
    property WAITM1 : TBits_1 read getWAITM1 write setWAITM1;
    property WAITM2 : TBits_1 read getWAITM2 write setWAITM2;
    property WAITM3 : TBits_1 read getWAITM3 write setWAITM3;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMADDR = record
  private
    function  getADDR : TBits_14; inline;
    function  getCS : TBits_2; inline;
    function  getCS1 : TBits_1; inline;
    function  getCS2 : TBits_1; inline;
    function  getPADDR : TBits_14; inline;
    function  getw : TBits_32; inline;
    procedure setADDR(thebits : TBits_14); inline;
    procedure setCS(thebits : TBits_2); inline;
    procedure setCS1(thebits : TBits_1); inline;
    procedure setCS2(thebits : TBits_1); inline;
    procedure setPADDR(thebits : TBits_14); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCS1; inline;
    procedure clearCS2; inline;
    procedure setCS1; inline;
    procedure setCS2; inline;
    property ADDR : TBits_14 read getADDR write setADDR;
    property CS : TBits_2 read getCS write setCS;
    property CS1 : TBits_1 read getCS1 write setCS1;
    property CS2 : TBits_1 read getCS2 write setCS2;
    property PADDR : TBits_14 read getPADDR write setPADDR;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMDOUT = record
  private
    function  getDATAOUT : TBits_32; inline;
    function  getw : TBits_32; inline;
    procedure setDATAOUT(thebits : TBits_32); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DATAOUT : TBits_32 read getDATAOUT write setDATAOUT;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMDIN = record
  private
    function  getDATAIN : TBits_32; inline;
    function  getw : TBits_32; inline;
    procedure setDATAIN(thebits : TBits_32); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DATAIN : TBits_32 read getDATAIN write setDATAIN;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMAEN = record
  private
    function  getPTEN : TBits_16; inline;
    function  getPTEN0 : TBits_1; inline;
    function  getPTEN1 : TBits_1; inline;
    function  getPTEN10 : TBits_1; inline;
    function  getPTEN11 : TBits_1; inline;
    function  getPTEN12 : TBits_1; inline;
    function  getPTEN13 : TBits_1; inline;
    function  getPTEN14 : TBits_1; inline;
    function  getPTEN15 : TBits_1; inline;
    function  getPTEN2 : TBits_1; inline;
    function  getPTEN3 : TBits_1; inline;
    function  getPTEN4 : TBits_1; inline;
    function  getPTEN5 : TBits_1; inline;
    function  getPTEN6 : TBits_1; inline;
    function  getPTEN7 : TBits_1; inline;
    function  getPTEN8 : TBits_1; inline;
    function  getPTEN9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setPTEN(thebits : TBits_16); inline;
    procedure setPTEN0(thebits : TBits_1); inline;
    procedure setPTEN1(thebits : TBits_1); inline;
    procedure setPTEN10(thebits : TBits_1); inline;
    procedure setPTEN11(thebits : TBits_1); inline;
    procedure setPTEN12(thebits : TBits_1); inline;
    procedure setPTEN13(thebits : TBits_1); inline;
    procedure setPTEN14(thebits : TBits_1); inline;
    procedure setPTEN15(thebits : TBits_1); inline;
    procedure setPTEN2(thebits : TBits_1); inline;
    procedure setPTEN3(thebits : TBits_1); inline;
    procedure setPTEN4(thebits : TBits_1); inline;
    procedure setPTEN5(thebits : TBits_1); inline;
    procedure setPTEN6(thebits : TBits_1); inline;
    procedure setPTEN7(thebits : TBits_1); inline;
    procedure setPTEN8(thebits : TBits_1); inline;
    procedure setPTEN9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearPTEN0; inline;
    procedure clearPTEN10; inline;
    procedure clearPTEN11; inline;
    procedure clearPTEN12; inline;
    procedure clearPTEN13; inline;
    procedure clearPTEN14; inline;
    procedure clearPTEN15; inline;
    procedure clearPTEN1; inline;
    procedure clearPTEN2; inline;
    procedure clearPTEN3; inline;
    procedure clearPTEN4; inline;
    procedure clearPTEN5; inline;
    procedure clearPTEN6; inline;
    procedure clearPTEN7; inline;
    procedure clearPTEN8; inline;
    procedure clearPTEN9; inline;
    procedure setPTEN0; inline;
    procedure setPTEN10; inline;
    procedure setPTEN11; inline;
    procedure setPTEN12; inline;
    procedure setPTEN13; inline;
    procedure setPTEN14; inline;
    procedure setPTEN15; inline;
    procedure setPTEN1; inline;
    procedure setPTEN2; inline;
    procedure setPTEN3; inline;
    procedure setPTEN4; inline;
    procedure setPTEN5; inline;
    procedure setPTEN6; inline;
    procedure setPTEN7; inline;
    procedure setPTEN8; inline;
    procedure setPTEN9; inline;
    property PTEN : TBits_16 read getPTEN write setPTEN;
    property PTEN0 : TBits_1 read getPTEN0 write setPTEN0;
    property PTEN1 : TBits_1 read getPTEN1 write setPTEN1;
    property PTEN10 : TBits_1 read getPTEN10 write setPTEN10;
    property PTEN11 : TBits_1 read getPTEN11 write setPTEN11;
    property PTEN12 : TBits_1 read getPTEN12 write setPTEN12;
    property PTEN13 : TBits_1 read getPTEN13 write setPTEN13;
    property PTEN14 : TBits_1 read getPTEN14 write setPTEN14;
    property PTEN15 : TBits_1 read getPTEN15 write setPTEN15;
    property PTEN2 : TBits_1 read getPTEN2 write setPTEN2;
    property PTEN3 : TBits_1 read getPTEN3 write setPTEN3;
    property PTEN4 : TBits_1 read getPTEN4 write setPTEN4;
    property PTEN5 : TBits_1 read getPTEN5 write setPTEN5;
    property PTEN6 : TBits_1 read getPTEN6 write setPTEN6;
    property PTEN7 : TBits_1 read getPTEN7 write setPTEN7;
    property PTEN8 : TBits_1 read getPTEN8 write setPTEN8;
    property PTEN9 : TBits_1 read getPTEN9 write setPTEN9;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMSTAT = record
  private
    function  getIB0F : TBits_1; inline;
    function  getIB1F : TBits_1; inline;
    function  getIB2F : TBits_1; inline;
    function  getIB3F : TBits_1; inline;
    function  getIBF : TBits_1; inline;
    function  getIBOV : TBits_1; inline;
    function  getOB0E : TBits_1; inline;
    function  getOB1E : TBits_1; inline;
    function  getOB2E : TBits_1; inline;
    function  getOB3E : TBits_1; inline;
    function  getOBE : TBits_1; inline;
    function  getOBUF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setIB0F(thebits : TBits_1); inline;
    procedure setIB1F(thebits : TBits_1); inline;
    procedure setIB2F(thebits : TBits_1); inline;
    procedure setIB3F(thebits : TBits_1); inline;
    procedure setIBF(thebits : TBits_1); inline;
    procedure setIBOV(thebits : TBits_1); inline;
    procedure setOB0E(thebits : TBits_1); inline;
    procedure setOB1E(thebits : TBits_1); inline;
    procedure setOB2E(thebits : TBits_1); inline;
    procedure setOB3E(thebits : TBits_1); inline;
    procedure setOBE(thebits : TBits_1); inline;
    procedure setOBUF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearIB0F; inline;
    procedure clearIB1F; inline;
    procedure clearIB2F; inline;
    procedure clearIB3F; inline;
    procedure clearIBF; inline;
    procedure clearIBOV; inline;
    procedure clearOB0E; inline;
    procedure clearOB1E; inline;
    procedure clearOB2E; inline;
    procedure clearOB3E; inline;
    procedure clearOBE; inline;
    procedure clearOBUF; inline;
    procedure setIB0F; inline;
    procedure setIB1F; inline;
    procedure setIB2F; inline;
    procedure setIB3F; inline;
    procedure setIBF; inline;
    procedure setIBOV; inline;
    procedure setOB0E; inline;
    procedure setOB1E; inline;
    procedure setOB2E; inline;
    procedure setOB3E; inline;
    procedure setOBE; inline;
    procedure setOBUF; inline;
    property IB0F : TBits_1 read getIB0F write setIB0F;
    property IB1F : TBits_1 read getIB1F write setIB1F;
    property IB2F : TBits_1 read getIB2F write setIB2F;
    property IB3F : TBits_1 read getIB3F write setIB3F;
    property IBF : TBits_1 read getIBF write setIBF;
    property IBOV : TBits_1 read getIBOV write setIBOV;
    property OB0E : TBits_1 read getOB0E write setOB0E;
    property OB1E : TBits_1 read getOB1E write setOB1E;
    property OB2E : TBits_1 read getOB2E write setOB2E;
    property OB3E : TBits_1 read getOB3E write setOB3E;
    property OBE : TBits_1 read getOBE write setOBE;
    property OBUF : TBits_1 read getOBUF write setOBUF;
    property w : TBits_32 read getw write setw;
  end;
type
  TPMPRegisters = record
    PMCONbits : TPMP_PMCON;
    PMCON : longWord;
    PMCONCLR : longWord;
    PMCONSET : longWord;
    PMCONINV : longWord;
    PMMODEbits : TPMP_PMMODE;
    PMMODE : longWord;
    PMMODECLR : longWord;
    PMMODESET : longWord;
    PMMODEINV : longWord;
    PMADDRbits : TPMP_PMADDR;
    PMADDR : longWord;
    PMADDRCLR : longWord;
    PMADDRSET : longWord;
    PMADDRINV : longWord;
    PMDOUTbits : TPMP_PMDOUT;
    PMDOUT : longWord;
    PMDOUTCLR : longWord;
    PMDOUTSET : longWord;
    PMDOUTINV : longWord;
    PMDINbits : TPMP_PMDIN;
    PMDIN : longWord;
    PMDINCLR : longWord;
    PMDINSET : longWord;
    PMDININV : longWord;
    PMAENbits : TPMP_PMAEN;
    PMAEN : longWord;
    PMAENCLR : longWord;
    PMAENSET : longWord;
    PMAENINV : longWord;
    PMSTATbits : TPMP_PMSTAT;
    PMSTAT : longWord;
    PMSTATCLR : longWord;
    PMSTATSET : longWord;
    PMSTATINV : longWord;
  end;
  TADC10_AD1CON1 = record
  private
    function  getADON : TBits_1; inline;
    function  getADSIDL : TBits_1; inline;
    function  getASAM : TBits_1; inline;
    function  getCLRASAM : TBits_1; inline;
    function  getDONE : TBits_1; inline;
    function  getFORM : TBits_3; inline;
    function  getFORM0 : TBits_1; inline;
    function  getFORM1 : TBits_1; inline;
    function  getFORM2 : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSAMP : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSSRC : TBits_3; inline;
    function  getSSRC0 : TBits_1; inline;
    function  getSSRC1 : TBits_1; inline;
    function  getSSRC2 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setADON(thebits : TBits_1); inline;
    procedure setADSIDL(thebits : TBits_1); inline;
    procedure setASAM(thebits : TBits_1); inline;
    procedure setCLRASAM(thebits : TBits_1); inline;
    procedure setDONE(thebits : TBits_1); inline;
    procedure setFORM(thebits : TBits_3); inline;
    procedure setFORM0(thebits : TBits_1); inline;
    procedure setFORM1(thebits : TBits_1); inline;
    procedure setFORM2(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSAMP(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSSRC(thebits : TBits_3); inline;
    procedure setSSRC0(thebits : TBits_1); inline;
    procedure setSSRC1(thebits : TBits_1); inline;
    procedure setSSRC2(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADON; inline;
    procedure clearADSIDL; inline;
    procedure clearASAM; inline;
    procedure clearCLRASAM; inline;
    procedure clearDONE; inline;
    procedure clearFORM0; inline;
    procedure clearFORM1; inline;
    procedure clearFORM2; inline;
    procedure clearON; inline;
    procedure clearSAMP; inline;
    procedure clearSIDL; inline;
    procedure clearSSRC0; inline;
    procedure clearSSRC1; inline;
    procedure clearSSRC2; inline;
    procedure setADON; inline;
    procedure setADSIDL; inline;
    procedure setASAM; inline;
    procedure setCLRASAM; inline;
    procedure setDONE; inline;
    procedure setFORM0; inline;
    procedure setFORM1; inline;
    procedure setFORM2; inline;
    procedure setON; inline;
    procedure setSAMP; inline;
    procedure setSIDL; inline;
    procedure setSSRC0; inline;
    procedure setSSRC1; inline;
    procedure setSSRC2; inline;
    property ADON : TBits_1 read getADON write setADON;
    property ADSIDL : TBits_1 read getADSIDL write setADSIDL;
    property ASAM : TBits_1 read getASAM write setASAM;
    property CLRASAM : TBits_1 read getCLRASAM write setCLRASAM;
    property DONE : TBits_1 read getDONE write setDONE;
    property FORM : TBits_3 read getFORM write setFORM;
    property FORM0 : TBits_1 read getFORM0 write setFORM0;
    property FORM1 : TBits_1 read getFORM1 write setFORM1;
    property FORM2 : TBits_1 read getFORM2 write setFORM2;
    property ON : TBits_1 read getON write setON;
    property SAMP : TBits_1 read getSAMP write setSAMP;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SSRC : TBits_3 read getSSRC write setSSRC;
    property SSRC0 : TBits_1 read getSSRC0 write setSSRC0;
    property SSRC1 : TBits_1 read getSSRC1 write setSSRC1;
    property SSRC2 : TBits_1 read getSSRC2 write setSSRC2;
    property w : TBits_32 read getw write setw;
  end;
  TADC10_AD1CON2 = record
  private
    function  getALTS : TBits_1; inline;
    function  getBUFM : TBits_1; inline;
    function  getBUFS : TBits_1; inline;
    function  getCSCNA : TBits_1; inline;
    function  getOFFCAL : TBits_1; inline;
    function  getSMPI : TBits_4; inline;
    function  getSMPI0 : TBits_1; inline;
    function  getSMPI1 : TBits_1; inline;
    function  getSMPI2 : TBits_1; inline;
    function  getSMPI3 : TBits_1; inline;
    function  getVCFG : TBits_3; inline;
    function  getVCFG0 : TBits_1; inline;
    function  getVCFG1 : TBits_1; inline;
    function  getVCFG2 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setALTS(thebits : TBits_1); inline;
    procedure setBUFM(thebits : TBits_1); inline;
    procedure setBUFS(thebits : TBits_1); inline;
    procedure setCSCNA(thebits : TBits_1); inline;
    procedure setOFFCAL(thebits : TBits_1); inline;
    procedure setSMPI(thebits : TBits_4); inline;
    procedure setSMPI0(thebits : TBits_1); inline;
    procedure setSMPI1(thebits : TBits_1); inline;
    procedure setSMPI2(thebits : TBits_1); inline;
    procedure setSMPI3(thebits : TBits_1); inline;
    procedure setVCFG(thebits : TBits_3); inline;
    procedure setVCFG0(thebits : TBits_1); inline;
    procedure setVCFG1(thebits : TBits_1); inline;
    procedure setVCFG2(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearALTS; inline;
    procedure clearBUFM; inline;
    procedure clearBUFS; inline;
    procedure clearCSCNA; inline;
    procedure clearOFFCAL; inline;
    procedure clearSMPI0; inline;
    procedure clearSMPI1; inline;
    procedure clearSMPI2; inline;
    procedure clearSMPI3; inline;
    procedure clearVCFG0; inline;
    procedure clearVCFG1; inline;
    procedure clearVCFG2; inline;
    procedure setALTS; inline;
    procedure setBUFM; inline;
    procedure setBUFS; inline;
    procedure setCSCNA; inline;
    procedure setOFFCAL; inline;
    procedure setSMPI0; inline;
    procedure setSMPI1; inline;
    procedure setSMPI2; inline;
    procedure setSMPI3; inline;
    procedure setVCFG0; inline;
    procedure setVCFG1; inline;
    procedure setVCFG2; inline;
    property ALTS : TBits_1 read getALTS write setALTS;
    property BUFM : TBits_1 read getBUFM write setBUFM;
    property BUFS : TBits_1 read getBUFS write setBUFS;
    property CSCNA : TBits_1 read getCSCNA write setCSCNA;
    property OFFCAL : TBits_1 read getOFFCAL write setOFFCAL;
    property SMPI : TBits_4 read getSMPI write setSMPI;
    property SMPI0 : TBits_1 read getSMPI0 write setSMPI0;
    property SMPI1 : TBits_1 read getSMPI1 write setSMPI1;
    property SMPI2 : TBits_1 read getSMPI2 write setSMPI2;
    property SMPI3 : TBits_1 read getSMPI3 write setSMPI3;
    property VCFG : TBits_3 read getVCFG write setVCFG;
    property VCFG0 : TBits_1 read getVCFG0 write setVCFG0;
    property VCFG1 : TBits_1 read getVCFG1 write setVCFG1;
    property VCFG2 : TBits_1 read getVCFG2 write setVCFG2;
    property w : TBits_32 read getw write setw;
  end;
  TADC10_AD1CON3 = record
  private
    function  getADCS : TBits_8; inline;
    function  getADCS0 : TBits_1; inline;
    function  getADCS1 : TBits_1; inline;
    function  getADCS2 : TBits_1; inline;
    function  getADCS3 : TBits_1; inline;
    function  getADCS4 : TBits_1; inline;
    function  getADCS5 : TBits_1; inline;
    function  getADCS6 : TBits_1; inline;
    function  getADCS7 : TBits_1; inline;
    function  getADRC : TBits_1; inline;
    function  getSAMC : TBits_5; inline;
    function  getSAMC0 : TBits_1; inline;
    function  getSAMC1 : TBits_1; inline;
    function  getSAMC2 : TBits_1; inline;
    function  getSAMC3 : TBits_1; inline;
    function  getSAMC4 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setADCS(thebits : TBits_8); inline;
    procedure setADCS0(thebits : TBits_1); inline;
    procedure setADCS1(thebits : TBits_1); inline;
    procedure setADCS2(thebits : TBits_1); inline;
    procedure setADCS3(thebits : TBits_1); inline;
    procedure setADCS4(thebits : TBits_1); inline;
    procedure setADCS5(thebits : TBits_1); inline;
    procedure setADCS6(thebits : TBits_1); inline;
    procedure setADCS7(thebits : TBits_1); inline;
    procedure setADRC(thebits : TBits_1); inline;
    procedure setSAMC(thebits : TBits_5); inline;
    procedure setSAMC0(thebits : TBits_1); inline;
    procedure setSAMC1(thebits : TBits_1); inline;
    procedure setSAMC2(thebits : TBits_1); inline;
    procedure setSAMC3(thebits : TBits_1); inline;
    procedure setSAMC4(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADCS0; inline;
    procedure clearADCS1; inline;
    procedure clearADCS2; inline;
    procedure clearADCS3; inline;
    procedure clearADCS4; inline;
    procedure clearADCS5; inline;
    procedure clearADCS6; inline;
    procedure clearADCS7; inline;
    procedure clearADRC; inline;
    procedure clearSAMC0; inline;
    procedure clearSAMC1; inline;
    procedure clearSAMC2; inline;
    procedure clearSAMC3; inline;
    procedure clearSAMC4; inline;
    procedure setADCS0; inline;
    procedure setADCS1; inline;
    procedure setADCS2; inline;
    procedure setADCS3; inline;
    procedure setADCS4; inline;
    procedure setADCS5; inline;
    procedure setADCS6; inline;
    procedure setADCS7; inline;
    procedure setADRC; inline;
    procedure setSAMC0; inline;
    procedure setSAMC1; inline;
    procedure setSAMC2; inline;
    procedure setSAMC3; inline;
    procedure setSAMC4; inline;
    property ADCS : TBits_8 read getADCS write setADCS;
    property ADCS0 : TBits_1 read getADCS0 write setADCS0;
    property ADCS1 : TBits_1 read getADCS1 write setADCS1;
    property ADCS2 : TBits_1 read getADCS2 write setADCS2;
    property ADCS3 : TBits_1 read getADCS3 write setADCS3;
    property ADCS4 : TBits_1 read getADCS4 write setADCS4;
    property ADCS5 : TBits_1 read getADCS5 write setADCS5;
    property ADCS6 : TBits_1 read getADCS6 write setADCS6;
    property ADCS7 : TBits_1 read getADCS7 write setADCS7;
    property ADRC : TBits_1 read getADRC write setADRC;
    property SAMC : TBits_5 read getSAMC write setSAMC;
    property SAMC0 : TBits_1 read getSAMC0 write setSAMC0;
    property SAMC1 : TBits_1 read getSAMC1 write setSAMC1;
    property SAMC2 : TBits_1 read getSAMC2 write setSAMC2;
    property SAMC3 : TBits_1 read getSAMC3 write setSAMC3;
    property SAMC4 : TBits_1 read getSAMC4 write setSAMC4;
    property w : TBits_32 read getw write setw;
  end;
  TADC10_AD1CHS = record
  private
    function  getCH0NA : TBits_1; inline;
    function  getCH0NB : TBits_1; inline;
    function  getCH0SA : TBits_4; inline;
    function  getCH0SA0 : TBits_1; inline;
    function  getCH0SA1 : TBits_1; inline;
    function  getCH0SA2 : TBits_1; inline;
    function  getCH0SA3 : TBits_1; inline;
    function  getCH0SB : TBits_4; inline;
    function  getCH0SB0 : TBits_1; inline;
    function  getCH0SB1 : TBits_1; inline;
    function  getCH0SB2 : TBits_1; inline;
    function  getCH0SB3 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCH0NA(thebits : TBits_1); inline;
    procedure setCH0NB(thebits : TBits_1); inline;
    procedure setCH0SA(thebits : TBits_4); inline;
    procedure setCH0SA0(thebits : TBits_1); inline;
    procedure setCH0SA1(thebits : TBits_1); inline;
    procedure setCH0SA2(thebits : TBits_1); inline;
    procedure setCH0SA3(thebits : TBits_1); inline;
    procedure setCH0SB(thebits : TBits_4); inline;
    procedure setCH0SB0(thebits : TBits_1); inline;
    procedure setCH0SB1(thebits : TBits_1); inline;
    procedure setCH0SB2(thebits : TBits_1); inline;
    procedure setCH0SB3(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCH0NA; inline;
    procedure clearCH0NB; inline;
    procedure clearCH0SA0; inline;
    procedure clearCH0SA1; inline;
    procedure clearCH0SA2; inline;
    procedure clearCH0SA3; inline;
    procedure clearCH0SB0; inline;
    procedure clearCH0SB1; inline;
    procedure clearCH0SB2; inline;
    procedure clearCH0SB3; inline;
    procedure setCH0NA; inline;
    procedure setCH0NB; inline;
    procedure setCH0SA0; inline;
    procedure setCH0SA1; inline;
    procedure setCH0SA2; inline;
    procedure setCH0SA3; inline;
    procedure setCH0SB0; inline;
    procedure setCH0SB1; inline;
    procedure setCH0SB2; inline;
    procedure setCH0SB3; inline;
    property CH0NA : TBits_1 read getCH0NA write setCH0NA;
    property CH0NB : TBits_1 read getCH0NB write setCH0NB;
    property CH0SA : TBits_4 read getCH0SA write setCH0SA;
    property CH0SA0 : TBits_1 read getCH0SA0 write setCH0SA0;
    property CH0SA1 : TBits_1 read getCH0SA1 write setCH0SA1;
    property CH0SA2 : TBits_1 read getCH0SA2 write setCH0SA2;
    property CH0SA3 : TBits_1 read getCH0SA3 write setCH0SA3;
    property CH0SB : TBits_4 read getCH0SB write setCH0SB;
    property CH0SB0 : TBits_1 read getCH0SB0 write setCH0SB0;
    property CH0SB1 : TBits_1 read getCH0SB1 write setCH0SB1;
    property CH0SB2 : TBits_1 read getCH0SB2 write setCH0SB2;
    property CH0SB3 : TBits_1 read getCH0SB3 write setCH0SB3;
    property w : TBits_32 read getw write setw;
  end;
  TADC10_AD1CSSL = record
  private
    function  getCSSL : TBits_16; inline;
    function  getCSSL0 : TBits_1; inline;
    function  getCSSL1 : TBits_1; inline;
    function  getCSSL10 : TBits_1; inline;
    function  getCSSL11 : TBits_1; inline;
    function  getCSSL12 : TBits_1; inline;
    function  getCSSL13 : TBits_1; inline;
    function  getCSSL14 : TBits_1; inline;
    function  getCSSL15 : TBits_1; inline;
    function  getCSSL2 : TBits_1; inline;
    function  getCSSL3 : TBits_1; inline;
    function  getCSSL4 : TBits_1; inline;
    function  getCSSL5 : TBits_1; inline;
    function  getCSSL6 : TBits_1; inline;
    function  getCSSL7 : TBits_1; inline;
    function  getCSSL8 : TBits_1; inline;
    function  getCSSL9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCSSL(thebits : TBits_16); inline;
    procedure setCSSL0(thebits : TBits_1); inline;
    procedure setCSSL1(thebits : TBits_1); inline;
    procedure setCSSL10(thebits : TBits_1); inline;
    procedure setCSSL11(thebits : TBits_1); inline;
    procedure setCSSL12(thebits : TBits_1); inline;
    procedure setCSSL13(thebits : TBits_1); inline;
    procedure setCSSL14(thebits : TBits_1); inline;
    procedure setCSSL15(thebits : TBits_1); inline;
    procedure setCSSL2(thebits : TBits_1); inline;
    procedure setCSSL3(thebits : TBits_1); inline;
    procedure setCSSL4(thebits : TBits_1); inline;
    procedure setCSSL5(thebits : TBits_1); inline;
    procedure setCSSL6(thebits : TBits_1); inline;
    procedure setCSSL7(thebits : TBits_1); inline;
    procedure setCSSL8(thebits : TBits_1); inline;
    procedure setCSSL9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCSSL0; inline;
    procedure clearCSSL10; inline;
    procedure clearCSSL11; inline;
    procedure clearCSSL12; inline;
    procedure clearCSSL13; inline;
    procedure clearCSSL14; inline;
    procedure clearCSSL15; inline;
    procedure clearCSSL1; inline;
    procedure clearCSSL2; inline;
    procedure clearCSSL3; inline;
    procedure clearCSSL4; inline;
    procedure clearCSSL5; inline;
    procedure clearCSSL6; inline;
    procedure clearCSSL7; inline;
    procedure clearCSSL8; inline;
    procedure clearCSSL9; inline;
    procedure setCSSL0; inline;
    procedure setCSSL10; inline;
    procedure setCSSL11; inline;
    procedure setCSSL12; inline;
    procedure setCSSL13; inline;
    procedure setCSSL14; inline;
    procedure setCSSL15; inline;
    procedure setCSSL1; inline;
    procedure setCSSL2; inline;
    procedure setCSSL3; inline;
    procedure setCSSL4; inline;
    procedure setCSSL5; inline;
    procedure setCSSL6; inline;
    procedure setCSSL7; inline;
    procedure setCSSL8; inline;
    procedure setCSSL9; inline;
    property CSSL : TBits_16 read getCSSL write setCSSL;
    property CSSL0 : TBits_1 read getCSSL0 write setCSSL0;
    property CSSL1 : TBits_1 read getCSSL1 write setCSSL1;
    property CSSL10 : TBits_1 read getCSSL10 write setCSSL10;
    property CSSL11 : TBits_1 read getCSSL11 write setCSSL11;
    property CSSL12 : TBits_1 read getCSSL12 write setCSSL12;
    property CSSL13 : TBits_1 read getCSSL13 write setCSSL13;
    property CSSL14 : TBits_1 read getCSSL14 write setCSSL14;
    property CSSL15 : TBits_1 read getCSSL15 write setCSSL15;
    property CSSL2 : TBits_1 read getCSSL2 write setCSSL2;
    property CSSL3 : TBits_1 read getCSSL3 write setCSSL3;
    property CSSL4 : TBits_1 read getCSSL4 write setCSSL4;
    property CSSL5 : TBits_1 read getCSSL5 write setCSSL5;
    property CSSL6 : TBits_1 read getCSSL6 write setCSSL6;
    property CSSL7 : TBits_1 read getCSSL7 write setCSSL7;
    property CSSL8 : TBits_1 read getCSSL8 write setCSSL8;
    property CSSL9 : TBits_1 read getCSSL9 write setCSSL9;
    property w : TBits_32 read getw write setw;
  end;
  TADC10_AD1PCFG = record
  private
    function  getPCFG : TBits_16; inline;
    function  getPCFG0 : TBits_1; inline;
    function  getPCFG1 : TBits_1; inline;
    function  getPCFG10 : TBits_1; inline;
    function  getPCFG11 : TBits_1; inline;
    function  getPCFG12 : TBits_1; inline;
    function  getPCFG13 : TBits_1; inline;
    function  getPCFG14 : TBits_1; inline;
    function  getPCFG15 : TBits_1; inline;
    function  getPCFG2 : TBits_1; inline;
    function  getPCFG3 : TBits_1; inline;
    function  getPCFG4 : TBits_1; inline;
    function  getPCFG5 : TBits_1; inline;
    function  getPCFG6 : TBits_1; inline;
    function  getPCFG7 : TBits_1; inline;
    function  getPCFG8 : TBits_1; inline;
    function  getPCFG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setPCFG(thebits : TBits_16); inline;
    procedure setPCFG0(thebits : TBits_1); inline;
    procedure setPCFG1(thebits : TBits_1); inline;
    procedure setPCFG10(thebits : TBits_1); inline;
    procedure setPCFG11(thebits : TBits_1); inline;
    procedure setPCFG12(thebits : TBits_1); inline;
    procedure setPCFG13(thebits : TBits_1); inline;
    procedure setPCFG14(thebits : TBits_1); inline;
    procedure setPCFG15(thebits : TBits_1); inline;
    procedure setPCFG2(thebits : TBits_1); inline;
    procedure setPCFG3(thebits : TBits_1); inline;
    procedure setPCFG4(thebits : TBits_1); inline;
    procedure setPCFG5(thebits : TBits_1); inline;
    procedure setPCFG6(thebits : TBits_1); inline;
    procedure setPCFG7(thebits : TBits_1); inline;
    procedure setPCFG8(thebits : TBits_1); inline;
    procedure setPCFG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearPCFG0; inline;
    procedure clearPCFG10; inline;
    procedure clearPCFG11; inline;
    procedure clearPCFG12; inline;
    procedure clearPCFG13; inline;
    procedure clearPCFG14; inline;
    procedure clearPCFG15; inline;
    procedure clearPCFG1; inline;
    procedure clearPCFG2; inline;
    procedure clearPCFG3; inline;
    procedure clearPCFG4; inline;
    procedure clearPCFG5; inline;
    procedure clearPCFG6; inline;
    procedure clearPCFG7; inline;
    procedure clearPCFG8; inline;
    procedure clearPCFG9; inline;
    procedure setPCFG0; inline;
    procedure setPCFG10; inline;
    procedure setPCFG11; inline;
    procedure setPCFG12; inline;
    procedure setPCFG13; inline;
    procedure setPCFG14; inline;
    procedure setPCFG15; inline;
    procedure setPCFG1; inline;
    procedure setPCFG2; inline;
    procedure setPCFG3; inline;
    procedure setPCFG4; inline;
    procedure setPCFG5; inline;
    procedure setPCFG6; inline;
    procedure setPCFG7; inline;
    procedure setPCFG8; inline;
    procedure setPCFG9; inline;
    property PCFG : TBits_16 read getPCFG write setPCFG;
    property PCFG0 : TBits_1 read getPCFG0 write setPCFG0;
    property PCFG1 : TBits_1 read getPCFG1 write setPCFG1;
    property PCFG10 : TBits_1 read getPCFG10 write setPCFG10;
    property PCFG11 : TBits_1 read getPCFG11 write setPCFG11;
    property PCFG12 : TBits_1 read getPCFG12 write setPCFG12;
    property PCFG13 : TBits_1 read getPCFG13 write setPCFG13;
    property PCFG14 : TBits_1 read getPCFG14 write setPCFG14;
    property PCFG15 : TBits_1 read getPCFG15 write setPCFG15;
    property PCFG2 : TBits_1 read getPCFG2 write setPCFG2;
    property PCFG3 : TBits_1 read getPCFG3 write setPCFG3;
    property PCFG4 : TBits_1 read getPCFG4 write setPCFG4;
    property PCFG5 : TBits_1 read getPCFG5 write setPCFG5;
    property PCFG6 : TBits_1 read getPCFG6 write setPCFG6;
    property PCFG7 : TBits_1 read getPCFG7 write setPCFG7;
    property PCFG8 : TBits_1 read getPCFG8 write setPCFG8;
    property PCFG9 : TBits_1 read getPCFG9 write setPCFG9;
    property w : TBits_32 read getw write setw;
  end;
type
  TADC10Registers = record
    AD1CON1bits : TADC10_AD1CON1;
    AD1CON1 : longWord;
    AD1CON1CLR : longWord;
    AD1CON1SET : longWord;
    AD1CON1INV : longWord;
    AD1CON2bits : TADC10_AD1CON2;
    AD1CON2 : longWord;
    AD1CON2CLR : longWord;
    AD1CON2SET : longWord;
    AD1CON2INV : longWord;
    AD1CON3bits : TADC10_AD1CON3;
    AD1CON3 : longWord;
    AD1CON3CLR : longWord;
    AD1CON3SET : longWord;
    AD1CON3INV : longWord;
    AD1CHSbits : TADC10_AD1CHS;
    AD1CHS : longWord;
    AD1CHSCLR : longWord;
    AD1CHSSET : longWord;
    AD1CHSINV : longWord;
    AD1CSSLbits : TADC10_AD1CSSL;
    AD1CSSL : longWord;
    AD1CSSLCLR : longWord;
    AD1CSSLSET : longWord;
    AD1CSSLINV : longWord;
    AD1PCFGbits : TADC10_AD1PCFG;
    AD1PCFG : longWord;
    AD1PCFGCLR : longWord;
    AD1PCFGSET : longWord;
    AD1PCFGINV : longWord;
    ADC1BUF0 : longWord;
    ADC1BUF1 : longWord;
    ADC1BUF2 : longWord;
    ADC1BUF3 : longWord;
    ADC1BUF4 : longWord;
    ADC1BUF5 : longWord;
    ADC1BUF6 : longWord;
    ADC1BUF7 : longWord;
    ADC1BUF8 : longWord;
    ADC1BUF9 : longWord;
    ADC1BUFA : longWord;
    ADC1BUFB : longWord;
    ADC1BUFC : longWord;
    ADC1BUFD : longWord;
    ADC1BUFE : longWord;
    ADC1BUFF : longWord;
  end;
  TCVR_CVRCON = record
  private
    function  getBGSEL : TBits_2; inline;
    function  getBGSEL0 : TBits_1; inline;
    function  getBGSEL1 : TBits_1; inline;
    function  getCVR : TBits_4; inline;
    function  getCVR0 : TBits_1; inline;
    function  getCVR1 : TBits_1; inline;
    function  getCVR2 : TBits_1; inline;
    function  getCVR3 : TBits_1; inline;
    function  getCVROE : TBits_1; inline;
    function  getCVRR : TBits_1; inline;
    function  getCVRSS : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getVREFSEL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBGSEL(thebits : TBits_2); inline;
    procedure setBGSEL0(thebits : TBits_1); inline;
    procedure setBGSEL1(thebits : TBits_1); inline;
    procedure setCVR(thebits : TBits_4); inline;
    procedure setCVR0(thebits : TBits_1); inline;
    procedure setCVR1(thebits : TBits_1); inline;
    procedure setCVR2(thebits : TBits_1); inline;
    procedure setCVR3(thebits : TBits_1); inline;
    procedure setCVROE(thebits : TBits_1); inline;
    procedure setCVRR(thebits : TBits_1); inline;
    procedure setCVRSS(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setVREFSEL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBGSEL0; inline;
    procedure clearBGSEL1; inline;
    procedure clearCVR0; inline;
    procedure clearCVR1; inline;
    procedure clearCVR2; inline;
    procedure clearCVR3; inline;
    procedure clearCVROE; inline;
    procedure clearCVRR; inline;
    procedure clearCVRSS; inline;
    procedure clearON; inline;
    procedure clearVREFSEL; inline;
    procedure setBGSEL0; inline;
    procedure setBGSEL1; inline;
    procedure setCVR0; inline;
    procedure setCVR1; inline;
    procedure setCVR2; inline;
    procedure setCVR3; inline;
    procedure setCVROE; inline;
    procedure setCVRR; inline;
    procedure setCVRSS; inline;
    procedure setON; inline;
    procedure setVREFSEL; inline;
    property BGSEL : TBits_2 read getBGSEL write setBGSEL;
    property BGSEL0 : TBits_1 read getBGSEL0 write setBGSEL0;
    property BGSEL1 : TBits_1 read getBGSEL1 write setBGSEL1;
    property CVR : TBits_4 read getCVR write setCVR;
    property CVR0 : TBits_1 read getCVR0 write setCVR0;
    property CVR1 : TBits_1 read getCVR1 write setCVR1;
    property CVR2 : TBits_1 read getCVR2 write setCVR2;
    property CVR3 : TBits_1 read getCVR3 write setCVR3;
    property CVROE : TBits_1 read getCVROE write setCVROE;
    property CVRR : TBits_1 read getCVRR write setCVRR;
    property CVRSS : TBits_1 read getCVRSS write setCVRSS;
    property ON : TBits_1 read getON write setON;
    property VREFSEL : TBits_1 read getVREFSEL write setVREFSEL;
    property w : TBits_32 read getw write setw;
  end;
type
  TCVRRegisters = record
    CVRCONbits : TCVR_CVRCON;
    CVRCON : longWord;
    CVRCONCLR : longWord;
    CVRCONSET : longWord;
    CVRCONINV : longWord;
  end;
  TCMP_CM1CON = record
  private
    function  getCCH : TBits_2; inline;
    function  getCCH0 : TBits_1; inline;
    function  getCCH1 : TBits_1; inline;
    function  getCOE : TBits_1; inline;
    function  getCOUT : TBits_1; inline;
    function  getCPOL : TBits_1; inline;
    function  getCREF : TBits_1; inline;
    function  getEVPOL : TBits_2; inline;
    function  getEVPOL0 : TBits_1; inline;
    function  getEVPOL1 : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCCH(thebits : TBits_2); inline;
    procedure setCCH0(thebits : TBits_1); inline;
    procedure setCCH1(thebits : TBits_1); inline;
    procedure setCOE(thebits : TBits_1); inline;
    procedure setCOUT(thebits : TBits_1); inline;
    procedure setCPOL(thebits : TBits_1); inline;
    procedure setCREF(thebits : TBits_1); inline;
    procedure setEVPOL(thebits : TBits_2); inline;
    procedure setEVPOL0(thebits : TBits_1); inline;
    procedure setEVPOL1(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCCH0; inline;
    procedure clearCCH1; inline;
    procedure clearCOE; inline;
    procedure clearCOUT; inline;
    procedure clearCPOL; inline;
    procedure clearCREF; inline;
    procedure clearEVPOL0; inline;
    procedure clearEVPOL1; inline;
    procedure clearON; inline;
    procedure setCCH0; inline;
    procedure setCCH1; inline;
    procedure setCOE; inline;
    procedure setCOUT; inline;
    procedure setCPOL; inline;
    procedure setCREF; inline;
    procedure setEVPOL0; inline;
    procedure setEVPOL1; inline;
    procedure setON; inline;
    property CCH : TBits_2 read getCCH write setCCH;
    property CCH0 : TBits_1 read getCCH0 write setCCH0;
    property CCH1 : TBits_1 read getCCH1 write setCCH1;
    property COE : TBits_1 read getCOE write setCOE;
    property COUT : TBits_1 read getCOUT write setCOUT;
    property CPOL : TBits_1 read getCPOL write setCPOL;
    property CREF : TBits_1 read getCREF write setCREF;
    property EVPOL : TBits_2 read getEVPOL write setEVPOL;
    property EVPOL0 : TBits_1 read getEVPOL0 write setEVPOL0;
    property EVPOL1 : TBits_1 read getEVPOL1 write setEVPOL1;
    property ON : TBits_1 read getON write setON;
    property w : TBits_32 read getw write setw;
  end;
  TCMP_CM2CON = record
  private
    function  getCCH : TBits_2; inline;
    function  getCCH0 : TBits_1; inline;
    function  getCCH1 : TBits_1; inline;
    function  getCOE : TBits_1; inline;
    function  getCOUT : TBits_1; inline;
    function  getCPOL : TBits_1; inline;
    function  getCREF : TBits_1; inline;
    function  getEVPOL : TBits_2; inline;
    function  getEVPOL0 : TBits_1; inline;
    function  getEVPOL1 : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCCH(thebits : TBits_2); inline;
    procedure setCCH0(thebits : TBits_1); inline;
    procedure setCCH1(thebits : TBits_1); inline;
    procedure setCOE(thebits : TBits_1); inline;
    procedure setCOUT(thebits : TBits_1); inline;
    procedure setCPOL(thebits : TBits_1); inline;
    procedure setCREF(thebits : TBits_1); inline;
    procedure setEVPOL(thebits : TBits_2); inline;
    procedure setEVPOL0(thebits : TBits_1); inline;
    procedure setEVPOL1(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCCH0; inline;
    procedure clearCCH1; inline;
    procedure clearCOE; inline;
    procedure clearCOUT; inline;
    procedure clearCPOL; inline;
    procedure clearCREF; inline;
    procedure clearEVPOL0; inline;
    procedure clearEVPOL1; inline;
    procedure clearON; inline;
    procedure setCCH0; inline;
    procedure setCCH1; inline;
    procedure setCOE; inline;
    procedure setCOUT; inline;
    procedure setCPOL; inline;
    procedure setCREF; inline;
    procedure setEVPOL0; inline;
    procedure setEVPOL1; inline;
    procedure setON; inline;
    property CCH : TBits_2 read getCCH write setCCH;
    property CCH0 : TBits_1 read getCCH0 write setCCH0;
    property CCH1 : TBits_1 read getCCH1 write setCCH1;
    property COE : TBits_1 read getCOE write setCOE;
    property COUT : TBits_1 read getCOUT write setCOUT;
    property CPOL : TBits_1 read getCPOL write setCPOL;
    property CREF : TBits_1 read getCREF write setCREF;
    property EVPOL : TBits_2 read getEVPOL write setEVPOL;
    property EVPOL0 : TBits_1 read getEVPOL0 write setEVPOL0;
    property EVPOL1 : TBits_1 read getEVPOL1 write setEVPOL1;
    property ON : TBits_1 read getON write setON;
    property w : TBits_32 read getw write setw;
  end;
  TCMP_CMSTAT = record
  private
    function  getC1OUT : TBits_1; inline;
    function  getC2OUT : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC1OUT(thebits : TBits_1); inline;
    procedure setC2OUT(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC1OUT; inline;
    procedure clearC2OUT; inline;
    procedure clearSIDL; inline;
    procedure setC1OUT; inline;
    procedure setC2OUT; inline;
    procedure setSIDL; inline;
    property C1OUT : TBits_1 read getC1OUT write setC1OUT;
    property C2OUT : TBits_1 read getC2OUT write setC2OUT;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TCMPRegisters = record
    CM1CONbits : TCMP_CM1CON;
    CM1CON : longWord;
    CM1CONCLR : longWord;
    CM1CONSET : longWord;
    CM1CONINV : longWord;
    CM2CONbits : TCMP_CM2CON;
    CM2CON : longWord;
    CM2CONCLR : longWord;
    CM2CONSET : longWord;
    CM2CONINV : longWord;
    CMSTATbits : TCMP_CMSTAT;
    CMSTAT : longWord;
    CMSTATCLR : longWord;
    CMSTATSET : longWord;
    CMSTATINV : longWord;
  end;
  TOSC_OSCCON = record
  private
    function  getCF : TBits_1; inline;
    function  getCLKLOCK : TBits_1; inline;
    function  getCOSC : TBits_3; inline;
    function  getCOSC0 : TBits_1; inline;
    function  getCOSC1 : TBits_1; inline;
    function  getCOSC2 : TBits_1; inline;
    function  getFRCDIV : TBits_3; inline;
    function  getFRCDIV0 : TBits_1; inline;
    function  getFRCDIV1 : TBits_1; inline;
    function  getFRCDIV2 : TBits_1; inline;
    function  getNOSC : TBits_3; inline;
    function  getNOSC0 : TBits_1; inline;
    function  getNOSC1 : TBits_1; inline;
    function  getNOSC2 : TBits_1; inline;
    function  getOSWEN : TBits_1; inline;
    function  getPBDIV : TBits_2; inline;
    function  getPBDIV0 : TBits_1; inline;
    function  getPBDIV1 : TBits_1; inline;
    function  getPLLMULT : TBits_3; inline;
    function  getPLLMULT0 : TBits_1; inline;
    function  getPLLMULT1 : TBits_1; inline;
    function  getPLLMULT2 : TBits_1; inline;
    function  getPLLODIV : TBits_3; inline;
    function  getPLLODIV0 : TBits_1; inline;
    function  getPLLODIV1 : TBits_1; inline;
    function  getPLLODIV2 : TBits_1; inline;
    function  getSLOCK : TBits_1; inline;
    function  getSLPEN : TBits_1; inline;
    function  getSOSCEN : TBits_1; inline;
    function  getSOSCRDY : TBits_1; inline;
    function  getUFRCEN : TBits_1; inline;
    function  getULOCK : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCF(thebits : TBits_1); inline;
    procedure setCLKLOCK(thebits : TBits_1); inline;
    procedure setCOSC(thebits : TBits_3); inline;
    procedure setCOSC0(thebits : TBits_1); inline;
    procedure setCOSC1(thebits : TBits_1); inline;
    procedure setCOSC2(thebits : TBits_1); inline;
    procedure setFRCDIV(thebits : TBits_3); inline;
    procedure setFRCDIV0(thebits : TBits_1); inline;
    procedure setFRCDIV1(thebits : TBits_1); inline;
    procedure setFRCDIV2(thebits : TBits_1); inline;
    procedure setNOSC(thebits : TBits_3); inline;
    procedure setNOSC0(thebits : TBits_1); inline;
    procedure setNOSC1(thebits : TBits_1); inline;
    procedure setNOSC2(thebits : TBits_1); inline;
    procedure setOSWEN(thebits : TBits_1); inline;
    procedure setPBDIV(thebits : TBits_2); inline;
    procedure setPBDIV0(thebits : TBits_1); inline;
    procedure setPBDIV1(thebits : TBits_1); inline;
    procedure setPLLMULT(thebits : TBits_3); inline;
    procedure setPLLMULT0(thebits : TBits_1); inline;
    procedure setPLLMULT1(thebits : TBits_1); inline;
    procedure setPLLMULT2(thebits : TBits_1); inline;
    procedure setPLLODIV(thebits : TBits_3); inline;
    procedure setPLLODIV0(thebits : TBits_1); inline;
    procedure setPLLODIV1(thebits : TBits_1); inline;
    procedure setPLLODIV2(thebits : TBits_1); inline;
    procedure setSLOCK(thebits : TBits_1); inline;
    procedure setSLPEN(thebits : TBits_1); inline;
    procedure setSOSCEN(thebits : TBits_1); inline;
    procedure setSOSCRDY(thebits : TBits_1); inline;
    procedure setUFRCEN(thebits : TBits_1); inline;
    procedure setULOCK(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCF; inline;
    procedure clearCLKLOCK; inline;
    procedure clearCOSC0; inline;
    procedure clearCOSC1; inline;
    procedure clearCOSC2; inline;
    procedure clearFRCDIV0; inline;
    procedure clearFRCDIV1; inline;
    procedure clearFRCDIV2; inline;
    procedure clearNOSC0; inline;
    procedure clearNOSC1; inline;
    procedure clearNOSC2; inline;
    procedure clearOSWEN; inline;
    procedure clearPBDIV0; inline;
    procedure clearPBDIV1; inline;
    procedure clearPLLMULT0; inline;
    procedure clearPLLMULT1; inline;
    procedure clearPLLMULT2; inline;
    procedure clearPLLODIV0; inline;
    procedure clearPLLODIV1; inline;
    procedure clearPLLODIV2; inline;
    procedure clearSLOCK; inline;
    procedure clearSLPEN; inline;
    procedure clearSOSCEN; inline;
    procedure clearSOSCRDY; inline;
    procedure clearUFRCEN; inline;
    procedure clearULOCK; inline;
    procedure setCF; inline;
    procedure setCLKLOCK; inline;
    procedure setCOSC0; inline;
    procedure setCOSC1; inline;
    procedure setCOSC2; inline;
    procedure setFRCDIV0; inline;
    procedure setFRCDIV1; inline;
    procedure setFRCDIV2; inline;
    procedure setNOSC0; inline;
    procedure setNOSC1; inline;
    procedure setNOSC2; inline;
    procedure setOSWEN; inline;
    procedure setPBDIV0; inline;
    procedure setPBDIV1; inline;
    procedure setPLLMULT0; inline;
    procedure setPLLMULT1; inline;
    procedure setPLLMULT2; inline;
    procedure setPLLODIV0; inline;
    procedure setPLLODIV1; inline;
    procedure setPLLODIV2; inline;
    procedure setSLOCK; inline;
    procedure setSLPEN; inline;
    procedure setSOSCEN; inline;
    procedure setSOSCRDY; inline;
    procedure setUFRCEN; inline;
    procedure setULOCK; inline;
    property CF : TBits_1 read getCF write setCF;
    property CLKLOCK : TBits_1 read getCLKLOCK write setCLKLOCK;
    property COSC : TBits_3 read getCOSC write setCOSC;
    property COSC0 : TBits_1 read getCOSC0 write setCOSC0;
    property COSC1 : TBits_1 read getCOSC1 write setCOSC1;
    property COSC2 : TBits_1 read getCOSC2 write setCOSC2;
    property FRCDIV : TBits_3 read getFRCDIV write setFRCDIV;
    property FRCDIV0 : TBits_1 read getFRCDIV0 write setFRCDIV0;
    property FRCDIV1 : TBits_1 read getFRCDIV1 write setFRCDIV1;
    property FRCDIV2 : TBits_1 read getFRCDIV2 write setFRCDIV2;
    property NOSC : TBits_3 read getNOSC write setNOSC;
    property NOSC0 : TBits_1 read getNOSC0 write setNOSC0;
    property NOSC1 : TBits_1 read getNOSC1 write setNOSC1;
    property NOSC2 : TBits_1 read getNOSC2 write setNOSC2;
    property OSWEN : TBits_1 read getOSWEN write setOSWEN;
    property PBDIV : TBits_2 read getPBDIV write setPBDIV;
    property PBDIV0 : TBits_1 read getPBDIV0 write setPBDIV0;
    property PBDIV1 : TBits_1 read getPBDIV1 write setPBDIV1;
    property PLLMULT : TBits_3 read getPLLMULT write setPLLMULT;
    property PLLMULT0 : TBits_1 read getPLLMULT0 write setPLLMULT0;
    property PLLMULT1 : TBits_1 read getPLLMULT1 write setPLLMULT1;
    property PLLMULT2 : TBits_1 read getPLLMULT2 write setPLLMULT2;
    property PLLODIV : TBits_3 read getPLLODIV write setPLLODIV;
    property PLLODIV0 : TBits_1 read getPLLODIV0 write setPLLODIV0;
    property PLLODIV1 : TBits_1 read getPLLODIV1 write setPLLODIV1;
    property PLLODIV2 : TBits_1 read getPLLODIV2 write setPLLODIV2;
    property SLOCK : TBits_1 read getSLOCK write setSLOCK;
    property SLPEN : TBits_1 read getSLPEN write setSLPEN;
    property SOSCEN : TBits_1 read getSOSCEN write setSOSCEN;
    property SOSCRDY : TBits_1 read getSOSCRDY write setSOSCRDY;
    property UFRCEN : TBits_1 read getUFRCEN write setUFRCEN;
    property ULOCK : TBits_1 read getULOCK write setULOCK;
    property w : TBits_32 read getw write setw;
  end;
  TOSC_OSCTUN = record
  private
    function  getTUN : TBits_6; inline;
    function  getTUN0 : TBits_1; inline;
    function  getTUN1 : TBits_1; inline;
    function  getTUN2 : TBits_1; inline;
    function  getTUN3 : TBits_1; inline;
    function  getTUN4 : TBits_1; inline;
    function  getTUN5 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTUN(thebits : TBits_6); inline;
    procedure setTUN0(thebits : TBits_1); inline;
    procedure setTUN1(thebits : TBits_1); inline;
    procedure setTUN2(thebits : TBits_1); inline;
    procedure setTUN3(thebits : TBits_1); inline;
    procedure setTUN4(thebits : TBits_1); inline;
    procedure setTUN5(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTUN0; inline;
    procedure clearTUN1; inline;
    procedure clearTUN2; inline;
    procedure clearTUN3; inline;
    procedure clearTUN4; inline;
    procedure clearTUN5; inline;
    procedure setTUN0; inline;
    procedure setTUN1; inline;
    procedure setTUN2; inline;
    procedure setTUN3; inline;
    procedure setTUN4; inline;
    procedure setTUN5; inline;
    property TUN : TBits_6 read getTUN write setTUN;
    property TUN0 : TBits_1 read getTUN0 write setTUN0;
    property TUN1 : TBits_1 read getTUN1 write setTUN1;
    property TUN2 : TBits_1 read getTUN2 write setTUN2;
    property TUN3 : TBits_1 read getTUN3 write setTUN3;
    property TUN4 : TBits_1 read getTUN4 write setTUN4;
    property TUN5 : TBits_1 read getTUN5 write setTUN5;
    property w : TBits_32 read getw write setw;
  end;
type
  TOSCRegisters = record
    OSCCONbits : TOSC_OSCCON;
    OSCCON : longWord;
    OSCCONCLR : longWord;
    OSCCONSET : longWord;
    OSCCONINV : longWord;
    OSCTUNbits : TOSC_OSCTUN;
    OSCTUN : longWord;
    OSCTUNCLR : longWord;
    OSCTUNSET : longWord;
    OSCTUNINV : longWord;
  end;
type
  TCFGRegisters = record
    DDPCON : longWord;
    DEVID : longWord;
    SYSKEY : longWord;
    SYSKEYCLR : longWord;
    SYSKEYSET : longWord;
    SYSKEYINV : longWord;
  end;
  TNVM_NVMCON = record
  private
    function  getLVDERR : TBits_1; inline;
    function  getLVDSTAT : TBits_1; inline;
    function  getNVMOP : TBits_4; inline;
    function  getNVMOP0 : TBits_1; inline;
    function  getNVMOP1 : TBits_1; inline;
    function  getNVMOP2 : TBits_1; inline;
    function  getNVMOP3 : TBits_1; inline;
    function  getPROGOP : TBits_4; inline;
    function  getPROGOP0 : TBits_1; inline;
    function  getPROGOP1 : TBits_1; inline;
    function  getPROGOP2 : TBits_1; inline;
    function  getPROGOP3 : TBits_1; inline;
    function  getWR : TBits_1; inline;
    function  getWREN : TBits_1; inline;
    function  getWRERR : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLVDERR(thebits : TBits_1); inline;
    procedure setLVDSTAT(thebits : TBits_1); inline;
    procedure setNVMOP(thebits : TBits_4); inline;
    procedure setNVMOP0(thebits : TBits_1); inline;
    procedure setNVMOP1(thebits : TBits_1); inline;
    procedure setNVMOP2(thebits : TBits_1); inline;
    procedure setNVMOP3(thebits : TBits_1); inline;
    procedure setPROGOP(thebits : TBits_4); inline;
    procedure setPROGOP0(thebits : TBits_1); inline;
    procedure setPROGOP1(thebits : TBits_1); inline;
    procedure setPROGOP2(thebits : TBits_1); inline;
    procedure setPROGOP3(thebits : TBits_1); inline;
    procedure setWR(thebits : TBits_1); inline;
    procedure setWREN(thebits : TBits_1); inline;
    procedure setWRERR(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLVDERR; inline;
    procedure clearLVDSTAT; inline;
    procedure clearNVMOP0; inline;
    procedure clearNVMOP1; inline;
    procedure clearNVMOP2; inline;
    procedure clearNVMOP3; inline;
    procedure clearPROGOP0; inline;
    procedure clearPROGOP1; inline;
    procedure clearPROGOP2; inline;
    procedure clearPROGOP3; inline;
    procedure clearWR; inline;
    procedure clearWREN; inline;
    procedure clearWRERR; inline;
    procedure setLVDERR; inline;
    procedure setLVDSTAT; inline;
    procedure setNVMOP0; inline;
    procedure setNVMOP1; inline;
    procedure setNVMOP2; inline;
    procedure setNVMOP3; inline;
    procedure setPROGOP0; inline;
    procedure setPROGOP1; inline;
    procedure setPROGOP2; inline;
    procedure setPROGOP3; inline;
    procedure setWR; inline;
    procedure setWREN; inline;
    procedure setWRERR; inline;
    property LVDERR : TBits_1 read getLVDERR write setLVDERR;
    property LVDSTAT : TBits_1 read getLVDSTAT write setLVDSTAT;
    property NVMOP : TBits_4 read getNVMOP write setNVMOP;
    property NVMOP0 : TBits_1 read getNVMOP0 write setNVMOP0;
    property NVMOP1 : TBits_1 read getNVMOP1 write setNVMOP1;
    property NVMOP2 : TBits_1 read getNVMOP2 write setNVMOP2;
    property NVMOP3 : TBits_1 read getNVMOP3 write setNVMOP3;
    property PROGOP : TBits_4 read getPROGOP write setPROGOP;
    property PROGOP0 : TBits_1 read getPROGOP0 write setPROGOP0;
    property PROGOP1 : TBits_1 read getPROGOP1 write setPROGOP1;
    property PROGOP2 : TBits_1 read getPROGOP2 write setPROGOP2;
    property PROGOP3 : TBits_1 read getPROGOP3 write setPROGOP3;
    property WR : TBits_1 read getWR write setWR;
    property WREN : TBits_1 read getWREN write setWREN;
    property WRERR : TBits_1 read getWRERR write setWRERR;
    property w : TBits_32 read getw write setw;
  end;
type
  TNVMRegisters = record
    NVMCONbits : TNVM_NVMCON;
    NVMCON : longWord;
    NVMCONCLR : longWord;
    NVMCONSET : longWord;
    NVMCONINV : longWord;
    NVMKEY : longWord;
    NVMADDR : longWord;
    NVMADDRCLR : longWord;
    NVMADDRSET : longWord;
    NVMADDRINV : longWord;
    NVMDATA : longWord;
    NVMSRCADDR : longWord;
  end;
  TRCON_RCON = record
  private
    function  getBOR : TBits_1; inline;
    function  getCMR : TBits_1; inline;
    function  getEXTR : TBits_1; inline;
    function  getIDLE : TBits_1; inline;
    function  getPOR : TBits_1; inline;
    function  getSLEEP : TBits_1; inline;
    function  getSWR : TBits_1; inline;
    function  getVREGS : TBits_1; inline;
    function  getWDTO : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBOR(thebits : TBits_1); inline;
    procedure setCMR(thebits : TBits_1); inline;
    procedure setEXTR(thebits : TBits_1); inline;
    procedure setIDLE(thebits : TBits_1); inline;
    procedure setPOR(thebits : TBits_1); inline;
    procedure setSLEEP(thebits : TBits_1); inline;
    procedure setSWR(thebits : TBits_1); inline;
    procedure setVREGS(thebits : TBits_1); inline;
    procedure setWDTO(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBOR; inline;
    procedure clearCMR; inline;
    procedure clearEXTR; inline;
    procedure clearIDLE; inline;
    procedure clearPOR; inline;
    procedure clearSLEEP; inline;
    procedure clearSWR; inline;
    procedure clearVREGS; inline;
    procedure clearWDTO; inline;
    procedure setBOR; inline;
    procedure setCMR; inline;
    procedure setEXTR; inline;
    procedure setIDLE; inline;
    procedure setPOR; inline;
    procedure setSLEEP; inline;
    procedure setSWR; inline;
    procedure setVREGS; inline;
    procedure setWDTO; inline;
    property BOR : TBits_1 read getBOR write setBOR;
    property CMR : TBits_1 read getCMR write setCMR;
    property EXTR : TBits_1 read getEXTR write setEXTR;
    property IDLE : TBits_1 read getIDLE write setIDLE;
    property POR : TBits_1 read getPOR write setPOR;
    property SLEEP : TBits_1 read getSLEEP write setSLEEP;
    property SWR : TBits_1 read getSWR write setSWR;
    property VREGS : TBits_1 read getVREGS write setVREGS;
    property WDTO : TBits_1 read getWDTO write setWDTO;
    property w : TBits_32 read getw write setw;
  end;
  TRCON_RSWRST = record
  private
    function  getSWRST : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setSWRST(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearSWRST; inline;
    procedure setSWRST; inline;
    property SWRST : TBits_1 read getSWRST write setSWRST;
    property w : TBits_32 read getw write setw;
  end;
type
  TRCONRegisters = record
    RCONbits : TRCON_RCON;
    RCON : longWord;
    RCONCLR : longWord;
    RCONSET : longWord;
    RCONINV : longWord;
    RSWRSTbits : TRCON_RSWRST;
    RSWRST : longWord;
    RSWRSTCLR : longWord;
    RSWRSTSET : longWord;
    RSWRSTINV : longWord;
  end;
type
  T_DDPSTATRegisters = record
    _DDPSTAT : longWord;
  end;
type
  T_STRORegisters = record
    _STRO : longWord;
    _STROCLR : longWord;
    _STROSET : longWord;
    _STROINV : longWord;
  end;
type
  T_APPORegisters = record
    _APPO : longWord;
    _APPOCLR : longWord;
    _APPOSET : longWord;
    _APPOINV : longWord;
  end;
type
  T_APPIRegisters = record
    _APPI : longWord;
  end;
  TINT_INTCON = record
  private
    function  getFRZ : TBits_1; inline;
    function  getINT0EP : TBits_1; inline;
    function  getINT1EP : TBits_1; inline;
    function  getINT2EP : TBits_1; inline;
    function  getINT3EP : TBits_1; inline;
    function  getINT4EP : TBits_1; inline;
    function  getMVEC : TBits_1; inline;
    function  getSS0 : TBits_1; inline;
    function  getTPC : TBits_3; inline;
    function  getw : TBits_32; inline;
    procedure setFRZ(thebits : TBits_1); inline;
    procedure setINT0EP(thebits : TBits_1); inline;
    procedure setINT1EP(thebits : TBits_1); inline;
    procedure setINT2EP(thebits : TBits_1); inline;
    procedure setINT3EP(thebits : TBits_1); inline;
    procedure setINT4EP(thebits : TBits_1); inline;
    procedure setMVEC(thebits : TBits_1); inline;
    procedure setSS0(thebits : TBits_1); inline;
    procedure setTPC(thebits : TBits_3); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFRZ; inline;
    procedure clearINT0EP; inline;
    procedure clearINT1EP; inline;
    procedure clearINT2EP; inline;
    procedure clearINT3EP; inline;
    procedure clearINT4EP; inline;
    procedure clearMVEC; inline;
    procedure clearSS0; inline;
    procedure setFRZ; inline;
    procedure setINT0EP; inline;
    procedure setINT1EP; inline;
    procedure setINT2EP; inline;
    procedure setINT3EP; inline;
    procedure setINT4EP; inline;
    procedure setMVEC; inline;
    procedure setSS0; inline;
    property FRZ : TBits_1 read getFRZ write setFRZ;
    property INT0EP : TBits_1 read getINT0EP write setINT0EP;
    property INT1EP : TBits_1 read getINT1EP write setINT1EP;
    property INT2EP : TBits_1 read getINT2EP write setINT2EP;
    property INT3EP : TBits_1 read getINT3EP write setINT3EP;
    property INT4EP : TBits_1 read getINT4EP write setINT4EP;
    property MVEC : TBits_1 read getMVEC write setMVEC;
    property SS0 : TBits_1 read getSS0 write setSS0;
    property TPC : TBits_3 read getTPC write setTPC;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IFS0 = record
  private
    function  getCS0IF : TBits_1; inline;
    function  getCS1IF : TBits_1; inline;
    function  getCTIF : TBits_1; inline;
    function  getI2C1ABIF : TBits_1; inline;
    function  getI2C1AMIF : TBits_1; inline;
    function  getI2C1ASIF : TBits_1; inline;
    function  getI2C1BIF : TBits_1; inline;
    function  getI2C1MIF : TBits_1; inline;
    function  getI2C1SIF : TBits_1; inline;
    function  getI2C3BIF : TBits_1; inline;
    function  getI2C3MIF : TBits_1; inline;
    function  getI2C3SIF : TBits_1; inline;
    function  getIC1IF : TBits_1; inline;
    function  getIC2IF : TBits_1; inline;
    function  getIC3IF : TBits_1; inline;
    function  getIC4IF : TBits_1; inline;
    function  getIC5IF : TBits_1; inline;
    function  getINT0IF : TBits_1; inline;
    function  getINT1IF : TBits_1; inline;
    function  getINT2IF : TBits_1; inline;
    function  getINT3IF : TBits_1; inline;
    function  getINT4IF : TBits_1; inline;
    function  getOC1IF : TBits_1; inline;
    function  getOC2IF : TBits_1; inline;
    function  getOC3IF : TBits_1; inline;
    function  getOC4IF : TBits_1; inline;
    function  getOC5IF : TBits_1; inline;
    function  getSPI1AEIF : TBits_1; inline;
    function  getSPI1ARXIF : TBits_1; inline;
    function  getSPI1ATXIF : TBits_1; inline;
    function  getSPI3EIF : TBits_1; inline;
    function  getSPI3RXIF : TBits_1; inline;
    function  getSPI3TXIF : TBits_1; inline;
    function  getT1IF : TBits_1; inline;
    function  getT2IF : TBits_1; inline;
    function  getT3IF : TBits_1; inline;
    function  getT4IF : TBits_1; inline;
    function  getT5IF : TBits_1; inline;
    function  getU1AEIF : TBits_1; inline;
    function  getU1ARXIF : TBits_1; inline;
    function  getU1ATXIF : TBits_1; inline;
    function  getU1EIF : TBits_1; inline;
    function  getU1RXIF : TBits_1; inline;
    function  getU1TXIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCS0IF(thebits : TBits_1); inline;
    procedure setCS1IF(thebits : TBits_1); inline;
    procedure setCTIF(thebits : TBits_1); inline;
    procedure setI2C1ABIF(thebits : TBits_1); inline;
    procedure setI2C1AMIF(thebits : TBits_1); inline;
    procedure setI2C1ASIF(thebits : TBits_1); inline;
    procedure setI2C1BIF(thebits : TBits_1); inline;
    procedure setI2C1MIF(thebits : TBits_1); inline;
    procedure setI2C1SIF(thebits : TBits_1); inline;
    procedure setI2C3BIF(thebits : TBits_1); inline;
    procedure setI2C3MIF(thebits : TBits_1); inline;
    procedure setI2C3SIF(thebits : TBits_1); inline;
    procedure setIC1IF(thebits : TBits_1); inline;
    procedure setIC2IF(thebits : TBits_1); inline;
    procedure setIC3IF(thebits : TBits_1); inline;
    procedure setIC4IF(thebits : TBits_1); inline;
    procedure setIC5IF(thebits : TBits_1); inline;
    procedure setINT0IF(thebits : TBits_1); inline;
    procedure setINT1IF(thebits : TBits_1); inline;
    procedure setINT2IF(thebits : TBits_1); inline;
    procedure setINT3IF(thebits : TBits_1); inline;
    procedure setINT4IF(thebits : TBits_1); inline;
    procedure setOC1IF(thebits : TBits_1); inline;
    procedure setOC2IF(thebits : TBits_1); inline;
    procedure setOC3IF(thebits : TBits_1); inline;
    procedure setOC4IF(thebits : TBits_1); inline;
    procedure setOC5IF(thebits : TBits_1); inline;
    procedure setSPI1AEIF(thebits : TBits_1); inline;
    procedure setSPI1ARXIF(thebits : TBits_1); inline;
    procedure setSPI1ATXIF(thebits : TBits_1); inline;
    procedure setSPI3EIF(thebits : TBits_1); inline;
    procedure setSPI3RXIF(thebits : TBits_1); inline;
    procedure setSPI3TXIF(thebits : TBits_1); inline;
    procedure setT1IF(thebits : TBits_1); inline;
    procedure setT2IF(thebits : TBits_1); inline;
    procedure setT3IF(thebits : TBits_1); inline;
    procedure setT4IF(thebits : TBits_1); inline;
    procedure setT5IF(thebits : TBits_1); inline;
    procedure setU1AEIF(thebits : TBits_1); inline;
    procedure setU1ARXIF(thebits : TBits_1); inline;
    procedure setU1ATXIF(thebits : TBits_1); inline;
    procedure setU1EIF(thebits : TBits_1); inline;
    procedure setU1RXIF(thebits : TBits_1); inline;
    procedure setU1TXIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCS0IF; inline;
    procedure clearCS1IF; inline;
    procedure clearCTIF; inline;
    procedure clearI2C1ABIF; inline;
    procedure clearI2C1AMIF; inline;
    procedure clearI2C1ASIF; inline;
    procedure clearI2C1BIF; inline;
    procedure clearI2C1MIF; inline;
    procedure clearI2C1SIF; inline;
    procedure clearI2C3BIF; inline;
    procedure clearI2C3MIF; inline;
    procedure clearI2C3SIF; inline;
    procedure clearIC1IF; inline;
    procedure clearIC2IF; inline;
    procedure clearIC3IF; inline;
    procedure clearIC4IF; inline;
    procedure clearIC5IF; inline;
    procedure clearINT0IF; inline;
    procedure clearINT1IF; inline;
    procedure clearINT2IF; inline;
    procedure clearINT3IF; inline;
    procedure clearINT4IF; inline;
    procedure clearOC1IF; inline;
    procedure clearOC2IF; inline;
    procedure clearOC3IF; inline;
    procedure clearOC4IF; inline;
    procedure clearOC5IF; inline;
    procedure clearSPI1AEIF; inline;
    procedure clearSPI1ARXIF; inline;
    procedure clearSPI1ATXIF; inline;
    procedure clearSPI3EIF; inline;
    procedure clearSPI3RXIF; inline;
    procedure clearSPI3TXIF; inline;
    procedure clearT1IF; inline;
    procedure clearT2IF; inline;
    procedure clearT3IF; inline;
    procedure clearT4IF; inline;
    procedure clearT5IF; inline;
    procedure clearU1AEIF; inline;
    procedure clearU1ARXIF; inline;
    procedure clearU1ATXIF; inline;
    procedure clearU1EIF; inline;
    procedure clearU1RXIF; inline;
    procedure clearU1TXIF; inline;
    procedure setCS0IF; inline;
    procedure setCS1IF; inline;
    procedure setCTIF; inline;
    procedure setI2C1ABIF; inline;
    procedure setI2C1AMIF; inline;
    procedure setI2C1ASIF; inline;
    procedure setI2C1BIF; inline;
    procedure setI2C1MIF; inline;
    procedure setI2C1SIF; inline;
    procedure setI2C3BIF; inline;
    procedure setI2C3MIF; inline;
    procedure setI2C3SIF; inline;
    procedure setIC1IF; inline;
    procedure setIC2IF; inline;
    procedure setIC3IF; inline;
    procedure setIC4IF; inline;
    procedure setIC5IF; inline;
    procedure setINT0IF; inline;
    procedure setINT1IF; inline;
    procedure setINT2IF; inline;
    procedure setINT3IF; inline;
    procedure setINT4IF; inline;
    procedure setOC1IF; inline;
    procedure setOC2IF; inline;
    procedure setOC3IF; inline;
    procedure setOC4IF; inline;
    procedure setOC5IF; inline;
    procedure setSPI1AEIF; inline;
    procedure setSPI1ARXIF; inline;
    procedure setSPI1ATXIF; inline;
    procedure setSPI3EIF; inline;
    procedure setSPI3RXIF; inline;
    procedure setSPI3TXIF; inline;
    procedure setT1IF; inline;
    procedure setT2IF; inline;
    procedure setT3IF; inline;
    procedure setT4IF; inline;
    procedure setT5IF; inline;
    procedure setU1AEIF; inline;
    procedure setU1ARXIF; inline;
    procedure setU1ATXIF; inline;
    procedure setU1EIF; inline;
    procedure setU1RXIF; inline;
    procedure setU1TXIF; inline;
    property CS0IF : TBits_1 read getCS0IF write setCS0IF;
    property CS1IF : TBits_1 read getCS1IF write setCS1IF;
    property CTIF : TBits_1 read getCTIF write setCTIF;
    property I2C1ABIF : TBits_1 read getI2C1ABIF write setI2C1ABIF;
    property I2C1AMIF : TBits_1 read getI2C1AMIF write setI2C1AMIF;
    property I2C1ASIF : TBits_1 read getI2C1ASIF write setI2C1ASIF;
    property I2C1BIF : TBits_1 read getI2C1BIF write setI2C1BIF;
    property I2C1MIF : TBits_1 read getI2C1MIF write setI2C1MIF;
    property I2C1SIF : TBits_1 read getI2C1SIF write setI2C1SIF;
    property I2C3BIF : TBits_1 read getI2C3BIF write setI2C3BIF;
    property I2C3MIF : TBits_1 read getI2C3MIF write setI2C3MIF;
    property I2C3SIF : TBits_1 read getI2C3SIF write setI2C3SIF;
    property IC1IF : TBits_1 read getIC1IF write setIC1IF;
    property IC2IF : TBits_1 read getIC2IF write setIC2IF;
    property IC3IF : TBits_1 read getIC3IF write setIC3IF;
    property IC4IF : TBits_1 read getIC4IF write setIC4IF;
    property IC5IF : TBits_1 read getIC5IF write setIC5IF;
    property INT0IF : TBits_1 read getINT0IF write setINT0IF;
    property INT1IF : TBits_1 read getINT1IF write setINT1IF;
    property INT2IF : TBits_1 read getINT2IF write setINT2IF;
    property INT3IF : TBits_1 read getINT3IF write setINT3IF;
    property INT4IF : TBits_1 read getINT4IF write setINT4IF;
    property OC1IF : TBits_1 read getOC1IF write setOC1IF;
    property OC2IF : TBits_1 read getOC2IF write setOC2IF;
    property OC3IF : TBits_1 read getOC3IF write setOC3IF;
    property OC4IF : TBits_1 read getOC4IF write setOC4IF;
    property OC5IF : TBits_1 read getOC5IF write setOC5IF;
    property SPI1AEIF : TBits_1 read getSPI1AEIF write setSPI1AEIF;
    property SPI1ARXIF : TBits_1 read getSPI1ARXIF write setSPI1ARXIF;
    property SPI1ATXIF : TBits_1 read getSPI1ATXIF write setSPI1ATXIF;
    property SPI3EIF : TBits_1 read getSPI3EIF write setSPI3EIF;
    property SPI3RXIF : TBits_1 read getSPI3RXIF write setSPI3RXIF;
    property SPI3TXIF : TBits_1 read getSPI3TXIF write setSPI3TXIF;
    property T1IF : TBits_1 read getT1IF write setT1IF;
    property T2IF : TBits_1 read getT2IF write setT2IF;
    property T3IF : TBits_1 read getT3IF write setT3IF;
    property T4IF : TBits_1 read getT4IF write setT4IF;
    property T5IF : TBits_1 read getT5IF write setT5IF;
    property U1AEIF : TBits_1 read getU1AEIF write setU1AEIF;
    property U1ARXIF : TBits_1 read getU1ARXIF write setU1ARXIF;
    property U1ATXIF : TBits_1 read getU1ATXIF write setU1ATXIF;
    property U1EIF : TBits_1 read getU1EIF write setU1EIF;
    property U1RXIF : TBits_1 read getU1RXIF write setU1RXIF;
    property U1TXIF : TBits_1 read getU1TXIF write setU1TXIF;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IFS1 = record
  private
    function  getAD1IF : TBits_1; inline;
    function  getCAN1IF : TBits_1; inline;
    function  getCMP1IF : TBits_1; inline;
    function  getCMP2IF : TBits_1; inline;
    function  getCNIF : TBits_1; inline;
    function  getDMA0IF : TBits_1; inline;
    function  getDMA1IF : TBits_1; inline;
    function  getDMA2IF : TBits_1; inline;
    function  getDMA3IF : TBits_1; inline;
    function  getFCEIF : TBits_1; inline;
    function  getFSCMIF : TBits_1; inline;
    function  getI2C2ABIF : TBits_1; inline;
    function  getI2C2AMIF : TBits_1; inline;
    function  getI2C2ASIF : TBits_1; inline;
    function  getI2C3ABIF : TBits_1; inline;
    function  getI2C3AMIF : TBits_1; inline;
    function  getI2C3ASIF : TBits_1; inline;
    function  getI2C4BIF : TBits_1; inline;
    function  getI2C4MIF : TBits_1; inline;
    function  getI2C4SIF : TBits_1; inline;
    function  getI2C5BIF : TBits_1; inline;
    function  getI2C5MIF : TBits_1; inline;
    function  getI2C5SIF : TBits_1; inline;
    function  getIC1EIF : TBits_1; inline;
    function  getIC2EIF : TBits_1; inline;
    function  getIC3EIF : TBits_1; inline;
    function  getPMPIF : TBits_1; inline;
    function  getRTCCIF : TBits_1; inline;
    function  getSPI2AEIF : TBits_1; inline;
    function  getSPI2ARXIF : TBits_1; inline;
    function  getSPI2ATXIF : TBits_1; inline;
    function  getSPI2EIF : TBits_1; inline;
    function  getSPI2RXIF : TBits_1; inline;
    function  getSPI2TXIF : TBits_1; inline;
    function  getSPI3AEIF : TBits_1; inline;
    function  getSPI3ARXIF : TBits_1; inline;
    function  getSPI3ATXIF : TBits_1; inline;
    function  getSPI4EIF : TBits_1; inline;
    function  getSPI4RXIF : TBits_1; inline;
    function  getSPI4TXIF : TBits_1; inline;
    function  getU2AEIF : TBits_1; inline;
    function  getU2ARXIF : TBits_1; inline;
    function  getU2ATXIF : TBits_1; inline;
    function  getU2EIF : TBits_1; inline;
    function  getU2RXIF : TBits_1; inline;
    function  getU2TXIF : TBits_1; inline;
    function  getU3AEIF : TBits_1; inline;
    function  getU3ARXIF : TBits_1; inline;
    function  getU3ATXIF : TBits_1; inline;
    function  getU3EIF : TBits_1; inline;
    function  getU3RXIF : TBits_1; inline;
    function  getU3TXIF : TBits_1; inline;
    function  getUSBIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAD1IF(thebits : TBits_1); inline;
    procedure setCAN1IF(thebits : TBits_1); inline;
    procedure setCMP1IF(thebits : TBits_1); inline;
    procedure setCMP2IF(thebits : TBits_1); inline;
    procedure setCNIF(thebits : TBits_1); inline;
    procedure setDMA0IF(thebits : TBits_1); inline;
    procedure setDMA1IF(thebits : TBits_1); inline;
    procedure setDMA2IF(thebits : TBits_1); inline;
    procedure setDMA3IF(thebits : TBits_1); inline;
    procedure setFCEIF(thebits : TBits_1); inline;
    procedure setFSCMIF(thebits : TBits_1); inline;
    procedure setI2C2ABIF(thebits : TBits_1); inline;
    procedure setI2C2AMIF(thebits : TBits_1); inline;
    procedure setI2C2ASIF(thebits : TBits_1); inline;
    procedure setI2C3ABIF(thebits : TBits_1); inline;
    procedure setI2C3AMIF(thebits : TBits_1); inline;
    procedure setI2C3ASIF(thebits : TBits_1); inline;
    procedure setI2C4BIF(thebits : TBits_1); inline;
    procedure setI2C4MIF(thebits : TBits_1); inline;
    procedure setI2C4SIF(thebits : TBits_1); inline;
    procedure setI2C5BIF(thebits : TBits_1); inline;
    procedure setI2C5MIF(thebits : TBits_1); inline;
    procedure setI2C5SIF(thebits : TBits_1); inline;
    procedure setIC1EIF(thebits : TBits_1); inline;
    procedure setIC2EIF(thebits : TBits_1); inline;
    procedure setIC3EIF(thebits : TBits_1); inline;
    procedure setPMPIF(thebits : TBits_1); inline;
    procedure setRTCCIF(thebits : TBits_1); inline;
    procedure setSPI2AEIF(thebits : TBits_1); inline;
    procedure setSPI2ARXIF(thebits : TBits_1); inline;
    procedure setSPI2ATXIF(thebits : TBits_1); inline;
    procedure setSPI2EIF(thebits : TBits_1); inline;
    procedure setSPI2RXIF(thebits : TBits_1); inline;
    procedure setSPI2TXIF(thebits : TBits_1); inline;
    procedure setSPI3AEIF(thebits : TBits_1); inline;
    procedure setSPI3ARXIF(thebits : TBits_1); inline;
    procedure setSPI3ATXIF(thebits : TBits_1); inline;
    procedure setSPI4EIF(thebits : TBits_1); inline;
    procedure setSPI4RXIF(thebits : TBits_1); inline;
    procedure setSPI4TXIF(thebits : TBits_1); inline;
    procedure setU2AEIF(thebits : TBits_1); inline;
    procedure setU2ARXIF(thebits : TBits_1); inline;
    procedure setU2ATXIF(thebits : TBits_1); inline;
    procedure setU2EIF(thebits : TBits_1); inline;
    procedure setU2RXIF(thebits : TBits_1); inline;
    procedure setU2TXIF(thebits : TBits_1); inline;
    procedure setU3AEIF(thebits : TBits_1); inline;
    procedure setU3ARXIF(thebits : TBits_1); inline;
    procedure setU3ATXIF(thebits : TBits_1); inline;
    procedure setU3EIF(thebits : TBits_1); inline;
    procedure setU3RXIF(thebits : TBits_1); inline;
    procedure setU3TXIF(thebits : TBits_1); inline;
    procedure setUSBIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAD1IF; inline;
    procedure clearCAN1IF; inline;
    procedure clearCMP1IF; inline;
    procedure clearCMP2IF; inline;
    procedure clearCNIF; inline;
    procedure clearDMA0IF; inline;
    procedure clearDMA1IF; inline;
    procedure clearDMA2IF; inline;
    procedure clearDMA3IF; inline;
    procedure clearFCEIF; inline;
    procedure clearFSCMIF; inline;
    procedure clearI2C2ABIF; inline;
    procedure clearI2C2AMIF; inline;
    procedure clearI2C2ASIF; inline;
    procedure clearI2C3ABIF; inline;
    procedure clearI2C3AMIF; inline;
    procedure clearI2C3ASIF; inline;
    procedure clearI2C4BIF; inline;
    procedure clearI2C4MIF; inline;
    procedure clearI2C4SIF; inline;
    procedure clearI2C5BIF; inline;
    procedure clearI2C5MIF; inline;
    procedure clearI2C5SIF; inline;
    procedure clearIC1EIF; inline;
    procedure clearIC2EIF; inline;
    procedure clearIC3EIF; inline;
    procedure clearPMPIF; inline;
    procedure clearRTCCIF; inline;
    procedure clearSPI2AEIF; inline;
    procedure clearSPI2ARXIF; inline;
    procedure clearSPI2ATXIF; inline;
    procedure clearSPI2EIF; inline;
    procedure clearSPI2RXIF; inline;
    procedure clearSPI2TXIF; inline;
    procedure clearSPI3AEIF; inline;
    procedure clearSPI3ARXIF; inline;
    procedure clearSPI3ATXIF; inline;
    procedure clearSPI4EIF; inline;
    procedure clearSPI4RXIF; inline;
    procedure clearSPI4TXIF; inline;
    procedure clearU2AEIF; inline;
    procedure clearU2ARXIF; inline;
    procedure clearU2ATXIF; inline;
    procedure clearU2EIF; inline;
    procedure clearU2RXIF; inline;
    procedure clearU2TXIF; inline;
    procedure clearU3AEIF; inline;
    procedure clearU3ARXIF; inline;
    procedure clearU3ATXIF; inline;
    procedure clearU3EIF; inline;
    procedure clearU3RXIF; inline;
    procedure clearU3TXIF; inline;
    procedure clearUSBIF; inline;
    procedure setAD1IF; inline;
    procedure setCAN1IF; inline;
    procedure setCMP1IF; inline;
    procedure setCMP2IF; inline;
    procedure setCNIF; inline;
    procedure setDMA0IF; inline;
    procedure setDMA1IF; inline;
    procedure setDMA2IF; inline;
    procedure setDMA3IF; inline;
    procedure setFCEIF; inline;
    procedure setFSCMIF; inline;
    procedure setI2C2ABIF; inline;
    procedure setI2C2AMIF; inline;
    procedure setI2C2ASIF; inline;
    procedure setI2C3ABIF; inline;
    procedure setI2C3AMIF; inline;
    procedure setI2C3ASIF; inline;
    procedure setI2C4BIF; inline;
    procedure setI2C4MIF; inline;
    procedure setI2C4SIF; inline;
    procedure setI2C5BIF; inline;
    procedure setI2C5MIF; inline;
    procedure setI2C5SIF; inline;
    procedure setIC1EIF; inline;
    procedure setIC2EIF; inline;
    procedure setIC3EIF; inline;
    procedure setPMPIF; inline;
    procedure setRTCCIF; inline;
    procedure setSPI2AEIF; inline;
    procedure setSPI2ARXIF; inline;
    procedure setSPI2ATXIF; inline;
    procedure setSPI2EIF; inline;
    procedure setSPI2RXIF; inline;
    procedure setSPI2TXIF; inline;
    procedure setSPI3AEIF; inline;
    procedure setSPI3ARXIF; inline;
    procedure setSPI3ATXIF; inline;
    procedure setSPI4EIF; inline;
    procedure setSPI4RXIF; inline;
    procedure setSPI4TXIF; inline;
    procedure setU2AEIF; inline;
    procedure setU2ARXIF; inline;
    procedure setU2ATXIF; inline;
    procedure setU2EIF; inline;
    procedure setU2RXIF; inline;
    procedure setU2TXIF; inline;
    procedure setU3AEIF; inline;
    procedure setU3ARXIF; inline;
    procedure setU3ATXIF; inline;
    procedure setU3EIF; inline;
    procedure setU3RXIF; inline;
    procedure setU3TXIF; inline;
    procedure setUSBIF; inline;
    property AD1IF : TBits_1 read getAD1IF write setAD1IF;
    property CAN1IF : TBits_1 read getCAN1IF write setCAN1IF;
    property CMP1IF : TBits_1 read getCMP1IF write setCMP1IF;
    property CMP2IF : TBits_1 read getCMP2IF write setCMP2IF;
    property CNIF : TBits_1 read getCNIF write setCNIF;
    property DMA0IF : TBits_1 read getDMA0IF write setDMA0IF;
    property DMA1IF : TBits_1 read getDMA1IF write setDMA1IF;
    property DMA2IF : TBits_1 read getDMA2IF write setDMA2IF;
    property DMA3IF : TBits_1 read getDMA3IF write setDMA3IF;
    property FCEIF : TBits_1 read getFCEIF write setFCEIF;
    property FSCMIF : TBits_1 read getFSCMIF write setFSCMIF;
    property I2C2ABIF : TBits_1 read getI2C2ABIF write setI2C2ABIF;
    property I2C2AMIF : TBits_1 read getI2C2AMIF write setI2C2AMIF;
    property I2C2ASIF : TBits_1 read getI2C2ASIF write setI2C2ASIF;
    property I2C3ABIF : TBits_1 read getI2C3ABIF write setI2C3ABIF;
    property I2C3AMIF : TBits_1 read getI2C3AMIF write setI2C3AMIF;
    property I2C3ASIF : TBits_1 read getI2C3ASIF write setI2C3ASIF;
    property I2C4BIF : TBits_1 read getI2C4BIF write setI2C4BIF;
    property I2C4MIF : TBits_1 read getI2C4MIF write setI2C4MIF;
    property I2C4SIF : TBits_1 read getI2C4SIF write setI2C4SIF;
    property I2C5BIF : TBits_1 read getI2C5BIF write setI2C5BIF;
    property I2C5MIF : TBits_1 read getI2C5MIF write setI2C5MIF;
    property I2C5SIF : TBits_1 read getI2C5SIF write setI2C5SIF;
    property IC1EIF : TBits_1 read getIC1EIF write setIC1EIF;
    property IC2EIF : TBits_1 read getIC2EIF write setIC2EIF;
    property IC3EIF : TBits_1 read getIC3EIF write setIC3EIF;
    property PMPIF : TBits_1 read getPMPIF write setPMPIF;
    property RTCCIF : TBits_1 read getRTCCIF write setRTCCIF;
    property SPI2AEIF : TBits_1 read getSPI2AEIF write setSPI2AEIF;
    property SPI2ARXIF : TBits_1 read getSPI2ARXIF write setSPI2ARXIF;
    property SPI2ATXIF : TBits_1 read getSPI2ATXIF write setSPI2ATXIF;
    property SPI2EIF : TBits_1 read getSPI2EIF write setSPI2EIF;
    property SPI2RXIF : TBits_1 read getSPI2RXIF write setSPI2RXIF;
    property SPI2TXIF : TBits_1 read getSPI2TXIF write setSPI2TXIF;
    property SPI3AEIF : TBits_1 read getSPI3AEIF write setSPI3AEIF;
    property SPI3ARXIF : TBits_1 read getSPI3ARXIF write setSPI3ARXIF;
    property SPI3ATXIF : TBits_1 read getSPI3ATXIF write setSPI3ATXIF;
    property SPI4EIF : TBits_1 read getSPI4EIF write setSPI4EIF;
    property SPI4RXIF : TBits_1 read getSPI4RXIF write setSPI4RXIF;
    property SPI4TXIF : TBits_1 read getSPI4TXIF write setSPI4TXIF;
    property U2AEIF : TBits_1 read getU2AEIF write setU2AEIF;
    property U2ARXIF : TBits_1 read getU2ARXIF write setU2ARXIF;
    property U2ATXIF : TBits_1 read getU2ATXIF write setU2ATXIF;
    property U2EIF : TBits_1 read getU2EIF write setU2EIF;
    property U2RXIF : TBits_1 read getU2RXIF write setU2RXIF;
    property U2TXIF : TBits_1 read getU2TXIF write setU2TXIF;
    property U3AEIF : TBits_1 read getU3AEIF write setU3AEIF;
    property U3ARXIF : TBits_1 read getU3ARXIF write setU3ARXIF;
    property U3ATXIF : TBits_1 read getU3ATXIF write setU3ATXIF;
    property U3EIF : TBits_1 read getU3EIF write setU3EIF;
    property U3RXIF : TBits_1 read getU3RXIF write setU3RXIF;
    property U3TXIF : TBits_1 read getU3TXIF write setU3TXIF;
    property USBIF : TBits_1 read getUSBIF write setUSBIF;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IFS2 = record
  private
    function  getIC4EIF : TBits_1; inline;
    function  getIC5EIF : TBits_1; inline;
    function  getPMPEIF : TBits_1; inline;
    function  getU1BEIF : TBits_1; inline;
    function  getU1BRXIF : TBits_1; inline;
    function  getU1BTXIF : TBits_1; inline;
    function  getU2BEIF : TBits_1; inline;
    function  getU2BRXIF : TBits_1; inline;
    function  getU2BTXIF : TBits_1; inline;
    function  getU3BEIF : TBits_1; inline;
    function  getU3BRXIF : TBits_1; inline;
    function  getU3BTXIF : TBits_1; inline;
    function  getU4EIF : TBits_1; inline;
    function  getU4RXIF : TBits_1; inline;
    function  getU4TXIF : TBits_1; inline;
    function  getU5EIF : TBits_1; inline;
    function  getU5RXIF : TBits_1; inline;
    function  getU5TXIF : TBits_1; inline;
    function  getU6EIF : TBits_1; inline;
    function  getU6RXIF : TBits_1; inline;
    function  getU6TXIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setIC4EIF(thebits : TBits_1); inline;
    procedure setIC5EIF(thebits : TBits_1); inline;
    procedure setPMPEIF(thebits : TBits_1); inline;
    procedure setU1BEIF(thebits : TBits_1); inline;
    procedure setU1BRXIF(thebits : TBits_1); inline;
    procedure setU1BTXIF(thebits : TBits_1); inline;
    procedure setU2BEIF(thebits : TBits_1); inline;
    procedure setU2BRXIF(thebits : TBits_1); inline;
    procedure setU2BTXIF(thebits : TBits_1); inline;
    procedure setU3BEIF(thebits : TBits_1); inline;
    procedure setU3BRXIF(thebits : TBits_1); inline;
    procedure setU3BTXIF(thebits : TBits_1); inline;
    procedure setU4EIF(thebits : TBits_1); inline;
    procedure setU4RXIF(thebits : TBits_1); inline;
    procedure setU4TXIF(thebits : TBits_1); inline;
    procedure setU5EIF(thebits : TBits_1); inline;
    procedure setU5RXIF(thebits : TBits_1); inline;
    procedure setU5TXIF(thebits : TBits_1); inline;
    procedure setU6EIF(thebits : TBits_1); inline;
    procedure setU6RXIF(thebits : TBits_1); inline;
    procedure setU6TXIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearIC4EIF; inline;
    procedure clearIC5EIF; inline;
    procedure clearPMPEIF; inline;
    procedure clearU1BEIF; inline;
    procedure clearU1BRXIF; inline;
    procedure clearU1BTXIF; inline;
    procedure clearU2BEIF; inline;
    procedure clearU2BRXIF; inline;
    procedure clearU2BTXIF; inline;
    procedure clearU3BEIF; inline;
    procedure clearU3BRXIF; inline;
    procedure clearU3BTXIF; inline;
    procedure clearU4EIF; inline;
    procedure clearU4RXIF; inline;
    procedure clearU4TXIF; inline;
    procedure clearU5EIF; inline;
    procedure clearU5RXIF; inline;
    procedure clearU5TXIF; inline;
    procedure clearU6EIF; inline;
    procedure clearU6RXIF; inline;
    procedure clearU6TXIF; inline;
    procedure setIC4EIF; inline;
    procedure setIC5EIF; inline;
    procedure setPMPEIF; inline;
    procedure setU1BEIF; inline;
    procedure setU1BRXIF; inline;
    procedure setU1BTXIF; inline;
    procedure setU2BEIF; inline;
    procedure setU2BRXIF; inline;
    procedure setU2BTXIF; inline;
    procedure setU3BEIF; inline;
    procedure setU3BRXIF; inline;
    procedure setU3BTXIF; inline;
    procedure setU4EIF; inline;
    procedure setU4RXIF; inline;
    procedure setU4TXIF; inline;
    procedure setU5EIF; inline;
    procedure setU5RXIF; inline;
    procedure setU5TXIF; inline;
    procedure setU6EIF; inline;
    procedure setU6RXIF; inline;
    procedure setU6TXIF; inline;
    property IC4EIF : TBits_1 read getIC4EIF write setIC4EIF;
    property IC5EIF : TBits_1 read getIC5EIF write setIC5EIF;
    property PMPEIF : TBits_1 read getPMPEIF write setPMPEIF;
    property U1BEIF : TBits_1 read getU1BEIF write setU1BEIF;
    property U1BRXIF : TBits_1 read getU1BRXIF write setU1BRXIF;
    property U1BTXIF : TBits_1 read getU1BTXIF write setU1BTXIF;
    property U2BEIF : TBits_1 read getU2BEIF write setU2BEIF;
    property U2BRXIF : TBits_1 read getU2BRXIF write setU2BRXIF;
    property U2BTXIF : TBits_1 read getU2BTXIF write setU2BTXIF;
    property U3BEIF : TBits_1 read getU3BEIF write setU3BEIF;
    property U3BRXIF : TBits_1 read getU3BRXIF write setU3BRXIF;
    property U3BTXIF : TBits_1 read getU3BTXIF write setU3BTXIF;
    property U4EIF : TBits_1 read getU4EIF write setU4EIF;
    property U4RXIF : TBits_1 read getU4RXIF write setU4RXIF;
    property U4TXIF : TBits_1 read getU4TXIF write setU4TXIF;
    property U5EIF : TBits_1 read getU5EIF write setU5EIF;
    property U5RXIF : TBits_1 read getU5RXIF write setU5RXIF;
    property U5TXIF : TBits_1 read getU5TXIF write setU5TXIF;
    property U6EIF : TBits_1 read getU6EIF write setU6EIF;
    property U6RXIF : TBits_1 read getU6RXIF write setU6RXIF;
    property U6TXIF : TBits_1 read getU6TXIF write setU6TXIF;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IEC0 = record
  private
    function  getCS0IE : TBits_1; inline;
    function  getCS1IE : TBits_1; inline;
    function  getCTIE : TBits_1; inline;
    function  getI2C1ABIE : TBits_1; inline;
    function  getI2C1AMIE : TBits_1; inline;
    function  getI2C1ASIE : TBits_1; inline;
    function  getI2C1BIE : TBits_1; inline;
    function  getI2C1MIE : TBits_1; inline;
    function  getI2C1SIE : TBits_1; inline;
    function  getI2C3BIE : TBits_1; inline;
    function  getI2C3MIE : TBits_1; inline;
    function  getI2C3SIE : TBits_1; inline;
    function  getIC1IE : TBits_1; inline;
    function  getIC2IE : TBits_1; inline;
    function  getIC3IE : TBits_1; inline;
    function  getIC4IE : TBits_1; inline;
    function  getIC5IE : TBits_1; inline;
    function  getINT0IE : TBits_1; inline;
    function  getINT1IE : TBits_1; inline;
    function  getINT2IE : TBits_1; inline;
    function  getINT3IE : TBits_1; inline;
    function  getINT4IE : TBits_1; inline;
    function  getOC1IE : TBits_1; inline;
    function  getOC2IE : TBits_1; inline;
    function  getOC3IE : TBits_1; inline;
    function  getOC4IE : TBits_1; inline;
    function  getOC5IE : TBits_1; inline;
    function  getSPI1AEIE : TBits_1; inline;
    function  getSPI1ARXIE : TBits_1; inline;
    function  getSPI1ATXIE : TBits_1; inline;
    function  getSPI3EIE : TBits_1; inline;
    function  getSPI3RXIE : TBits_1; inline;
    function  getSPI3TXIE : TBits_1; inline;
    function  getT1IE : TBits_1; inline;
    function  getT2IE : TBits_1; inline;
    function  getT3IE : TBits_1; inline;
    function  getT4IE : TBits_1; inline;
    function  getT5IE : TBits_1; inline;
    function  getU1AEIE : TBits_1; inline;
    function  getU1ARXIE : TBits_1; inline;
    function  getU1ATXIE : TBits_1; inline;
    function  getU1EIE : TBits_1; inline;
    function  getU1RXIE : TBits_1; inline;
    function  getU1TXIE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCS0IE(thebits : TBits_1); inline;
    procedure setCS1IE(thebits : TBits_1); inline;
    procedure setCTIE(thebits : TBits_1); inline;
    procedure setI2C1ABIE(thebits : TBits_1); inline;
    procedure setI2C1AMIE(thebits : TBits_1); inline;
    procedure setI2C1ASIE(thebits : TBits_1); inline;
    procedure setI2C1BIE(thebits : TBits_1); inline;
    procedure setI2C1MIE(thebits : TBits_1); inline;
    procedure setI2C1SIE(thebits : TBits_1); inline;
    procedure setI2C3BIE(thebits : TBits_1); inline;
    procedure setI2C3MIE(thebits : TBits_1); inline;
    procedure setI2C3SIE(thebits : TBits_1); inline;
    procedure setIC1IE(thebits : TBits_1); inline;
    procedure setIC2IE(thebits : TBits_1); inline;
    procedure setIC3IE(thebits : TBits_1); inline;
    procedure setIC4IE(thebits : TBits_1); inline;
    procedure setIC5IE(thebits : TBits_1); inline;
    procedure setINT0IE(thebits : TBits_1); inline;
    procedure setINT1IE(thebits : TBits_1); inline;
    procedure setINT2IE(thebits : TBits_1); inline;
    procedure setINT3IE(thebits : TBits_1); inline;
    procedure setINT4IE(thebits : TBits_1); inline;
    procedure setOC1IE(thebits : TBits_1); inline;
    procedure setOC2IE(thebits : TBits_1); inline;
    procedure setOC3IE(thebits : TBits_1); inline;
    procedure setOC4IE(thebits : TBits_1); inline;
    procedure setOC5IE(thebits : TBits_1); inline;
    procedure setSPI1AEIE(thebits : TBits_1); inline;
    procedure setSPI1ARXIE(thebits : TBits_1); inline;
    procedure setSPI1ATXIE(thebits : TBits_1); inline;
    procedure setSPI3EIE(thebits : TBits_1); inline;
    procedure setSPI3RXIE(thebits : TBits_1); inline;
    procedure setSPI3TXIE(thebits : TBits_1); inline;
    procedure setT1IE(thebits : TBits_1); inline;
    procedure setT2IE(thebits : TBits_1); inline;
    procedure setT3IE(thebits : TBits_1); inline;
    procedure setT4IE(thebits : TBits_1); inline;
    procedure setT5IE(thebits : TBits_1); inline;
    procedure setU1AEIE(thebits : TBits_1); inline;
    procedure setU1ARXIE(thebits : TBits_1); inline;
    procedure setU1ATXIE(thebits : TBits_1); inline;
    procedure setU1EIE(thebits : TBits_1); inline;
    procedure setU1RXIE(thebits : TBits_1); inline;
    procedure setU1TXIE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCS0IE; inline;
    procedure clearCS1IE; inline;
    procedure clearCTIE; inline;
    procedure clearI2C1ABIE; inline;
    procedure clearI2C1AMIE; inline;
    procedure clearI2C1ASIE; inline;
    procedure clearI2C1BIE; inline;
    procedure clearI2C1MIE; inline;
    procedure clearI2C1SIE; inline;
    procedure clearI2C3BIE; inline;
    procedure clearI2C3MIE; inline;
    procedure clearI2C3SIE; inline;
    procedure clearIC1IE; inline;
    procedure clearIC2IE; inline;
    procedure clearIC3IE; inline;
    procedure clearIC4IE; inline;
    procedure clearIC5IE; inline;
    procedure clearINT0IE; inline;
    procedure clearINT1IE; inline;
    procedure clearINT2IE; inline;
    procedure clearINT3IE; inline;
    procedure clearINT4IE; inline;
    procedure clearOC1IE; inline;
    procedure clearOC2IE; inline;
    procedure clearOC3IE; inline;
    procedure clearOC4IE; inline;
    procedure clearOC5IE; inline;
    procedure clearSPI1AEIE; inline;
    procedure clearSPI1ARXIE; inline;
    procedure clearSPI1ATXIE; inline;
    procedure clearSPI3EIE; inline;
    procedure clearSPI3RXIE; inline;
    procedure clearSPI3TXIE; inline;
    procedure clearT1IE; inline;
    procedure clearT2IE; inline;
    procedure clearT3IE; inline;
    procedure clearT4IE; inline;
    procedure clearT5IE; inline;
    procedure clearU1AEIE; inline;
    procedure clearU1ARXIE; inline;
    procedure clearU1ATXIE; inline;
    procedure clearU1EIE; inline;
    procedure clearU1RXIE; inline;
    procedure clearU1TXIE; inline;
    procedure setCS0IE; inline;
    procedure setCS1IE; inline;
    procedure setCTIE; inline;
    procedure setI2C1ABIE; inline;
    procedure setI2C1AMIE; inline;
    procedure setI2C1ASIE; inline;
    procedure setI2C1BIE; inline;
    procedure setI2C1MIE; inline;
    procedure setI2C1SIE; inline;
    procedure setI2C3BIE; inline;
    procedure setI2C3MIE; inline;
    procedure setI2C3SIE; inline;
    procedure setIC1IE; inline;
    procedure setIC2IE; inline;
    procedure setIC3IE; inline;
    procedure setIC4IE; inline;
    procedure setIC5IE; inline;
    procedure setINT0IE; inline;
    procedure setINT1IE; inline;
    procedure setINT2IE; inline;
    procedure setINT3IE; inline;
    procedure setINT4IE; inline;
    procedure setOC1IE; inline;
    procedure setOC2IE; inline;
    procedure setOC3IE; inline;
    procedure setOC4IE; inline;
    procedure setOC5IE; inline;
    procedure setSPI1AEIE; inline;
    procedure setSPI1ARXIE; inline;
    procedure setSPI1ATXIE; inline;
    procedure setSPI3EIE; inline;
    procedure setSPI3RXIE; inline;
    procedure setSPI3TXIE; inline;
    procedure setT1IE; inline;
    procedure setT2IE; inline;
    procedure setT3IE; inline;
    procedure setT4IE; inline;
    procedure setT5IE; inline;
    procedure setU1AEIE; inline;
    procedure setU1ARXIE; inline;
    procedure setU1ATXIE; inline;
    procedure setU1EIE; inline;
    procedure setU1RXIE; inline;
    procedure setU1TXIE; inline;
    property CS0IE : TBits_1 read getCS0IE write setCS0IE;
    property CS1IE : TBits_1 read getCS1IE write setCS1IE;
    property CTIE : TBits_1 read getCTIE write setCTIE;
    property I2C1ABIE : TBits_1 read getI2C1ABIE write setI2C1ABIE;
    property I2C1AMIE : TBits_1 read getI2C1AMIE write setI2C1AMIE;
    property I2C1ASIE : TBits_1 read getI2C1ASIE write setI2C1ASIE;
    property I2C1BIE : TBits_1 read getI2C1BIE write setI2C1BIE;
    property I2C1MIE : TBits_1 read getI2C1MIE write setI2C1MIE;
    property I2C1SIE : TBits_1 read getI2C1SIE write setI2C1SIE;
    property I2C3BIE : TBits_1 read getI2C3BIE write setI2C3BIE;
    property I2C3MIE : TBits_1 read getI2C3MIE write setI2C3MIE;
    property I2C3SIE : TBits_1 read getI2C3SIE write setI2C3SIE;
    property IC1IE : TBits_1 read getIC1IE write setIC1IE;
    property IC2IE : TBits_1 read getIC2IE write setIC2IE;
    property IC3IE : TBits_1 read getIC3IE write setIC3IE;
    property IC4IE : TBits_1 read getIC4IE write setIC4IE;
    property IC5IE : TBits_1 read getIC5IE write setIC5IE;
    property INT0IE : TBits_1 read getINT0IE write setINT0IE;
    property INT1IE : TBits_1 read getINT1IE write setINT1IE;
    property INT2IE : TBits_1 read getINT2IE write setINT2IE;
    property INT3IE : TBits_1 read getINT3IE write setINT3IE;
    property INT4IE : TBits_1 read getINT4IE write setINT4IE;
    property OC1IE : TBits_1 read getOC1IE write setOC1IE;
    property OC2IE : TBits_1 read getOC2IE write setOC2IE;
    property OC3IE : TBits_1 read getOC3IE write setOC3IE;
    property OC4IE : TBits_1 read getOC4IE write setOC4IE;
    property OC5IE : TBits_1 read getOC5IE write setOC5IE;
    property SPI1AEIE : TBits_1 read getSPI1AEIE write setSPI1AEIE;
    property SPI1ARXIE : TBits_1 read getSPI1ARXIE write setSPI1ARXIE;
    property SPI1ATXIE : TBits_1 read getSPI1ATXIE write setSPI1ATXIE;
    property SPI3EIE : TBits_1 read getSPI3EIE write setSPI3EIE;
    property SPI3RXIE : TBits_1 read getSPI3RXIE write setSPI3RXIE;
    property SPI3TXIE : TBits_1 read getSPI3TXIE write setSPI3TXIE;
    property T1IE : TBits_1 read getT1IE write setT1IE;
    property T2IE : TBits_1 read getT2IE write setT2IE;
    property T3IE : TBits_1 read getT3IE write setT3IE;
    property T4IE : TBits_1 read getT4IE write setT4IE;
    property T5IE : TBits_1 read getT5IE write setT5IE;
    property U1AEIE : TBits_1 read getU1AEIE write setU1AEIE;
    property U1ARXIE : TBits_1 read getU1ARXIE write setU1ARXIE;
    property U1ATXIE : TBits_1 read getU1ATXIE write setU1ATXIE;
    property U1EIE : TBits_1 read getU1EIE write setU1EIE;
    property U1RXIE : TBits_1 read getU1RXIE write setU1RXIE;
    property U1TXIE : TBits_1 read getU1TXIE write setU1TXIE;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IEC1 = record
  private
    function  getAD1IE : TBits_1; inline;
    function  getCAN1IE : TBits_1; inline;
    function  getCMP1IE : TBits_1; inline;
    function  getCMP2IE : TBits_1; inline;
    function  getCNIE : TBits_1; inline;
    function  getDMA0IE : TBits_1; inline;
    function  getDMA1IE : TBits_1; inline;
    function  getDMA2IE : TBits_1; inline;
    function  getDMA3IE : TBits_1; inline;
    function  getFCEIE : TBits_1; inline;
    function  getFSCMIE : TBits_1; inline;
    function  getI2C2ABIE : TBits_1; inline;
    function  getI2C2AMIE : TBits_1; inline;
    function  getI2C2ASIE : TBits_1; inline;
    function  getI2C3ABIE : TBits_1; inline;
    function  getI2C3AMIE : TBits_1; inline;
    function  getI2C3ASIE : TBits_1; inline;
    function  getI2C4BIE : TBits_1; inline;
    function  getI2C4MIE : TBits_1; inline;
    function  getI2C4SIE : TBits_1; inline;
    function  getI2C5BIE : TBits_1; inline;
    function  getI2C5MIE : TBits_1; inline;
    function  getI2C5SIE : TBits_1; inline;
    function  getIC1EIE : TBits_1; inline;
    function  getIC2EIE : TBits_1; inline;
    function  getIC3EIE : TBits_1; inline;
    function  getPMPIE : TBits_1; inline;
    function  getRTCCIE : TBits_1; inline;
    function  getSPI2AEIE : TBits_1; inline;
    function  getSPI2ARXIE : TBits_1; inline;
    function  getSPI2ATXIE : TBits_1; inline;
    function  getSPI2EIE : TBits_1; inline;
    function  getSPI2RXIE : TBits_1; inline;
    function  getSPI2TXIE : TBits_1; inline;
    function  getSPI3AEIE : TBits_1; inline;
    function  getSPI3ARXIE : TBits_1; inline;
    function  getSPI3ATXIE : TBits_1; inline;
    function  getSPI4EIE : TBits_1; inline;
    function  getSPI4RXIE : TBits_1; inline;
    function  getSPI4TXIE : TBits_1; inline;
    function  getU2AEIE : TBits_1; inline;
    function  getU2ARXIE : TBits_1; inline;
    function  getU2ATXIE : TBits_1; inline;
    function  getU2EIE : TBits_1; inline;
    function  getU2RXIE : TBits_1; inline;
    function  getU2TXIE : TBits_1; inline;
    function  getU3AEIE : TBits_1; inline;
    function  getU3ARXIE : TBits_1; inline;
    function  getU3ATXIE : TBits_1; inline;
    function  getU3EIE : TBits_1; inline;
    function  getU3RXIE : TBits_1; inline;
    function  getU3TXIE : TBits_1; inline;
    function  getUSBIE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAD1IE(thebits : TBits_1); inline;
    procedure setCAN1IE(thebits : TBits_1); inline;
    procedure setCMP1IE(thebits : TBits_1); inline;
    procedure setCMP2IE(thebits : TBits_1); inline;
    procedure setCNIE(thebits : TBits_1); inline;
    procedure setDMA0IE(thebits : TBits_1); inline;
    procedure setDMA1IE(thebits : TBits_1); inline;
    procedure setDMA2IE(thebits : TBits_1); inline;
    procedure setDMA3IE(thebits : TBits_1); inline;
    procedure setFCEIE(thebits : TBits_1); inline;
    procedure setFSCMIE(thebits : TBits_1); inline;
    procedure setI2C2ABIE(thebits : TBits_1); inline;
    procedure setI2C2AMIE(thebits : TBits_1); inline;
    procedure setI2C2ASIE(thebits : TBits_1); inline;
    procedure setI2C3ABIE(thebits : TBits_1); inline;
    procedure setI2C3AMIE(thebits : TBits_1); inline;
    procedure setI2C3ASIE(thebits : TBits_1); inline;
    procedure setI2C4BIE(thebits : TBits_1); inline;
    procedure setI2C4MIE(thebits : TBits_1); inline;
    procedure setI2C4SIE(thebits : TBits_1); inline;
    procedure setI2C5BIE(thebits : TBits_1); inline;
    procedure setI2C5MIE(thebits : TBits_1); inline;
    procedure setI2C5SIE(thebits : TBits_1); inline;
    procedure setIC1EIE(thebits : TBits_1); inline;
    procedure setIC2EIE(thebits : TBits_1); inline;
    procedure setIC3EIE(thebits : TBits_1); inline;
    procedure setPMPIE(thebits : TBits_1); inline;
    procedure setRTCCIE(thebits : TBits_1); inline;
    procedure setSPI2AEIE(thebits : TBits_1); inline;
    procedure setSPI2ARXIE(thebits : TBits_1); inline;
    procedure setSPI2ATXIE(thebits : TBits_1); inline;
    procedure setSPI2EIE(thebits : TBits_1); inline;
    procedure setSPI2RXIE(thebits : TBits_1); inline;
    procedure setSPI2TXIE(thebits : TBits_1); inline;
    procedure setSPI3AEIE(thebits : TBits_1); inline;
    procedure setSPI3ARXIE(thebits : TBits_1); inline;
    procedure setSPI3ATXIE(thebits : TBits_1); inline;
    procedure setSPI4EIE(thebits : TBits_1); inline;
    procedure setSPI4RXIE(thebits : TBits_1); inline;
    procedure setSPI4TXIE(thebits : TBits_1); inline;
    procedure setU2AEIE(thebits : TBits_1); inline;
    procedure setU2ARXIE(thebits : TBits_1); inline;
    procedure setU2ATXIE(thebits : TBits_1); inline;
    procedure setU2EIE(thebits : TBits_1); inline;
    procedure setU2RXIE(thebits : TBits_1); inline;
    procedure setU2TXIE(thebits : TBits_1); inline;
    procedure setU3AEIE(thebits : TBits_1); inline;
    procedure setU3ARXIE(thebits : TBits_1); inline;
    procedure setU3ATXIE(thebits : TBits_1); inline;
    procedure setU3EIE(thebits : TBits_1); inline;
    procedure setU3RXIE(thebits : TBits_1); inline;
    procedure setU3TXIE(thebits : TBits_1); inline;
    procedure setUSBIE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAD1IE; inline;
    procedure clearCAN1IE; inline;
    procedure clearCMP1IE; inline;
    procedure clearCMP2IE; inline;
    procedure clearCNIE; inline;
    procedure clearDMA0IE; inline;
    procedure clearDMA1IE; inline;
    procedure clearDMA2IE; inline;
    procedure clearDMA3IE; inline;
    procedure clearFCEIE; inline;
    procedure clearFSCMIE; inline;
    procedure clearI2C2ABIE; inline;
    procedure clearI2C2AMIE; inline;
    procedure clearI2C2ASIE; inline;
    procedure clearI2C3ABIE; inline;
    procedure clearI2C3AMIE; inline;
    procedure clearI2C3ASIE; inline;
    procedure clearI2C4BIE; inline;
    procedure clearI2C4MIE; inline;
    procedure clearI2C4SIE; inline;
    procedure clearI2C5BIE; inline;
    procedure clearI2C5MIE; inline;
    procedure clearI2C5SIE; inline;
    procedure clearIC1EIE; inline;
    procedure clearIC2EIE; inline;
    procedure clearIC3EIE; inline;
    procedure clearPMPIE; inline;
    procedure clearRTCCIE; inline;
    procedure clearSPI2AEIE; inline;
    procedure clearSPI2ARXIE; inline;
    procedure clearSPI2ATXIE; inline;
    procedure clearSPI2EIE; inline;
    procedure clearSPI2RXIE; inline;
    procedure clearSPI2TXIE; inline;
    procedure clearSPI3AEIE; inline;
    procedure clearSPI3ARXIE; inline;
    procedure clearSPI3ATXIE; inline;
    procedure clearSPI4EIE; inline;
    procedure clearSPI4RXIE; inline;
    procedure clearSPI4TXIE; inline;
    procedure clearU2AEIE; inline;
    procedure clearU2ARXIE; inline;
    procedure clearU2ATXIE; inline;
    procedure clearU2EIE; inline;
    procedure clearU2RXIE; inline;
    procedure clearU2TXIE; inline;
    procedure clearU3AEIE; inline;
    procedure clearU3ARXIE; inline;
    procedure clearU3ATXIE; inline;
    procedure clearU3EIE; inline;
    procedure clearU3RXIE; inline;
    procedure clearU3TXIE; inline;
    procedure clearUSBIE; inline;
    procedure setAD1IE; inline;
    procedure setCAN1IE; inline;
    procedure setCMP1IE; inline;
    procedure setCMP2IE; inline;
    procedure setCNIE; inline;
    procedure setDMA0IE; inline;
    procedure setDMA1IE; inline;
    procedure setDMA2IE; inline;
    procedure setDMA3IE; inline;
    procedure setFCEIE; inline;
    procedure setFSCMIE; inline;
    procedure setI2C2ABIE; inline;
    procedure setI2C2AMIE; inline;
    procedure setI2C2ASIE; inline;
    procedure setI2C3ABIE; inline;
    procedure setI2C3AMIE; inline;
    procedure setI2C3ASIE; inline;
    procedure setI2C4BIE; inline;
    procedure setI2C4MIE; inline;
    procedure setI2C4SIE; inline;
    procedure setI2C5BIE; inline;
    procedure setI2C5MIE; inline;
    procedure setI2C5SIE; inline;
    procedure setIC1EIE; inline;
    procedure setIC2EIE; inline;
    procedure setIC3EIE; inline;
    procedure setPMPIE; inline;
    procedure setRTCCIE; inline;
    procedure setSPI2AEIE; inline;
    procedure setSPI2ARXIE; inline;
    procedure setSPI2ATXIE; inline;
    procedure setSPI2EIE; inline;
    procedure setSPI2RXIE; inline;
    procedure setSPI2TXIE; inline;
    procedure setSPI3AEIE; inline;
    procedure setSPI3ARXIE; inline;
    procedure setSPI3ATXIE; inline;
    procedure setSPI4EIE; inline;
    procedure setSPI4RXIE; inline;
    procedure setSPI4TXIE; inline;
    procedure setU2AEIE; inline;
    procedure setU2ARXIE; inline;
    procedure setU2ATXIE; inline;
    procedure setU2EIE; inline;
    procedure setU2RXIE; inline;
    procedure setU2TXIE; inline;
    procedure setU3AEIE; inline;
    procedure setU3ARXIE; inline;
    procedure setU3ATXIE; inline;
    procedure setU3EIE; inline;
    procedure setU3RXIE; inline;
    procedure setU3TXIE; inline;
    procedure setUSBIE; inline;
    property AD1IE : TBits_1 read getAD1IE write setAD1IE;
    property CAN1IE : TBits_1 read getCAN1IE write setCAN1IE;
    property CMP1IE : TBits_1 read getCMP1IE write setCMP1IE;
    property CMP2IE : TBits_1 read getCMP2IE write setCMP2IE;
    property CNIE : TBits_1 read getCNIE write setCNIE;
    property DMA0IE : TBits_1 read getDMA0IE write setDMA0IE;
    property DMA1IE : TBits_1 read getDMA1IE write setDMA1IE;
    property DMA2IE : TBits_1 read getDMA2IE write setDMA2IE;
    property DMA3IE : TBits_1 read getDMA3IE write setDMA3IE;
    property FCEIE : TBits_1 read getFCEIE write setFCEIE;
    property FSCMIE : TBits_1 read getFSCMIE write setFSCMIE;
    property I2C2ABIE : TBits_1 read getI2C2ABIE write setI2C2ABIE;
    property I2C2AMIE : TBits_1 read getI2C2AMIE write setI2C2AMIE;
    property I2C2ASIE : TBits_1 read getI2C2ASIE write setI2C2ASIE;
    property I2C3ABIE : TBits_1 read getI2C3ABIE write setI2C3ABIE;
    property I2C3AMIE : TBits_1 read getI2C3AMIE write setI2C3AMIE;
    property I2C3ASIE : TBits_1 read getI2C3ASIE write setI2C3ASIE;
    property I2C4BIE : TBits_1 read getI2C4BIE write setI2C4BIE;
    property I2C4MIE : TBits_1 read getI2C4MIE write setI2C4MIE;
    property I2C4SIE : TBits_1 read getI2C4SIE write setI2C4SIE;
    property I2C5BIE : TBits_1 read getI2C5BIE write setI2C5BIE;
    property I2C5MIE : TBits_1 read getI2C5MIE write setI2C5MIE;
    property I2C5SIE : TBits_1 read getI2C5SIE write setI2C5SIE;
    property IC1EIE : TBits_1 read getIC1EIE write setIC1EIE;
    property IC2EIE : TBits_1 read getIC2EIE write setIC2EIE;
    property IC3EIE : TBits_1 read getIC3EIE write setIC3EIE;
    property PMPIE : TBits_1 read getPMPIE write setPMPIE;
    property RTCCIE : TBits_1 read getRTCCIE write setRTCCIE;
    property SPI2AEIE : TBits_1 read getSPI2AEIE write setSPI2AEIE;
    property SPI2ARXIE : TBits_1 read getSPI2ARXIE write setSPI2ARXIE;
    property SPI2ATXIE : TBits_1 read getSPI2ATXIE write setSPI2ATXIE;
    property SPI2EIE : TBits_1 read getSPI2EIE write setSPI2EIE;
    property SPI2RXIE : TBits_1 read getSPI2RXIE write setSPI2RXIE;
    property SPI2TXIE : TBits_1 read getSPI2TXIE write setSPI2TXIE;
    property SPI3AEIE : TBits_1 read getSPI3AEIE write setSPI3AEIE;
    property SPI3ARXIE : TBits_1 read getSPI3ARXIE write setSPI3ARXIE;
    property SPI3ATXIE : TBits_1 read getSPI3ATXIE write setSPI3ATXIE;
    property SPI4EIE : TBits_1 read getSPI4EIE write setSPI4EIE;
    property SPI4RXIE : TBits_1 read getSPI4RXIE write setSPI4RXIE;
    property SPI4TXIE : TBits_1 read getSPI4TXIE write setSPI4TXIE;
    property U2AEIE : TBits_1 read getU2AEIE write setU2AEIE;
    property U2ARXIE : TBits_1 read getU2ARXIE write setU2ARXIE;
    property U2ATXIE : TBits_1 read getU2ATXIE write setU2ATXIE;
    property U2EIE : TBits_1 read getU2EIE write setU2EIE;
    property U2RXIE : TBits_1 read getU2RXIE write setU2RXIE;
    property U2TXIE : TBits_1 read getU2TXIE write setU2TXIE;
    property U3AEIE : TBits_1 read getU3AEIE write setU3AEIE;
    property U3ARXIE : TBits_1 read getU3ARXIE write setU3ARXIE;
    property U3ATXIE : TBits_1 read getU3ATXIE write setU3ATXIE;
    property U3EIE : TBits_1 read getU3EIE write setU3EIE;
    property U3RXIE : TBits_1 read getU3RXIE write setU3RXIE;
    property U3TXIE : TBits_1 read getU3TXIE write setU3TXIE;
    property USBIE : TBits_1 read getUSBIE write setUSBIE;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IEC2 = record
  private
    function  getIC4EIE : TBits_1; inline;
    function  getIC5EIE : TBits_1; inline;
    function  getPMPEIE : TBits_1; inline;
    function  getU1BEIE : TBits_1; inline;
    function  getU1BRXIE : TBits_1; inline;
    function  getU1BTXIE : TBits_1; inline;
    function  getU2BEIE : TBits_1; inline;
    function  getU2BRXIE : TBits_1; inline;
    function  getU2BTXIE : TBits_1; inline;
    function  getU3BEIE : TBits_1; inline;
    function  getU3BRXIE : TBits_1; inline;
    function  getU3BTXIE : TBits_1; inline;
    function  getU4EIE : TBits_1; inline;
    function  getU4RXIE : TBits_1; inline;
    function  getU4TXIE : TBits_1; inline;
    function  getU5EIE : TBits_1; inline;
    function  getU5RXIE : TBits_1; inline;
    function  getU5TXIE : TBits_1; inline;
    function  getU6EIE : TBits_1; inline;
    function  getU6RXIE : TBits_1; inline;
    function  getU6TXIE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setIC4EIE(thebits : TBits_1); inline;
    procedure setIC5EIE(thebits : TBits_1); inline;
    procedure setPMPEIE(thebits : TBits_1); inline;
    procedure setU1BEIE(thebits : TBits_1); inline;
    procedure setU1BRXIE(thebits : TBits_1); inline;
    procedure setU1BTXIE(thebits : TBits_1); inline;
    procedure setU2BEIE(thebits : TBits_1); inline;
    procedure setU2BRXIE(thebits : TBits_1); inline;
    procedure setU2BTXIE(thebits : TBits_1); inline;
    procedure setU3BEIE(thebits : TBits_1); inline;
    procedure setU3BRXIE(thebits : TBits_1); inline;
    procedure setU3BTXIE(thebits : TBits_1); inline;
    procedure setU4EIE(thebits : TBits_1); inline;
    procedure setU4RXIE(thebits : TBits_1); inline;
    procedure setU4TXIE(thebits : TBits_1); inline;
    procedure setU5EIE(thebits : TBits_1); inline;
    procedure setU5RXIE(thebits : TBits_1); inline;
    procedure setU5TXIE(thebits : TBits_1); inline;
    procedure setU6EIE(thebits : TBits_1); inline;
    procedure setU6RXIE(thebits : TBits_1); inline;
    procedure setU6TXIE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearIC4EIE; inline;
    procedure clearIC5EIE; inline;
    procedure clearPMPEIE; inline;
    procedure clearU1BEIE; inline;
    procedure clearU1BRXIE; inline;
    procedure clearU1BTXIE; inline;
    procedure clearU2BEIE; inline;
    procedure clearU2BRXIE; inline;
    procedure clearU2BTXIE; inline;
    procedure clearU3BEIE; inline;
    procedure clearU3BRXIE; inline;
    procedure clearU3BTXIE; inline;
    procedure clearU4EIE; inline;
    procedure clearU4RXIE; inline;
    procedure clearU4TXIE; inline;
    procedure clearU5EIE; inline;
    procedure clearU5RXIE; inline;
    procedure clearU5TXIE; inline;
    procedure clearU6EIE; inline;
    procedure clearU6RXIE; inline;
    procedure clearU6TXIE; inline;
    procedure setIC4EIE; inline;
    procedure setIC5EIE; inline;
    procedure setPMPEIE; inline;
    procedure setU1BEIE; inline;
    procedure setU1BRXIE; inline;
    procedure setU1BTXIE; inline;
    procedure setU2BEIE; inline;
    procedure setU2BRXIE; inline;
    procedure setU2BTXIE; inline;
    procedure setU3BEIE; inline;
    procedure setU3BRXIE; inline;
    procedure setU3BTXIE; inline;
    procedure setU4EIE; inline;
    procedure setU4RXIE; inline;
    procedure setU4TXIE; inline;
    procedure setU5EIE; inline;
    procedure setU5RXIE; inline;
    procedure setU5TXIE; inline;
    procedure setU6EIE; inline;
    procedure setU6RXIE; inline;
    procedure setU6TXIE; inline;
    property IC4EIE : TBits_1 read getIC4EIE write setIC4EIE;
    property IC5EIE : TBits_1 read getIC5EIE write setIC5EIE;
    property PMPEIE : TBits_1 read getPMPEIE write setPMPEIE;
    property U1BEIE : TBits_1 read getU1BEIE write setU1BEIE;
    property U1BRXIE : TBits_1 read getU1BRXIE write setU1BRXIE;
    property U1BTXIE : TBits_1 read getU1BTXIE write setU1BTXIE;
    property U2BEIE : TBits_1 read getU2BEIE write setU2BEIE;
    property U2BRXIE : TBits_1 read getU2BRXIE write setU2BRXIE;
    property U2BTXIE : TBits_1 read getU2BTXIE write setU2BTXIE;
    property U3BEIE : TBits_1 read getU3BEIE write setU3BEIE;
    property U3BRXIE : TBits_1 read getU3BRXIE write setU3BRXIE;
    property U3BTXIE : TBits_1 read getU3BTXIE write setU3BTXIE;
    property U4EIE : TBits_1 read getU4EIE write setU4EIE;
    property U4RXIE : TBits_1 read getU4RXIE write setU4RXIE;
    property U4TXIE : TBits_1 read getU4TXIE write setU4TXIE;
    property U5EIE : TBits_1 read getU5EIE write setU5EIE;
    property U5RXIE : TBits_1 read getU5RXIE write setU5RXIE;
    property U5TXIE : TBits_1 read getU5TXIE write setU5TXIE;
    property U6EIE : TBits_1 read getU6EIE write setU6EIE;
    property U6RXIE : TBits_1 read getU6RXIE write setU6RXIE;
    property U6TXIE : TBits_1 read getU6TXIE write setU6TXIE;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC0 = record
  private
    function  getCS0IP : TBits_3; inline;
    function  getCS0IS : TBits_2; inline;
    function  getCS1IP : TBits_3; inline;
    function  getCS1IS : TBits_2; inline;
    function  getCTIP : TBits_3; inline;
    function  getCTIS : TBits_2; inline;
    function  getINT0IP : TBits_3; inline;
    function  getINT0IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCS0IP(thebits : TBits_3); inline;
    procedure setCS0IS(thebits : TBits_2); inline;
    procedure setCS1IP(thebits : TBits_3); inline;
    procedure setCS1IS(thebits : TBits_2); inline;
    procedure setCTIP(thebits : TBits_3); inline;
    procedure setCTIS(thebits : TBits_2); inline;
    procedure setINT0IP(thebits : TBits_3); inline;
    procedure setINT0IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CS0IP : TBits_3 read getCS0IP write setCS0IP;
    property CS0IS : TBits_2 read getCS0IS write setCS0IS;
    property CS1IP : TBits_3 read getCS1IP write setCS1IP;
    property CS1IS : TBits_2 read getCS1IS write setCS1IS;
    property CTIP : TBits_3 read getCTIP write setCTIP;
    property CTIS : TBits_2 read getCTIS write setCTIS;
    property INT0IP : TBits_3 read getINT0IP write setINT0IP;
    property INT0IS : TBits_2 read getINT0IS write setINT0IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC1 = record
  private
    function  getIC1IP : TBits_3; inline;
    function  getIC1IS : TBits_2; inline;
    function  getINT1IP : TBits_3; inline;
    function  getINT1IS : TBits_2; inline;
    function  getOC1IP : TBits_3; inline;
    function  getOC1IS : TBits_2; inline;
    function  getT1IP : TBits_3; inline;
    function  getT1IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setIC1IP(thebits : TBits_3); inline;
    procedure setIC1IS(thebits : TBits_2); inline;
    procedure setINT1IP(thebits : TBits_3); inline;
    procedure setINT1IS(thebits : TBits_2); inline;
    procedure setOC1IP(thebits : TBits_3); inline;
    procedure setOC1IS(thebits : TBits_2); inline;
    procedure setT1IP(thebits : TBits_3); inline;
    procedure setT1IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property IC1IP : TBits_3 read getIC1IP write setIC1IP;
    property IC1IS : TBits_2 read getIC1IS write setIC1IS;
    property INT1IP : TBits_3 read getINT1IP write setINT1IP;
    property INT1IS : TBits_2 read getINT1IS write setINT1IS;
    property OC1IP : TBits_3 read getOC1IP write setOC1IP;
    property OC1IS : TBits_2 read getOC1IS write setOC1IS;
    property T1IP : TBits_3 read getT1IP write setT1IP;
    property T1IS : TBits_2 read getT1IS write setT1IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC2 = record
  private
    function  getIC2IP : TBits_3; inline;
    function  getIC2IS : TBits_2; inline;
    function  getINT2IP : TBits_3; inline;
    function  getINT2IS : TBits_2; inline;
    function  getOC2IP : TBits_3; inline;
    function  getOC2IS : TBits_2; inline;
    function  getT2IP : TBits_3; inline;
    function  getT2IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setIC2IP(thebits : TBits_3); inline;
    procedure setIC2IS(thebits : TBits_2); inline;
    procedure setINT2IP(thebits : TBits_3); inline;
    procedure setINT2IS(thebits : TBits_2); inline;
    procedure setOC2IP(thebits : TBits_3); inline;
    procedure setOC2IS(thebits : TBits_2); inline;
    procedure setT2IP(thebits : TBits_3); inline;
    procedure setT2IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property IC2IP : TBits_3 read getIC2IP write setIC2IP;
    property IC2IS : TBits_2 read getIC2IS write setIC2IS;
    property INT2IP : TBits_3 read getINT2IP write setINT2IP;
    property INT2IS : TBits_2 read getINT2IS write setINT2IS;
    property OC2IP : TBits_3 read getOC2IP write setOC2IP;
    property OC2IS : TBits_2 read getOC2IS write setOC2IS;
    property T2IP : TBits_3 read getT2IP write setT2IP;
    property T2IS : TBits_2 read getT2IS write setT2IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC3 = record
  private
    function  getIC3IP : TBits_3; inline;
    function  getIC3IS : TBits_2; inline;
    function  getINT3IP : TBits_3; inline;
    function  getINT3IS : TBits_2; inline;
    function  getOC3IP : TBits_3; inline;
    function  getOC3IS : TBits_2; inline;
    function  getT3IP : TBits_3; inline;
    function  getT3IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setIC3IP(thebits : TBits_3); inline;
    procedure setIC3IS(thebits : TBits_2); inline;
    procedure setINT3IP(thebits : TBits_3); inline;
    procedure setINT3IS(thebits : TBits_2); inline;
    procedure setOC3IP(thebits : TBits_3); inline;
    procedure setOC3IS(thebits : TBits_2); inline;
    procedure setT3IP(thebits : TBits_3); inline;
    procedure setT3IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property IC3IP : TBits_3 read getIC3IP write setIC3IP;
    property IC3IS : TBits_2 read getIC3IS write setIC3IS;
    property INT3IP : TBits_3 read getINT3IP write setINT3IP;
    property INT3IS : TBits_2 read getINT3IS write setINT3IS;
    property OC3IP : TBits_3 read getOC3IP write setOC3IP;
    property OC3IS : TBits_2 read getOC3IS write setOC3IS;
    property T3IP : TBits_3 read getT3IP write setT3IP;
    property T3IS : TBits_2 read getT3IS write setT3IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC4 = record
  private
    function  getIC4IP : TBits_3; inline;
    function  getIC4IS : TBits_2; inline;
    function  getINT4IP : TBits_3; inline;
    function  getINT4IS : TBits_2; inline;
    function  getOC4IP : TBits_3; inline;
    function  getOC4IS : TBits_2; inline;
    function  getT4IP : TBits_3; inline;
    function  getT4IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setIC4IP(thebits : TBits_3); inline;
    procedure setIC4IS(thebits : TBits_2); inline;
    procedure setINT4IP(thebits : TBits_3); inline;
    procedure setINT4IS(thebits : TBits_2); inline;
    procedure setOC4IP(thebits : TBits_3); inline;
    procedure setOC4IS(thebits : TBits_2); inline;
    procedure setT4IP(thebits : TBits_3); inline;
    procedure setT4IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property IC4IP : TBits_3 read getIC4IP write setIC4IP;
    property IC4IS : TBits_2 read getIC4IS write setIC4IS;
    property INT4IP : TBits_3 read getINT4IP write setINT4IP;
    property INT4IS : TBits_2 read getINT4IS write setINT4IS;
    property OC4IP : TBits_3 read getOC4IP write setOC4IP;
    property OC4IS : TBits_2 read getOC4IS write setOC4IS;
    property T4IP : TBits_3 read getT4IP write setT4IP;
    property T4IS : TBits_2 read getT4IS write setT4IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC5 = record
  private
    function  getIC5IP : TBits_3; inline;
    function  getIC5IS : TBits_2; inline;
    function  getOC5IP : TBits_3; inline;
    function  getOC5IS : TBits_2; inline;
    function  getT5IP : TBits_3; inline;
    function  getT5IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setIC5IP(thebits : TBits_3); inline;
    procedure setIC5IS(thebits : TBits_2); inline;
    procedure setOC5IP(thebits : TBits_3); inline;
    procedure setOC5IS(thebits : TBits_2); inline;
    procedure setT5IP(thebits : TBits_3); inline;
    procedure setT5IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property IC5IP : TBits_3 read getIC5IP write setIC5IP;
    property IC5IS : TBits_2 read getIC5IS write setIC5IS;
    property OC5IP : TBits_3 read getOC5IP write setOC5IP;
    property OC5IS : TBits_2 read getOC5IS write setOC5IS;
    property T5IP : TBits_3 read getT5IP write setT5IP;
    property T5IS : TBits_2 read getT5IS write setT5IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC6 = record
  private
    function  getAD1IP : TBits_3; inline;
    function  getAD1IS : TBits_2; inline;
    function  getCNIP : TBits_3; inline;
    function  getCNIS : TBits_2; inline;
    function  getI2C1AIP : TBits_3; inline;
    function  getI2C1AIS : TBits_2; inline;
    function  getI2C1IP : TBits_3; inline;
    function  getI2C1IS : TBits_2; inline;
    function  getI2C3IP : TBits_3; inline;
    function  getI2C3IS : TBits_2; inline;
    function  getSPI1AIP : TBits_3; inline;
    function  getSPI1AIS : TBits_2; inline;
    function  getSPI3IP : TBits_3; inline;
    function  getSPI3IS : TBits_2; inline;
    function  getU1AIP : TBits_3; inline;
    function  getU1AIS : TBits_2; inline;
    function  getU1IP : TBits_3; inline;
    function  getU1IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setAD1IP(thebits : TBits_3); inline;
    procedure setAD1IS(thebits : TBits_2); inline;
    procedure setCNIP(thebits : TBits_3); inline;
    procedure setCNIS(thebits : TBits_2); inline;
    procedure setI2C1AIP(thebits : TBits_3); inline;
    procedure setI2C1AIS(thebits : TBits_2); inline;
    procedure setI2C1IP(thebits : TBits_3); inline;
    procedure setI2C1IS(thebits : TBits_2); inline;
    procedure setI2C3IP(thebits : TBits_3); inline;
    procedure setI2C3IS(thebits : TBits_2); inline;
    procedure setSPI1AIP(thebits : TBits_3); inline;
    procedure setSPI1AIS(thebits : TBits_2); inline;
    procedure setSPI3IP(thebits : TBits_3); inline;
    procedure setSPI3IS(thebits : TBits_2); inline;
    procedure setU1AIP(thebits : TBits_3); inline;
    procedure setU1AIS(thebits : TBits_2); inline;
    procedure setU1IP(thebits : TBits_3); inline;
    procedure setU1IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property AD1IP : TBits_3 read getAD1IP write setAD1IP;
    property AD1IS : TBits_2 read getAD1IS write setAD1IS;
    property CNIP : TBits_3 read getCNIP write setCNIP;
    property CNIS : TBits_2 read getCNIS write setCNIS;
    property I2C1AIP : TBits_3 read getI2C1AIP write setI2C1AIP;
    property I2C1AIS : TBits_2 read getI2C1AIS write setI2C1AIS;
    property I2C1IP : TBits_3 read getI2C1IP write setI2C1IP;
    property I2C1IS : TBits_2 read getI2C1IS write setI2C1IS;
    property I2C3IP : TBits_3 read getI2C3IP write setI2C3IP;
    property I2C3IS : TBits_2 read getI2C3IS write setI2C3IS;
    property SPI1AIP : TBits_3 read getSPI1AIP write setSPI1AIP;
    property SPI1AIS : TBits_2 read getSPI1AIS write setSPI1AIS;
    property SPI3IP : TBits_3 read getSPI3IP write setSPI3IP;
    property SPI3IS : TBits_2 read getSPI3IS write setSPI3IS;
    property U1AIP : TBits_3 read getU1AIP write setU1AIP;
    property U1AIS : TBits_2 read getU1AIS write setU1AIS;
    property U1IP : TBits_3 read getU1IP write setU1IP;
    property U1IS : TBits_2 read getU1IS write setU1IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC7 = record
  private
    function  getCMP1IP : TBits_3; inline;
    function  getCMP1IS : TBits_2; inline;
    function  getCMP2IP : TBits_3; inline;
    function  getCMP2IS : TBits_2; inline;
    function  getI2C2AIP : TBits_3; inline;
    function  getI2C2AIS : TBits_2; inline;
    function  getI2C4IP : TBits_3; inline;
    function  getI2C4IS : TBits_2; inline;
    function  getPMPIP : TBits_3; inline;
    function  getPMPIS : TBits_2; inline;
    function  getSPI2AIP : TBits_3; inline;
    function  getSPI2AIS : TBits_2; inline;
    function  getSPI2IP : TBits_3; inline;
    function  getSPI2IS : TBits_2; inline;
    function  getU2AIP : TBits_3; inline;
    function  getU2AIS : TBits_2; inline;
    function  getU3IP : TBits_3; inline;
    function  getU3IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCMP1IP(thebits : TBits_3); inline;
    procedure setCMP1IS(thebits : TBits_2); inline;
    procedure setCMP2IP(thebits : TBits_3); inline;
    procedure setCMP2IS(thebits : TBits_2); inline;
    procedure setI2C2AIP(thebits : TBits_3); inline;
    procedure setI2C2AIS(thebits : TBits_2); inline;
    procedure setI2C4IP(thebits : TBits_3); inline;
    procedure setI2C4IS(thebits : TBits_2); inline;
    procedure setPMPIP(thebits : TBits_3); inline;
    procedure setPMPIS(thebits : TBits_2); inline;
    procedure setSPI2AIP(thebits : TBits_3); inline;
    procedure setSPI2AIS(thebits : TBits_2); inline;
    procedure setSPI2IP(thebits : TBits_3); inline;
    procedure setSPI2IS(thebits : TBits_2); inline;
    procedure setU2AIP(thebits : TBits_3); inline;
    procedure setU2AIS(thebits : TBits_2); inline;
    procedure setU3IP(thebits : TBits_3); inline;
    procedure setU3IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CMP1IP : TBits_3 read getCMP1IP write setCMP1IP;
    property CMP1IS : TBits_2 read getCMP1IS write setCMP1IS;
    property CMP2IP : TBits_3 read getCMP2IP write setCMP2IP;
    property CMP2IS : TBits_2 read getCMP2IS write setCMP2IS;
    property I2C2AIP : TBits_3 read getI2C2AIP write setI2C2AIP;
    property I2C2AIS : TBits_2 read getI2C2AIS write setI2C2AIS;
    property I2C4IP : TBits_3 read getI2C4IP write setI2C4IP;
    property I2C4IS : TBits_2 read getI2C4IS write setI2C4IS;
    property PMPIP : TBits_3 read getPMPIP write setPMPIP;
    property PMPIS : TBits_2 read getPMPIS write setPMPIS;
    property SPI2AIP : TBits_3 read getSPI2AIP write setSPI2AIP;
    property SPI2AIS : TBits_2 read getSPI2AIS write setSPI2AIS;
    property SPI2IP : TBits_3 read getSPI2IP write setSPI2IP;
    property SPI2IS : TBits_2 read getSPI2IS write setSPI2IS;
    property U2AIP : TBits_3 read getU2AIP write setU2AIP;
    property U2AIS : TBits_2 read getU2AIS write setU2AIS;
    property U3IP : TBits_3 read getU3IP write setU3IP;
    property U3IS : TBits_2 read getU3IS write setU3IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC8 = record
  private
    function  getFSCMIP : TBits_3; inline;
    function  getFSCMIS : TBits_2; inline;
    function  getI2C3AIP : TBits_3; inline;
    function  getI2C3AIS : TBits_2; inline;
    function  getI2C5IP : TBits_3; inline;
    function  getI2C5IS : TBits_2; inline;
    function  getRTCCIP : TBits_3; inline;
    function  getRTCCIS : TBits_2; inline;
    function  getSPI3AIP : TBits_3; inline;
    function  getSPI3AIS : TBits_2; inline;
    function  getSPI4IP : TBits_3; inline;
    function  getSPI4IS : TBits_2; inline;
    function  getU2IP : TBits_3; inline;
    function  getU2IS : TBits_2; inline;
    function  getU3AIP : TBits_3; inline;
    function  getU3AIS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setFSCMIP(thebits : TBits_3); inline;
    procedure setFSCMIS(thebits : TBits_2); inline;
    procedure setI2C3AIP(thebits : TBits_3); inline;
    procedure setI2C3AIS(thebits : TBits_2); inline;
    procedure setI2C5IP(thebits : TBits_3); inline;
    procedure setI2C5IS(thebits : TBits_2); inline;
    procedure setRTCCIP(thebits : TBits_3); inline;
    procedure setRTCCIS(thebits : TBits_2); inline;
    procedure setSPI3AIP(thebits : TBits_3); inline;
    procedure setSPI3AIS(thebits : TBits_2); inline;
    procedure setSPI4IP(thebits : TBits_3); inline;
    procedure setSPI4IS(thebits : TBits_2); inline;
    procedure setU2IP(thebits : TBits_3); inline;
    procedure setU2IS(thebits : TBits_2); inline;
    procedure setU3AIP(thebits : TBits_3); inline;
    procedure setU3AIS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property FSCMIP : TBits_3 read getFSCMIP write setFSCMIP;
    property FSCMIS : TBits_2 read getFSCMIS write setFSCMIS;
    property I2C3AIP : TBits_3 read getI2C3AIP write setI2C3AIP;
    property I2C3AIS : TBits_2 read getI2C3AIS write setI2C3AIS;
    property I2C5IP : TBits_3 read getI2C5IP write setI2C5IP;
    property I2C5IS : TBits_2 read getI2C5IS write setI2C5IS;
    property RTCCIP : TBits_3 read getRTCCIP write setRTCCIP;
    property RTCCIS : TBits_2 read getRTCCIS write setRTCCIS;
    property SPI3AIP : TBits_3 read getSPI3AIP write setSPI3AIP;
    property SPI3AIS : TBits_2 read getSPI3AIS write setSPI3AIS;
    property SPI4IP : TBits_3 read getSPI4IP write setSPI4IP;
    property SPI4IS : TBits_2 read getSPI4IS write setSPI4IS;
    property U2IP : TBits_3 read getU2IP write setU2IP;
    property U2IS : TBits_2 read getU2IS write setU2IS;
    property U3AIP : TBits_3 read getU3AIP write setU3AIP;
    property U3AIS : TBits_2 read getU3AIS write setU3AIS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC9 = record
  private
    function  getDMA0IP : TBits_3; inline;
    function  getDMA0IS : TBits_2; inline;
    function  getDMA1IP : TBits_3; inline;
    function  getDMA1IS : TBits_2; inline;
    function  getDMA2IP : TBits_3; inline;
    function  getDMA2IS : TBits_2; inline;
    function  getDMA3IP : TBits_3; inline;
    function  getDMA3IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setDMA0IP(thebits : TBits_3); inline;
    procedure setDMA0IS(thebits : TBits_2); inline;
    procedure setDMA1IP(thebits : TBits_3); inline;
    procedure setDMA1IS(thebits : TBits_2); inline;
    procedure setDMA2IP(thebits : TBits_3); inline;
    procedure setDMA2IS(thebits : TBits_2); inline;
    procedure setDMA3IP(thebits : TBits_3); inline;
    procedure setDMA3IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DMA0IP : TBits_3 read getDMA0IP write setDMA0IP;
    property DMA0IS : TBits_2 read getDMA0IS write setDMA0IS;
    property DMA1IP : TBits_3 read getDMA1IP write setDMA1IP;
    property DMA1IS : TBits_2 read getDMA1IS write setDMA1IS;
    property DMA2IP : TBits_3 read getDMA2IP write setDMA2IP;
    property DMA2IS : TBits_2 read getDMA2IS write setDMA2IS;
    property DMA3IP : TBits_3 read getDMA3IP write setDMA3IP;
    property DMA3IS : TBits_2 read getDMA3IS write setDMA3IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC11 = record
  private
    function  getCAN1IP : TBits_3; inline;
    function  getCAN1IS : TBits_2; inline;
    function  getFCEIP : TBits_3; inline;
    function  getFCEIS : TBits_2; inline;
    function  getUSBIP : TBits_3; inline;
    function  getUSBIS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCAN1IP(thebits : TBits_3); inline;
    procedure setCAN1IS(thebits : TBits_2); inline;
    procedure setFCEIP(thebits : TBits_3); inline;
    procedure setFCEIS(thebits : TBits_2); inline;
    procedure setUSBIP(thebits : TBits_3); inline;
    procedure setUSBIS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CAN1IP : TBits_3 read getCAN1IP write setCAN1IP;
    property CAN1IS : TBits_2 read getCAN1IS write setCAN1IS;
    property FCEIP : TBits_3 read getFCEIP write setFCEIP;
    property FCEIS : TBits_2 read getFCEIS write setFCEIS;
    property USBIP : TBits_3 read getUSBIP write setUSBIP;
    property USBIS : TBits_2 read getUSBIS write setUSBIS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC12 = record
  private
    function  getU1BIP : TBits_3; inline;
    function  getU1BIS : TBits_2; inline;
    function  getU2BIP : TBits_3; inline;
    function  getU2BIS : TBits_2; inline;
    function  getU3BIP : TBits_3; inline;
    function  getU3BIS : TBits_2; inline;
    function  getU4IP : TBits_3; inline;
    function  getU4IS : TBits_2; inline;
    function  getU5IP : TBits_3; inline;
    function  getU5IS : TBits_2; inline;
    function  getU6IP : TBits_3; inline;
    function  getU6IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setU1BIP(thebits : TBits_3); inline;
    procedure setU1BIS(thebits : TBits_2); inline;
    procedure setU2BIP(thebits : TBits_3); inline;
    procedure setU2BIS(thebits : TBits_2); inline;
    procedure setU3BIP(thebits : TBits_3); inline;
    procedure setU3BIS(thebits : TBits_2); inline;
    procedure setU4IP(thebits : TBits_3); inline;
    procedure setU4IS(thebits : TBits_2); inline;
    procedure setU5IP(thebits : TBits_3); inline;
    procedure setU5IS(thebits : TBits_2); inline;
    procedure setU6IP(thebits : TBits_3); inline;
    procedure setU6IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property U1BIP : TBits_3 read getU1BIP write setU1BIP;
    property U1BIS : TBits_2 read getU1BIS write setU1BIS;
    property U2BIP : TBits_3 read getU2BIP write setU2BIP;
    property U2BIS : TBits_2 read getU2BIS write setU2BIS;
    property U3BIP : TBits_3 read getU3BIP write setU3BIP;
    property U3BIS : TBits_2 read getU3BIS write setU3BIS;
    property U4IP : TBits_3 read getU4IP write setU4IP;
    property U4IS : TBits_2 read getU4IS write setU4IS;
    property U5IP : TBits_3 read getU5IP write setU5IP;
    property U5IS : TBits_2 read getU5IS write setU5IS;
    property U6IP : TBits_3 read getU6IP write setU6IP;
    property U6IS : TBits_2 read getU6IS write setU6IS;
    property w : TBits_32 read getw write setw;
  end;
type
  TINTRegisters = record
    INTCONbits : TINT_INTCON;
    INTCON : longWord;
    INTCONCLR : longWord;
    INTCONSET : longWord;
    INTCONINV : longWord;
    INTSTAT : longWord;
    IPTMR : longWord;
    IPTMRCLR : longWord;
    IPTMRSET : longWord;
    IPTMRINV : longWord;
    IFS0bits : TINT_IFS0;
    IFS0 : longWord;
    IFS0CLR : longWord;
    IFS0SET : longWord;
    IFS0INV : longWord;
    IFS1bits : TINT_IFS1;
    IFS1 : longWord;
    IFS1CLR : longWord;
    IFS1SET : longWord;
    IFS1INV : longWord;
    IFS2bits : TINT_IFS2;
    IFS2 : longWord;
    IFS2CLR : longWord;
    IFS2SET : longWord;
    IFS2INV : longWord;
    IEC0bits : TINT_IEC0;
    IEC0 : longWord;
    IEC0CLR : longWord;
    IEC0SET : longWord;
    IEC0INV : longWord;
    IEC1bits : TINT_IEC1;
    IEC1 : longWord;
    IEC1CLR : longWord;
    IEC1SET : longWord;
    IEC1INV : longWord;
    IEC2bits : TINT_IEC2;
    IEC2 : longWord;
    IEC2CLR : longWord;
    IEC2SET : longWord;
    IEC2INV : longWord;
    IPC0bits : TINT_IPC0;
    IPC0 : longWord;
    IPC0CLR : longWord;
    IPC0SET : longWord;
    IPC0INV : longWord;
    IPC1bits : TINT_IPC1;
    IPC1 : longWord;
    IPC1CLR : longWord;
    IPC1SET : longWord;
    IPC1INV : longWord;
    IPC2bits : TINT_IPC2;
    IPC2 : longWord;
    IPC2CLR : longWord;
    IPC2SET : longWord;
    IPC2INV : longWord;
    IPC3bits : TINT_IPC3;
    IPC3 : longWord;
    IPC3CLR : longWord;
    IPC3SET : longWord;
    IPC3INV : longWord;
    IPC4bits : TINT_IPC4;
    IPC4 : longWord;
    IPC4CLR : longWord;
    IPC4SET : longWord;
    IPC4INV : longWord;
    IPC5bits : TINT_IPC5;
    IPC5 : longWord;
    IPC5CLR : longWord;
    IPC5SET : longWord;
    IPC5INV : longWord;
    IPC6bits : TINT_IPC6;
    IPC6 : longWord;
    IPC6CLR : longWord;
    IPC6SET : longWord;
    IPC6INV : longWord;
    IPC7bits : TINT_IPC7;
    IPC7 : longWord;
    IPC7CLR : longWord;
    IPC7SET : longWord;
    IPC7INV : longWord;
    IPC8bits : TINT_IPC8;
    IPC8 : longWord;
    IPC8CLR : longWord;
    IPC8SET : longWord;
    IPC8INV : longWord;
    IPC9bits : TINT_IPC9;
    IPC9 : longWord;
    IPC9CLR : longWord;
    IPC9SET : longWord;
    IPC9INV : longWord;
    IPC10 : longWord;
    IPC10CLR : longWord;
    IPC10SET : longWord;
    IPC10INV : longWord;
    IPC11bits : TINT_IPC11;
    IPC11 : longWord;
    IPC11CLR : longWord;
    IPC11SET : longWord;
    IPC11INV : longWord;
    IPC12bits : TINT_IPC12;
    IPC12 : longWord;
    IPC12CLR : longWord;
    IPC12SET : longWord;
    IPC12INV : longWord;
  end;
  TBMX_BMXCON = record
  private
    function  getBMXARB : TBits_3; inline;
    function  getBMXCHEDMA : TBits_1; inline;
    function  getBMXERRDMA : TBits_1; inline;
    function  getBMXERRDS : TBits_1; inline;
    function  getBMXERRICD : TBits_1; inline;
    function  getBMXERRIS : TBits_1; inline;
    function  getBMXERRIXI : TBits_1; inline;
    function  getBMXWSDRM : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBMXARB(thebits : TBits_3); inline;
    procedure setBMXCHEDMA(thebits : TBits_1); inline;
    procedure setBMXERRDMA(thebits : TBits_1); inline;
    procedure setBMXERRDS(thebits : TBits_1); inline;
    procedure setBMXERRICD(thebits : TBits_1); inline;
    procedure setBMXERRIS(thebits : TBits_1); inline;
    procedure setBMXERRIXI(thebits : TBits_1); inline;
    procedure setBMXWSDRM(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBMXCHEDMA; inline;
    procedure clearBMXERRDMA; inline;
    procedure clearBMXERRDS; inline;
    procedure clearBMXERRICD; inline;
    procedure clearBMXERRIS; inline;
    procedure clearBMXERRIXI; inline;
    procedure clearBMXWSDRM; inline;
    procedure setBMXCHEDMA; inline;
    procedure setBMXERRDMA; inline;
    procedure setBMXERRDS; inline;
    procedure setBMXERRICD; inline;
    procedure setBMXERRIS; inline;
    procedure setBMXERRIXI; inline;
    procedure setBMXWSDRM; inline;
    property BMXARB : TBits_3 read getBMXARB write setBMXARB;
    property BMXCHEDMA : TBits_1 read getBMXCHEDMA write setBMXCHEDMA;
    property BMXERRDMA : TBits_1 read getBMXERRDMA write setBMXERRDMA;
    property BMXERRDS : TBits_1 read getBMXERRDS write setBMXERRDS;
    property BMXERRICD : TBits_1 read getBMXERRICD write setBMXERRICD;
    property BMXERRIS : TBits_1 read getBMXERRIS write setBMXERRIS;
    property BMXERRIXI : TBits_1 read getBMXERRIXI write setBMXERRIXI;
    property BMXWSDRM : TBits_1 read getBMXWSDRM write setBMXWSDRM;
    property w : TBits_32 read getw write setw;
  end;
type
  TBMXRegisters = record
    BMXCONbits : TBMX_BMXCON;
    BMXCON : longWord;
    BMXCONCLR : longWord;
    BMXCONSET : longWord;
    BMXCONINV : longWord;
    BMXDKPBA : longWord;
    BMXDKPBACLR : longWord;
    BMXDKPBASET : longWord;
    BMXDKPBAINV : longWord;
    BMXDUDBA : longWord;
    BMXDUDBACLR : longWord;
    BMXDUDBASET : longWord;
    BMXDUDBAINV : longWord;
    BMXDUPBA : longWord;
    BMXDUPBACLR : longWord;
    BMXDUPBASET : longWord;
    BMXDUPBAINV : longWord;
    BMXDRMSZ : longWord;
    BMXPUPBA : longWord;
    BMXPUPBACLR : longWord;
    BMXPUPBASET : longWord;
    BMXPUPBAINV : longWord;
    BMXPFMSZ : longWord;
    BMXBOOTSZ : longWord;
  end;
  TDMAC_DMACON = record
  private
    function  getDMABUSY : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSUSPEND : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDMABUSY(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSUSPEND(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDMABUSY; inline;
    procedure clearON; inline;
    procedure clearSUSPEND; inline;
    procedure setDMABUSY; inline;
    procedure setON; inline;
    procedure setSUSPEND; inline;
    property DMABUSY : TBits_1 read getDMABUSY write setDMABUSY;
    property ON : TBits_1 read getON write setON;
    property SUSPEND : TBits_1 read getSUSPEND write setSUSPEND;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC_DMASTAT = record
  private
    function  getDMACH : TBits_3; inline;
    function  getRDWR : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDMACH(thebits : TBits_3); inline;
    procedure setRDWR(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRDWR; inline;
    procedure setRDWR; inline;
    property DMACH : TBits_3 read getDMACH write setDMACH;
    property RDWR : TBits_1 read getRDWR write setRDWR;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC_DCRCCON = record
  private
    function  getBITO : TBits_1; inline;
    function  getBYTO : TBits_2; inline;
    function  getCRCAPP : TBits_1; inline;
    function  getCRCCH : TBits_3; inline;
    function  getCRCEN : TBits_1; inline;
    function  getCRCTYP : TBits_1; inline;
    function  getPLEN : TBits_5; inline;
    function  getWBO : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBITO(thebits : TBits_1); inline;
    procedure setBYTO(thebits : TBits_2); inline;
    procedure setCRCAPP(thebits : TBits_1); inline;
    procedure setCRCCH(thebits : TBits_3); inline;
    procedure setCRCEN(thebits : TBits_1); inline;
    procedure setCRCTYP(thebits : TBits_1); inline;
    procedure setPLEN(thebits : TBits_5); inline;
    procedure setWBO(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBITO; inline;
    procedure clearCRCAPP; inline;
    procedure clearCRCEN; inline;
    procedure clearCRCTYP; inline;
    procedure clearWBO; inline;
    procedure setBITO; inline;
    procedure setCRCAPP; inline;
    procedure setCRCEN; inline;
    procedure setCRCTYP; inline;
    procedure setWBO; inline;
    property BITO : TBits_1 read getBITO write setBITO;
    property BYTO : TBits_2 read getBYTO write setBYTO;
    property CRCAPP : TBits_1 read getCRCAPP write setCRCAPP;
    property CRCCH : TBits_3 read getCRCCH write setCRCCH;
    property CRCEN : TBits_1 read getCRCEN write setCRCEN;
    property CRCTYP : TBits_1 read getCRCTYP write setCRCTYP;
    property PLEN : TBits_5 read getPLEN write setPLEN;
    property WBO : TBits_1 read getWBO write setWBO;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMACRegisters = record
    DMACONbits : TDMAC_DMACON;
    DMACON : longWord;
    DMACONCLR : longWord;
    DMACONSET : longWord;
    DMACONINV : longWord;
    DMASTATbits : TDMAC_DMASTAT;
    DMASTAT : longWord;
    DMASTATCLR : longWord;
    DMASTATSET : longWord;
    DMASTATINV : longWord;
    DMAADDR : longWord;
    DMAADDRCLR : longWord;
    DMAADDRSET : longWord;
    DMAADDRINV : longWord;
    DCRCCONbits : TDMAC_DCRCCON;
    DCRCCON : longWord;
    DCRCCONCLR : longWord;
    DCRCCONSET : longWord;
    DCRCCONINV : longWord;
    DCRCDATA : longWord;
    DCRCDATACLR : longWord;
    DCRCDATASET : longWord;
    DCRCDATAINV : longWord;
    DCRCXOR : longWord;
    DCRCXORCLR : longWord;
    DCRCXORSET : longWord;
    DCRCXORINV : longWord;
  end;
  TDMAC0_DCH0CON = record
  private
    function  getCHAED : TBits_1; inline;
    function  getCHAEN : TBits_1; inline;
    function  getCHBUSY : TBits_1; inline;
    function  getCHCHN : TBits_1; inline;
    function  getCHCHNS : TBits_1; inline;
    function  getCHEDET : TBits_1; inline;
    function  getCHEN : TBits_1; inline;
    function  getCHPRI : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHAED(thebits : TBits_1); inline;
    procedure setCHAEN(thebits : TBits_1); inline;
    procedure setCHBUSY(thebits : TBits_1); inline;
    procedure setCHCHN(thebits : TBits_1); inline;
    procedure setCHCHNS(thebits : TBits_1); inline;
    procedure setCHEDET(thebits : TBits_1); inline;
    procedure setCHEN(thebits : TBits_1); inline;
    procedure setCHPRI(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHAED; inline;
    procedure clearCHAEN; inline;
    procedure clearCHBUSY; inline;
    procedure clearCHCHN; inline;
    procedure clearCHCHNS; inline;
    procedure clearCHEDET; inline;
    procedure clearCHEN; inline;
    procedure setCHAED; inline;
    procedure setCHAEN; inline;
    procedure setCHBUSY; inline;
    procedure setCHCHN; inline;
    procedure setCHCHNS; inline;
    procedure setCHEDET; inline;
    procedure setCHEN; inline;
    property CHAED : TBits_1 read getCHAED write setCHAED;
    property CHAEN : TBits_1 read getCHAEN write setCHAEN;
    property CHBUSY : TBits_1 read getCHBUSY write setCHBUSY;
    property CHCHN : TBits_1 read getCHCHN write setCHCHN;
    property CHCHNS : TBits_1 read getCHCHNS write setCHCHNS;
    property CHEDET : TBits_1 read getCHEDET write setCHEDET;
    property CHEN : TBits_1 read getCHEN write setCHEN;
    property CHPRI : TBits_2 read getCHPRI write setCHPRI;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC0_DCH0ECON = record
  private
    function  getAIRQEN : TBits_1; inline;
    function  getCABORT : TBits_1; inline;
    function  getCFORCE : TBits_1; inline;
    function  getCHAIRQ : TBits_8; inline;
    function  getCHSIRQ : TBits_8; inline;
    function  getPATEN : TBits_1; inline;
    function  getSIRQEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAIRQEN(thebits : TBits_1); inline;
    procedure setCABORT(thebits : TBits_1); inline;
    procedure setCFORCE(thebits : TBits_1); inline;
    procedure setCHAIRQ(thebits : TBits_8); inline;
    procedure setCHSIRQ(thebits : TBits_8); inline;
    procedure setPATEN(thebits : TBits_1); inline;
    procedure setSIRQEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAIRQEN; inline;
    procedure clearCABORT; inline;
    procedure clearCFORCE; inline;
    procedure clearPATEN; inline;
    procedure clearSIRQEN; inline;
    procedure setAIRQEN; inline;
    procedure setCABORT; inline;
    procedure setCFORCE; inline;
    procedure setPATEN; inline;
    procedure setSIRQEN; inline;
    property AIRQEN : TBits_1 read getAIRQEN write setAIRQEN;
    property CABORT : TBits_1 read getCABORT write setCABORT;
    property CFORCE : TBits_1 read getCFORCE write setCFORCE;
    property CHAIRQ : TBits_8 read getCHAIRQ write setCHAIRQ;
    property CHSIRQ : TBits_8 read getCHSIRQ write setCHSIRQ;
    property PATEN : TBits_1 read getPATEN write setPATEN;
    property SIRQEN : TBits_1 read getSIRQEN write setSIRQEN;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC0_DCH0INT = record
  private
    function  getCHBCIE : TBits_1; inline;
    function  getCHBCIF : TBits_1; inline;
    function  getCHCCIE : TBits_1; inline;
    function  getCHCCIF : TBits_1; inline;
    function  getCHDDIE : TBits_1; inline;
    function  getCHDDIF : TBits_1; inline;
    function  getCHDHIE : TBits_1; inline;
    function  getCHDHIF : TBits_1; inline;
    function  getCHERIE : TBits_1; inline;
    function  getCHERIF : TBits_1; inline;
    function  getCHSDIE : TBits_1; inline;
    function  getCHSDIF : TBits_1; inline;
    function  getCHSHIE : TBits_1; inline;
    function  getCHSHIF : TBits_1; inline;
    function  getCHTAIE : TBits_1; inline;
    function  getCHTAIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCHBCIE(thebits : TBits_1); inline;
    procedure setCHBCIF(thebits : TBits_1); inline;
    procedure setCHCCIE(thebits : TBits_1); inline;
    procedure setCHCCIF(thebits : TBits_1); inline;
    procedure setCHDDIE(thebits : TBits_1); inline;
    procedure setCHDDIF(thebits : TBits_1); inline;
    procedure setCHDHIE(thebits : TBits_1); inline;
    procedure setCHDHIF(thebits : TBits_1); inline;
    procedure setCHERIE(thebits : TBits_1); inline;
    procedure setCHERIF(thebits : TBits_1); inline;
    procedure setCHSDIE(thebits : TBits_1); inline;
    procedure setCHSDIF(thebits : TBits_1); inline;
    procedure setCHSHIE(thebits : TBits_1); inline;
    procedure setCHSHIF(thebits : TBits_1); inline;
    procedure setCHTAIE(thebits : TBits_1); inline;
    procedure setCHTAIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHBCIE; inline;
    procedure clearCHBCIF; inline;
    procedure clearCHCCIE; inline;
    procedure clearCHCCIF; inline;
    procedure clearCHDDIE; inline;
    procedure clearCHDDIF; inline;
    procedure clearCHDHIE; inline;
    procedure clearCHDHIF; inline;
    procedure clearCHERIE; inline;
    procedure clearCHERIF; inline;
    procedure clearCHSDIE; inline;
    procedure clearCHSDIF; inline;
    procedure clearCHSHIE; inline;
    procedure clearCHSHIF; inline;
    procedure clearCHTAIE; inline;
    procedure clearCHTAIF; inline;
    procedure setCHBCIE; inline;
    procedure setCHBCIF; inline;
    procedure setCHCCIE; inline;
    procedure setCHCCIF; inline;
    procedure setCHDDIE; inline;
    procedure setCHDDIF; inline;
    procedure setCHDHIE; inline;
    procedure setCHDHIF; inline;
    procedure setCHERIE; inline;
    procedure setCHERIF; inline;
    procedure setCHSDIE; inline;
    procedure setCHSDIF; inline;
    procedure setCHSHIE; inline;
    procedure setCHSHIF; inline;
    procedure setCHTAIE; inline;
    procedure setCHTAIF; inline;
    property CHBCIE : TBits_1 read getCHBCIE write setCHBCIE;
    property CHBCIF : TBits_1 read getCHBCIF write setCHBCIF;
    property CHCCIE : TBits_1 read getCHCCIE write setCHCCIE;
    property CHCCIF : TBits_1 read getCHCCIF write setCHCCIF;
    property CHDDIE : TBits_1 read getCHDDIE write setCHDDIE;
    property CHDDIF : TBits_1 read getCHDDIF write setCHDDIF;
    property CHDHIE : TBits_1 read getCHDHIE write setCHDHIE;
    property CHDHIF : TBits_1 read getCHDHIF write setCHDHIF;
    property CHERIE : TBits_1 read getCHERIE write setCHERIE;
    property CHERIF : TBits_1 read getCHERIF write setCHERIF;
    property CHSDIE : TBits_1 read getCHSDIE write setCHSDIE;
    property CHSDIF : TBits_1 read getCHSDIF write setCHSDIF;
    property CHSHIE : TBits_1 read getCHSHIE write setCHSHIE;
    property CHSHIF : TBits_1 read getCHSHIF write setCHSHIF;
    property CHTAIE : TBits_1 read getCHTAIE write setCHTAIE;
    property CHTAIF : TBits_1 read getCHTAIF write setCHTAIF;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMAC0Registers = record
    DCH0CONbits : TDMAC0_DCH0CON;
    DCH0CON : longWord;
    DCH0CONCLR : longWord;
    DCH0CONSET : longWord;
    DCH0CONINV : longWord;
    DCH0ECONbits : TDMAC0_DCH0ECON;
    DCH0ECON : longWord;
    DCH0ECONCLR : longWord;
    DCH0ECONSET : longWord;
    DCH0ECONINV : longWord;
    DCH0INTbits : TDMAC0_DCH0INT;
    DCH0INT : longWord;
    DCH0INTCLR : longWord;
    DCH0INTSET : longWord;
    DCH0INTINV : longWord;
    DCH0SSA : longWord;
    DCH0SSACLR : longWord;
    DCH0SSASET : longWord;
    DCH0SSAINV : longWord;
    DCH0DSA : longWord;
    DCH0DSACLR : longWord;
    DCH0DSASET : longWord;
    DCH0DSAINV : longWord;
    DCH0SSIZ : longWord;
    DCH0SSIZCLR : longWord;
    DCH0SSIZSET : longWord;
    DCH0SSIZINV : longWord;
    DCH0DSIZ : longWord;
    DCH0DSIZCLR : longWord;
    DCH0DSIZSET : longWord;
    DCH0DSIZINV : longWord;
    DCH0SPTR : longWord;
    DCH0SPTRCLR : longWord;
    DCH0SPTRSET : longWord;
    DCH0SPTRINV : longWord;
    DCH0DPTR : longWord;
    DCH0DPTRCLR : longWord;
    DCH0DPTRSET : longWord;
    DCH0DPTRINV : longWord;
    DCH0CSIZ : longWord;
    DCH0CSIZCLR : longWord;
    DCH0CSIZSET : longWord;
    DCH0CSIZINV : longWord;
    DCH0CPTR : longWord;
    DCH0CPTRCLR : longWord;
    DCH0CPTRSET : longWord;
    DCH0CPTRINV : longWord;
    DCH0DAT : longWord;
    DCH0DATCLR : longWord;
    DCH0DATSET : longWord;
    DCH0DATINV : longWord;
  end;
  TDMAC1_DCH1CON = record
  private
    function  getCHAED : TBits_1; inline;
    function  getCHAEN : TBits_1; inline;
    function  getCHBUSY : TBits_1; inline;
    function  getCHCHN : TBits_1; inline;
    function  getCHCHNS : TBits_1; inline;
    function  getCHEDET : TBits_1; inline;
    function  getCHEN : TBits_1; inline;
    function  getCHPRI : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHAED(thebits : TBits_1); inline;
    procedure setCHAEN(thebits : TBits_1); inline;
    procedure setCHBUSY(thebits : TBits_1); inline;
    procedure setCHCHN(thebits : TBits_1); inline;
    procedure setCHCHNS(thebits : TBits_1); inline;
    procedure setCHEDET(thebits : TBits_1); inline;
    procedure setCHEN(thebits : TBits_1); inline;
    procedure setCHPRI(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHAED; inline;
    procedure clearCHAEN; inline;
    procedure clearCHBUSY; inline;
    procedure clearCHCHN; inline;
    procedure clearCHCHNS; inline;
    procedure clearCHEDET; inline;
    procedure clearCHEN; inline;
    procedure setCHAED; inline;
    procedure setCHAEN; inline;
    procedure setCHBUSY; inline;
    procedure setCHCHN; inline;
    procedure setCHCHNS; inline;
    procedure setCHEDET; inline;
    procedure setCHEN; inline;
    property CHAED : TBits_1 read getCHAED write setCHAED;
    property CHAEN : TBits_1 read getCHAEN write setCHAEN;
    property CHBUSY : TBits_1 read getCHBUSY write setCHBUSY;
    property CHCHN : TBits_1 read getCHCHN write setCHCHN;
    property CHCHNS : TBits_1 read getCHCHNS write setCHCHNS;
    property CHEDET : TBits_1 read getCHEDET write setCHEDET;
    property CHEN : TBits_1 read getCHEN write setCHEN;
    property CHPRI : TBits_2 read getCHPRI write setCHPRI;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC1_DCH1ECON = record
  private
    function  getAIRQEN : TBits_1; inline;
    function  getCABORT : TBits_1; inline;
    function  getCFORCE : TBits_1; inline;
    function  getCHAIRQ : TBits_8; inline;
    function  getCHSIRQ : TBits_8; inline;
    function  getPATEN : TBits_1; inline;
    function  getSIRQEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAIRQEN(thebits : TBits_1); inline;
    procedure setCABORT(thebits : TBits_1); inline;
    procedure setCFORCE(thebits : TBits_1); inline;
    procedure setCHAIRQ(thebits : TBits_8); inline;
    procedure setCHSIRQ(thebits : TBits_8); inline;
    procedure setPATEN(thebits : TBits_1); inline;
    procedure setSIRQEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAIRQEN; inline;
    procedure clearCABORT; inline;
    procedure clearCFORCE; inline;
    procedure clearPATEN; inline;
    procedure clearSIRQEN; inline;
    procedure setAIRQEN; inline;
    procedure setCABORT; inline;
    procedure setCFORCE; inline;
    procedure setPATEN; inline;
    procedure setSIRQEN; inline;
    property AIRQEN : TBits_1 read getAIRQEN write setAIRQEN;
    property CABORT : TBits_1 read getCABORT write setCABORT;
    property CFORCE : TBits_1 read getCFORCE write setCFORCE;
    property CHAIRQ : TBits_8 read getCHAIRQ write setCHAIRQ;
    property CHSIRQ : TBits_8 read getCHSIRQ write setCHSIRQ;
    property PATEN : TBits_1 read getPATEN write setPATEN;
    property SIRQEN : TBits_1 read getSIRQEN write setSIRQEN;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC1_DCH1INT = record
  private
    function  getCHBCIE : TBits_1; inline;
    function  getCHBCIF : TBits_1; inline;
    function  getCHCCIE : TBits_1; inline;
    function  getCHCCIF : TBits_1; inline;
    function  getCHDDIE : TBits_1; inline;
    function  getCHDDIF : TBits_1; inline;
    function  getCHDHIE : TBits_1; inline;
    function  getCHDHIF : TBits_1; inline;
    function  getCHERIE : TBits_1; inline;
    function  getCHERIF : TBits_1; inline;
    function  getCHSDIE : TBits_1; inline;
    function  getCHSDIF : TBits_1; inline;
    function  getCHSHIE : TBits_1; inline;
    function  getCHSHIF : TBits_1; inline;
    function  getCHTAIE : TBits_1; inline;
    function  getCHTAIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCHBCIE(thebits : TBits_1); inline;
    procedure setCHBCIF(thebits : TBits_1); inline;
    procedure setCHCCIE(thebits : TBits_1); inline;
    procedure setCHCCIF(thebits : TBits_1); inline;
    procedure setCHDDIE(thebits : TBits_1); inline;
    procedure setCHDDIF(thebits : TBits_1); inline;
    procedure setCHDHIE(thebits : TBits_1); inline;
    procedure setCHDHIF(thebits : TBits_1); inline;
    procedure setCHERIE(thebits : TBits_1); inline;
    procedure setCHERIF(thebits : TBits_1); inline;
    procedure setCHSDIE(thebits : TBits_1); inline;
    procedure setCHSDIF(thebits : TBits_1); inline;
    procedure setCHSHIE(thebits : TBits_1); inline;
    procedure setCHSHIF(thebits : TBits_1); inline;
    procedure setCHTAIE(thebits : TBits_1); inline;
    procedure setCHTAIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHBCIE; inline;
    procedure clearCHBCIF; inline;
    procedure clearCHCCIE; inline;
    procedure clearCHCCIF; inline;
    procedure clearCHDDIE; inline;
    procedure clearCHDDIF; inline;
    procedure clearCHDHIE; inline;
    procedure clearCHDHIF; inline;
    procedure clearCHERIE; inline;
    procedure clearCHERIF; inline;
    procedure clearCHSDIE; inline;
    procedure clearCHSDIF; inline;
    procedure clearCHSHIE; inline;
    procedure clearCHSHIF; inline;
    procedure clearCHTAIE; inline;
    procedure clearCHTAIF; inline;
    procedure setCHBCIE; inline;
    procedure setCHBCIF; inline;
    procedure setCHCCIE; inline;
    procedure setCHCCIF; inline;
    procedure setCHDDIE; inline;
    procedure setCHDDIF; inline;
    procedure setCHDHIE; inline;
    procedure setCHDHIF; inline;
    procedure setCHERIE; inline;
    procedure setCHERIF; inline;
    procedure setCHSDIE; inline;
    procedure setCHSDIF; inline;
    procedure setCHSHIE; inline;
    procedure setCHSHIF; inline;
    procedure setCHTAIE; inline;
    procedure setCHTAIF; inline;
    property CHBCIE : TBits_1 read getCHBCIE write setCHBCIE;
    property CHBCIF : TBits_1 read getCHBCIF write setCHBCIF;
    property CHCCIE : TBits_1 read getCHCCIE write setCHCCIE;
    property CHCCIF : TBits_1 read getCHCCIF write setCHCCIF;
    property CHDDIE : TBits_1 read getCHDDIE write setCHDDIE;
    property CHDDIF : TBits_1 read getCHDDIF write setCHDDIF;
    property CHDHIE : TBits_1 read getCHDHIE write setCHDHIE;
    property CHDHIF : TBits_1 read getCHDHIF write setCHDHIF;
    property CHERIE : TBits_1 read getCHERIE write setCHERIE;
    property CHERIF : TBits_1 read getCHERIF write setCHERIF;
    property CHSDIE : TBits_1 read getCHSDIE write setCHSDIE;
    property CHSDIF : TBits_1 read getCHSDIF write setCHSDIF;
    property CHSHIE : TBits_1 read getCHSHIE write setCHSHIE;
    property CHSHIF : TBits_1 read getCHSHIF write setCHSHIF;
    property CHTAIE : TBits_1 read getCHTAIE write setCHTAIE;
    property CHTAIF : TBits_1 read getCHTAIF write setCHTAIF;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMAC1Registers = record
    DCH1CONbits : TDMAC1_DCH1CON;
    DCH1CON : longWord;
    DCH1CONCLR : longWord;
    DCH1CONSET : longWord;
    DCH1CONINV : longWord;
    DCH1ECONbits : TDMAC1_DCH1ECON;
    DCH1ECON : longWord;
    DCH1ECONCLR : longWord;
    DCH1ECONSET : longWord;
    DCH1ECONINV : longWord;
    DCH1INTbits : TDMAC1_DCH1INT;
    DCH1INT : longWord;
    DCH1INTCLR : longWord;
    DCH1INTSET : longWord;
    DCH1INTINV : longWord;
    DCH1SSA : longWord;
    DCH1SSACLR : longWord;
    DCH1SSASET : longWord;
    DCH1SSAINV : longWord;
    DCH1DSA : longWord;
    DCH1DSACLR : longWord;
    DCH1DSASET : longWord;
    DCH1DSAINV : longWord;
    DCH1SSIZ : longWord;
    DCH1SSIZCLR : longWord;
    DCH1SSIZSET : longWord;
    DCH1SSIZINV : longWord;
    DCH1DSIZ : longWord;
    DCH1DSIZCLR : longWord;
    DCH1DSIZSET : longWord;
    DCH1DSIZINV : longWord;
    DCH1SPTR : longWord;
    DCH1SPTRCLR : longWord;
    DCH1SPTRSET : longWord;
    DCH1SPTRINV : longWord;
    DCH1DPTR : longWord;
    DCH1DPTRCLR : longWord;
    DCH1DPTRSET : longWord;
    DCH1DPTRINV : longWord;
    DCH1CSIZ : longWord;
    DCH1CSIZCLR : longWord;
    DCH1CSIZSET : longWord;
    DCH1CSIZINV : longWord;
    DCH1CPTR : longWord;
    DCH1CPTRCLR : longWord;
    DCH1CPTRSET : longWord;
    DCH1CPTRINV : longWord;
    DCH1DAT : longWord;
    DCH1DATCLR : longWord;
    DCH1DATSET : longWord;
    DCH1DATINV : longWord;
  end;
  TDMAC2_DCH2CON = record
  private
    function  getCHAED : TBits_1; inline;
    function  getCHAEN : TBits_1; inline;
    function  getCHBUSY : TBits_1; inline;
    function  getCHCHN : TBits_1; inline;
    function  getCHCHNS : TBits_1; inline;
    function  getCHEDET : TBits_1; inline;
    function  getCHEN : TBits_1; inline;
    function  getCHPRI : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHAED(thebits : TBits_1); inline;
    procedure setCHAEN(thebits : TBits_1); inline;
    procedure setCHBUSY(thebits : TBits_1); inline;
    procedure setCHCHN(thebits : TBits_1); inline;
    procedure setCHCHNS(thebits : TBits_1); inline;
    procedure setCHEDET(thebits : TBits_1); inline;
    procedure setCHEN(thebits : TBits_1); inline;
    procedure setCHPRI(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHAED; inline;
    procedure clearCHAEN; inline;
    procedure clearCHBUSY; inline;
    procedure clearCHCHN; inline;
    procedure clearCHCHNS; inline;
    procedure clearCHEDET; inline;
    procedure clearCHEN; inline;
    procedure setCHAED; inline;
    procedure setCHAEN; inline;
    procedure setCHBUSY; inline;
    procedure setCHCHN; inline;
    procedure setCHCHNS; inline;
    procedure setCHEDET; inline;
    procedure setCHEN; inline;
    property CHAED : TBits_1 read getCHAED write setCHAED;
    property CHAEN : TBits_1 read getCHAEN write setCHAEN;
    property CHBUSY : TBits_1 read getCHBUSY write setCHBUSY;
    property CHCHN : TBits_1 read getCHCHN write setCHCHN;
    property CHCHNS : TBits_1 read getCHCHNS write setCHCHNS;
    property CHEDET : TBits_1 read getCHEDET write setCHEDET;
    property CHEN : TBits_1 read getCHEN write setCHEN;
    property CHPRI : TBits_2 read getCHPRI write setCHPRI;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC2_DCH2ECON = record
  private
    function  getAIRQEN : TBits_1; inline;
    function  getCABORT : TBits_1; inline;
    function  getCFORCE : TBits_1; inline;
    function  getCHAIRQ : TBits_8; inline;
    function  getCHSIRQ : TBits_8; inline;
    function  getPATEN : TBits_1; inline;
    function  getSIRQEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAIRQEN(thebits : TBits_1); inline;
    procedure setCABORT(thebits : TBits_1); inline;
    procedure setCFORCE(thebits : TBits_1); inline;
    procedure setCHAIRQ(thebits : TBits_8); inline;
    procedure setCHSIRQ(thebits : TBits_8); inline;
    procedure setPATEN(thebits : TBits_1); inline;
    procedure setSIRQEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAIRQEN; inline;
    procedure clearCABORT; inline;
    procedure clearCFORCE; inline;
    procedure clearPATEN; inline;
    procedure clearSIRQEN; inline;
    procedure setAIRQEN; inline;
    procedure setCABORT; inline;
    procedure setCFORCE; inline;
    procedure setPATEN; inline;
    procedure setSIRQEN; inline;
    property AIRQEN : TBits_1 read getAIRQEN write setAIRQEN;
    property CABORT : TBits_1 read getCABORT write setCABORT;
    property CFORCE : TBits_1 read getCFORCE write setCFORCE;
    property CHAIRQ : TBits_8 read getCHAIRQ write setCHAIRQ;
    property CHSIRQ : TBits_8 read getCHSIRQ write setCHSIRQ;
    property PATEN : TBits_1 read getPATEN write setPATEN;
    property SIRQEN : TBits_1 read getSIRQEN write setSIRQEN;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC2_DCH2INT = record
  private
    function  getCHBCIE : TBits_1; inline;
    function  getCHBCIF : TBits_1; inline;
    function  getCHCCIE : TBits_1; inline;
    function  getCHCCIF : TBits_1; inline;
    function  getCHDDIE : TBits_1; inline;
    function  getCHDDIF : TBits_1; inline;
    function  getCHDHIE : TBits_1; inline;
    function  getCHDHIF : TBits_1; inline;
    function  getCHERIE : TBits_1; inline;
    function  getCHERIF : TBits_1; inline;
    function  getCHSDIE : TBits_1; inline;
    function  getCHSDIF : TBits_1; inline;
    function  getCHSHIE : TBits_1; inline;
    function  getCHSHIF : TBits_1; inline;
    function  getCHTAIE : TBits_1; inline;
    function  getCHTAIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCHBCIE(thebits : TBits_1); inline;
    procedure setCHBCIF(thebits : TBits_1); inline;
    procedure setCHCCIE(thebits : TBits_1); inline;
    procedure setCHCCIF(thebits : TBits_1); inline;
    procedure setCHDDIE(thebits : TBits_1); inline;
    procedure setCHDDIF(thebits : TBits_1); inline;
    procedure setCHDHIE(thebits : TBits_1); inline;
    procedure setCHDHIF(thebits : TBits_1); inline;
    procedure setCHERIE(thebits : TBits_1); inline;
    procedure setCHERIF(thebits : TBits_1); inline;
    procedure setCHSDIE(thebits : TBits_1); inline;
    procedure setCHSDIF(thebits : TBits_1); inline;
    procedure setCHSHIE(thebits : TBits_1); inline;
    procedure setCHSHIF(thebits : TBits_1); inline;
    procedure setCHTAIE(thebits : TBits_1); inline;
    procedure setCHTAIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHBCIE; inline;
    procedure clearCHBCIF; inline;
    procedure clearCHCCIE; inline;
    procedure clearCHCCIF; inline;
    procedure clearCHDDIE; inline;
    procedure clearCHDDIF; inline;
    procedure clearCHDHIE; inline;
    procedure clearCHDHIF; inline;
    procedure clearCHERIE; inline;
    procedure clearCHERIF; inline;
    procedure clearCHSDIE; inline;
    procedure clearCHSDIF; inline;
    procedure clearCHSHIE; inline;
    procedure clearCHSHIF; inline;
    procedure clearCHTAIE; inline;
    procedure clearCHTAIF; inline;
    procedure setCHBCIE; inline;
    procedure setCHBCIF; inline;
    procedure setCHCCIE; inline;
    procedure setCHCCIF; inline;
    procedure setCHDDIE; inline;
    procedure setCHDDIF; inline;
    procedure setCHDHIE; inline;
    procedure setCHDHIF; inline;
    procedure setCHERIE; inline;
    procedure setCHERIF; inline;
    procedure setCHSDIE; inline;
    procedure setCHSDIF; inline;
    procedure setCHSHIE; inline;
    procedure setCHSHIF; inline;
    procedure setCHTAIE; inline;
    procedure setCHTAIF; inline;
    property CHBCIE : TBits_1 read getCHBCIE write setCHBCIE;
    property CHBCIF : TBits_1 read getCHBCIF write setCHBCIF;
    property CHCCIE : TBits_1 read getCHCCIE write setCHCCIE;
    property CHCCIF : TBits_1 read getCHCCIF write setCHCCIF;
    property CHDDIE : TBits_1 read getCHDDIE write setCHDDIE;
    property CHDDIF : TBits_1 read getCHDDIF write setCHDDIF;
    property CHDHIE : TBits_1 read getCHDHIE write setCHDHIE;
    property CHDHIF : TBits_1 read getCHDHIF write setCHDHIF;
    property CHERIE : TBits_1 read getCHERIE write setCHERIE;
    property CHERIF : TBits_1 read getCHERIF write setCHERIF;
    property CHSDIE : TBits_1 read getCHSDIE write setCHSDIE;
    property CHSDIF : TBits_1 read getCHSDIF write setCHSDIF;
    property CHSHIE : TBits_1 read getCHSHIE write setCHSHIE;
    property CHSHIF : TBits_1 read getCHSHIF write setCHSHIF;
    property CHTAIE : TBits_1 read getCHTAIE write setCHTAIE;
    property CHTAIF : TBits_1 read getCHTAIF write setCHTAIF;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMAC2Registers = record
    DCH2CONbits : TDMAC2_DCH2CON;
    DCH2CON : longWord;
    DCH2CONCLR : longWord;
    DCH2CONSET : longWord;
    DCH2CONINV : longWord;
    DCH2ECONbits : TDMAC2_DCH2ECON;
    DCH2ECON : longWord;
    DCH2ECONCLR : longWord;
    DCH2ECONSET : longWord;
    DCH2ECONINV : longWord;
    DCH2INTbits : TDMAC2_DCH2INT;
    DCH2INT : longWord;
    DCH2INTCLR : longWord;
    DCH2INTSET : longWord;
    DCH2INTINV : longWord;
    DCH2SSA : longWord;
    DCH2SSACLR : longWord;
    DCH2SSASET : longWord;
    DCH2SSAINV : longWord;
    DCH2DSA : longWord;
    DCH2DSACLR : longWord;
    DCH2DSASET : longWord;
    DCH2DSAINV : longWord;
    DCH2SSIZ : longWord;
    DCH2SSIZCLR : longWord;
    DCH2SSIZSET : longWord;
    DCH2SSIZINV : longWord;
    DCH2DSIZ : longWord;
    DCH2DSIZCLR : longWord;
    DCH2DSIZSET : longWord;
    DCH2DSIZINV : longWord;
    DCH2SPTR : longWord;
    DCH2SPTRCLR : longWord;
    DCH2SPTRSET : longWord;
    DCH2SPTRINV : longWord;
    DCH2DPTR : longWord;
    DCH2DPTRCLR : longWord;
    DCH2DPTRSET : longWord;
    DCH2DPTRINV : longWord;
    DCH2CSIZ : longWord;
    DCH2CSIZCLR : longWord;
    DCH2CSIZSET : longWord;
    DCH2CSIZINV : longWord;
    DCH2CPTR : longWord;
    DCH2CPTRCLR : longWord;
    DCH2CPTRSET : longWord;
    DCH2CPTRINV : longWord;
    DCH2DAT : longWord;
    DCH2DATCLR : longWord;
    DCH2DATSET : longWord;
    DCH2DATINV : longWord;
  end;
  TDMAC3_DCH3CON = record
  private
    function  getCHAED : TBits_1; inline;
    function  getCHAEN : TBits_1; inline;
    function  getCHBUSY : TBits_1; inline;
    function  getCHCHN : TBits_1; inline;
    function  getCHCHNS : TBits_1; inline;
    function  getCHEDET : TBits_1; inline;
    function  getCHEN : TBits_1; inline;
    function  getCHPRI : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHAED(thebits : TBits_1); inline;
    procedure setCHAEN(thebits : TBits_1); inline;
    procedure setCHBUSY(thebits : TBits_1); inline;
    procedure setCHCHN(thebits : TBits_1); inline;
    procedure setCHCHNS(thebits : TBits_1); inline;
    procedure setCHEDET(thebits : TBits_1); inline;
    procedure setCHEN(thebits : TBits_1); inline;
    procedure setCHPRI(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHAED; inline;
    procedure clearCHAEN; inline;
    procedure clearCHBUSY; inline;
    procedure clearCHCHN; inline;
    procedure clearCHCHNS; inline;
    procedure clearCHEDET; inline;
    procedure clearCHEN; inline;
    procedure setCHAED; inline;
    procedure setCHAEN; inline;
    procedure setCHBUSY; inline;
    procedure setCHCHN; inline;
    procedure setCHCHNS; inline;
    procedure setCHEDET; inline;
    procedure setCHEN; inline;
    property CHAED : TBits_1 read getCHAED write setCHAED;
    property CHAEN : TBits_1 read getCHAEN write setCHAEN;
    property CHBUSY : TBits_1 read getCHBUSY write setCHBUSY;
    property CHCHN : TBits_1 read getCHCHN write setCHCHN;
    property CHCHNS : TBits_1 read getCHCHNS write setCHCHNS;
    property CHEDET : TBits_1 read getCHEDET write setCHEDET;
    property CHEN : TBits_1 read getCHEN write setCHEN;
    property CHPRI : TBits_2 read getCHPRI write setCHPRI;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC3_DCH3ECON = record
  private
    function  getAIRQEN : TBits_1; inline;
    function  getCABORT : TBits_1; inline;
    function  getCFORCE : TBits_1; inline;
    function  getCHAIRQ : TBits_8; inline;
    function  getCHSIRQ : TBits_8; inline;
    function  getPATEN : TBits_1; inline;
    function  getSIRQEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAIRQEN(thebits : TBits_1); inline;
    procedure setCABORT(thebits : TBits_1); inline;
    procedure setCFORCE(thebits : TBits_1); inline;
    procedure setCHAIRQ(thebits : TBits_8); inline;
    procedure setCHSIRQ(thebits : TBits_8); inline;
    procedure setPATEN(thebits : TBits_1); inline;
    procedure setSIRQEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAIRQEN; inline;
    procedure clearCABORT; inline;
    procedure clearCFORCE; inline;
    procedure clearPATEN; inline;
    procedure clearSIRQEN; inline;
    procedure setAIRQEN; inline;
    procedure setCABORT; inline;
    procedure setCFORCE; inline;
    procedure setPATEN; inline;
    procedure setSIRQEN; inline;
    property AIRQEN : TBits_1 read getAIRQEN write setAIRQEN;
    property CABORT : TBits_1 read getCABORT write setCABORT;
    property CFORCE : TBits_1 read getCFORCE write setCFORCE;
    property CHAIRQ : TBits_8 read getCHAIRQ write setCHAIRQ;
    property CHSIRQ : TBits_8 read getCHSIRQ write setCHSIRQ;
    property PATEN : TBits_1 read getPATEN write setPATEN;
    property SIRQEN : TBits_1 read getSIRQEN write setSIRQEN;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC3_DCH3INT = record
  private
    function  getCHBCIE : TBits_1; inline;
    function  getCHBCIF : TBits_1; inline;
    function  getCHCCIE : TBits_1; inline;
    function  getCHCCIF : TBits_1; inline;
    function  getCHDDIE : TBits_1; inline;
    function  getCHDDIF : TBits_1; inline;
    function  getCHDHIE : TBits_1; inline;
    function  getCHDHIF : TBits_1; inline;
    function  getCHERIE : TBits_1; inline;
    function  getCHERIF : TBits_1; inline;
    function  getCHSDIE : TBits_1; inline;
    function  getCHSDIF : TBits_1; inline;
    function  getCHSHIE : TBits_1; inline;
    function  getCHSHIF : TBits_1; inline;
    function  getCHTAIE : TBits_1; inline;
    function  getCHTAIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCHBCIE(thebits : TBits_1); inline;
    procedure setCHBCIF(thebits : TBits_1); inline;
    procedure setCHCCIE(thebits : TBits_1); inline;
    procedure setCHCCIF(thebits : TBits_1); inline;
    procedure setCHDDIE(thebits : TBits_1); inline;
    procedure setCHDDIF(thebits : TBits_1); inline;
    procedure setCHDHIE(thebits : TBits_1); inline;
    procedure setCHDHIF(thebits : TBits_1); inline;
    procedure setCHERIE(thebits : TBits_1); inline;
    procedure setCHERIF(thebits : TBits_1); inline;
    procedure setCHSDIE(thebits : TBits_1); inline;
    procedure setCHSDIF(thebits : TBits_1); inline;
    procedure setCHSHIE(thebits : TBits_1); inline;
    procedure setCHSHIF(thebits : TBits_1); inline;
    procedure setCHTAIE(thebits : TBits_1); inline;
    procedure setCHTAIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHBCIE; inline;
    procedure clearCHBCIF; inline;
    procedure clearCHCCIE; inline;
    procedure clearCHCCIF; inline;
    procedure clearCHDDIE; inline;
    procedure clearCHDDIF; inline;
    procedure clearCHDHIE; inline;
    procedure clearCHDHIF; inline;
    procedure clearCHERIE; inline;
    procedure clearCHERIF; inline;
    procedure clearCHSDIE; inline;
    procedure clearCHSDIF; inline;
    procedure clearCHSHIE; inline;
    procedure clearCHSHIF; inline;
    procedure clearCHTAIE; inline;
    procedure clearCHTAIF; inline;
    procedure setCHBCIE; inline;
    procedure setCHBCIF; inline;
    procedure setCHCCIE; inline;
    procedure setCHCCIF; inline;
    procedure setCHDDIE; inline;
    procedure setCHDDIF; inline;
    procedure setCHDHIE; inline;
    procedure setCHDHIF; inline;
    procedure setCHERIE; inline;
    procedure setCHERIF; inline;
    procedure setCHSDIE; inline;
    procedure setCHSDIF; inline;
    procedure setCHSHIE; inline;
    procedure setCHSHIF; inline;
    procedure setCHTAIE; inline;
    procedure setCHTAIF; inline;
    property CHBCIE : TBits_1 read getCHBCIE write setCHBCIE;
    property CHBCIF : TBits_1 read getCHBCIF write setCHBCIF;
    property CHCCIE : TBits_1 read getCHCCIE write setCHCCIE;
    property CHCCIF : TBits_1 read getCHCCIF write setCHCCIF;
    property CHDDIE : TBits_1 read getCHDDIE write setCHDDIE;
    property CHDDIF : TBits_1 read getCHDDIF write setCHDDIF;
    property CHDHIE : TBits_1 read getCHDHIE write setCHDHIE;
    property CHDHIF : TBits_1 read getCHDHIF write setCHDHIF;
    property CHERIE : TBits_1 read getCHERIE write setCHERIE;
    property CHERIF : TBits_1 read getCHERIF write setCHERIF;
    property CHSDIE : TBits_1 read getCHSDIE write setCHSDIE;
    property CHSDIF : TBits_1 read getCHSDIF write setCHSDIF;
    property CHSHIE : TBits_1 read getCHSHIE write setCHSHIE;
    property CHSHIF : TBits_1 read getCHSHIF write setCHSHIF;
    property CHTAIE : TBits_1 read getCHTAIE write setCHTAIE;
    property CHTAIF : TBits_1 read getCHTAIF write setCHTAIF;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMAC3Registers = record
    DCH3CONbits : TDMAC3_DCH3CON;
    DCH3CON : longWord;
    DCH3CONCLR : longWord;
    DCH3CONSET : longWord;
    DCH3CONINV : longWord;
    DCH3ECONbits : TDMAC3_DCH3ECON;
    DCH3ECON : longWord;
    DCH3ECONCLR : longWord;
    DCH3ECONSET : longWord;
    DCH3ECONINV : longWord;
    DCH3INTbits : TDMAC3_DCH3INT;
    DCH3INT : longWord;
    DCH3INTCLR : longWord;
    DCH3INTSET : longWord;
    DCH3INTINV : longWord;
    DCH3SSA : longWord;
    DCH3SSACLR : longWord;
    DCH3SSASET : longWord;
    DCH3SSAINV : longWord;
    DCH3DSA : longWord;
    DCH3DSACLR : longWord;
    DCH3DSASET : longWord;
    DCH3DSAINV : longWord;
    DCH3SSIZ : longWord;
    DCH3SSIZCLR : longWord;
    DCH3SSIZSET : longWord;
    DCH3SSIZINV : longWord;
    DCH3DSIZ : longWord;
    DCH3DSIZCLR : longWord;
    DCH3DSIZSET : longWord;
    DCH3DSIZINV : longWord;
    DCH3SPTR : longWord;
    DCH3SPTRCLR : longWord;
    DCH3SPTRSET : longWord;
    DCH3SPTRINV : longWord;
    DCH3DPTR : longWord;
    DCH3DPTRCLR : longWord;
    DCH3DPTRSET : longWord;
    DCH3DPTRINV : longWord;
    DCH3CSIZ : longWord;
    DCH3CSIZCLR : longWord;
    DCH3CSIZSET : longWord;
    DCH3CSIZINV : longWord;
    DCH3CPTR : longWord;
    DCH3CPTRCLR : longWord;
    DCH3CPTRSET : longWord;
    DCH3CPTRINV : longWord;
    DCH3DAT : longWord;
    DCH3DATCLR : longWord;
    DCH3DATSET : longWord;
    DCH3DATINV : longWord;
  end;
  TPCACHE_CHECON = record
  private
    function  getCHECOH : TBits_1; inline;
    function  getDCSZ : TBits_2; inline;
    function  getPFMWS : TBits_3; inline;
    function  getPREFEN : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHECOH(thebits : TBits_1); inline;
    procedure setDCSZ(thebits : TBits_2); inline;
    procedure setPFMWS(thebits : TBits_3); inline;
    procedure setPREFEN(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHECOH; inline;
    procedure setCHECOH; inline;
    property CHECOH : TBits_1 read getCHECOH write setCHECOH;
    property DCSZ : TBits_2 read getDCSZ write setDCSZ;
    property PFMWS : TBits_3 read getPFMWS write setPFMWS;
    property PREFEN : TBits_2 read getPREFEN write setPREFEN;
    property w : TBits_32 read getw write setw;
  end;
  TPCACHE_CHETAG = record
  private
    function  getLLOCK : TBits_1; inline;
    function  getLTAG : TBits_20; inline;
    function  getLTAGBOOT : TBits_1; inline;
    function  getLTYPE : TBits_1; inline;
    function  getLVALID : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLLOCK(thebits : TBits_1); inline;
    procedure setLTAG(thebits : TBits_20); inline;
    procedure setLTAGBOOT(thebits : TBits_1); inline;
    procedure setLTYPE(thebits : TBits_1); inline;
    procedure setLVALID(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLLOCK; inline;
    procedure clearLTAGBOOT; inline;
    procedure clearLTYPE; inline;
    procedure clearLVALID; inline;
    procedure setLLOCK; inline;
    procedure setLTAGBOOT; inline;
    procedure setLTYPE; inline;
    procedure setLVALID; inline;
    property LLOCK : TBits_1 read getLLOCK write setLLOCK;
    property LTAG : TBits_20 read getLTAG write setLTAG;
    property LTAGBOOT : TBits_1 read getLTAGBOOT write setLTAGBOOT;
    property LTYPE : TBits_1 read getLTYPE write setLTYPE;
    property LVALID : TBits_1 read getLVALID write setLVALID;
    property w : TBits_32 read getw write setw;
  end;
type
  TPCACHERegisters = record
    CHECONbits : TPCACHE_CHECON;
    CHECON : longWord;
    CHECONCLR : longWord;
    CHECONSET : longWord;
    CHECONINV : longWord;
    CHEACC : longWord;
    CHEACCCLR : longWord;
    CHEACCSET : longWord;
    CHEACCINV : longWord;
    CHETAGbits : TPCACHE_CHETAG;
    CHETAG : longWord;
    CHETAGCLR : longWord;
    CHETAGSET : longWord;
    CHETAGINV : longWord;
    CHEMSK : longWord;
    CHEMSKCLR : longWord;
    CHEMSKSET : longWord;
    CHEMSKINV : longWord;
    CHEW0 : longWord;
    CHEW1 : longWord;
    CHEW2 : longWord;
    CHEW3 : longWord;
    CHELRU : longWord;
    CHEHIT : longWord;
    CHEMIS : longWord;
    CHEPFABT : longWord;
  end;
  TUSB_U1IR = record
  private
    function  getATTACHIF : TBits_1; inline;
    function  getDETACHIF : TBits_1; inline;
    function  getIDLEIF : TBits_1; inline;
    function  getRESUMEIF : TBits_1; inline;
    function  getSOFIF : TBits_1; inline;
    function  getSTALLIF : TBits_1; inline;
    function  getTRNIF : TBits_1; inline;
    function  getUERRIF : TBits_1; inline;
    function  getURSTIF : TBits_1; inline;
    function  getURSTIF_DETACHIF : TBits_1; inline;
    procedure setATTACHIF(thebits : TBits_1); inline;
    procedure setDETACHIF(thebits : TBits_1); inline;
    procedure setIDLEIF(thebits : TBits_1); inline;
    procedure setRESUMEIF(thebits : TBits_1); inline;
    procedure setSOFIF(thebits : TBits_1); inline;
    procedure setSTALLIF(thebits : TBits_1); inline;
    procedure setTRNIF(thebits : TBits_1); inline;
    procedure setUERRIF(thebits : TBits_1); inline;
    procedure setURSTIF(thebits : TBits_1); inline;
    procedure setURSTIF_DETACHIF(thebits : TBits_1); inline;
  public
    procedure clearATTACHIF; inline;
    procedure clearDETACHIF; inline;
    procedure clearIDLEIF; inline;
    procedure clearRESUMEIF; inline;
    procedure clearSOFIF; inline;
    procedure clearSTALLIF; inline;
    procedure clearTRNIF; inline;
    procedure clearUERRIF; inline;
    procedure clearURSTIF; inline;
    procedure clearURSTIF_DETACHIF; inline;
    procedure setATTACHIF; inline;
    procedure setDETACHIF; inline;
    procedure setIDLEIF; inline;
    procedure setRESUMEIF; inline;
    procedure setSOFIF; inline;
    procedure setSTALLIF; inline;
    procedure setTRNIF; inline;
    procedure setUERRIF; inline;
    procedure setURSTIF; inline;
    procedure setURSTIF_DETACHIF; inline;
    property ATTACHIF : TBits_1 read getATTACHIF write setATTACHIF;
    property DETACHIF : TBits_1 read getDETACHIF write setDETACHIF;
    property IDLEIF : TBits_1 read getIDLEIF write setIDLEIF;
    property RESUMEIF : TBits_1 read getRESUMEIF write setRESUMEIF;
    property SOFIF : TBits_1 read getSOFIF write setSOFIF;
    property STALLIF : TBits_1 read getSTALLIF write setSTALLIF;
    property TRNIF : TBits_1 read getTRNIF write setTRNIF;
    property UERRIF : TBits_1 read getUERRIF write setUERRIF;
    property URSTIF : TBits_1 read getURSTIF write setURSTIF;
    property URSTIF_DETACHIF : TBits_1 read getURSTIF_DETACHIF write setURSTIF_DETACHIF;
  end;
  TUSB_U1IE = record
  private
    function  getATTACHIE : TBits_1; inline;
    function  getDETACHIE : TBits_1; inline;
    function  getIDLEIE : TBits_1; inline;
    function  getRESUMEIE : TBits_1; inline;
    function  getSOFIE : TBits_1; inline;
    function  getSTALLIE : TBits_1; inline;
    function  getTRNIE : TBits_1; inline;
    function  getUERRIE : TBits_1; inline;
    function  getURSTIE : TBits_1; inline;
    function  getURSTIE_DETACHIE : TBits_1; inline;
    procedure setATTACHIE(thebits : TBits_1); inline;
    procedure setDETACHIE(thebits : TBits_1); inline;
    procedure setIDLEIE(thebits : TBits_1); inline;
    procedure setRESUMEIE(thebits : TBits_1); inline;
    procedure setSOFIE(thebits : TBits_1); inline;
    procedure setSTALLIE(thebits : TBits_1); inline;
    procedure setTRNIE(thebits : TBits_1); inline;
    procedure setUERRIE(thebits : TBits_1); inline;
    procedure setURSTIE(thebits : TBits_1); inline;
    procedure setURSTIE_DETACHIE(thebits : TBits_1); inline;
  public
    procedure clearATTACHIE; inline;
    procedure clearDETACHIE; inline;
    procedure clearIDLEIE; inline;
    procedure clearRESUMEIE; inline;
    procedure clearSOFIE; inline;
    procedure clearSTALLIE; inline;
    procedure clearTRNIE; inline;
    procedure clearUERRIE; inline;
    procedure clearURSTIE; inline;
    procedure clearURSTIE_DETACHIE; inline;
    procedure setATTACHIE; inline;
    procedure setDETACHIE; inline;
    procedure setIDLEIE; inline;
    procedure setRESUMEIE; inline;
    procedure setSOFIE; inline;
    procedure setSTALLIE; inline;
    procedure setTRNIE; inline;
    procedure setUERRIE; inline;
    procedure setURSTIE; inline;
    procedure setURSTIE_DETACHIE; inline;
    property ATTACHIE : TBits_1 read getATTACHIE write setATTACHIE;
    property DETACHIE : TBits_1 read getDETACHIE write setDETACHIE;
    property IDLEIE : TBits_1 read getIDLEIE write setIDLEIE;
    property RESUMEIE : TBits_1 read getRESUMEIE write setRESUMEIE;
    property SOFIE : TBits_1 read getSOFIE write setSOFIE;
    property STALLIE : TBits_1 read getSTALLIE write setSTALLIE;
    property TRNIE : TBits_1 read getTRNIE write setTRNIE;
    property UERRIE : TBits_1 read getUERRIE write setUERRIE;
    property URSTIE : TBits_1 read getURSTIE write setURSTIE;
    property URSTIE_DETACHIE : TBits_1 read getURSTIE_DETACHIE write setURSTIE_DETACHIE;
  end;
  TUSB_U1EIR = record
  private
    function  getBMXEF : TBits_1; inline;
    function  getBTOEF : TBits_1; inline;
    function  getBTSEF : TBits_1; inline;
    function  getCRC16EF : TBits_1; inline;
    function  getCRC5EF : TBits_1; inline;
    function  getCRC5EF_EOFEF : TBits_1; inline;
    function  getDFN8EF : TBits_1; inline;
    function  getDMAEF : TBits_1; inline;
    function  getEOFEF : TBits_1; inline;
    function  getPIDEF : TBits_1; inline;
    procedure setBMXEF(thebits : TBits_1); inline;
    procedure setBTOEF(thebits : TBits_1); inline;
    procedure setBTSEF(thebits : TBits_1); inline;
    procedure setCRC16EF(thebits : TBits_1); inline;
    procedure setCRC5EF(thebits : TBits_1); inline;
    procedure setCRC5EF_EOFEF(thebits : TBits_1); inline;
    procedure setDFN8EF(thebits : TBits_1); inline;
    procedure setDMAEF(thebits : TBits_1); inline;
    procedure setEOFEF(thebits : TBits_1); inline;
    procedure setPIDEF(thebits : TBits_1); inline;
  public
    procedure clearBMXEF; inline;
    procedure clearBTOEF; inline;
    procedure clearBTSEF; inline;
    procedure clearCRC16EF; inline;
    procedure clearCRC5EF; inline;
    procedure clearCRC5EF_EOFEF; inline;
    procedure clearDFN8EF; inline;
    procedure clearDMAEF; inline;
    procedure clearEOFEF; inline;
    procedure clearPIDEF; inline;
    procedure setBMXEF; inline;
    procedure setBTOEF; inline;
    procedure setBTSEF; inline;
    procedure setCRC16EF; inline;
    procedure setCRC5EF; inline;
    procedure setCRC5EF_EOFEF; inline;
    procedure setDFN8EF; inline;
    procedure setDMAEF; inline;
    procedure setEOFEF; inline;
    procedure setPIDEF; inline;
    property BMXEF : TBits_1 read getBMXEF write setBMXEF;
    property BTOEF : TBits_1 read getBTOEF write setBTOEF;
    property BTSEF : TBits_1 read getBTSEF write setBTSEF;
    property CRC16EF : TBits_1 read getCRC16EF write setCRC16EF;
    property CRC5EF : TBits_1 read getCRC5EF write setCRC5EF;
    property CRC5EF_EOFEF : TBits_1 read getCRC5EF_EOFEF write setCRC5EF_EOFEF;
    property DFN8EF : TBits_1 read getDFN8EF write setDFN8EF;
    property DMAEF : TBits_1 read getDMAEF write setDMAEF;
    property EOFEF : TBits_1 read getEOFEF write setEOFEF;
    property PIDEF : TBits_1 read getPIDEF write setPIDEF;
  end;
  TUSB_U1EIE = record
  private
    function  getBMXEE : TBits_1; inline;
    function  getBTOEE : TBits_1; inline;
    function  getBTSEE : TBits_1; inline;
    function  getCRC16EE : TBits_1; inline;
    function  getCRC5EE : TBits_1; inline;
    function  getCRC5EE_EOFEE : TBits_1; inline;
    function  getDFN8EE : TBits_1; inline;
    function  getDMAEE : TBits_1; inline;
    function  getEOFEE : TBits_1; inline;
    function  getPIDEE : TBits_1; inline;
    procedure setBMXEE(thebits : TBits_1); inline;
    procedure setBTOEE(thebits : TBits_1); inline;
    procedure setBTSEE(thebits : TBits_1); inline;
    procedure setCRC16EE(thebits : TBits_1); inline;
    procedure setCRC5EE(thebits : TBits_1); inline;
    procedure setCRC5EE_EOFEE(thebits : TBits_1); inline;
    procedure setDFN8EE(thebits : TBits_1); inline;
    procedure setDMAEE(thebits : TBits_1); inline;
    procedure setEOFEE(thebits : TBits_1); inline;
    procedure setPIDEE(thebits : TBits_1); inline;
  public
    procedure clearBMXEE; inline;
    procedure clearBTOEE; inline;
    procedure clearBTSEE; inline;
    procedure clearCRC16EE; inline;
    procedure clearCRC5EE; inline;
    procedure clearCRC5EE_EOFEE; inline;
    procedure clearDFN8EE; inline;
    procedure clearDMAEE; inline;
    procedure clearEOFEE; inline;
    procedure clearPIDEE; inline;
    procedure setBMXEE; inline;
    procedure setBTOEE; inline;
    procedure setBTSEE; inline;
    procedure setCRC16EE; inline;
    procedure setCRC5EE; inline;
    procedure setCRC5EE_EOFEE; inline;
    procedure setDFN8EE; inline;
    procedure setDMAEE; inline;
    procedure setEOFEE; inline;
    procedure setPIDEE; inline;
    property BMXEE : TBits_1 read getBMXEE write setBMXEE;
    property BTOEE : TBits_1 read getBTOEE write setBTOEE;
    property BTSEE : TBits_1 read getBTSEE write setBTSEE;
    property CRC16EE : TBits_1 read getCRC16EE write setCRC16EE;
    property CRC5EE : TBits_1 read getCRC5EE write setCRC5EE;
    property CRC5EE_EOFEE : TBits_1 read getCRC5EE_EOFEE write setCRC5EE_EOFEE;
    property DFN8EE : TBits_1 read getDFN8EE write setDFN8EE;
    property DMAEE : TBits_1 read getDMAEE write setDMAEE;
    property EOFEE : TBits_1 read getEOFEE write setEOFEE;
    property PIDEE : TBits_1 read getPIDEE write setPIDEE;
  end;
  TUSB_U1STAT = record
  private
    function  getDIR : TBits_1; inline;
    function  getENDPT : TBits_4; inline;
    function  getENDPT0 : TBits_1; inline;
    function  getENDPT1 : TBits_1; inline;
    function  getENDPT2 : TBits_1; inline;
    function  getENDPT3 : TBits_1; inline;
    function  getPPBI : TBits_1; inline;
    procedure setDIR(thebits : TBits_1); inline;
    procedure setENDPT(thebits : TBits_4); inline;
    procedure setENDPT0(thebits : TBits_1); inline;
    procedure setENDPT1(thebits : TBits_1); inline;
    procedure setENDPT2(thebits : TBits_1); inline;
    procedure setENDPT3(thebits : TBits_1); inline;
    procedure setPPBI(thebits : TBits_1); inline;
  public
    procedure clearDIR; inline;
    procedure clearENDPT0; inline;
    procedure clearENDPT1; inline;
    procedure clearENDPT2; inline;
    procedure clearENDPT3; inline;
    procedure clearPPBI; inline;
    procedure setDIR; inline;
    procedure setENDPT0; inline;
    procedure setENDPT1; inline;
    procedure setENDPT2; inline;
    procedure setENDPT3; inline;
    procedure setPPBI; inline;
    property DIR : TBits_1 read getDIR write setDIR;
    property ENDPT : TBits_4 read getENDPT write setENDPT;
    property ENDPT0 : TBits_1 read getENDPT0 write setENDPT0;
    property ENDPT1 : TBits_1 read getENDPT1 write setENDPT1;
    property ENDPT2 : TBits_1 read getENDPT2 write setENDPT2;
    property ENDPT3 : TBits_1 read getENDPT3 write setENDPT3;
    property PPBI : TBits_1 read getPPBI write setPPBI;
  end;
  TUSB_U1CON = record
  private
    function  getHOSTEN : TBits_1; inline;
    function  getJSTATE : TBits_1; inline;
    function  getPKTDIS : TBits_1; inline;
    function  getPKTDIS_TOKBUSY : TBits_1; inline;
    function  getPPBRST : TBits_1; inline;
    function  getRESUME : TBits_1; inline;
    function  getSE0 : TBits_1; inline;
    function  getSOFEN : TBits_1; inline;
    function  getTOKBUSY : TBits_1; inline;
    function  getUSBEN : TBits_1; inline;
    function  getUSBEN_SOFEN : TBits_1; inline;
    function  getUSBRST : TBits_1; inline;
    procedure setHOSTEN(thebits : TBits_1); inline;
    procedure setJSTATE(thebits : TBits_1); inline;
    procedure setPKTDIS(thebits : TBits_1); inline;
    procedure setPKTDIS_TOKBUSY(thebits : TBits_1); inline;
    procedure setPPBRST(thebits : TBits_1); inline;
    procedure setRESUME(thebits : TBits_1); inline;
    procedure setSE0(thebits : TBits_1); inline;
    procedure setSOFEN(thebits : TBits_1); inline;
    procedure setTOKBUSY(thebits : TBits_1); inline;
    procedure setUSBEN(thebits : TBits_1); inline;
    procedure setUSBEN_SOFEN(thebits : TBits_1); inline;
    procedure setUSBRST(thebits : TBits_1); inline;
  public
    procedure clearHOSTEN; inline;
    procedure clearJSTATE; inline;
    procedure clearPKTDIS; inline;
    procedure clearPKTDIS_TOKBUSY; inline;
    procedure clearPPBRST; inline;
    procedure clearRESUME; inline;
    procedure clearSE0; inline;
    procedure clearSOFEN; inline;
    procedure clearTOKBUSY; inline;
    procedure clearUSBEN; inline;
    procedure clearUSBEN_SOFEN; inline;
    procedure clearUSBRST; inline;
    procedure setHOSTEN; inline;
    procedure setJSTATE; inline;
    procedure setPKTDIS; inline;
    procedure setPKTDIS_TOKBUSY; inline;
    procedure setPPBRST; inline;
    procedure setRESUME; inline;
    procedure setSE0; inline;
    procedure setSOFEN; inline;
    procedure setTOKBUSY; inline;
    procedure setUSBEN; inline;
    procedure setUSBEN_SOFEN; inline;
    procedure setUSBRST; inline;
    property HOSTEN : TBits_1 read getHOSTEN write setHOSTEN;
    property JSTATE : TBits_1 read getJSTATE write setJSTATE;
    property PKTDIS : TBits_1 read getPKTDIS write setPKTDIS;
    property PKTDIS_TOKBUSY : TBits_1 read getPKTDIS_TOKBUSY write setPKTDIS_TOKBUSY;
    property PPBRST : TBits_1 read getPPBRST write setPPBRST;
    property RESUME : TBits_1 read getRESUME write setRESUME;
    property SE0 : TBits_1 read getSE0 write setSE0;
    property SOFEN : TBits_1 read getSOFEN write setSOFEN;
    property TOKBUSY : TBits_1 read getTOKBUSY write setTOKBUSY;
    property USBEN : TBits_1 read getUSBEN write setUSBEN;
    property USBEN_SOFEN : TBits_1 read getUSBEN_SOFEN write setUSBEN_SOFEN;
    property USBRST : TBits_1 read getUSBRST write setUSBRST;
  end;
  TUSB_U1ADDR = record
  private
    function  getDEVADDR : TBits_7; inline;
    function  getDEVADDR0 : TBits_1; inline;
    function  getDEVADDR1 : TBits_1; inline;
    function  getDEVADDR2 : TBits_1; inline;
    function  getDEVADDR3 : TBits_1; inline;
    function  getDEVADDR4 : TBits_1; inline;
    function  getDEVADDR5 : TBits_1; inline;
    function  getDEVADDR6 : TBits_1; inline;
    function  getLSPDEN : TBits_1; inline;
    procedure setDEVADDR(thebits : TBits_7); inline;
    procedure setDEVADDR0(thebits : TBits_1); inline;
    procedure setDEVADDR1(thebits : TBits_1); inline;
    procedure setDEVADDR2(thebits : TBits_1); inline;
    procedure setDEVADDR3(thebits : TBits_1); inline;
    procedure setDEVADDR4(thebits : TBits_1); inline;
    procedure setDEVADDR5(thebits : TBits_1); inline;
    procedure setDEVADDR6(thebits : TBits_1); inline;
    procedure setLSPDEN(thebits : TBits_1); inline;
  public
    procedure clearDEVADDR0; inline;
    procedure clearDEVADDR1; inline;
    procedure clearDEVADDR2; inline;
    procedure clearDEVADDR3; inline;
    procedure clearDEVADDR4; inline;
    procedure clearDEVADDR5; inline;
    procedure clearDEVADDR6; inline;
    procedure clearLSPDEN; inline;
    procedure setDEVADDR0; inline;
    procedure setDEVADDR1; inline;
    procedure setDEVADDR2; inline;
    procedure setDEVADDR3; inline;
    procedure setDEVADDR4; inline;
    procedure setDEVADDR5; inline;
    procedure setDEVADDR6; inline;
    procedure setLSPDEN; inline;
    property DEVADDR : TBits_7 read getDEVADDR write setDEVADDR;
    property DEVADDR0 : TBits_1 read getDEVADDR0 write setDEVADDR0;
    property DEVADDR1 : TBits_1 read getDEVADDR1 write setDEVADDR1;
    property DEVADDR2 : TBits_1 read getDEVADDR2 write setDEVADDR2;
    property DEVADDR3 : TBits_1 read getDEVADDR3 write setDEVADDR3;
    property DEVADDR4 : TBits_1 read getDEVADDR4 write setDEVADDR4;
    property DEVADDR5 : TBits_1 read getDEVADDR5 write setDEVADDR5;
    property DEVADDR6 : TBits_1 read getDEVADDR6 write setDEVADDR6;
    property LSPDEN : TBits_1 read getLSPDEN write setLSPDEN;
  end;
  TUSB_U1FRML = record
  private
    function  getFRM0 : TBits_1; inline;
    function  getFRM1 : TBits_1; inline;
    function  getFRM2 : TBits_1; inline;
    function  getFRM3 : TBits_1; inline;
    function  getFRM4 : TBits_1; inline;
    function  getFRM5 : TBits_1; inline;
    function  getFRM6 : TBits_1; inline;
    function  getFRM7 : TBits_1; inline;
    function  getFRML : TBits_8; inline;
    procedure setFRM0(thebits : TBits_1); inline;
    procedure setFRM1(thebits : TBits_1); inline;
    procedure setFRM2(thebits : TBits_1); inline;
    procedure setFRM3(thebits : TBits_1); inline;
    procedure setFRM4(thebits : TBits_1); inline;
    procedure setFRM5(thebits : TBits_1); inline;
    procedure setFRM6(thebits : TBits_1); inline;
    procedure setFRM7(thebits : TBits_1); inline;
    procedure setFRML(thebits : TBits_8); inline;
  public
    procedure clearFRM0; inline;
    procedure clearFRM1; inline;
    procedure clearFRM2; inline;
    procedure clearFRM3; inline;
    procedure clearFRM4; inline;
    procedure clearFRM5; inline;
    procedure clearFRM6; inline;
    procedure clearFRM7; inline;
    procedure setFRM0; inline;
    procedure setFRM1; inline;
    procedure setFRM2; inline;
    procedure setFRM3; inline;
    procedure setFRM4; inline;
    procedure setFRM5; inline;
    procedure setFRM6; inline;
    procedure setFRM7; inline;
    property FRM0 : TBits_1 read getFRM0 write setFRM0;
    property FRM1 : TBits_1 read getFRM1 write setFRM1;
    property FRM2 : TBits_1 read getFRM2 write setFRM2;
    property FRM3 : TBits_1 read getFRM3 write setFRM3;
    property FRM4 : TBits_1 read getFRM4 write setFRM4;
    property FRM5 : TBits_1 read getFRM5 write setFRM5;
    property FRM6 : TBits_1 read getFRM6 write setFRM6;
    property FRM7 : TBits_1 read getFRM7 write setFRM7;
    property FRML : TBits_8 read getFRML write setFRML;
  end;
  TUSB_U1FRMH = record
  private
    function  getFRM10 : TBits_1; inline;
    function  getFRM8 : TBits_1; inline;
    function  getFRM9 : TBits_1; inline;
    function  getFRMH : TBits_3; inline;
    procedure setFRM10(thebits : TBits_1); inline;
    procedure setFRM8(thebits : TBits_1); inline;
    procedure setFRM9(thebits : TBits_1); inline;
    procedure setFRMH(thebits : TBits_3); inline;
  public
    procedure clearFRM10; inline;
    procedure clearFRM8; inline;
    procedure clearFRM9; inline;
    procedure setFRM10; inline;
    procedure setFRM8; inline;
    procedure setFRM9; inline;
    property FRM10 : TBits_1 read getFRM10 write setFRM10;
    property FRM8 : TBits_1 read getFRM8 write setFRM8;
    property FRM9 : TBits_1 read getFRM9 write setFRM9;
    property FRMH : TBits_3 read getFRMH write setFRMH;
  end;
  TUSB_U1TOK = record
  private
    function  getEP : TBits_4; inline;
    function  getEP0 : TBits_1; inline;
    function  getEP1 : TBits_1; inline;
    function  getEP2 : TBits_1; inline;
    function  getEP3 : TBits_1; inline;
    function  getPID : TBits_4; inline;
    function  getPID0 : TBits_1; inline;
    function  getPID1 : TBits_1; inline;
    function  getPID2 : TBits_1; inline;
    function  getPID3 : TBits_1; inline;
    procedure setEP(thebits : TBits_4); inline;
    procedure setEP0(thebits : TBits_1); inline;
    procedure setEP1(thebits : TBits_1); inline;
    procedure setEP2(thebits : TBits_1); inline;
    procedure setEP3(thebits : TBits_1); inline;
    procedure setPID(thebits : TBits_4); inline;
    procedure setPID0(thebits : TBits_1); inline;
    procedure setPID1(thebits : TBits_1); inline;
    procedure setPID2(thebits : TBits_1); inline;
    procedure setPID3(thebits : TBits_1); inline;
  public
    procedure clearEP0; inline;
    procedure clearEP1; inline;
    procedure clearEP2; inline;
    procedure clearEP3; inline;
    procedure clearPID0; inline;
    procedure clearPID1; inline;
    procedure clearPID2; inline;
    procedure clearPID3; inline;
    procedure setEP0; inline;
    procedure setEP1; inline;
    procedure setEP2; inline;
    procedure setEP3; inline;
    procedure setPID0; inline;
    procedure setPID1; inline;
    procedure setPID2; inline;
    procedure setPID3; inline;
    property EP : TBits_4 read getEP write setEP;
    property EP0 : TBits_1 read getEP0 write setEP0;
    property EP1 : TBits_1 read getEP1 write setEP1;
    property EP2 : TBits_1 read getEP2 write setEP2;
    property EP3 : TBits_1 read getEP3 write setEP3;
    property PID : TBits_4 read getPID write setPID;
    property PID0 : TBits_1 read getPID0 write setPID0;
    property PID1 : TBits_1 read getPID1 write setPID1;
    property PID2 : TBits_1 read getPID2 write setPID2;
    property PID3 : TBits_1 read getPID3 write setPID3;
  end;
type
  TUSBRegisters = record
    U1OTGIR : longWord;
    U1OTGIRCLR : longWord;
    U1OTGIE : longWord;
    U1OTGIECLR : longWord;
    U1OTGIESET : longWord;
    U1OTGIEINV : longWord;
    U1OTGSTAT : longWord;
    U1OTGCON : longWord;
    U1OTGCONCLR : longWord;
    U1OTGCONSET : longWord;
    U1OTGCONINV : longWord;
    U1PWRC : longWord;
    U1PWRCCLR : longWord;
    U1PWRCSET : longWord;
    U1PWRCINV : longWord;
    U1IRbits : TUSB_U1IR;
    U1IR : longWord;
    U1IRCLR : longWord;
    U1IEbits : TUSB_U1IE;
    U1IE : longWord;
    U1IECLR : longWord;
    U1IESET : longWord;
    U1IEINV : longWord;
    U1EIRbits : TUSB_U1EIR;
    U1EIR : longWord;
    U1EIRCLR : longWord;
    U1EIEbits : TUSB_U1EIE;
    U1EIE : longWord;
    U1EIECLR : longWord;
    U1EIESET : longWord;
    U1EIEINV : longWord;
    U1STATbits : TUSB_U1STAT;
    U1STAT : longWord;
    U1CONbits : TUSB_U1CON;
    U1CON : longWord;
    U1CONCLR : longWord;
    U1CONSET : longWord;
    U1CONINV : longWord;
    U1ADDRbits : TUSB_U1ADDR;
    U1ADDR : longWord;
    U1ADDRCLR : longWord;
    U1ADDRSET : longWord;
    U1ADDRINV : longWord;
    U1BDTP1 : longWord;
    U1BDTP1CLR : longWord;
    U1BDTP1SET : longWord;
    U1BDTP1INV : longWord;
    U1FRMLbits : TUSB_U1FRML;
    U1FRML : longWord;
    U1FRMHbits : TUSB_U1FRMH;
    U1FRMH : longWord;
    U1TOKbits : TUSB_U1TOK;
    U1TOK : longWord;
    U1TOKCLR : longWord;
    U1TOKSET : longWord;
    U1TOKINV : longWord;
    U1SOF : longWord;
    U1SOFCLR : longWord;
    U1SOFSET : longWord;
    U1SOFINV : longWord;
    U1BDTP2 : longWord;
    U1BDTP2CLR : longWord;
    U1BDTP2SET : longWord;
    U1BDTP2INV : longWord;
    U1BDTP3 : longWord;
    U1BDTP3CLR : longWord;
    U1BDTP3SET : longWord;
    U1BDTP3INV : longWord;
    U1CNFG1 : longWord;
    U1CNFG1CLR : longWord;
    U1CNFG1SET : longWord;
    U1CNFG1INV : longWord;
    U1EP0 : longWord;
    U1EP0CLR : longWord;
    U1EP0SET : longWord;
    U1EP0INV : longWord;
    U1EP1 : longWord;
    U1EP1CLR : longWord;
    U1EP1SET : longWord;
    U1EP1INV : longWord;
    U1EP2 : longWord;
    U1EP2CLR : longWord;
    U1EP2SET : longWord;
    U1EP2INV : longWord;
    U1EP3 : longWord;
    U1EP3CLR : longWord;
    U1EP3SET : longWord;
    U1EP3INV : longWord;
    U1EP4 : longWord;
    U1EP4CLR : longWord;
    U1EP4SET : longWord;
    U1EP4INV : longWord;
    U1EP5 : longWord;
    U1EP5CLR : longWord;
    U1EP5SET : longWord;
    U1EP5INV : longWord;
    U1EP6 : longWord;
    U1EP6CLR : longWord;
    U1EP6SET : longWord;
    U1EP6INV : longWord;
    U1EP7 : longWord;
    U1EP7CLR : longWord;
    U1EP7SET : longWord;
    U1EP7INV : longWord;
    U1EP8 : longWord;
    U1EP8CLR : longWord;
    U1EP8SET : longWord;
    U1EP8INV : longWord;
    U1EP9 : longWord;
    U1EP9CLR : longWord;
    U1EP9SET : longWord;
    U1EP9INV : longWord;
    U1EP10 : longWord;
    U1EP10CLR : longWord;
    U1EP10SET : longWord;
    U1EP10INV : longWord;
    U1EP11 : longWord;
    U1EP11CLR : longWord;
    U1EP11SET : longWord;
    U1EP11INV : longWord;
    U1EP12 : longWord;
    U1EP12CLR : longWord;
    U1EP12SET : longWord;
    U1EP12INV : longWord;
    U1EP13 : longWord;
    U1EP13CLR : longWord;
    U1EP13SET : longWord;
    U1EP13INV : longWord;
    U1EP14 : longWord;
    U1EP14CLR : longWord;
    U1EP14SET : longWord;
    U1EP14INV : longWord;
    U1EP15 : longWord;
    U1EP15CLR : longWord;
    U1EP15SET : longWord;
    U1EP15INV : longWord;
  end;
  TPORTB_TRISB = record
  private
    function  getTRISB0 : TBits_1; inline;
    function  getTRISB1 : TBits_1; inline;
    function  getTRISB10 : TBits_1; inline;
    function  getTRISB11 : TBits_1; inline;
    function  getTRISB12 : TBits_1; inline;
    function  getTRISB13 : TBits_1; inline;
    function  getTRISB14 : TBits_1; inline;
    function  getTRISB15 : TBits_1; inline;
    function  getTRISB2 : TBits_1; inline;
    function  getTRISB3 : TBits_1; inline;
    function  getTRISB4 : TBits_1; inline;
    function  getTRISB5 : TBits_1; inline;
    function  getTRISB6 : TBits_1; inline;
    function  getTRISB7 : TBits_1; inline;
    function  getTRISB8 : TBits_1; inline;
    function  getTRISB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISB0(thebits : TBits_1); inline;
    procedure setTRISB1(thebits : TBits_1); inline;
    procedure setTRISB10(thebits : TBits_1); inline;
    procedure setTRISB11(thebits : TBits_1); inline;
    procedure setTRISB12(thebits : TBits_1); inline;
    procedure setTRISB13(thebits : TBits_1); inline;
    procedure setTRISB14(thebits : TBits_1); inline;
    procedure setTRISB15(thebits : TBits_1); inline;
    procedure setTRISB2(thebits : TBits_1); inline;
    procedure setTRISB3(thebits : TBits_1); inline;
    procedure setTRISB4(thebits : TBits_1); inline;
    procedure setTRISB5(thebits : TBits_1); inline;
    procedure setTRISB6(thebits : TBits_1); inline;
    procedure setTRISB7(thebits : TBits_1); inline;
    procedure setTRISB8(thebits : TBits_1); inline;
    procedure setTRISB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISB0; inline;
    procedure clearTRISB10; inline;
    procedure clearTRISB11; inline;
    procedure clearTRISB12; inline;
    procedure clearTRISB13; inline;
    procedure clearTRISB14; inline;
    procedure clearTRISB15; inline;
    procedure clearTRISB1; inline;
    procedure clearTRISB2; inline;
    procedure clearTRISB3; inline;
    procedure clearTRISB4; inline;
    procedure clearTRISB5; inline;
    procedure clearTRISB6; inline;
    procedure clearTRISB7; inline;
    procedure clearTRISB8; inline;
    procedure clearTRISB9; inline;
    procedure setTRISB0; inline;
    procedure setTRISB10; inline;
    procedure setTRISB11; inline;
    procedure setTRISB12; inline;
    procedure setTRISB13; inline;
    procedure setTRISB14; inline;
    procedure setTRISB15; inline;
    procedure setTRISB1; inline;
    procedure setTRISB2; inline;
    procedure setTRISB3; inline;
    procedure setTRISB4; inline;
    procedure setTRISB5; inline;
    procedure setTRISB6; inline;
    procedure setTRISB7; inline;
    procedure setTRISB8; inline;
    procedure setTRISB9; inline;
    property TRISB0 : TBits_1 read getTRISB0 write setTRISB0;
    property TRISB1 : TBits_1 read getTRISB1 write setTRISB1;
    property TRISB10 : TBits_1 read getTRISB10 write setTRISB10;
    property TRISB11 : TBits_1 read getTRISB11 write setTRISB11;
    property TRISB12 : TBits_1 read getTRISB12 write setTRISB12;
    property TRISB13 : TBits_1 read getTRISB13 write setTRISB13;
    property TRISB14 : TBits_1 read getTRISB14 write setTRISB14;
    property TRISB15 : TBits_1 read getTRISB15 write setTRISB15;
    property TRISB2 : TBits_1 read getTRISB2 write setTRISB2;
    property TRISB3 : TBits_1 read getTRISB3 write setTRISB3;
    property TRISB4 : TBits_1 read getTRISB4 write setTRISB4;
    property TRISB5 : TBits_1 read getTRISB5 write setTRISB5;
    property TRISB6 : TBits_1 read getTRISB6 write setTRISB6;
    property TRISB7 : TBits_1 read getTRISB7 write setTRISB7;
    property TRISB8 : TBits_1 read getTRISB8 write setTRISB8;
    property TRISB9 : TBits_1 read getTRISB9 write setTRISB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_PORTB = record
  private
    function  getRB0 : TBits_1; inline;
    function  getRB1 : TBits_1; inline;
    function  getRB10 : TBits_1; inline;
    function  getRB11 : TBits_1; inline;
    function  getRB12 : TBits_1; inline;
    function  getRB13 : TBits_1; inline;
    function  getRB14 : TBits_1; inline;
    function  getRB15 : TBits_1; inline;
    function  getRB2 : TBits_1; inline;
    function  getRB3 : TBits_1; inline;
    function  getRB4 : TBits_1; inline;
    function  getRB5 : TBits_1; inline;
    function  getRB6 : TBits_1; inline;
    function  getRB7 : TBits_1; inline;
    function  getRB8 : TBits_1; inline;
    function  getRB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRB0(thebits : TBits_1); inline;
    procedure setRB1(thebits : TBits_1); inline;
    procedure setRB10(thebits : TBits_1); inline;
    procedure setRB11(thebits : TBits_1); inline;
    procedure setRB12(thebits : TBits_1); inline;
    procedure setRB13(thebits : TBits_1); inline;
    procedure setRB14(thebits : TBits_1); inline;
    procedure setRB15(thebits : TBits_1); inline;
    procedure setRB2(thebits : TBits_1); inline;
    procedure setRB3(thebits : TBits_1); inline;
    procedure setRB4(thebits : TBits_1); inline;
    procedure setRB5(thebits : TBits_1); inline;
    procedure setRB6(thebits : TBits_1); inline;
    procedure setRB7(thebits : TBits_1); inline;
    procedure setRB8(thebits : TBits_1); inline;
    procedure setRB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRB0; inline;
    procedure clearRB10; inline;
    procedure clearRB11; inline;
    procedure clearRB12; inline;
    procedure clearRB13; inline;
    procedure clearRB14; inline;
    procedure clearRB15; inline;
    procedure clearRB1; inline;
    procedure clearRB2; inline;
    procedure clearRB3; inline;
    procedure clearRB4; inline;
    procedure clearRB5; inline;
    procedure clearRB6; inline;
    procedure clearRB7; inline;
    procedure clearRB8; inline;
    procedure clearRB9; inline;
    procedure setRB0; inline;
    procedure setRB10; inline;
    procedure setRB11; inline;
    procedure setRB12; inline;
    procedure setRB13; inline;
    procedure setRB14; inline;
    procedure setRB15; inline;
    procedure setRB1; inline;
    procedure setRB2; inline;
    procedure setRB3; inline;
    procedure setRB4; inline;
    procedure setRB5; inline;
    procedure setRB6; inline;
    procedure setRB7; inline;
    procedure setRB8; inline;
    procedure setRB9; inline;
    property RB0 : TBits_1 read getRB0 write setRB0;
    property RB1 : TBits_1 read getRB1 write setRB1;
    property RB10 : TBits_1 read getRB10 write setRB10;
    property RB11 : TBits_1 read getRB11 write setRB11;
    property RB12 : TBits_1 read getRB12 write setRB12;
    property RB13 : TBits_1 read getRB13 write setRB13;
    property RB14 : TBits_1 read getRB14 write setRB14;
    property RB15 : TBits_1 read getRB15 write setRB15;
    property RB2 : TBits_1 read getRB2 write setRB2;
    property RB3 : TBits_1 read getRB3 write setRB3;
    property RB4 : TBits_1 read getRB4 write setRB4;
    property RB5 : TBits_1 read getRB5 write setRB5;
    property RB6 : TBits_1 read getRB6 write setRB6;
    property RB7 : TBits_1 read getRB7 write setRB7;
    property RB8 : TBits_1 read getRB8 write setRB8;
    property RB9 : TBits_1 read getRB9 write setRB9;
    property w : TBits_32 read getw write setw;
  end;
  TPortB_bits=(RB0=0,RB1=1,RB2=2,RB3=3,RB4=4,RB5=5,RB6=6,RB7=7,RB8=8,RB9=9,RB10=10,RB11=11,RB12=12,RB13=13,RB14=14,RB15=15);
  TPortB_bitset = set of TPortB_bits;
  TPORTB_LATB = record
  private
    function  getLATB0 : TBits_1; inline;
    function  getLATB1 : TBits_1; inline;
    function  getLATB10 : TBits_1; inline;
    function  getLATB11 : TBits_1; inline;
    function  getLATB12 : TBits_1; inline;
    function  getLATB13 : TBits_1; inline;
    function  getLATB14 : TBits_1; inline;
    function  getLATB15 : TBits_1; inline;
    function  getLATB2 : TBits_1; inline;
    function  getLATB3 : TBits_1; inline;
    function  getLATB4 : TBits_1; inline;
    function  getLATB5 : TBits_1; inline;
    function  getLATB6 : TBits_1; inline;
    function  getLATB7 : TBits_1; inline;
    function  getLATB8 : TBits_1; inline;
    function  getLATB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATB0(thebits : TBits_1); inline;
    procedure setLATB1(thebits : TBits_1); inline;
    procedure setLATB10(thebits : TBits_1); inline;
    procedure setLATB11(thebits : TBits_1); inline;
    procedure setLATB12(thebits : TBits_1); inline;
    procedure setLATB13(thebits : TBits_1); inline;
    procedure setLATB14(thebits : TBits_1); inline;
    procedure setLATB15(thebits : TBits_1); inline;
    procedure setLATB2(thebits : TBits_1); inline;
    procedure setLATB3(thebits : TBits_1); inline;
    procedure setLATB4(thebits : TBits_1); inline;
    procedure setLATB5(thebits : TBits_1); inline;
    procedure setLATB6(thebits : TBits_1); inline;
    procedure setLATB7(thebits : TBits_1); inline;
    procedure setLATB8(thebits : TBits_1); inline;
    procedure setLATB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATB0; inline;
    procedure clearLATB10; inline;
    procedure clearLATB11; inline;
    procedure clearLATB12; inline;
    procedure clearLATB13; inline;
    procedure clearLATB14; inline;
    procedure clearLATB15; inline;
    procedure clearLATB1; inline;
    procedure clearLATB2; inline;
    procedure clearLATB3; inline;
    procedure clearLATB4; inline;
    procedure clearLATB5; inline;
    procedure clearLATB6; inline;
    procedure clearLATB7; inline;
    procedure clearLATB8; inline;
    procedure clearLATB9; inline;
    procedure setLATB0; inline;
    procedure setLATB10; inline;
    procedure setLATB11; inline;
    procedure setLATB12; inline;
    procedure setLATB13; inline;
    procedure setLATB14; inline;
    procedure setLATB15; inline;
    procedure setLATB1; inline;
    procedure setLATB2; inline;
    procedure setLATB3; inline;
    procedure setLATB4; inline;
    procedure setLATB5; inline;
    procedure setLATB6; inline;
    procedure setLATB7; inline;
    procedure setLATB8; inline;
    procedure setLATB9; inline;
    property LATB0 : TBits_1 read getLATB0 write setLATB0;
    property LATB1 : TBits_1 read getLATB1 write setLATB1;
    property LATB10 : TBits_1 read getLATB10 write setLATB10;
    property LATB11 : TBits_1 read getLATB11 write setLATB11;
    property LATB12 : TBits_1 read getLATB12 write setLATB12;
    property LATB13 : TBits_1 read getLATB13 write setLATB13;
    property LATB14 : TBits_1 read getLATB14 write setLATB14;
    property LATB15 : TBits_1 read getLATB15 write setLATB15;
    property LATB2 : TBits_1 read getLATB2 write setLATB2;
    property LATB3 : TBits_1 read getLATB3 write setLATB3;
    property LATB4 : TBits_1 read getLATB4 write setLATB4;
    property LATB5 : TBits_1 read getLATB5 write setLATB5;
    property LATB6 : TBits_1 read getLATB6 write setLATB6;
    property LATB7 : TBits_1 read getLATB7 write setLATB7;
    property LATB8 : TBits_1 read getLATB8 write setLATB8;
    property LATB9 : TBits_1 read getLATB9 write setLATB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_ODCB = record
  private
    function  getODCB0 : TBits_1; inline;
    function  getODCB1 : TBits_1; inline;
    function  getODCB10 : TBits_1; inline;
    function  getODCB11 : TBits_1; inline;
    function  getODCB12 : TBits_1; inline;
    function  getODCB13 : TBits_1; inline;
    function  getODCB14 : TBits_1; inline;
    function  getODCB15 : TBits_1; inline;
    function  getODCB2 : TBits_1; inline;
    function  getODCB3 : TBits_1; inline;
    function  getODCB4 : TBits_1; inline;
    function  getODCB5 : TBits_1; inline;
    function  getODCB6 : TBits_1; inline;
    function  getODCB7 : TBits_1; inline;
    function  getODCB8 : TBits_1; inline;
    function  getODCB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCB0(thebits : TBits_1); inline;
    procedure setODCB1(thebits : TBits_1); inline;
    procedure setODCB10(thebits : TBits_1); inline;
    procedure setODCB11(thebits : TBits_1); inline;
    procedure setODCB12(thebits : TBits_1); inline;
    procedure setODCB13(thebits : TBits_1); inline;
    procedure setODCB14(thebits : TBits_1); inline;
    procedure setODCB15(thebits : TBits_1); inline;
    procedure setODCB2(thebits : TBits_1); inline;
    procedure setODCB3(thebits : TBits_1); inline;
    procedure setODCB4(thebits : TBits_1); inline;
    procedure setODCB5(thebits : TBits_1); inline;
    procedure setODCB6(thebits : TBits_1); inline;
    procedure setODCB7(thebits : TBits_1); inline;
    procedure setODCB8(thebits : TBits_1); inline;
    procedure setODCB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCB0; inline;
    procedure clearODCB10; inline;
    procedure clearODCB11; inline;
    procedure clearODCB12; inline;
    procedure clearODCB13; inline;
    procedure clearODCB14; inline;
    procedure clearODCB15; inline;
    procedure clearODCB1; inline;
    procedure clearODCB2; inline;
    procedure clearODCB3; inline;
    procedure clearODCB4; inline;
    procedure clearODCB5; inline;
    procedure clearODCB6; inline;
    procedure clearODCB7; inline;
    procedure clearODCB8; inline;
    procedure clearODCB9; inline;
    procedure setODCB0; inline;
    procedure setODCB10; inline;
    procedure setODCB11; inline;
    procedure setODCB12; inline;
    procedure setODCB13; inline;
    procedure setODCB14; inline;
    procedure setODCB15; inline;
    procedure setODCB1; inline;
    procedure setODCB2; inline;
    procedure setODCB3; inline;
    procedure setODCB4; inline;
    procedure setODCB5; inline;
    procedure setODCB6; inline;
    procedure setODCB7; inline;
    procedure setODCB8; inline;
    procedure setODCB9; inline;
    property ODCB0 : TBits_1 read getODCB0 write setODCB0;
    property ODCB1 : TBits_1 read getODCB1 write setODCB1;
    property ODCB10 : TBits_1 read getODCB10 write setODCB10;
    property ODCB11 : TBits_1 read getODCB11 write setODCB11;
    property ODCB12 : TBits_1 read getODCB12 write setODCB12;
    property ODCB13 : TBits_1 read getODCB13 write setODCB13;
    property ODCB14 : TBits_1 read getODCB14 write setODCB14;
    property ODCB15 : TBits_1 read getODCB15 write setODCB15;
    property ODCB2 : TBits_1 read getODCB2 write setODCB2;
    property ODCB3 : TBits_1 read getODCB3 write setODCB3;
    property ODCB4 : TBits_1 read getODCB4 write setODCB4;
    property ODCB5 : TBits_1 read getODCB5 write setODCB5;
    property ODCB6 : TBits_1 read getODCB6 write setODCB6;
    property ODCB7 : TBits_1 read getODCB7 write setODCB7;
    property ODCB8 : TBits_1 read getODCB8 write setODCB8;
    property ODCB9 : TBits_1 read getODCB9 write setODCB9;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTBRegisters = record
    TRISBbits : TPORTB_TRISB;
    TRISB : longWord;
    TRISBCLR : longWord;
    TRISBSET : longWord;
    TRISBINV : longWord;
    PORTBbits : TPORTB_PORTB;
    PORTB : longWord;
    PORTBCLR : longWord;
    PORTBSET : longWord;
    PORTBINV : longWord;
    LATBbits : TPORTB_LATB;
    LATB : longWord;
    LATBCLR : longWord;
    LATBSET : longWord;
    LATBINV : longWord;
    ODCBbits : TPORTB_ODCB;
    ODCB : longWord;
    ODCBCLR : longWord;
    ODCBSET : longWord;
    ODCBINV : longWord;
  end;
  TPORTC_TRISC = record
  private
    function  getTRISC12 : TBits_1; inline;
    function  getTRISC13 : TBits_1; inline;
    function  getTRISC14 : TBits_1; inline;
    function  getTRISC15 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISC12(thebits : TBits_1); inline;
    procedure setTRISC13(thebits : TBits_1); inline;
    procedure setTRISC14(thebits : TBits_1); inline;
    procedure setTRISC15(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISC12; inline;
    procedure clearTRISC13; inline;
    procedure clearTRISC14; inline;
    procedure clearTRISC15; inline;
    procedure setTRISC12; inline;
    procedure setTRISC13; inline;
    procedure setTRISC14; inline;
    procedure setTRISC15; inline;
    property TRISC12 : TBits_1 read getTRISC12 write setTRISC12;
    property TRISC13 : TBits_1 read getTRISC13 write setTRISC13;
    property TRISC14 : TBits_1 read getTRISC14 write setTRISC14;
    property TRISC15 : TBits_1 read getTRISC15 write setTRISC15;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_PORTC = record
  private
    function  getRC12 : TBits_1; inline;
    function  getRC13 : TBits_1; inline;
    function  getRC14 : TBits_1; inline;
    function  getRC15 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRC12(thebits : TBits_1); inline;
    procedure setRC13(thebits : TBits_1); inline;
    procedure setRC14(thebits : TBits_1); inline;
    procedure setRC15(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRC12; inline;
    procedure clearRC13; inline;
    procedure clearRC14; inline;
    procedure clearRC15; inline;
    procedure setRC12; inline;
    procedure setRC13; inline;
    procedure setRC14; inline;
    procedure setRC15; inline;
    property RC12 : TBits_1 read getRC12 write setRC12;
    property RC13 : TBits_1 read getRC13 write setRC13;
    property RC14 : TBits_1 read getRC14 write setRC14;
    property RC15 : TBits_1 read getRC15 write setRC15;
    property w : TBits_32 read getw write setw;
  end;
  TPortC_bits=(RC12=12,RC13=13,RC14=14,RC15=15);
  TPortC_bitset = set of TPortC_bits;
  TPORTC_LATC = record
  private
    function  getLATC12 : TBits_1; inline;
    function  getLATC13 : TBits_1; inline;
    function  getLATC14 : TBits_1; inline;
    function  getLATC15 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATC12(thebits : TBits_1); inline;
    procedure setLATC13(thebits : TBits_1); inline;
    procedure setLATC14(thebits : TBits_1); inline;
    procedure setLATC15(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATC12; inline;
    procedure clearLATC13; inline;
    procedure clearLATC14; inline;
    procedure clearLATC15; inline;
    procedure setLATC12; inline;
    procedure setLATC13; inline;
    procedure setLATC14; inline;
    procedure setLATC15; inline;
    property LATC12 : TBits_1 read getLATC12 write setLATC12;
    property LATC13 : TBits_1 read getLATC13 write setLATC13;
    property LATC14 : TBits_1 read getLATC14 write setLATC14;
    property LATC15 : TBits_1 read getLATC15 write setLATC15;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_ODCC = record
  private
    function  getODCC12 : TBits_1; inline;
    function  getODCC13 : TBits_1; inline;
    function  getODCC14 : TBits_1; inline;
    function  getODCC15 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCC12(thebits : TBits_1); inline;
    procedure setODCC13(thebits : TBits_1); inline;
    procedure setODCC14(thebits : TBits_1); inline;
    procedure setODCC15(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCC12; inline;
    procedure clearODCC13; inline;
    procedure clearODCC14; inline;
    procedure clearODCC15; inline;
    procedure setODCC12; inline;
    procedure setODCC13; inline;
    procedure setODCC14; inline;
    procedure setODCC15; inline;
    property ODCC12 : TBits_1 read getODCC12 write setODCC12;
    property ODCC13 : TBits_1 read getODCC13 write setODCC13;
    property ODCC14 : TBits_1 read getODCC14 write setODCC14;
    property ODCC15 : TBits_1 read getODCC15 write setODCC15;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTCRegisters = record
    TRISCbits : TPORTC_TRISC;
    TRISC : longWord;
    TRISCCLR : longWord;
    TRISCSET : longWord;
    TRISCINV : longWord;
    PORTCbits : TPORTC_PORTC;
    PORTC : longWord;
    PORTCCLR : longWord;
    PORTCSET : longWord;
    PORTCINV : longWord;
    LATCbits : TPORTC_LATC;
    LATC : longWord;
    LATCCLR : longWord;
    LATCSET : longWord;
    LATCINV : longWord;
    ODCCbits : TPORTC_ODCC;
    ODCC : longWord;
    ODCCCLR : longWord;
    ODCCSET : longWord;
    ODCCINV : longWord;
  end;
  TPORTD_TRISD = record
  private
    function  getTRISD0 : TBits_1; inline;
    function  getTRISD1 : TBits_1; inline;
    function  getTRISD10 : TBits_1; inline;
    function  getTRISD11 : TBits_1; inline;
    function  getTRISD2 : TBits_1; inline;
    function  getTRISD3 : TBits_1; inline;
    function  getTRISD4 : TBits_1; inline;
    function  getTRISD5 : TBits_1; inline;
    function  getTRISD6 : TBits_1; inline;
    function  getTRISD7 : TBits_1; inline;
    function  getTRISD8 : TBits_1; inline;
    function  getTRISD9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISD0(thebits : TBits_1); inline;
    procedure setTRISD1(thebits : TBits_1); inline;
    procedure setTRISD10(thebits : TBits_1); inline;
    procedure setTRISD11(thebits : TBits_1); inline;
    procedure setTRISD2(thebits : TBits_1); inline;
    procedure setTRISD3(thebits : TBits_1); inline;
    procedure setTRISD4(thebits : TBits_1); inline;
    procedure setTRISD5(thebits : TBits_1); inline;
    procedure setTRISD6(thebits : TBits_1); inline;
    procedure setTRISD7(thebits : TBits_1); inline;
    procedure setTRISD8(thebits : TBits_1); inline;
    procedure setTRISD9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISD0; inline;
    procedure clearTRISD10; inline;
    procedure clearTRISD11; inline;
    procedure clearTRISD1; inline;
    procedure clearTRISD2; inline;
    procedure clearTRISD3; inline;
    procedure clearTRISD4; inline;
    procedure clearTRISD5; inline;
    procedure clearTRISD6; inline;
    procedure clearTRISD7; inline;
    procedure clearTRISD8; inline;
    procedure clearTRISD9; inline;
    procedure setTRISD0; inline;
    procedure setTRISD10; inline;
    procedure setTRISD11; inline;
    procedure setTRISD1; inline;
    procedure setTRISD2; inline;
    procedure setTRISD3; inline;
    procedure setTRISD4; inline;
    procedure setTRISD5; inline;
    procedure setTRISD6; inline;
    procedure setTRISD7; inline;
    procedure setTRISD8; inline;
    procedure setTRISD9; inline;
    property TRISD0 : TBits_1 read getTRISD0 write setTRISD0;
    property TRISD1 : TBits_1 read getTRISD1 write setTRISD1;
    property TRISD10 : TBits_1 read getTRISD10 write setTRISD10;
    property TRISD11 : TBits_1 read getTRISD11 write setTRISD11;
    property TRISD2 : TBits_1 read getTRISD2 write setTRISD2;
    property TRISD3 : TBits_1 read getTRISD3 write setTRISD3;
    property TRISD4 : TBits_1 read getTRISD4 write setTRISD4;
    property TRISD5 : TBits_1 read getTRISD5 write setTRISD5;
    property TRISD6 : TBits_1 read getTRISD6 write setTRISD6;
    property TRISD7 : TBits_1 read getTRISD7 write setTRISD7;
    property TRISD8 : TBits_1 read getTRISD8 write setTRISD8;
    property TRISD9 : TBits_1 read getTRISD9 write setTRISD9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTD_PORTD = record
  private
    function  getRD0 : TBits_1; inline;
    function  getRD1 : TBits_1; inline;
    function  getRD10 : TBits_1; inline;
    function  getRD11 : TBits_1; inline;
    function  getRD2 : TBits_1; inline;
    function  getRD3 : TBits_1; inline;
    function  getRD4 : TBits_1; inline;
    function  getRD5 : TBits_1; inline;
    function  getRD6 : TBits_1; inline;
    function  getRD7 : TBits_1; inline;
    function  getRD8 : TBits_1; inline;
    function  getRD9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRD0(thebits : TBits_1); inline;
    procedure setRD1(thebits : TBits_1); inline;
    procedure setRD10(thebits : TBits_1); inline;
    procedure setRD11(thebits : TBits_1); inline;
    procedure setRD2(thebits : TBits_1); inline;
    procedure setRD3(thebits : TBits_1); inline;
    procedure setRD4(thebits : TBits_1); inline;
    procedure setRD5(thebits : TBits_1); inline;
    procedure setRD6(thebits : TBits_1); inline;
    procedure setRD7(thebits : TBits_1); inline;
    procedure setRD8(thebits : TBits_1); inline;
    procedure setRD9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRD0; inline;
    procedure clearRD10; inline;
    procedure clearRD11; inline;
    procedure clearRD1; inline;
    procedure clearRD2; inline;
    procedure clearRD3; inline;
    procedure clearRD4; inline;
    procedure clearRD5; inline;
    procedure clearRD6; inline;
    procedure clearRD7; inline;
    procedure clearRD8; inline;
    procedure clearRD9; inline;
    procedure setRD0; inline;
    procedure setRD10; inline;
    procedure setRD11; inline;
    procedure setRD1; inline;
    procedure setRD2; inline;
    procedure setRD3; inline;
    procedure setRD4; inline;
    procedure setRD5; inline;
    procedure setRD6; inline;
    procedure setRD7; inline;
    procedure setRD8; inline;
    procedure setRD9; inline;
    property RD0 : TBits_1 read getRD0 write setRD0;
    property RD1 : TBits_1 read getRD1 write setRD1;
    property RD10 : TBits_1 read getRD10 write setRD10;
    property RD11 : TBits_1 read getRD11 write setRD11;
    property RD2 : TBits_1 read getRD2 write setRD2;
    property RD3 : TBits_1 read getRD3 write setRD3;
    property RD4 : TBits_1 read getRD4 write setRD4;
    property RD5 : TBits_1 read getRD5 write setRD5;
    property RD6 : TBits_1 read getRD6 write setRD6;
    property RD7 : TBits_1 read getRD7 write setRD7;
    property RD8 : TBits_1 read getRD8 write setRD8;
    property RD9 : TBits_1 read getRD9 write setRD9;
    property w : TBits_32 read getw write setw;
  end;
  TPortD_bits=(RD0=0,RD1=1,RD2=2,RD3=3,RD4=4,RD5=5,RD6=6,RD7=7,RD8=8,RD9=9,RD10=10,RD11=11);
  TPortD_bitset = set of TPortD_bits;
  TPORTD_LATD = record
  private
    function  getLATD0 : TBits_1; inline;
    function  getLATD1 : TBits_1; inline;
    function  getLATD10 : TBits_1; inline;
    function  getLATD11 : TBits_1; inline;
    function  getLATD2 : TBits_1; inline;
    function  getLATD3 : TBits_1; inline;
    function  getLATD4 : TBits_1; inline;
    function  getLATD5 : TBits_1; inline;
    function  getLATD6 : TBits_1; inline;
    function  getLATD7 : TBits_1; inline;
    function  getLATD8 : TBits_1; inline;
    function  getLATD9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATD0(thebits : TBits_1); inline;
    procedure setLATD1(thebits : TBits_1); inline;
    procedure setLATD10(thebits : TBits_1); inline;
    procedure setLATD11(thebits : TBits_1); inline;
    procedure setLATD2(thebits : TBits_1); inline;
    procedure setLATD3(thebits : TBits_1); inline;
    procedure setLATD4(thebits : TBits_1); inline;
    procedure setLATD5(thebits : TBits_1); inline;
    procedure setLATD6(thebits : TBits_1); inline;
    procedure setLATD7(thebits : TBits_1); inline;
    procedure setLATD8(thebits : TBits_1); inline;
    procedure setLATD9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATD0; inline;
    procedure clearLATD10; inline;
    procedure clearLATD11; inline;
    procedure clearLATD1; inline;
    procedure clearLATD2; inline;
    procedure clearLATD3; inline;
    procedure clearLATD4; inline;
    procedure clearLATD5; inline;
    procedure clearLATD6; inline;
    procedure clearLATD7; inline;
    procedure clearLATD8; inline;
    procedure clearLATD9; inline;
    procedure setLATD0; inline;
    procedure setLATD10; inline;
    procedure setLATD11; inline;
    procedure setLATD1; inline;
    procedure setLATD2; inline;
    procedure setLATD3; inline;
    procedure setLATD4; inline;
    procedure setLATD5; inline;
    procedure setLATD6; inline;
    procedure setLATD7; inline;
    procedure setLATD8; inline;
    procedure setLATD9; inline;
    property LATD0 : TBits_1 read getLATD0 write setLATD0;
    property LATD1 : TBits_1 read getLATD1 write setLATD1;
    property LATD10 : TBits_1 read getLATD10 write setLATD10;
    property LATD11 : TBits_1 read getLATD11 write setLATD11;
    property LATD2 : TBits_1 read getLATD2 write setLATD2;
    property LATD3 : TBits_1 read getLATD3 write setLATD3;
    property LATD4 : TBits_1 read getLATD4 write setLATD4;
    property LATD5 : TBits_1 read getLATD5 write setLATD5;
    property LATD6 : TBits_1 read getLATD6 write setLATD6;
    property LATD7 : TBits_1 read getLATD7 write setLATD7;
    property LATD8 : TBits_1 read getLATD8 write setLATD8;
    property LATD9 : TBits_1 read getLATD9 write setLATD9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTD_ODCD = record
  private
    function  getODCD0 : TBits_1; inline;
    function  getODCD1 : TBits_1; inline;
    function  getODCD10 : TBits_1; inline;
    function  getODCD11 : TBits_1; inline;
    function  getODCD2 : TBits_1; inline;
    function  getODCD3 : TBits_1; inline;
    function  getODCD4 : TBits_1; inline;
    function  getODCD5 : TBits_1; inline;
    function  getODCD6 : TBits_1; inline;
    function  getODCD7 : TBits_1; inline;
    function  getODCD8 : TBits_1; inline;
    function  getODCD9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCD0(thebits : TBits_1); inline;
    procedure setODCD1(thebits : TBits_1); inline;
    procedure setODCD10(thebits : TBits_1); inline;
    procedure setODCD11(thebits : TBits_1); inline;
    procedure setODCD2(thebits : TBits_1); inline;
    procedure setODCD3(thebits : TBits_1); inline;
    procedure setODCD4(thebits : TBits_1); inline;
    procedure setODCD5(thebits : TBits_1); inline;
    procedure setODCD6(thebits : TBits_1); inline;
    procedure setODCD7(thebits : TBits_1); inline;
    procedure setODCD8(thebits : TBits_1); inline;
    procedure setODCD9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCD0; inline;
    procedure clearODCD10; inline;
    procedure clearODCD11; inline;
    procedure clearODCD1; inline;
    procedure clearODCD2; inline;
    procedure clearODCD3; inline;
    procedure clearODCD4; inline;
    procedure clearODCD5; inline;
    procedure clearODCD6; inline;
    procedure clearODCD7; inline;
    procedure clearODCD8; inline;
    procedure clearODCD9; inline;
    procedure setODCD0; inline;
    procedure setODCD10; inline;
    procedure setODCD11; inline;
    procedure setODCD1; inline;
    procedure setODCD2; inline;
    procedure setODCD3; inline;
    procedure setODCD4; inline;
    procedure setODCD5; inline;
    procedure setODCD6; inline;
    procedure setODCD7; inline;
    procedure setODCD8; inline;
    procedure setODCD9; inline;
    property ODCD0 : TBits_1 read getODCD0 write setODCD0;
    property ODCD1 : TBits_1 read getODCD1 write setODCD1;
    property ODCD10 : TBits_1 read getODCD10 write setODCD10;
    property ODCD11 : TBits_1 read getODCD11 write setODCD11;
    property ODCD2 : TBits_1 read getODCD2 write setODCD2;
    property ODCD3 : TBits_1 read getODCD3 write setODCD3;
    property ODCD4 : TBits_1 read getODCD4 write setODCD4;
    property ODCD5 : TBits_1 read getODCD5 write setODCD5;
    property ODCD6 : TBits_1 read getODCD6 write setODCD6;
    property ODCD7 : TBits_1 read getODCD7 write setODCD7;
    property ODCD8 : TBits_1 read getODCD8 write setODCD8;
    property ODCD9 : TBits_1 read getODCD9 write setODCD9;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTDRegisters = record
    TRISDbits : TPORTD_TRISD;
    TRISD : longWord;
    TRISDCLR : longWord;
    TRISDSET : longWord;
    TRISDINV : longWord;
    PORTDbits : TPORTD_PORTD;
    PORTD : longWord;
    PORTDCLR : longWord;
    PORTDSET : longWord;
    PORTDINV : longWord;
    LATDbits : TPORTD_LATD;
    LATD : longWord;
    LATDCLR : longWord;
    LATDSET : longWord;
    LATDINV : longWord;
    ODCDbits : TPORTD_ODCD;
    ODCD : longWord;
    ODCDCLR : longWord;
    ODCDSET : longWord;
    ODCDINV : longWord;
  end;
  TPORTE_TRISE = record
  private
    function  getTRISE0 : TBits_1; inline;
    function  getTRISE1 : TBits_1; inline;
    function  getTRISE2 : TBits_1; inline;
    function  getTRISE3 : TBits_1; inline;
    function  getTRISE4 : TBits_1; inline;
    function  getTRISE5 : TBits_1; inline;
    function  getTRISE6 : TBits_1; inline;
    function  getTRISE7 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISE0(thebits : TBits_1); inline;
    procedure setTRISE1(thebits : TBits_1); inline;
    procedure setTRISE2(thebits : TBits_1); inline;
    procedure setTRISE3(thebits : TBits_1); inline;
    procedure setTRISE4(thebits : TBits_1); inline;
    procedure setTRISE5(thebits : TBits_1); inline;
    procedure setTRISE6(thebits : TBits_1); inline;
    procedure setTRISE7(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISE0; inline;
    procedure clearTRISE1; inline;
    procedure clearTRISE2; inline;
    procedure clearTRISE3; inline;
    procedure clearTRISE4; inline;
    procedure clearTRISE5; inline;
    procedure clearTRISE6; inline;
    procedure clearTRISE7; inline;
    procedure setTRISE0; inline;
    procedure setTRISE1; inline;
    procedure setTRISE2; inline;
    procedure setTRISE3; inline;
    procedure setTRISE4; inline;
    procedure setTRISE5; inline;
    procedure setTRISE6; inline;
    procedure setTRISE7; inline;
    property TRISE0 : TBits_1 read getTRISE0 write setTRISE0;
    property TRISE1 : TBits_1 read getTRISE1 write setTRISE1;
    property TRISE2 : TBits_1 read getTRISE2 write setTRISE2;
    property TRISE3 : TBits_1 read getTRISE3 write setTRISE3;
    property TRISE4 : TBits_1 read getTRISE4 write setTRISE4;
    property TRISE5 : TBits_1 read getTRISE5 write setTRISE5;
    property TRISE6 : TBits_1 read getTRISE6 write setTRISE6;
    property TRISE7 : TBits_1 read getTRISE7 write setTRISE7;
    property w : TBits_32 read getw write setw;
  end;
  TPORTE_PORTE = record
  private
    function  getRE0 : TBits_1; inline;
    function  getRE1 : TBits_1; inline;
    function  getRE2 : TBits_1; inline;
    function  getRE3 : TBits_1; inline;
    function  getRE4 : TBits_1; inline;
    function  getRE5 : TBits_1; inline;
    function  getRE6 : TBits_1; inline;
    function  getRE7 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRE0(thebits : TBits_1); inline;
    procedure setRE1(thebits : TBits_1); inline;
    procedure setRE2(thebits : TBits_1); inline;
    procedure setRE3(thebits : TBits_1); inline;
    procedure setRE4(thebits : TBits_1); inline;
    procedure setRE5(thebits : TBits_1); inline;
    procedure setRE6(thebits : TBits_1); inline;
    procedure setRE7(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRE0; inline;
    procedure clearRE1; inline;
    procedure clearRE2; inline;
    procedure clearRE3; inline;
    procedure clearRE4; inline;
    procedure clearRE5; inline;
    procedure clearRE6; inline;
    procedure clearRE7; inline;
    procedure setRE0; inline;
    procedure setRE1; inline;
    procedure setRE2; inline;
    procedure setRE3; inline;
    procedure setRE4; inline;
    procedure setRE5; inline;
    procedure setRE6; inline;
    procedure setRE7; inline;
    property RE0 : TBits_1 read getRE0 write setRE0;
    property RE1 : TBits_1 read getRE1 write setRE1;
    property RE2 : TBits_1 read getRE2 write setRE2;
    property RE3 : TBits_1 read getRE3 write setRE3;
    property RE4 : TBits_1 read getRE4 write setRE4;
    property RE5 : TBits_1 read getRE5 write setRE5;
    property RE6 : TBits_1 read getRE6 write setRE6;
    property RE7 : TBits_1 read getRE7 write setRE7;
    property w : TBits_32 read getw write setw;
  end;
  TPortE_bits=(RE0=0,RE1=1,RE2=2,RE3=3,RE4=4,RE5=5,RE6=6,RE7=7);
  TPortE_bitset = set of TPortE_bits;
  TPORTE_LATE = record
  private
    function  getLATE0 : TBits_1; inline;
    function  getLATE1 : TBits_1; inline;
    function  getLATE2 : TBits_1; inline;
    function  getLATE3 : TBits_1; inline;
    function  getLATE4 : TBits_1; inline;
    function  getLATE5 : TBits_1; inline;
    function  getLATE6 : TBits_1; inline;
    function  getLATE7 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATE0(thebits : TBits_1); inline;
    procedure setLATE1(thebits : TBits_1); inline;
    procedure setLATE2(thebits : TBits_1); inline;
    procedure setLATE3(thebits : TBits_1); inline;
    procedure setLATE4(thebits : TBits_1); inline;
    procedure setLATE5(thebits : TBits_1); inline;
    procedure setLATE6(thebits : TBits_1); inline;
    procedure setLATE7(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATE0; inline;
    procedure clearLATE1; inline;
    procedure clearLATE2; inline;
    procedure clearLATE3; inline;
    procedure clearLATE4; inline;
    procedure clearLATE5; inline;
    procedure clearLATE6; inline;
    procedure clearLATE7; inline;
    procedure setLATE0; inline;
    procedure setLATE1; inline;
    procedure setLATE2; inline;
    procedure setLATE3; inline;
    procedure setLATE4; inline;
    procedure setLATE5; inline;
    procedure setLATE6; inline;
    procedure setLATE7; inline;
    property LATE0 : TBits_1 read getLATE0 write setLATE0;
    property LATE1 : TBits_1 read getLATE1 write setLATE1;
    property LATE2 : TBits_1 read getLATE2 write setLATE2;
    property LATE3 : TBits_1 read getLATE3 write setLATE3;
    property LATE4 : TBits_1 read getLATE4 write setLATE4;
    property LATE5 : TBits_1 read getLATE5 write setLATE5;
    property LATE6 : TBits_1 read getLATE6 write setLATE6;
    property LATE7 : TBits_1 read getLATE7 write setLATE7;
    property w : TBits_32 read getw write setw;
  end;
  TPORTE_ODCE = record
  private
    function  getODCE0 : TBits_1; inline;
    function  getODCE1 : TBits_1; inline;
    function  getODCE2 : TBits_1; inline;
    function  getODCE3 : TBits_1; inline;
    function  getODCE4 : TBits_1; inline;
    function  getODCE5 : TBits_1; inline;
    function  getODCE6 : TBits_1; inline;
    function  getODCE7 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCE0(thebits : TBits_1); inline;
    procedure setODCE1(thebits : TBits_1); inline;
    procedure setODCE2(thebits : TBits_1); inline;
    procedure setODCE3(thebits : TBits_1); inline;
    procedure setODCE4(thebits : TBits_1); inline;
    procedure setODCE5(thebits : TBits_1); inline;
    procedure setODCE6(thebits : TBits_1); inline;
    procedure setODCE7(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCE0; inline;
    procedure clearODCE1; inline;
    procedure clearODCE2; inline;
    procedure clearODCE3; inline;
    procedure clearODCE4; inline;
    procedure clearODCE5; inline;
    procedure clearODCE6; inline;
    procedure clearODCE7; inline;
    procedure setODCE0; inline;
    procedure setODCE1; inline;
    procedure setODCE2; inline;
    procedure setODCE3; inline;
    procedure setODCE4; inline;
    procedure setODCE5; inline;
    procedure setODCE6; inline;
    procedure setODCE7; inline;
    property ODCE0 : TBits_1 read getODCE0 write setODCE0;
    property ODCE1 : TBits_1 read getODCE1 write setODCE1;
    property ODCE2 : TBits_1 read getODCE2 write setODCE2;
    property ODCE3 : TBits_1 read getODCE3 write setODCE3;
    property ODCE4 : TBits_1 read getODCE4 write setODCE4;
    property ODCE5 : TBits_1 read getODCE5 write setODCE5;
    property ODCE6 : TBits_1 read getODCE6 write setODCE6;
    property ODCE7 : TBits_1 read getODCE7 write setODCE7;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTERegisters = record
    TRISEbits : TPORTE_TRISE;
    TRISE : longWord;
    TRISECLR : longWord;
    TRISESET : longWord;
    TRISEINV : longWord;
    PORTEbits : TPORTE_PORTE;
    PORTE : longWord;
    PORTECLR : longWord;
    PORTESET : longWord;
    PORTEINV : longWord;
    LATEbits : TPORTE_LATE;
    LATE : longWord;
    LATECLR : longWord;
    LATESET : longWord;
    LATEINV : longWord;
    ODCEbits : TPORTE_ODCE;
    ODCE : longWord;
    ODCECLR : longWord;
    ODCESET : longWord;
    ODCEINV : longWord;
  end;
  TPORTF_TRISF = record
  private
    function  getTRISF0 : TBits_1; inline;
    function  getTRISF1 : TBits_1; inline;
    function  getTRISF2 : TBits_1; inline;
    function  getTRISF3 : TBits_1; inline;
    function  getTRISF4 : TBits_1; inline;
    function  getTRISF5 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISF0(thebits : TBits_1); inline;
    procedure setTRISF1(thebits : TBits_1); inline;
    procedure setTRISF2(thebits : TBits_1); inline;
    procedure setTRISF3(thebits : TBits_1); inline;
    procedure setTRISF4(thebits : TBits_1); inline;
    procedure setTRISF5(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISF0; inline;
    procedure clearTRISF1; inline;
    procedure clearTRISF2; inline;
    procedure clearTRISF3; inline;
    procedure clearTRISF4; inline;
    procedure clearTRISF5; inline;
    procedure setTRISF0; inline;
    procedure setTRISF1; inline;
    procedure setTRISF2; inline;
    procedure setTRISF3; inline;
    procedure setTRISF4; inline;
    procedure setTRISF5; inline;
    property TRISF0 : TBits_1 read getTRISF0 write setTRISF0;
    property TRISF1 : TBits_1 read getTRISF1 write setTRISF1;
    property TRISF2 : TBits_1 read getTRISF2 write setTRISF2;
    property TRISF3 : TBits_1 read getTRISF3 write setTRISF3;
    property TRISF4 : TBits_1 read getTRISF4 write setTRISF4;
    property TRISF5 : TBits_1 read getTRISF5 write setTRISF5;
    property w : TBits_32 read getw write setw;
  end;
  TPORTF_PORTF = record
  private
    function  getRF0 : TBits_1; inline;
    function  getRF1 : TBits_1; inline;
    function  getRF2 : TBits_1; inline;
    function  getRF3 : TBits_1; inline;
    function  getRF4 : TBits_1; inline;
    function  getRF5 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRF0(thebits : TBits_1); inline;
    procedure setRF1(thebits : TBits_1); inline;
    procedure setRF2(thebits : TBits_1); inline;
    procedure setRF3(thebits : TBits_1); inline;
    procedure setRF4(thebits : TBits_1); inline;
    procedure setRF5(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRF0; inline;
    procedure clearRF1; inline;
    procedure clearRF2; inline;
    procedure clearRF3; inline;
    procedure clearRF4; inline;
    procedure clearRF5; inline;
    procedure setRF0; inline;
    procedure setRF1; inline;
    procedure setRF2; inline;
    procedure setRF3; inline;
    procedure setRF4; inline;
    procedure setRF5; inline;
    property RF0 : TBits_1 read getRF0 write setRF0;
    property RF1 : TBits_1 read getRF1 write setRF1;
    property RF2 : TBits_1 read getRF2 write setRF2;
    property RF3 : TBits_1 read getRF3 write setRF3;
    property RF4 : TBits_1 read getRF4 write setRF4;
    property RF5 : TBits_1 read getRF5 write setRF5;
    property w : TBits_32 read getw write setw;
  end;
  TPortF_bits=(RF0=0,RF1=1,RF2=2,RF3=3,RF4=4,RF5=5);
  TPortF_bitset = set of TPortF_bits;
  TPORTF_LATF = record
  private
    function  getLATF0 : TBits_1; inline;
    function  getLATF1 : TBits_1; inline;
    function  getLATF2 : TBits_1; inline;
    function  getLATF3 : TBits_1; inline;
    function  getLATF4 : TBits_1; inline;
    function  getLATF5 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATF0(thebits : TBits_1); inline;
    procedure setLATF1(thebits : TBits_1); inline;
    procedure setLATF2(thebits : TBits_1); inline;
    procedure setLATF3(thebits : TBits_1); inline;
    procedure setLATF4(thebits : TBits_1); inline;
    procedure setLATF5(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATF0; inline;
    procedure clearLATF1; inline;
    procedure clearLATF2; inline;
    procedure clearLATF3; inline;
    procedure clearLATF4; inline;
    procedure clearLATF5; inline;
    procedure setLATF0; inline;
    procedure setLATF1; inline;
    procedure setLATF2; inline;
    procedure setLATF3; inline;
    procedure setLATF4; inline;
    procedure setLATF5; inline;
    property LATF0 : TBits_1 read getLATF0 write setLATF0;
    property LATF1 : TBits_1 read getLATF1 write setLATF1;
    property LATF2 : TBits_1 read getLATF2 write setLATF2;
    property LATF3 : TBits_1 read getLATF3 write setLATF3;
    property LATF4 : TBits_1 read getLATF4 write setLATF4;
    property LATF5 : TBits_1 read getLATF5 write setLATF5;
    property w : TBits_32 read getw write setw;
  end;
  TPORTF_ODCF = record
  private
    function  getODCF0 : TBits_1; inline;
    function  getODCF1 : TBits_1; inline;
    function  getODCF2 : TBits_1; inline;
    function  getODCF3 : TBits_1; inline;
    function  getODCF4 : TBits_1; inline;
    function  getODCF5 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCF0(thebits : TBits_1); inline;
    procedure setODCF1(thebits : TBits_1); inline;
    procedure setODCF2(thebits : TBits_1); inline;
    procedure setODCF3(thebits : TBits_1); inline;
    procedure setODCF4(thebits : TBits_1); inline;
    procedure setODCF5(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCF0; inline;
    procedure clearODCF1; inline;
    procedure clearODCF2; inline;
    procedure clearODCF3; inline;
    procedure clearODCF4; inline;
    procedure clearODCF5; inline;
    procedure setODCF0; inline;
    procedure setODCF1; inline;
    procedure setODCF2; inline;
    procedure setODCF3; inline;
    procedure setODCF4; inline;
    procedure setODCF5; inline;
    property ODCF0 : TBits_1 read getODCF0 write setODCF0;
    property ODCF1 : TBits_1 read getODCF1 write setODCF1;
    property ODCF2 : TBits_1 read getODCF2 write setODCF2;
    property ODCF3 : TBits_1 read getODCF3 write setODCF3;
    property ODCF4 : TBits_1 read getODCF4 write setODCF4;
    property ODCF5 : TBits_1 read getODCF5 write setODCF5;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTFRegisters = record
    TRISFbits : TPORTF_TRISF;
    TRISF : longWord;
    TRISFCLR : longWord;
    TRISFSET : longWord;
    TRISFINV : longWord;
    PORTFbits : TPORTF_PORTF;
    PORTF : longWord;
    PORTFCLR : longWord;
    PORTFSET : longWord;
    PORTFINV : longWord;
    LATFbits : TPORTF_LATF;
    LATF : longWord;
    LATFCLR : longWord;
    LATFSET : longWord;
    LATFINV : longWord;
    ODCFbits : TPORTF_ODCF;
    ODCF : longWord;
    ODCFCLR : longWord;
    ODCFSET : longWord;
    ODCFINV : longWord;
  end;
  TPORTG_TRISG = record
  private
    function  getTRISG2 : TBits_1; inline;
    function  getTRISG3 : TBits_1; inline;
    function  getTRISG6 : TBits_1; inline;
    function  getTRISG7 : TBits_1; inline;
    function  getTRISG8 : TBits_1; inline;
    function  getTRISG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISG2(thebits : TBits_1); inline;
    procedure setTRISG3(thebits : TBits_1); inline;
    procedure setTRISG6(thebits : TBits_1); inline;
    procedure setTRISG7(thebits : TBits_1); inline;
    procedure setTRISG8(thebits : TBits_1); inline;
    procedure setTRISG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISG2; inline;
    procedure clearTRISG3; inline;
    procedure clearTRISG6; inline;
    procedure clearTRISG7; inline;
    procedure clearTRISG8; inline;
    procedure clearTRISG9; inline;
    procedure setTRISG2; inline;
    procedure setTRISG3; inline;
    procedure setTRISG6; inline;
    procedure setTRISG7; inline;
    procedure setTRISG8; inline;
    procedure setTRISG9; inline;
    property TRISG2 : TBits_1 read getTRISG2 write setTRISG2;
    property TRISG3 : TBits_1 read getTRISG3 write setTRISG3;
    property TRISG6 : TBits_1 read getTRISG6 write setTRISG6;
    property TRISG7 : TBits_1 read getTRISG7 write setTRISG7;
    property TRISG8 : TBits_1 read getTRISG8 write setTRISG8;
    property TRISG9 : TBits_1 read getTRISG9 write setTRISG9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTG_PORTG = record
  private
    function  getRG2 : TBits_1; inline;
    function  getRG3 : TBits_1; inline;
    function  getRG6 : TBits_1; inline;
    function  getRG7 : TBits_1; inline;
    function  getRG8 : TBits_1; inline;
    function  getRG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRG2(thebits : TBits_1); inline;
    procedure setRG3(thebits : TBits_1); inline;
    procedure setRG6(thebits : TBits_1); inline;
    procedure setRG7(thebits : TBits_1); inline;
    procedure setRG8(thebits : TBits_1); inline;
    procedure setRG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRG2; inline;
    procedure clearRG3; inline;
    procedure clearRG6; inline;
    procedure clearRG7; inline;
    procedure clearRG8; inline;
    procedure clearRG9; inline;
    procedure setRG2; inline;
    procedure setRG3; inline;
    procedure setRG6; inline;
    procedure setRG7; inline;
    procedure setRG8; inline;
    procedure setRG9; inline;
    property RG2 : TBits_1 read getRG2 write setRG2;
    property RG3 : TBits_1 read getRG3 write setRG3;
    property RG6 : TBits_1 read getRG6 write setRG6;
    property RG7 : TBits_1 read getRG7 write setRG7;
    property RG8 : TBits_1 read getRG8 write setRG8;
    property RG9 : TBits_1 read getRG9 write setRG9;
    property w : TBits_32 read getw write setw;
  end;
  TPortG_bits=(RG2=2,RG3=3,RG6=6,RG7=7,RG8=8,RG9=9);
  TPortG_bitset = set of TPortG_bits;
  TPORTG_LATG = record
  private
    function  getLATG2 : TBits_1; inline;
    function  getLATG3 : TBits_1; inline;
    function  getLATG6 : TBits_1; inline;
    function  getLATG7 : TBits_1; inline;
    function  getLATG8 : TBits_1; inline;
    function  getLATG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATG2(thebits : TBits_1); inline;
    procedure setLATG3(thebits : TBits_1); inline;
    procedure setLATG6(thebits : TBits_1); inline;
    procedure setLATG7(thebits : TBits_1); inline;
    procedure setLATG8(thebits : TBits_1); inline;
    procedure setLATG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATG2; inline;
    procedure clearLATG3; inline;
    procedure clearLATG6; inline;
    procedure clearLATG7; inline;
    procedure clearLATG8; inline;
    procedure clearLATG9; inline;
    procedure setLATG2; inline;
    procedure setLATG3; inline;
    procedure setLATG6; inline;
    procedure setLATG7; inline;
    procedure setLATG8; inline;
    procedure setLATG9; inline;
    property LATG2 : TBits_1 read getLATG2 write setLATG2;
    property LATG3 : TBits_1 read getLATG3 write setLATG3;
    property LATG6 : TBits_1 read getLATG6 write setLATG6;
    property LATG7 : TBits_1 read getLATG7 write setLATG7;
    property LATG8 : TBits_1 read getLATG8 write setLATG8;
    property LATG9 : TBits_1 read getLATG9 write setLATG9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTG_ODCG = record
  private
    function  getODCG2 : TBits_1; inline;
    function  getODCG3 : TBits_1; inline;
    function  getODCG6 : TBits_1; inline;
    function  getODCG7 : TBits_1; inline;
    function  getODCG8 : TBits_1; inline;
    function  getODCG9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCG2(thebits : TBits_1); inline;
    procedure setODCG3(thebits : TBits_1); inline;
    procedure setODCG6(thebits : TBits_1); inline;
    procedure setODCG7(thebits : TBits_1); inline;
    procedure setODCG8(thebits : TBits_1); inline;
    procedure setODCG9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCG2; inline;
    procedure clearODCG3; inline;
    procedure clearODCG6; inline;
    procedure clearODCG7; inline;
    procedure clearODCG8; inline;
    procedure clearODCG9; inline;
    procedure setODCG2; inline;
    procedure setODCG3; inline;
    procedure setODCG6; inline;
    procedure setODCG7; inline;
    procedure setODCG8; inline;
    procedure setODCG9; inline;
    property ODCG2 : TBits_1 read getODCG2 write setODCG2;
    property ODCG3 : TBits_1 read getODCG3 write setODCG3;
    property ODCG6 : TBits_1 read getODCG6 write setODCG6;
    property ODCG7 : TBits_1 read getODCG7 write setODCG7;
    property ODCG8 : TBits_1 read getODCG8 write setODCG8;
    property ODCG9 : TBits_1 read getODCG9 write setODCG9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTG_CNCON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TPORTG_CNEN = record
  private
    function  getCNEN0 : TBits_1; inline;
    function  getCNEN1 : TBits_1; inline;
    function  getCNEN10 : TBits_1; inline;
    function  getCNEN11 : TBits_1; inline;
    function  getCNEN12 : TBits_1; inline;
    function  getCNEN13 : TBits_1; inline;
    function  getCNEN14 : TBits_1; inline;
    function  getCNEN15 : TBits_1; inline;
    function  getCNEN16 : TBits_1; inline;
    function  getCNEN17 : TBits_1; inline;
    function  getCNEN18 : TBits_1; inline;
    function  getCNEN2 : TBits_1; inline;
    function  getCNEN3 : TBits_1; inline;
    function  getCNEN4 : TBits_1; inline;
    function  getCNEN5 : TBits_1; inline;
    function  getCNEN6 : TBits_1; inline;
    function  getCNEN7 : TBits_1; inline;
    function  getCNEN8 : TBits_1; inline;
    function  getCNEN9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNEN0(thebits : TBits_1); inline;
    procedure setCNEN1(thebits : TBits_1); inline;
    procedure setCNEN10(thebits : TBits_1); inline;
    procedure setCNEN11(thebits : TBits_1); inline;
    procedure setCNEN12(thebits : TBits_1); inline;
    procedure setCNEN13(thebits : TBits_1); inline;
    procedure setCNEN14(thebits : TBits_1); inline;
    procedure setCNEN15(thebits : TBits_1); inline;
    procedure setCNEN16(thebits : TBits_1); inline;
    procedure setCNEN17(thebits : TBits_1); inline;
    procedure setCNEN18(thebits : TBits_1); inline;
    procedure setCNEN2(thebits : TBits_1); inline;
    procedure setCNEN3(thebits : TBits_1); inline;
    procedure setCNEN4(thebits : TBits_1); inline;
    procedure setCNEN5(thebits : TBits_1); inline;
    procedure setCNEN6(thebits : TBits_1); inline;
    procedure setCNEN7(thebits : TBits_1); inline;
    procedure setCNEN8(thebits : TBits_1); inline;
    procedure setCNEN9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNEN0; inline;
    procedure clearCNEN10; inline;
    procedure clearCNEN11; inline;
    procedure clearCNEN12; inline;
    procedure clearCNEN13; inline;
    procedure clearCNEN14; inline;
    procedure clearCNEN15; inline;
    procedure clearCNEN16; inline;
    procedure clearCNEN17; inline;
    procedure clearCNEN18; inline;
    procedure clearCNEN1; inline;
    procedure clearCNEN2; inline;
    procedure clearCNEN3; inline;
    procedure clearCNEN4; inline;
    procedure clearCNEN5; inline;
    procedure clearCNEN6; inline;
    procedure clearCNEN7; inline;
    procedure clearCNEN8; inline;
    procedure clearCNEN9; inline;
    procedure setCNEN0; inline;
    procedure setCNEN10; inline;
    procedure setCNEN11; inline;
    procedure setCNEN12; inline;
    procedure setCNEN13; inline;
    procedure setCNEN14; inline;
    procedure setCNEN15; inline;
    procedure setCNEN16; inline;
    procedure setCNEN17; inline;
    procedure setCNEN18; inline;
    procedure setCNEN1; inline;
    procedure setCNEN2; inline;
    procedure setCNEN3; inline;
    procedure setCNEN4; inline;
    procedure setCNEN5; inline;
    procedure setCNEN6; inline;
    procedure setCNEN7; inline;
    procedure setCNEN8; inline;
    procedure setCNEN9; inline;
    property CNEN0 : TBits_1 read getCNEN0 write setCNEN0;
    property CNEN1 : TBits_1 read getCNEN1 write setCNEN1;
    property CNEN10 : TBits_1 read getCNEN10 write setCNEN10;
    property CNEN11 : TBits_1 read getCNEN11 write setCNEN11;
    property CNEN12 : TBits_1 read getCNEN12 write setCNEN12;
    property CNEN13 : TBits_1 read getCNEN13 write setCNEN13;
    property CNEN14 : TBits_1 read getCNEN14 write setCNEN14;
    property CNEN15 : TBits_1 read getCNEN15 write setCNEN15;
    property CNEN16 : TBits_1 read getCNEN16 write setCNEN16;
    property CNEN17 : TBits_1 read getCNEN17 write setCNEN17;
    property CNEN18 : TBits_1 read getCNEN18 write setCNEN18;
    property CNEN2 : TBits_1 read getCNEN2 write setCNEN2;
    property CNEN3 : TBits_1 read getCNEN3 write setCNEN3;
    property CNEN4 : TBits_1 read getCNEN4 write setCNEN4;
    property CNEN5 : TBits_1 read getCNEN5 write setCNEN5;
    property CNEN6 : TBits_1 read getCNEN6 write setCNEN6;
    property CNEN7 : TBits_1 read getCNEN7 write setCNEN7;
    property CNEN8 : TBits_1 read getCNEN8 write setCNEN8;
    property CNEN9 : TBits_1 read getCNEN9 write setCNEN9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTG_CNPUE = record
  private
    function  getCNPUE0 : TBits_1; inline;
    function  getCNPUE1 : TBits_1; inline;
    function  getCNPUE10 : TBits_1; inline;
    function  getCNPUE11 : TBits_1; inline;
    function  getCNPUE12 : TBits_1; inline;
    function  getCNPUE13 : TBits_1; inline;
    function  getCNPUE14 : TBits_1; inline;
    function  getCNPUE15 : TBits_1; inline;
    function  getCNPUE16 : TBits_1; inline;
    function  getCNPUE17 : TBits_1; inline;
    function  getCNPUE18 : TBits_1; inline;
    function  getCNPUE2 : TBits_1; inline;
    function  getCNPUE3 : TBits_1; inline;
    function  getCNPUE4 : TBits_1; inline;
    function  getCNPUE5 : TBits_1; inline;
    function  getCNPUE6 : TBits_1; inline;
    function  getCNPUE7 : TBits_1; inline;
    function  getCNPUE8 : TBits_1; inline;
    function  getCNPUE9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPUE0(thebits : TBits_1); inline;
    procedure setCNPUE1(thebits : TBits_1); inline;
    procedure setCNPUE10(thebits : TBits_1); inline;
    procedure setCNPUE11(thebits : TBits_1); inline;
    procedure setCNPUE12(thebits : TBits_1); inline;
    procedure setCNPUE13(thebits : TBits_1); inline;
    procedure setCNPUE14(thebits : TBits_1); inline;
    procedure setCNPUE15(thebits : TBits_1); inline;
    procedure setCNPUE16(thebits : TBits_1); inline;
    procedure setCNPUE17(thebits : TBits_1); inline;
    procedure setCNPUE18(thebits : TBits_1); inline;
    procedure setCNPUE2(thebits : TBits_1); inline;
    procedure setCNPUE3(thebits : TBits_1); inline;
    procedure setCNPUE4(thebits : TBits_1); inline;
    procedure setCNPUE5(thebits : TBits_1); inline;
    procedure setCNPUE6(thebits : TBits_1); inline;
    procedure setCNPUE7(thebits : TBits_1); inline;
    procedure setCNPUE8(thebits : TBits_1); inline;
    procedure setCNPUE9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPUE0; inline;
    procedure clearCNPUE10; inline;
    procedure clearCNPUE11; inline;
    procedure clearCNPUE12; inline;
    procedure clearCNPUE13; inline;
    procedure clearCNPUE14; inline;
    procedure clearCNPUE15; inline;
    procedure clearCNPUE16; inline;
    procedure clearCNPUE17; inline;
    procedure clearCNPUE18; inline;
    procedure clearCNPUE1; inline;
    procedure clearCNPUE2; inline;
    procedure clearCNPUE3; inline;
    procedure clearCNPUE4; inline;
    procedure clearCNPUE5; inline;
    procedure clearCNPUE6; inline;
    procedure clearCNPUE7; inline;
    procedure clearCNPUE8; inline;
    procedure clearCNPUE9; inline;
    procedure setCNPUE0; inline;
    procedure setCNPUE10; inline;
    procedure setCNPUE11; inline;
    procedure setCNPUE12; inline;
    procedure setCNPUE13; inline;
    procedure setCNPUE14; inline;
    procedure setCNPUE15; inline;
    procedure setCNPUE16; inline;
    procedure setCNPUE17; inline;
    procedure setCNPUE18; inline;
    procedure setCNPUE1; inline;
    procedure setCNPUE2; inline;
    procedure setCNPUE3; inline;
    procedure setCNPUE4; inline;
    procedure setCNPUE5; inline;
    procedure setCNPUE6; inline;
    procedure setCNPUE7; inline;
    procedure setCNPUE8; inline;
    procedure setCNPUE9; inline;
    property CNPUE0 : TBits_1 read getCNPUE0 write setCNPUE0;
    property CNPUE1 : TBits_1 read getCNPUE1 write setCNPUE1;
    property CNPUE10 : TBits_1 read getCNPUE10 write setCNPUE10;
    property CNPUE11 : TBits_1 read getCNPUE11 write setCNPUE11;
    property CNPUE12 : TBits_1 read getCNPUE12 write setCNPUE12;
    property CNPUE13 : TBits_1 read getCNPUE13 write setCNPUE13;
    property CNPUE14 : TBits_1 read getCNPUE14 write setCNPUE14;
    property CNPUE15 : TBits_1 read getCNPUE15 write setCNPUE15;
    property CNPUE16 : TBits_1 read getCNPUE16 write setCNPUE16;
    property CNPUE17 : TBits_1 read getCNPUE17 write setCNPUE17;
    property CNPUE18 : TBits_1 read getCNPUE18 write setCNPUE18;
    property CNPUE2 : TBits_1 read getCNPUE2 write setCNPUE2;
    property CNPUE3 : TBits_1 read getCNPUE3 write setCNPUE3;
    property CNPUE4 : TBits_1 read getCNPUE4 write setCNPUE4;
    property CNPUE5 : TBits_1 read getCNPUE5 write setCNPUE5;
    property CNPUE6 : TBits_1 read getCNPUE6 write setCNPUE6;
    property CNPUE7 : TBits_1 read getCNPUE7 write setCNPUE7;
    property CNPUE8 : TBits_1 read getCNPUE8 write setCNPUE8;
    property CNPUE9 : TBits_1 read getCNPUE9 write setCNPUE9;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTGRegisters = record
    TRISGbits : TPORTG_TRISG;
    TRISG : longWord;
    TRISGCLR : longWord;
    TRISGSET : longWord;
    TRISGINV : longWord;
    PORTGbits : TPORTG_PORTG;
    PORTG : longWord;
    PORTGCLR : longWord;
    PORTGSET : longWord;
    PORTGINV : longWord;
    LATGbits : TPORTG_LATG;
    LATG : longWord;
    LATGCLR : longWord;
    LATGSET : longWord;
    LATGINV : longWord;
    ODCGbits : TPORTG_ODCG;
    ODCG : longWord;
    ODCGCLR : longWord;
    ODCGSET : longWord;
    ODCGINV : longWord;
    CNCONbits : TPORTG_CNCON;
    CNCON : longWord;
    CNCONCLR : longWord;
    CNCONSET : longWord;
    CNCONINV : longWord;
    CNENbits : TPORTG_CNEN;
    CNEN : longWord;
    CNENCLR : longWord;
    CNENSET : longWord;
    CNENINV : longWord;
    CNPUEbits : TPORTG_CNPUE;
    CNPUE : longWord;
    CNPUECLR : longWord;
    CNPUESET : longWord;
    CNPUEINV : longWord;
  end;
  TCAN1_C1CON = record
  private
    function  getABAT : TBits_1; inline;
    function  getCANBUSY : TBits_1; inline;
    function  getCANCAP : TBits_1; inline;
    function  getDNCNT : TBits_5; inline;
    function  getON : TBits_1; inline;
    function  getOPMOD : TBits_3; inline;
    function  getREQOP : TBits_3; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAT(thebits : TBits_1); inline;
    procedure setCANBUSY(thebits : TBits_1); inline;
    procedure setCANCAP(thebits : TBits_1); inline;
    procedure setDNCNT(thebits : TBits_5); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setOPMOD(thebits : TBits_3); inline;
    procedure setREQOP(thebits : TBits_3); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAT; inline;
    procedure clearCANBUSY; inline;
    procedure clearCANCAP; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setABAT; inline;
    procedure setCANBUSY; inline;
    procedure setCANCAP; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property ABAT : TBits_1 read getABAT write setABAT;
    property CANBUSY : TBits_1 read getCANBUSY write setCANBUSY;
    property CANCAP : TBits_1 read getCANCAP write setCANCAP;
    property DNCNT : TBits_5 read getDNCNT write setDNCNT;
    property ON : TBits_1 read getON write setON;
    property OPMOD : TBits_3 read getOPMOD write setOPMOD;
    property REQOP : TBits_3 read getREQOP write setREQOP;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1CFG = record
  private
    function  getBRP : TBits_6; inline;
    function  getPRSEG : TBits_3; inline;
    function  getSAM : TBits_1; inline;
    function  getSEG1PH : TBits_3; inline;
    function  getSEG2PH : TBits_3; inline;
    function  getSEG2PHTS : TBits_1; inline;
    function  getSJW : TBits_2; inline;
    function  getWAKFIL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBRP(thebits : TBits_6); inline;
    procedure setPRSEG(thebits : TBits_3); inline;
    procedure setSAM(thebits : TBits_1); inline;
    procedure setSEG1PH(thebits : TBits_3); inline;
    procedure setSEG2PH(thebits : TBits_3); inline;
    procedure setSEG2PHTS(thebits : TBits_1); inline;
    procedure setSJW(thebits : TBits_2); inline;
    procedure setWAKFIL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearSAM; inline;
    procedure clearSEG2PHTS; inline;
    procedure clearWAKFIL; inline;
    procedure setSAM; inline;
    procedure setSEG2PHTS; inline;
    procedure setWAKFIL; inline;
    property BRP : TBits_6 read getBRP write setBRP;
    property PRSEG : TBits_3 read getPRSEG write setPRSEG;
    property SAM : TBits_1 read getSAM write setSAM;
    property SEG1PH : TBits_3 read getSEG1PH write setSEG1PH;
    property SEG2PH : TBits_3 read getSEG2PH write setSEG2PH;
    property SEG2PHTS : TBits_1 read getSEG2PHTS write setSEG2PHTS;
    property SJW : TBits_2 read getSJW write setSJW;
    property WAKFIL : TBits_1 read getWAKFIL write setWAKFIL;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1INT = record
  private
    function  getCERRIE : TBits_1; inline;
    function  getCERRIF : TBits_1; inline;
    function  getCTMRIE : TBits_1; inline;
    function  getCTMRIF : TBits_1; inline;
    function  getIVRIE : TBits_1; inline;
    function  getIVRIF : TBits_1; inline;
    function  getMODIE : TBits_1; inline;
    function  getMODIF : TBits_1; inline;
    function  getRBIE : TBits_1; inline;
    function  getRBIF : TBits_1; inline;
    function  getRBOVIE : TBits_1; inline;
    function  getRBOVIF : TBits_1; inline;
    function  getSERRIE : TBits_1; inline;
    function  getSERRIF : TBits_1; inline;
    function  getTBIE : TBits_1; inline;
    function  getTBIF : TBits_1; inline;
    function  getWAKIE : TBits_1; inline;
    function  getWAKIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCERRIE(thebits : TBits_1); inline;
    procedure setCERRIF(thebits : TBits_1); inline;
    procedure setCTMRIE(thebits : TBits_1); inline;
    procedure setCTMRIF(thebits : TBits_1); inline;
    procedure setIVRIE(thebits : TBits_1); inline;
    procedure setIVRIF(thebits : TBits_1); inline;
    procedure setMODIE(thebits : TBits_1); inline;
    procedure setMODIF(thebits : TBits_1); inline;
    procedure setRBIE(thebits : TBits_1); inline;
    procedure setRBIF(thebits : TBits_1); inline;
    procedure setRBOVIE(thebits : TBits_1); inline;
    procedure setRBOVIF(thebits : TBits_1); inline;
    procedure setSERRIE(thebits : TBits_1); inline;
    procedure setSERRIF(thebits : TBits_1); inline;
    procedure setTBIE(thebits : TBits_1); inline;
    procedure setTBIF(thebits : TBits_1); inline;
    procedure setWAKIE(thebits : TBits_1); inline;
    procedure setWAKIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCERRIE; inline;
    procedure clearCERRIF; inline;
    procedure clearCTMRIE; inline;
    procedure clearCTMRIF; inline;
    procedure clearIVRIE; inline;
    procedure clearIVRIF; inline;
    procedure clearMODIE; inline;
    procedure clearMODIF; inline;
    procedure clearRBIE; inline;
    procedure clearRBIF; inline;
    procedure clearRBOVIE; inline;
    procedure clearRBOVIF; inline;
    procedure clearSERRIE; inline;
    procedure clearSERRIF; inline;
    procedure clearTBIE; inline;
    procedure clearTBIF; inline;
    procedure clearWAKIE; inline;
    procedure clearWAKIF; inline;
    procedure setCERRIE; inline;
    procedure setCERRIF; inline;
    procedure setCTMRIE; inline;
    procedure setCTMRIF; inline;
    procedure setIVRIE; inline;
    procedure setIVRIF; inline;
    procedure setMODIE; inline;
    procedure setMODIF; inline;
    procedure setRBIE; inline;
    procedure setRBIF; inline;
    procedure setRBOVIE; inline;
    procedure setRBOVIF; inline;
    procedure setSERRIE; inline;
    procedure setSERRIF; inline;
    procedure setTBIE; inline;
    procedure setTBIF; inline;
    procedure setWAKIE; inline;
    procedure setWAKIF; inline;
    property CERRIE : TBits_1 read getCERRIE write setCERRIE;
    property CERRIF : TBits_1 read getCERRIF write setCERRIF;
    property CTMRIE : TBits_1 read getCTMRIE write setCTMRIE;
    property CTMRIF : TBits_1 read getCTMRIF write setCTMRIF;
    property IVRIE : TBits_1 read getIVRIE write setIVRIE;
    property IVRIF : TBits_1 read getIVRIF write setIVRIF;
    property MODIE : TBits_1 read getMODIE write setMODIE;
    property MODIF : TBits_1 read getMODIF write setMODIF;
    property RBIE : TBits_1 read getRBIE write setRBIE;
    property RBIF : TBits_1 read getRBIF write setRBIF;
    property RBOVIE : TBits_1 read getRBOVIE write setRBOVIE;
    property RBOVIF : TBits_1 read getRBOVIF write setRBOVIF;
    property SERRIE : TBits_1 read getSERRIE write setSERRIE;
    property SERRIF : TBits_1 read getSERRIF write setSERRIF;
    property TBIE : TBits_1 read getTBIE write setTBIE;
    property TBIF : TBits_1 read getTBIF write setTBIF;
    property WAKIE : TBits_1 read getWAKIE write setWAKIE;
    property WAKIF : TBits_1 read getWAKIF write setWAKIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1VEC = record
  private
    function  getFILHIT : TBits_5; inline;
    function  getICODE : TBits_7; inline;
    function  getw : TBits_32; inline;
    procedure setFILHIT(thebits : TBits_5); inline;
    procedure setICODE(thebits : TBits_7); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property FILHIT : TBits_5 read getFILHIT write setFILHIT;
    property ICODE : TBits_7 read getICODE write setICODE;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1TREC = record
  private
    function  getEWARN : TBits_1; inline;
    function  getRERRCNT : TBits_8; inline;
    function  getRXBP : TBits_1; inline;
    function  getRXWARN : TBits_1; inline;
    function  getTERRCNT : TBits_8; inline;
    function  getTXBO : TBits_1; inline;
    function  getTXBP : TBits_1; inline;
    function  getTXWARN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setEWARN(thebits : TBits_1); inline;
    procedure setRERRCNT(thebits : TBits_8); inline;
    procedure setRXBP(thebits : TBits_1); inline;
    procedure setRXWARN(thebits : TBits_1); inline;
    procedure setTERRCNT(thebits : TBits_8); inline;
    procedure setTXBO(thebits : TBits_1); inline;
    procedure setTXBP(thebits : TBits_1); inline;
    procedure setTXWARN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEWARN; inline;
    procedure clearRXBP; inline;
    procedure clearRXWARN; inline;
    procedure clearTXBO; inline;
    procedure clearTXBP; inline;
    procedure clearTXWARN; inline;
    procedure setEWARN; inline;
    procedure setRXBP; inline;
    procedure setRXWARN; inline;
    procedure setTXBO; inline;
    procedure setTXBP; inline;
    procedure setTXWARN; inline;
    property EWARN : TBits_1 read getEWARN write setEWARN;
    property RERRCNT : TBits_8 read getRERRCNT write setRERRCNT;
    property RXBP : TBits_1 read getRXBP write setRXBP;
    property RXWARN : TBits_1 read getRXWARN write setRXWARN;
    property TERRCNT : TBits_8 read getTERRCNT write setTERRCNT;
    property TXBO : TBits_1 read getTXBO write setTXBO;
    property TXBP : TBits_1 read getTXBP write setTXBP;
    property TXWARN : TBits_1 read getTXWARN write setTXWARN;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FSTAT = record
  private
    function  getFIFOIP : TBits_32; inline;
    function  getFIFOIP0 : TBits_1; inline;
    function  getFIFOIP1 : TBits_1; inline;
    function  getFIFOIP10 : TBits_1; inline;
    function  getFIFOIP11 : TBits_1; inline;
    function  getFIFOIP12 : TBits_1; inline;
    function  getFIFOIP13 : TBits_1; inline;
    function  getFIFOIP14 : TBits_1; inline;
    function  getFIFOIP15 : TBits_1; inline;
    function  getFIFOIP16 : TBits_1; inline;
    function  getFIFOIP17 : TBits_1; inline;
    function  getFIFOIP18 : TBits_1; inline;
    function  getFIFOIP19 : TBits_1; inline;
    function  getFIFOIP2 : TBits_1; inline;
    function  getFIFOIP20 : TBits_1; inline;
    function  getFIFOIP21 : TBits_1; inline;
    function  getFIFOIP22 : TBits_1; inline;
    function  getFIFOIP23 : TBits_1; inline;
    function  getFIFOIP24 : TBits_1; inline;
    function  getFIFOIP25 : TBits_1; inline;
    function  getFIFOIP26 : TBits_1; inline;
    function  getFIFOIP27 : TBits_1; inline;
    function  getFIFOIP28 : TBits_1; inline;
    function  getFIFOIP29 : TBits_1; inline;
    function  getFIFOIP3 : TBits_1; inline;
    function  getFIFOIP30 : TBits_1; inline;
    function  getFIFOIP31 : TBits_1; inline;
    function  getFIFOIP4 : TBits_1; inline;
    function  getFIFOIP5 : TBits_1; inline;
    function  getFIFOIP6 : TBits_1; inline;
    function  getFIFOIP7 : TBits_1; inline;
    function  getFIFOIP8 : TBits_1; inline;
    function  getFIFOIP9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setFIFOIP(thebits : TBits_32); inline;
    procedure setFIFOIP0(thebits : TBits_1); inline;
    procedure setFIFOIP1(thebits : TBits_1); inline;
    procedure setFIFOIP10(thebits : TBits_1); inline;
    procedure setFIFOIP11(thebits : TBits_1); inline;
    procedure setFIFOIP12(thebits : TBits_1); inline;
    procedure setFIFOIP13(thebits : TBits_1); inline;
    procedure setFIFOIP14(thebits : TBits_1); inline;
    procedure setFIFOIP15(thebits : TBits_1); inline;
    procedure setFIFOIP16(thebits : TBits_1); inline;
    procedure setFIFOIP17(thebits : TBits_1); inline;
    procedure setFIFOIP18(thebits : TBits_1); inline;
    procedure setFIFOIP19(thebits : TBits_1); inline;
    procedure setFIFOIP2(thebits : TBits_1); inline;
    procedure setFIFOIP20(thebits : TBits_1); inline;
    procedure setFIFOIP21(thebits : TBits_1); inline;
    procedure setFIFOIP22(thebits : TBits_1); inline;
    procedure setFIFOIP23(thebits : TBits_1); inline;
    procedure setFIFOIP24(thebits : TBits_1); inline;
    procedure setFIFOIP25(thebits : TBits_1); inline;
    procedure setFIFOIP26(thebits : TBits_1); inline;
    procedure setFIFOIP27(thebits : TBits_1); inline;
    procedure setFIFOIP28(thebits : TBits_1); inline;
    procedure setFIFOIP29(thebits : TBits_1); inline;
    procedure setFIFOIP3(thebits : TBits_1); inline;
    procedure setFIFOIP30(thebits : TBits_1); inline;
    procedure setFIFOIP31(thebits : TBits_1); inline;
    procedure setFIFOIP4(thebits : TBits_1); inline;
    procedure setFIFOIP5(thebits : TBits_1); inline;
    procedure setFIFOIP6(thebits : TBits_1); inline;
    procedure setFIFOIP7(thebits : TBits_1); inline;
    procedure setFIFOIP8(thebits : TBits_1); inline;
    procedure setFIFOIP9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFIFOIP0; inline;
    procedure clearFIFOIP10; inline;
    procedure clearFIFOIP11; inline;
    procedure clearFIFOIP12; inline;
    procedure clearFIFOIP13; inline;
    procedure clearFIFOIP14; inline;
    procedure clearFIFOIP15; inline;
    procedure clearFIFOIP16; inline;
    procedure clearFIFOIP17; inline;
    procedure clearFIFOIP18; inline;
    procedure clearFIFOIP19; inline;
    procedure clearFIFOIP1; inline;
    procedure clearFIFOIP20; inline;
    procedure clearFIFOIP21; inline;
    procedure clearFIFOIP22; inline;
    procedure clearFIFOIP23; inline;
    procedure clearFIFOIP24; inline;
    procedure clearFIFOIP25; inline;
    procedure clearFIFOIP26; inline;
    procedure clearFIFOIP27; inline;
    procedure clearFIFOIP28; inline;
    procedure clearFIFOIP29; inline;
    procedure clearFIFOIP2; inline;
    procedure clearFIFOIP30; inline;
    procedure clearFIFOIP31; inline;
    procedure clearFIFOIP3; inline;
    procedure clearFIFOIP4; inline;
    procedure clearFIFOIP5; inline;
    procedure clearFIFOIP6; inline;
    procedure clearFIFOIP7; inline;
    procedure clearFIFOIP8; inline;
    procedure clearFIFOIP9; inline;
    procedure setFIFOIP0; inline;
    procedure setFIFOIP10; inline;
    procedure setFIFOIP11; inline;
    procedure setFIFOIP12; inline;
    procedure setFIFOIP13; inline;
    procedure setFIFOIP14; inline;
    procedure setFIFOIP15; inline;
    procedure setFIFOIP16; inline;
    procedure setFIFOIP17; inline;
    procedure setFIFOIP18; inline;
    procedure setFIFOIP19; inline;
    procedure setFIFOIP1; inline;
    procedure setFIFOIP20; inline;
    procedure setFIFOIP21; inline;
    procedure setFIFOIP22; inline;
    procedure setFIFOIP23; inline;
    procedure setFIFOIP24; inline;
    procedure setFIFOIP25; inline;
    procedure setFIFOIP26; inline;
    procedure setFIFOIP27; inline;
    procedure setFIFOIP28; inline;
    procedure setFIFOIP29; inline;
    procedure setFIFOIP2; inline;
    procedure setFIFOIP30; inline;
    procedure setFIFOIP31; inline;
    procedure setFIFOIP3; inline;
    procedure setFIFOIP4; inline;
    procedure setFIFOIP5; inline;
    procedure setFIFOIP6; inline;
    procedure setFIFOIP7; inline;
    procedure setFIFOIP8; inline;
    procedure setFIFOIP9; inline;
    property FIFOIP : TBits_32 read getFIFOIP write setFIFOIP;
    property FIFOIP0 : TBits_1 read getFIFOIP0 write setFIFOIP0;
    property FIFOIP1 : TBits_1 read getFIFOIP1 write setFIFOIP1;
    property FIFOIP10 : TBits_1 read getFIFOIP10 write setFIFOIP10;
    property FIFOIP11 : TBits_1 read getFIFOIP11 write setFIFOIP11;
    property FIFOIP12 : TBits_1 read getFIFOIP12 write setFIFOIP12;
    property FIFOIP13 : TBits_1 read getFIFOIP13 write setFIFOIP13;
    property FIFOIP14 : TBits_1 read getFIFOIP14 write setFIFOIP14;
    property FIFOIP15 : TBits_1 read getFIFOIP15 write setFIFOIP15;
    property FIFOIP16 : TBits_1 read getFIFOIP16 write setFIFOIP16;
    property FIFOIP17 : TBits_1 read getFIFOIP17 write setFIFOIP17;
    property FIFOIP18 : TBits_1 read getFIFOIP18 write setFIFOIP18;
    property FIFOIP19 : TBits_1 read getFIFOIP19 write setFIFOIP19;
    property FIFOIP2 : TBits_1 read getFIFOIP2 write setFIFOIP2;
    property FIFOIP20 : TBits_1 read getFIFOIP20 write setFIFOIP20;
    property FIFOIP21 : TBits_1 read getFIFOIP21 write setFIFOIP21;
    property FIFOIP22 : TBits_1 read getFIFOIP22 write setFIFOIP22;
    property FIFOIP23 : TBits_1 read getFIFOIP23 write setFIFOIP23;
    property FIFOIP24 : TBits_1 read getFIFOIP24 write setFIFOIP24;
    property FIFOIP25 : TBits_1 read getFIFOIP25 write setFIFOIP25;
    property FIFOIP26 : TBits_1 read getFIFOIP26 write setFIFOIP26;
    property FIFOIP27 : TBits_1 read getFIFOIP27 write setFIFOIP27;
    property FIFOIP28 : TBits_1 read getFIFOIP28 write setFIFOIP28;
    property FIFOIP29 : TBits_1 read getFIFOIP29 write setFIFOIP29;
    property FIFOIP3 : TBits_1 read getFIFOIP3 write setFIFOIP3;
    property FIFOIP30 : TBits_1 read getFIFOIP30 write setFIFOIP30;
    property FIFOIP31 : TBits_1 read getFIFOIP31 write setFIFOIP31;
    property FIFOIP4 : TBits_1 read getFIFOIP4 write setFIFOIP4;
    property FIFOIP5 : TBits_1 read getFIFOIP5 write setFIFOIP5;
    property FIFOIP6 : TBits_1 read getFIFOIP6 write setFIFOIP6;
    property FIFOIP7 : TBits_1 read getFIFOIP7 write setFIFOIP7;
    property FIFOIP8 : TBits_1 read getFIFOIP8 write setFIFOIP8;
    property FIFOIP9 : TBits_1 read getFIFOIP9 write setFIFOIP9;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXOVF = record
  private
    function  getRXOVF : TBits_32; inline;
    function  getRXOVF0 : TBits_1; inline;
    function  getRXOVF1 : TBits_1; inline;
    function  getRXOVF10 : TBits_1; inline;
    function  getRXOVF11 : TBits_1; inline;
    function  getRXOVF12 : TBits_1; inline;
    function  getRXOVF13 : TBits_1; inline;
    function  getRXOVF14 : TBits_1; inline;
    function  getRXOVF15 : TBits_1; inline;
    function  getRXOVF16 : TBits_1; inline;
    function  getRXOVF17 : TBits_1; inline;
    function  getRXOVF18 : TBits_1; inline;
    function  getRXOVF19 : TBits_1; inline;
    function  getRXOVF2 : TBits_1; inline;
    function  getRXOVF20 : TBits_1; inline;
    function  getRXOVF21 : TBits_1; inline;
    function  getRXOVF22 : TBits_1; inline;
    function  getRXOVF23 : TBits_1; inline;
    function  getRXOVF24 : TBits_1; inline;
    function  getRXOVF25 : TBits_1; inline;
    function  getRXOVF26 : TBits_1; inline;
    function  getRXOVF27 : TBits_1; inline;
    function  getRXOVF28 : TBits_1; inline;
    function  getRXOVF29 : TBits_1; inline;
    function  getRXOVF3 : TBits_1; inline;
    function  getRXOVF30 : TBits_1; inline;
    function  getRXOVF31 : TBits_1; inline;
    function  getRXOVF4 : TBits_1; inline;
    function  getRXOVF5 : TBits_1; inline;
    function  getRXOVF6 : TBits_1; inline;
    function  getRXOVF7 : TBits_1; inline;
    function  getRXOVF8 : TBits_1; inline;
    function  getRXOVF9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXOVF(thebits : TBits_32); inline;
    procedure setRXOVF0(thebits : TBits_1); inline;
    procedure setRXOVF1(thebits : TBits_1); inline;
    procedure setRXOVF10(thebits : TBits_1); inline;
    procedure setRXOVF11(thebits : TBits_1); inline;
    procedure setRXOVF12(thebits : TBits_1); inline;
    procedure setRXOVF13(thebits : TBits_1); inline;
    procedure setRXOVF14(thebits : TBits_1); inline;
    procedure setRXOVF15(thebits : TBits_1); inline;
    procedure setRXOVF16(thebits : TBits_1); inline;
    procedure setRXOVF17(thebits : TBits_1); inline;
    procedure setRXOVF18(thebits : TBits_1); inline;
    procedure setRXOVF19(thebits : TBits_1); inline;
    procedure setRXOVF2(thebits : TBits_1); inline;
    procedure setRXOVF20(thebits : TBits_1); inline;
    procedure setRXOVF21(thebits : TBits_1); inline;
    procedure setRXOVF22(thebits : TBits_1); inline;
    procedure setRXOVF23(thebits : TBits_1); inline;
    procedure setRXOVF24(thebits : TBits_1); inline;
    procedure setRXOVF25(thebits : TBits_1); inline;
    procedure setRXOVF26(thebits : TBits_1); inline;
    procedure setRXOVF27(thebits : TBits_1); inline;
    procedure setRXOVF28(thebits : TBits_1); inline;
    procedure setRXOVF29(thebits : TBits_1); inline;
    procedure setRXOVF3(thebits : TBits_1); inline;
    procedure setRXOVF30(thebits : TBits_1); inline;
    procedure setRXOVF31(thebits : TBits_1); inline;
    procedure setRXOVF4(thebits : TBits_1); inline;
    procedure setRXOVF5(thebits : TBits_1); inline;
    procedure setRXOVF6(thebits : TBits_1); inline;
    procedure setRXOVF7(thebits : TBits_1); inline;
    procedure setRXOVF8(thebits : TBits_1); inline;
    procedure setRXOVF9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXOVF0; inline;
    procedure clearRXOVF10; inline;
    procedure clearRXOVF11; inline;
    procedure clearRXOVF12; inline;
    procedure clearRXOVF13; inline;
    procedure clearRXOVF14; inline;
    procedure clearRXOVF15; inline;
    procedure clearRXOVF16; inline;
    procedure clearRXOVF17; inline;
    procedure clearRXOVF18; inline;
    procedure clearRXOVF19; inline;
    procedure clearRXOVF1; inline;
    procedure clearRXOVF20; inline;
    procedure clearRXOVF21; inline;
    procedure clearRXOVF22; inline;
    procedure clearRXOVF23; inline;
    procedure clearRXOVF24; inline;
    procedure clearRXOVF25; inline;
    procedure clearRXOVF26; inline;
    procedure clearRXOVF27; inline;
    procedure clearRXOVF28; inline;
    procedure clearRXOVF29; inline;
    procedure clearRXOVF2; inline;
    procedure clearRXOVF30; inline;
    procedure clearRXOVF31; inline;
    procedure clearRXOVF3; inline;
    procedure clearRXOVF4; inline;
    procedure clearRXOVF5; inline;
    procedure clearRXOVF6; inline;
    procedure clearRXOVF7; inline;
    procedure clearRXOVF8; inline;
    procedure clearRXOVF9; inline;
    procedure setRXOVF0; inline;
    procedure setRXOVF10; inline;
    procedure setRXOVF11; inline;
    procedure setRXOVF12; inline;
    procedure setRXOVF13; inline;
    procedure setRXOVF14; inline;
    procedure setRXOVF15; inline;
    procedure setRXOVF16; inline;
    procedure setRXOVF17; inline;
    procedure setRXOVF18; inline;
    procedure setRXOVF19; inline;
    procedure setRXOVF1; inline;
    procedure setRXOVF20; inline;
    procedure setRXOVF21; inline;
    procedure setRXOVF22; inline;
    procedure setRXOVF23; inline;
    procedure setRXOVF24; inline;
    procedure setRXOVF25; inline;
    procedure setRXOVF26; inline;
    procedure setRXOVF27; inline;
    procedure setRXOVF28; inline;
    procedure setRXOVF29; inline;
    procedure setRXOVF2; inline;
    procedure setRXOVF30; inline;
    procedure setRXOVF31; inline;
    procedure setRXOVF3; inline;
    procedure setRXOVF4; inline;
    procedure setRXOVF5; inline;
    procedure setRXOVF6; inline;
    procedure setRXOVF7; inline;
    procedure setRXOVF8; inline;
    procedure setRXOVF9; inline;
    property RXOVF : TBits_32 read getRXOVF write setRXOVF;
    property RXOVF0 : TBits_1 read getRXOVF0 write setRXOVF0;
    property RXOVF1 : TBits_1 read getRXOVF1 write setRXOVF1;
    property RXOVF10 : TBits_1 read getRXOVF10 write setRXOVF10;
    property RXOVF11 : TBits_1 read getRXOVF11 write setRXOVF11;
    property RXOVF12 : TBits_1 read getRXOVF12 write setRXOVF12;
    property RXOVF13 : TBits_1 read getRXOVF13 write setRXOVF13;
    property RXOVF14 : TBits_1 read getRXOVF14 write setRXOVF14;
    property RXOVF15 : TBits_1 read getRXOVF15 write setRXOVF15;
    property RXOVF16 : TBits_1 read getRXOVF16 write setRXOVF16;
    property RXOVF17 : TBits_1 read getRXOVF17 write setRXOVF17;
    property RXOVF18 : TBits_1 read getRXOVF18 write setRXOVF18;
    property RXOVF19 : TBits_1 read getRXOVF19 write setRXOVF19;
    property RXOVF2 : TBits_1 read getRXOVF2 write setRXOVF2;
    property RXOVF20 : TBits_1 read getRXOVF20 write setRXOVF20;
    property RXOVF21 : TBits_1 read getRXOVF21 write setRXOVF21;
    property RXOVF22 : TBits_1 read getRXOVF22 write setRXOVF22;
    property RXOVF23 : TBits_1 read getRXOVF23 write setRXOVF23;
    property RXOVF24 : TBits_1 read getRXOVF24 write setRXOVF24;
    property RXOVF25 : TBits_1 read getRXOVF25 write setRXOVF25;
    property RXOVF26 : TBits_1 read getRXOVF26 write setRXOVF26;
    property RXOVF27 : TBits_1 read getRXOVF27 write setRXOVF27;
    property RXOVF28 : TBits_1 read getRXOVF28 write setRXOVF28;
    property RXOVF29 : TBits_1 read getRXOVF29 write setRXOVF29;
    property RXOVF3 : TBits_1 read getRXOVF3 write setRXOVF3;
    property RXOVF30 : TBits_1 read getRXOVF30 write setRXOVF30;
    property RXOVF31 : TBits_1 read getRXOVF31 write setRXOVF31;
    property RXOVF4 : TBits_1 read getRXOVF4 write setRXOVF4;
    property RXOVF5 : TBits_1 read getRXOVF5 write setRXOVF5;
    property RXOVF6 : TBits_1 read getRXOVF6 write setRXOVF6;
    property RXOVF7 : TBits_1 read getRXOVF7 write setRXOVF7;
    property RXOVF8 : TBits_1 read getRXOVF8 write setRXOVF8;
    property RXOVF9 : TBits_1 read getRXOVF9 write setRXOVF9;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1TMR = record
  private
    function  getCANTS : TBits_16; inline;
    function  getCANTSPRE : TBits_16; inline;
    function  getw : TBits_32; inline;
    procedure setCANTS(thebits : TBits_16); inline;
    procedure setCANTSPRE(thebits : TBits_16); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CANTS : TBits_16 read getCANTS write setCANTS;
    property CANTSPRE : TBits_16 read getCANTSPRE write setCANTSPRE;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXM0 = record
  private
    function  getEID : TBits_18; inline;
    function  getMIDE : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setMIDE(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearMIDE; inline;
    procedure setMIDE; inline;
    property EID : TBits_18 read getEID write setEID;
    property MIDE : TBits_1 read getMIDE write setMIDE;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXM1 = record
  private
    function  getEID : TBits_18; inline;
    function  getMIDE : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setMIDE(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearMIDE; inline;
    procedure setMIDE; inline;
    property EID : TBits_18 read getEID write setEID;
    property MIDE : TBits_1 read getMIDE write setMIDE;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXM2 = record
  private
    function  getEID : TBits_18; inline;
    function  getMIDE : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setMIDE(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearMIDE; inline;
    procedure setMIDE; inline;
    property EID : TBits_18 read getEID write setEID;
    property MIDE : TBits_1 read getMIDE write setMIDE;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXM3 = record
  private
    function  getEID : TBits_18; inline;
    function  getMIDE : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setMIDE(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearMIDE; inline;
    procedure setMIDE; inline;
    property EID : TBits_18 read getEID write setEID;
    property MIDE : TBits_1 read getMIDE write setMIDE;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FLTCON0 = record
  private
    function  getFLTEN0 : TBits_1; inline;
    function  getFLTEN1 : TBits_1; inline;
    function  getFLTEN2 : TBits_1; inline;
    function  getFLTEN3 : TBits_1; inline;
    function  getFSEL0 : TBits_5; inline;
    function  getFSEL1 : TBits_5; inline;
    function  getFSEL2 : TBits_5; inline;
    function  getFSEL3 : TBits_5; inline;
    function  getMSEL0 : TBits_2; inline;
    function  getMSEL1 : TBits_2; inline;
    function  getMSEL2 : TBits_2; inline;
    function  getMSEL3 : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setFLTEN0(thebits : TBits_1); inline;
    procedure setFLTEN1(thebits : TBits_1); inline;
    procedure setFLTEN2(thebits : TBits_1); inline;
    procedure setFLTEN3(thebits : TBits_1); inline;
    procedure setFSEL0(thebits : TBits_5); inline;
    procedure setFSEL1(thebits : TBits_5); inline;
    procedure setFSEL2(thebits : TBits_5); inline;
    procedure setFSEL3(thebits : TBits_5); inline;
    procedure setMSEL0(thebits : TBits_2); inline;
    procedure setMSEL1(thebits : TBits_2); inline;
    procedure setMSEL2(thebits : TBits_2); inline;
    procedure setMSEL3(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFLTEN0; inline;
    procedure clearFLTEN1; inline;
    procedure clearFLTEN2; inline;
    procedure clearFLTEN3; inline;
    procedure setFLTEN0; inline;
    procedure setFLTEN1; inline;
    procedure setFLTEN2; inline;
    procedure setFLTEN3; inline;
    property FLTEN0 : TBits_1 read getFLTEN0 write setFLTEN0;
    property FLTEN1 : TBits_1 read getFLTEN1 write setFLTEN1;
    property FLTEN2 : TBits_1 read getFLTEN2 write setFLTEN2;
    property FLTEN3 : TBits_1 read getFLTEN3 write setFLTEN3;
    property FSEL0 : TBits_5 read getFSEL0 write setFSEL0;
    property FSEL1 : TBits_5 read getFSEL1 write setFSEL1;
    property FSEL2 : TBits_5 read getFSEL2 write setFSEL2;
    property FSEL3 : TBits_5 read getFSEL3 write setFSEL3;
    property MSEL0 : TBits_2 read getMSEL0 write setMSEL0;
    property MSEL1 : TBits_2 read getMSEL1 write setMSEL1;
    property MSEL2 : TBits_2 read getMSEL2 write setMSEL2;
    property MSEL3 : TBits_2 read getMSEL3 write setMSEL3;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FLTCON1 = record
  private
    function  getFLTEN4 : TBits_1; inline;
    function  getFLTEN5 : TBits_1; inline;
    function  getFLTEN6 : TBits_1; inline;
    function  getFLTEN7 : TBits_1; inline;
    function  getFSEL4 : TBits_5; inline;
    function  getFSEL5 : TBits_5; inline;
    function  getFSEL6 : TBits_5; inline;
    function  getFSEL7 : TBits_5; inline;
    function  getMSEL4 : TBits_2; inline;
    function  getMSEL5 : TBits_2; inline;
    function  getMSEL6 : TBits_2; inline;
    function  getMSEL7 : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setFLTEN4(thebits : TBits_1); inline;
    procedure setFLTEN5(thebits : TBits_1); inline;
    procedure setFLTEN6(thebits : TBits_1); inline;
    procedure setFLTEN7(thebits : TBits_1); inline;
    procedure setFSEL4(thebits : TBits_5); inline;
    procedure setFSEL5(thebits : TBits_5); inline;
    procedure setFSEL6(thebits : TBits_5); inline;
    procedure setFSEL7(thebits : TBits_5); inline;
    procedure setMSEL4(thebits : TBits_2); inline;
    procedure setMSEL5(thebits : TBits_2); inline;
    procedure setMSEL6(thebits : TBits_2); inline;
    procedure setMSEL7(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFLTEN4; inline;
    procedure clearFLTEN5; inline;
    procedure clearFLTEN6; inline;
    procedure clearFLTEN7; inline;
    procedure setFLTEN4; inline;
    procedure setFLTEN5; inline;
    procedure setFLTEN6; inline;
    procedure setFLTEN7; inline;
    property FLTEN4 : TBits_1 read getFLTEN4 write setFLTEN4;
    property FLTEN5 : TBits_1 read getFLTEN5 write setFLTEN5;
    property FLTEN6 : TBits_1 read getFLTEN6 write setFLTEN6;
    property FLTEN7 : TBits_1 read getFLTEN7 write setFLTEN7;
    property FSEL4 : TBits_5 read getFSEL4 write setFSEL4;
    property FSEL5 : TBits_5 read getFSEL5 write setFSEL5;
    property FSEL6 : TBits_5 read getFSEL6 write setFSEL6;
    property FSEL7 : TBits_5 read getFSEL7 write setFSEL7;
    property MSEL4 : TBits_2 read getMSEL4 write setMSEL4;
    property MSEL5 : TBits_2 read getMSEL5 write setMSEL5;
    property MSEL6 : TBits_2 read getMSEL6 write setMSEL6;
    property MSEL7 : TBits_2 read getMSEL7 write setMSEL7;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FLTCON2 = record
  private
    function  getFLTEN10 : TBits_1; inline;
    function  getFLTEN11 : TBits_1; inline;
    function  getFLTEN8 : TBits_1; inline;
    function  getFLTEN9 : TBits_1; inline;
    function  getFSEL10 : TBits_5; inline;
    function  getFSEL11 : TBits_5; inline;
    function  getFSEL8 : TBits_5; inline;
    function  getFSEL9 : TBits_5; inline;
    function  getMSEL10 : TBits_2; inline;
    function  getMSEL11 : TBits_2; inline;
    function  getMSEL8 : TBits_2; inline;
    function  getMSEL9 : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setFLTEN10(thebits : TBits_1); inline;
    procedure setFLTEN11(thebits : TBits_1); inline;
    procedure setFLTEN8(thebits : TBits_1); inline;
    procedure setFLTEN9(thebits : TBits_1); inline;
    procedure setFSEL10(thebits : TBits_5); inline;
    procedure setFSEL11(thebits : TBits_5); inline;
    procedure setFSEL8(thebits : TBits_5); inline;
    procedure setFSEL9(thebits : TBits_5); inline;
    procedure setMSEL10(thebits : TBits_2); inline;
    procedure setMSEL11(thebits : TBits_2); inline;
    procedure setMSEL8(thebits : TBits_2); inline;
    procedure setMSEL9(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFLTEN10; inline;
    procedure clearFLTEN11; inline;
    procedure clearFLTEN8; inline;
    procedure clearFLTEN9; inline;
    procedure setFLTEN10; inline;
    procedure setFLTEN11; inline;
    procedure setFLTEN8; inline;
    procedure setFLTEN9; inline;
    property FLTEN10 : TBits_1 read getFLTEN10 write setFLTEN10;
    property FLTEN11 : TBits_1 read getFLTEN11 write setFLTEN11;
    property FLTEN8 : TBits_1 read getFLTEN8 write setFLTEN8;
    property FLTEN9 : TBits_1 read getFLTEN9 write setFLTEN9;
    property FSEL10 : TBits_5 read getFSEL10 write setFSEL10;
    property FSEL11 : TBits_5 read getFSEL11 write setFSEL11;
    property FSEL8 : TBits_5 read getFSEL8 write setFSEL8;
    property FSEL9 : TBits_5 read getFSEL9 write setFSEL9;
    property MSEL10 : TBits_2 read getMSEL10 write setMSEL10;
    property MSEL11 : TBits_2 read getMSEL11 write setMSEL11;
    property MSEL8 : TBits_2 read getMSEL8 write setMSEL8;
    property MSEL9 : TBits_2 read getMSEL9 write setMSEL9;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FLTCON3 = record
  private
    function  getFLTEN12 : TBits_1; inline;
    function  getFLTEN13 : TBits_1; inline;
    function  getFLTEN14 : TBits_1; inline;
    function  getFLTEN15 : TBits_1; inline;
    function  getFSEL12 : TBits_5; inline;
    function  getFSEL13 : TBits_5; inline;
    function  getFSEL14 : TBits_5; inline;
    function  getFSEL15 : TBits_5; inline;
    function  getMSEL12 : TBits_2; inline;
    function  getMSEL13 : TBits_2; inline;
    function  getMSEL14 : TBits_2; inline;
    function  getMSEL15 : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setFLTEN12(thebits : TBits_1); inline;
    procedure setFLTEN13(thebits : TBits_1); inline;
    procedure setFLTEN14(thebits : TBits_1); inline;
    procedure setFLTEN15(thebits : TBits_1); inline;
    procedure setFSEL12(thebits : TBits_5); inline;
    procedure setFSEL13(thebits : TBits_5); inline;
    procedure setFSEL14(thebits : TBits_5); inline;
    procedure setFSEL15(thebits : TBits_5); inline;
    procedure setMSEL12(thebits : TBits_2); inline;
    procedure setMSEL13(thebits : TBits_2); inline;
    procedure setMSEL14(thebits : TBits_2); inline;
    procedure setMSEL15(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFLTEN12; inline;
    procedure clearFLTEN13; inline;
    procedure clearFLTEN14; inline;
    procedure clearFLTEN15; inline;
    procedure setFLTEN12; inline;
    procedure setFLTEN13; inline;
    procedure setFLTEN14; inline;
    procedure setFLTEN15; inline;
    property FLTEN12 : TBits_1 read getFLTEN12 write setFLTEN12;
    property FLTEN13 : TBits_1 read getFLTEN13 write setFLTEN13;
    property FLTEN14 : TBits_1 read getFLTEN14 write setFLTEN14;
    property FLTEN15 : TBits_1 read getFLTEN15 write setFLTEN15;
    property FSEL12 : TBits_5 read getFSEL12 write setFSEL12;
    property FSEL13 : TBits_5 read getFSEL13 write setFSEL13;
    property FSEL14 : TBits_5 read getFSEL14 write setFSEL14;
    property FSEL15 : TBits_5 read getFSEL15 write setFSEL15;
    property MSEL12 : TBits_2 read getMSEL12 write setMSEL12;
    property MSEL13 : TBits_2 read getMSEL13 write setMSEL13;
    property MSEL14 : TBits_2 read getMSEL14 write setMSEL14;
    property MSEL15 : TBits_2 read getMSEL15 write setMSEL15;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FLTCON4 = record
  private
    function  getFLTEN16 : TBits_1; inline;
    function  getFLTEN17 : TBits_1; inline;
    function  getFLTEN18 : TBits_1; inline;
    function  getFLTEN19 : TBits_1; inline;
    function  getFSEL16 : TBits_5; inline;
    function  getFSEL17 : TBits_5; inline;
    function  getFSEL18 : TBits_5; inline;
    function  getFSEL19 : TBits_5; inline;
    function  getMSEL16 : TBits_2; inline;
    function  getMSEL17 : TBits_2; inline;
    function  getMSEL18 : TBits_2; inline;
    function  getMSEL19 : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setFLTEN16(thebits : TBits_1); inline;
    procedure setFLTEN17(thebits : TBits_1); inline;
    procedure setFLTEN18(thebits : TBits_1); inline;
    procedure setFLTEN19(thebits : TBits_1); inline;
    procedure setFSEL16(thebits : TBits_5); inline;
    procedure setFSEL17(thebits : TBits_5); inline;
    procedure setFSEL18(thebits : TBits_5); inline;
    procedure setFSEL19(thebits : TBits_5); inline;
    procedure setMSEL16(thebits : TBits_2); inline;
    procedure setMSEL17(thebits : TBits_2); inline;
    procedure setMSEL18(thebits : TBits_2); inline;
    procedure setMSEL19(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFLTEN16; inline;
    procedure clearFLTEN17; inline;
    procedure clearFLTEN18; inline;
    procedure clearFLTEN19; inline;
    procedure setFLTEN16; inline;
    procedure setFLTEN17; inline;
    procedure setFLTEN18; inline;
    procedure setFLTEN19; inline;
    property FLTEN16 : TBits_1 read getFLTEN16 write setFLTEN16;
    property FLTEN17 : TBits_1 read getFLTEN17 write setFLTEN17;
    property FLTEN18 : TBits_1 read getFLTEN18 write setFLTEN18;
    property FLTEN19 : TBits_1 read getFLTEN19 write setFLTEN19;
    property FSEL16 : TBits_5 read getFSEL16 write setFSEL16;
    property FSEL17 : TBits_5 read getFSEL17 write setFSEL17;
    property FSEL18 : TBits_5 read getFSEL18 write setFSEL18;
    property FSEL19 : TBits_5 read getFSEL19 write setFSEL19;
    property MSEL16 : TBits_2 read getMSEL16 write setMSEL16;
    property MSEL17 : TBits_2 read getMSEL17 write setMSEL17;
    property MSEL18 : TBits_2 read getMSEL18 write setMSEL18;
    property MSEL19 : TBits_2 read getMSEL19 write setMSEL19;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FLTCON5 = record
  private
    function  getFLTEN20 : TBits_1; inline;
    function  getFLTEN21 : TBits_1; inline;
    function  getFLTEN22 : TBits_1; inline;
    function  getFLTEN23 : TBits_1; inline;
    function  getFSEL20 : TBits_5; inline;
    function  getFSEL21 : TBits_5; inline;
    function  getFSEL22 : TBits_5; inline;
    function  getFSEL23 : TBits_5; inline;
    function  getMSEL20 : TBits_2; inline;
    function  getMSEL21 : TBits_2; inline;
    function  getMSEL22 : TBits_2; inline;
    function  getMSEL23 : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setFLTEN20(thebits : TBits_1); inline;
    procedure setFLTEN21(thebits : TBits_1); inline;
    procedure setFLTEN22(thebits : TBits_1); inline;
    procedure setFLTEN23(thebits : TBits_1); inline;
    procedure setFSEL20(thebits : TBits_5); inline;
    procedure setFSEL21(thebits : TBits_5); inline;
    procedure setFSEL22(thebits : TBits_5); inline;
    procedure setFSEL23(thebits : TBits_5); inline;
    procedure setMSEL20(thebits : TBits_2); inline;
    procedure setMSEL21(thebits : TBits_2); inline;
    procedure setMSEL22(thebits : TBits_2); inline;
    procedure setMSEL23(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFLTEN20; inline;
    procedure clearFLTEN21; inline;
    procedure clearFLTEN22; inline;
    procedure clearFLTEN23; inline;
    procedure setFLTEN20; inline;
    procedure setFLTEN21; inline;
    procedure setFLTEN22; inline;
    procedure setFLTEN23; inline;
    property FLTEN20 : TBits_1 read getFLTEN20 write setFLTEN20;
    property FLTEN21 : TBits_1 read getFLTEN21 write setFLTEN21;
    property FLTEN22 : TBits_1 read getFLTEN22 write setFLTEN22;
    property FLTEN23 : TBits_1 read getFLTEN23 write setFLTEN23;
    property FSEL20 : TBits_5 read getFSEL20 write setFSEL20;
    property FSEL21 : TBits_5 read getFSEL21 write setFSEL21;
    property FSEL22 : TBits_5 read getFSEL22 write setFSEL22;
    property FSEL23 : TBits_5 read getFSEL23 write setFSEL23;
    property MSEL20 : TBits_2 read getMSEL20 write setMSEL20;
    property MSEL21 : TBits_2 read getMSEL21 write setMSEL21;
    property MSEL22 : TBits_2 read getMSEL22 write setMSEL22;
    property MSEL23 : TBits_2 read getMSEL23 write setMSEL23;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FLTCON6 = record
  private
    function  getFLTEN24 : TBits_1; inline;
    function  getFLTEN25 : TBits_1; inline;
    function  getFLTEN26 : TBits_1; inline;
    function  getFLTEN27 : TBits_1; inline;
    function  getFSEL24 : TBits_5; inline;
    function  getFSEL25 : TBits_5; inline;
    function  getFSEL26 : TBits_5; inline;
    function  getFSEL27 : TBits_5; inline;
    function  getMSEL24 : TBits_2; inline;
    function  getMSEL25 : TBits_2; inline;
    function  getMSEL26 : TBits_2; inline;
    function  getMSEL27 : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setFLTEN24(thebits : TBits_1); inline;
    procedure setFLTEN25(thebits : TBits_1); inline;
    procedure setFLTEN26(thebits : TBits_1); inline;
    procedure setFLTEN27(thebits : TBits_1); inline;
    procedure setFSEL24(thebits : TBits_5); inline;
    procedure setFSEL25(thebits : TBits_5); inline;
    procedure setFSEL26(thebits : TBits_5); inline;
    procedure setFSEL27(thebits : TBits_5); inline;
    procedure setMSEL24(thebits : TBits_2); inline;
    procedure setMSEL25(thebits : TBits_2); inline;
    procedure setMSEL26(thebits : TBits_2); inline;
    procedure setMSEL27(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFLTEN24; inline;
    procedure clearFLTEN25; inline;
    procedure clearFLTEN26; inline;
    procedure clearFLTEN27; inline;
    procedure setFLTEN24; inline;
    procedure setFLTEN25; inline;
    procedure setFLTEN26; inline;
    procedure setFLTEN27; inline;
    property FLTEN24 : TBits_1 read getFLTEN24 write setFLTEN24;
    property FLTEN25 : TBits_1 read getFLTEN25 write setFLTEN25;
    property FLTEN26 : TBits_1 read getFLTEN26 write setFLTEN26;
    property FLTEN27 : TBits_1 read getFLTEN27 write setFLTEN27;
    property FSEL24 : TBits_5 read getFSEL24 write setFSEL24;
    property FSEL25 : TBits_5 read getFSEL25 write setFSEL25;
    property FSEL26 : TBits_5 read getFSEL26 write setFSEL26;
    property FSEL27 : TBits_5 read getFSEL27 write setFSEL27;
    property MSEL24 : TBits_2 read getMSEL24 write setMSEL24;
    property MSEL25 : TBits_2 read getMSEL25 write setMSEL25;
    property MSEL26 : TBits_2 read getMSEL26 write setMSEL26;
    property MSEL27 : TBits_2 read getMSEL27 write setMSEL27;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FLTCON7 = record
  private
    function  getFLTEN28 : TBits_1; inline;
    function  getFLTEN29 : TBits_1; inline;
    function  getFLTEN30 : TBits_1; inline;
    function  getFLTEN31 : TBits_1; inline;
    function  getFSEL28 : TBits_5; inline;
    function  getFSEL29 : TBits_5; inline;
    function  getFSEL30 : TBits_5; inline;
    function  getFSEL31 : TBits_5; inline;
    function  getMSEL28 : TBits_2; inline;
    function  getMSEL29 : TBits_2; inline;
    function  getMSEL30 : TBits_2; inline;
    function  getMSEL31 : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setFLTEN28(thebits : TBits_1); inline;
    procedure setFLTEN29(thebits : TBits_1); inline;
    procedure setFLTEN30(thebits : TBits_1); inline;
    procedure setFLTEN31(thebits : TBits_1); inline;
    procedure setFSEL28(thebits : TBits_5); inline;
    procedure setFSEL29(thebits : TBits_5); inline;
    procedure setFSEL30(thebits : TBits_5); inline;
    procedure setFSEL31(thebits : TBits_5); inline;
    procedure setMSEL28(thebits : TBits_2); inline;
    procedure setMSEL29(thebits : TBits_2); inline;
    procedure setMSEL30(thebits : TBits_2); inline;
    procedure setMSEL31(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFLTEN28; inline;
    procedure clearFLTEN29; inline;
    procedure clearFLTEN30; inline;
    procedure clearFLTEN31; inline;
    procedure setFLTEN28; inline;
    procedure setFLTEN29; inline;
    procedure setFLTEN30; inline;
    procedure setFLTEN31; inline;
    property FLTEN28 : TBits_1 read getFLTEN28 write setFLTEN28;
    property FLTEN29 : TBits_1 read getFLTEN29 write setFLTEN29;
    property FLTEN30 : TBits_1 read getFLTEN30 write setFLTEN30;
    property FLTEN31 : TBits_1 read getFLTEN31 write setFLTEN31;
    property FSEL28 : TBits_5 read getFSEL28 write setFSEL28;
    property FSEL29 : TBits_5 read getFSEL29 write setFSEL29;
    property FSEL30 : TBits_5 read getFSEL30 write setFSEL30;
    property FSEL31 : TBits_5 read getFSEL31 write setFSEL31;
    property MSEL28 : TBits_2 read getMSEL28 write setMSEL28;
    property MSEL29 : TBits_2 read getMSEL29 write setMSEL29;
    property MSEL30 : TBits_2 read getMSEL30 write setMSEL30;
    property MSEL31 : TBits_2 read getMSEL31 write setMSEL31;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF0 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF1 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF2 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF3 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF4 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF5 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF6 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF7 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF8 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF9 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF10 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF11 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF12 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF13 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF14 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF15 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF16 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF17 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF18 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF19 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF20 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF21 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF22 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF23 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF24 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF25 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF26 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF27 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF28 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF29 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF30 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1RXF31 = record
  private
    function  getEID : TBits_18; inline;
    function  getEXID : TBits_1; inline;
    function  getSID : TBits_11; inline;
    function  getw : TBits_32; inline;
    procedure setEID(thebits : TBits_18); inline;
    procedure setEXID(thebits : TBits_1); inline;
    procedure setSID(thebits : TBits_11); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearEXID; inline;
    procedure setEXID; inline;
    property EID : TBits_18 read getEID write setEID;
    property EXID : TBits_1 read getEXID write setEXID;
    property SID : TBits_11 read getSID write setSID;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON0 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT0 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI0 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON1 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT1 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI1 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON2 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT2 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI2 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON3 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT3 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI3 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON4 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT4 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI4 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON5 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT5 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI5 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON6 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT6 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI6 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON7 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT7 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI7 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON8 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT8 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI8 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON9 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT9 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI9 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON10 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT10 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI10 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON11 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT11 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI11 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON12 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT12 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI12 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON13 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT13 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI13 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON14 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT14 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI14 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON15 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT15 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI15 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON16 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT16 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI16 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON17 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT17 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI17 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON18 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT18 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI18 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON19 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT19 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI19 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON20 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT20 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI20 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON21 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT21 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI21 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON22 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT22 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI22 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON23 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT23 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI23 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON24 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT24 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI24 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON25 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT25 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI25 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON26 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT26 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI26 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON27 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT27 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI27 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON28 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT28 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI28 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON29 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT29 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI29 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON30 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT30 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI30 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCON31 = record
  private
    function  getDONLY : TBits_1; inline;
    function  getFRESET : TBits_1; inline;
    function  getFSIZE : TBits_5; inline;
    function  getRTREN : TBits_1; inline;
    function  getTXABAT : TBits_1; inline;
    function  getTXEN : TBits_1; inline;
    function  getTXERR : TBits_1; inline;
    function  getTXLARB : TBits_1; inline;
    function  getTXPRI : TBits_2; inline;
    function  getTXREQ : TBits_1; inline;
    function  getUINC : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDONLY(thebits : TBits_1); inline;
    procedure setFRESET(thebits : TBits_1); inline;
    procedure setFSIZE(thebits : TBits_5); inline;
    procedure setRTREN(thebits : TBits_1); inline;
    procedure setTXABAT(thebits : TBits_1); inline;
    procedure setTXEN(thebits : TBits_1); inline;
    procedure setTXERR(thebits : TBits_1); inline;
    procedure setTXLARB(thebits : TBits_1); inline;
    procedure setTXPRI(thebits : TBits_2); inline;
    procedure setTXREQ(thebits : TBits_1); inline;
    procedure setUINC(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDONLY; inline;
    procedure clearFRESET; inline;
    procedure clearRTREN; inline;
    procedure clearTXABAT; inline;
    procedure clearTXEN; inline;
    procedure clearTXERR; inline;
    procedure clearTXLARB; inline;
    procedure clearTXREQ; inline;
    procedure clearUINC; inline;
    procedure setDONLY; inline;
    procedure setFRESET; inline;
    procedure setRTREN; inline;
    procedure setTXABAT; inline;
    procedure setTXEN; inline;
    procedure setTXERR; inline;
    procedure setTXLARB; inline;
    procedure setTXREQ; inline;
    procedure setUINC; inline;
    property DONLY : TBits_1 read getDONLY write setDONLY;
    property FRESET : TBits_1 read getFRESET write setFRESET;
    property FSIZE : TBits_5 read getFSIZE write setFSIZE;
    property RTREN : TBits_1 read getRTREN write setRTREN;
    property TXABAT : TBits_1 read getTXABAT write setTXABAT;
    property TXEN : TBits_1 read getTXEN write setTXEN;
    property TXERR : TBits_1 read getTXERR write setTXERR;
    property TXLARB : TBits_1 read getTXLARB write setTXLARB;
    property TXPRI : TBits_2 read getTXPRI write setTXPRI;
    property TXREQ : TBits_1 read getTXREQ write setTXREQ;
    property UINC : TBits_1 read getUINC write setUINC;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOINT31 = record
  private
    function  getRXFULLIE : TBits_1; inline;
    function  getRXFULLIF : TBits_1; inline;
    function  getRXHALFIE : TBits_1; inline;
    function  getRXHALFIF : TBits_1; inline;
    function  getRXNEMPTYIE : TBits_1; inline;
    function  getRXNEMPTYIF : TBits_1; inline;
    function  getRXOVFLIE : TBits_1; inline;
    function  getRXOVFLIF : TBits_1; inline;
    function  getTXEMPTYIE : TBits_1; inline;
    function  getTXEMPTYIF : TBits_1; inline;
    function  getTXHALFIE : TBits_1; inline;
    function  getTXHALFIF : TBits_1; inline;
    function  getTXNFULLIE : TBits_1; inline;
    function  getTXNFULLIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRXFULLIE(thebits : TBits_1); inline;
    procedure setRXFULLIF(thebits : TBits_1); inline;
    procedure setRXHALFIE(thebits : TBits_1); inline;
    procedure setRXHALFIF(thebits : TBits_1); inline;
    procedure setRXNEMPTYIE(thebits : TBits_1); inline;
    procedure setRXNEMPTYIF(thebits : TBits_1); inline;
    procedure setRXOVFLIE(thebits : TBits_1); inline;
    procedure setRXOVFLIF(thebits : TBits_1); inline;
    procedure setTXEMPTYIE(thebits : TBits_1); inline;
    procedure setTXEMPTYIF(thebits : TBits_1); inline;
    procedure setTXHALFIE(thebits : TBits_1); inline;
    procedure setTXHALFIF(thebits : TBits_1); inline;
    procedure setTXNFULLIE(thebits : TBits_1); inline;
    procedure setTXNFULLIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRXFULLIE; inline;
    procedure clearRXFULLIF; inline;
    procedure clearRXHALFIE; inline;
    procedure clearRXHALFIF; inline;
    procedure clearRXNEMPTYIE; inline;
    procedure clearRXNEMPTYIF; inline;
    procedure clearRXOVFLIE; inline;
    procedure clearRXOVFLIF; inline;
    procedure clearTXEMPTYIE; inline;
    procedure clearTXEMPTYIF; inline;
    procedure clearTXHALFIE; inline;
    procedure clearTXHALFIF; inline;
    procedure clearTXNFULLIE; inline;
    procedure clearTXNFULLIF; inline;
    procedure setRXFULLIE; inline;
    procedure setRXFULLIF; inline;
    procedure setRXHALFIE; inline;
    procedure setRXHALFIF; inline;
    procedure setRXNEMPTYIE; inline;
    procedure setRXNEMPTYIF; inline;
    procedure setRXOVFLIE; inline;
    procedure setRXOVFLIF; inline;
    procedure setTXEMPTYIE; inline;
    procedure setTXEMPTYIF; inline;
    procedure setTXHALFIE; inline;
    procedure setTXHALFIF; inline;
    procedure setTXNFULLIE; inline;
    procedure setTXNFULLIF; inline;
    property RXFULLIE : TBits_1 read getRXFULLIE write setRXFULLIE;
    property RXFULLIF : TBits_1 read getRXFULLIF write setRXFULLIF;
    property RXHALFIE : TBits_1 read getRXHALFIE write setRXHALFIE;
    property RXHALFIF : TBits_1 read getRXHALFIF write setRXHALFIF;
    property RXNEMPTYIE : TBits_1 read getRXNEMPTYIE write setRXNEMPTYIE;
    property RXNEMPTYIF : TBits_1 read getRXNEMPTYIF write setRXNEMPTYIF;
    property RXOVFLIE : TBits_1 read getRXOVFLIE write setRXOVFLIE;
    property RXOVFLIF : TBits_1 read getRXOVFLIF write setRXOVFLIF;
    property TXEMPTYIE : TBits_1 read getTXEMPTYIE write setTXEMPTYIE;
    property TXEMPTYIF : TBits_1 read getTXEMPTYIF write setTXEMPTYIF;
    property TXHALFIE : TBits_1 read getTXHALFIE write setTXHALFIE;
    property TXHALFIF : TBits_1 read getTXHALFIF write setTXHALFIF;
    property TXNFULLIE : TBits_1 read getTXNFULLIE write setTXNFULLIE;
    property TXNFULLIF : TBits_1 read getTXNFULLIF write setTXNFULLIF;
    property w : TBits_32 read getw write setw;
  end;
  TCAN1_C1FIFOCI31 = record
  private
    function  getCFIFOCI : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setCFIFOCI(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CFIFOCI : TBits_5 read getCFIFOCI write setCFIFOCI;
    property w : TBits_32 read getw write setw;
  end;
type
  TCAN1Registers = record
    C1CONbits : TCAN1_C1CON;
    C1CON : longWord;
    C1CONCLR : longWord;
    C1CONSET : longWord;
    C1CONINV : longWord;
    C1CFGbits : TCAN1_C1CFG;
    C1CFG : longWord;
    C1CFGCLR : longWord;
    C1CFGSET : longWord;
    C1CFGINV : longWord;
    C1INTbits : TCAN1_C1INT;
    C1INT : longWord;
    C1INTCLR : longWord;
    C1INTSET : longWord;
    C1INTINV : longWord;
    C1VECbits : TCAN1_C1VEC;
    C1VEC : longWord;
    C1VECCLR : longWord;
    C1VECSET : longWord;
    C1VECINV : longWord;
    C1TRECbits : TCAN1_C1TREC;
    C1TREC : longWord;
    C1TRECCLR : longWord;
    C1TRECSET : longWord;
    C1TRECINV : longWord;
    C1FSTATbits : TCAN1_C1FSTAT;
    C1FSTAT : longWord;
    C1FSTATCLR : longWord;
    C1FSTATSET : longWord;
    C1FSTATINV : longWord;
    C1RXOVFbits : TCAN1_C1RXOVF;
    C1RXOVF : longWord;
    C1RXOVFCLR : longWord;
    C1RXOVFSET : longWord;
    C1RXOVFINV : longWord;
    C1TMRbits : TCAN1_C1TMR;
    C1TMR : longWord;
    C1TMRCLR : longWord;
    C1TMRSET : longWord;
    C1TMRINV : longWord;
    C1RXM0bits : TCAN1_C1RXM0;
    C1RXM0 : longWord;
    C1RXM0CLR : longWord;
    C1RXM0SET : longWord;
    C1RXM0INV : longWord;
    C1RXM1bits : TCAN1_C1RXM1;
    C1RXM1 : longWord;
    C1RXM1CLR : longWord;
    C1RXM1SET : longWord;
    C1RXM1INV : longWord;
    C1RXM2bits : TCAN1_C1RXM2;
    C1RXM2 : longWord;
    C1RXM2CLR : longWord;
    C1RXM2SET : longWord;
    C1RXM2INV : longWord;
    C1RXM3bits : TCAN1_C1RXM3;
    C1RXM3 : longWord;
    C1RXM3CLR : longWord;
    C1RXM3SET : longWord;
    C1RXM3INV : longWord;
    C1FLTCON0bits : TCAN1_C1FLTCON0;
    C1FLTCON0 : longWord;
    C1FLTCON0CLR : longWord;
    C1FLTCON0SET : longWord;
    C1FLTCON0INV : longWord;
    C1FLTCON1bits : TCAN1_C1FLTCON1;
    C1FLTCON1 : longWord;
    C1FLTCON1CLR : longWord;
    C1FLTCON1SET : longWord;
    C1FLTCON1INV : longWord;
    C1FLTCON2bits : TCAN1_C1FLTCON2;
    C1FLTCON2 : longWord;
    C1FLTCON2CLR : longWord;
    C1FLTCON2SET : longWord;
    C1FLTCON2INV : longWord;
    C1FLTCON3bits : TCAN1_C1FLTCON3;
    C1FLTCON3 : longWord;
    C1FLTCON3CLR : longWord;
    C1FLTCON3SET : longWord;
    C1FLTCON3INV : longWord;
    C1FLTCON4bits : TCAN1_C1FLTCON4;
    C1FLTCON4 : longWord;
    C1FLTCON4CLR : longWord;
    C1FLTCON4SET : longWord;
    C1FLTCON4INV : longWord;
    C1FLTCON5bits : TCAN1_C1FLTCON5;
    C1FLTCON5 : longWord;
    C1FLTCON5CLR : longWord;
    C1FLTCON5SET : longWord;
    C1FLTCON5INV : longWord;
    C1FLTCON6bits : TCAN1_C1FLTCON6;
    C1FLTCON6 : longWord;
    C1FLTCON6CLR : longWord;
    C1FLTCON6SET : longWord;
    C1FLTCON6INV : longWord;
    C1FLTCON7bits : TCAN1_C1FLTCON7;
    C1FLTCON7 : longWord;
    C1FLTCON7CLR : longWord;
    C1FLTCON7SET : longWord;
    C1FLTCON7INV : longWord;
    C1RXF0bits : TCAN1_C1RXF0;
    C1RXF0 : longWord;
    C1RXF0CLR : longWord;
    C1RXF0SET : longWord;
    C1RXF0INV : longWord;
    C1RXF1bits : TCAN1_C1RXF1;
    C1RXF1 : longWord;
    C1RXF1CLR : longWord;
    C1RXF1SET : longWord;
    C1RXF1INV : longWord;
    C1RXF2bits : TCAN1_C1RXF2;
    C1RXF2 : longWord;
    C1RXF2CLR : longWord;
    C1RXF2SET : longWord;
    C1RXF2INV : longWord;
    C1RXF3bits : TCAN1_C1RXF3;
    C1RXF3 : longWord;
    C1RXF3CLR : longWord;
    C1RXF3SET : longWord;
    C1RXF3INV : longWord;
    C1RXF4bits : TCAN1_C1RXF4;
    C1RXF4 : longWord;
    C1RXF4CLR : longWord;
    C1RXF4SET : longWord;
    C1RXF4INV : longWord;
    C1RXF5bits : TCAN1_C1RXF5;
    C1RXF5 : longWord;
    C1RXF5CLR : longWord;
    C1RXF5SET : longWord;
    C1RXF5INV : longWord;
    C1RXF6bits : TCAN1_C1RXF6;
    C1RXF6 : longWord;
    C1RXF6CLR : longWord;
    C1RXF6SET : longWord;
    C1RXF6INV : longWord;
    C1RXF7bits : TCAN1_C1RXF7;
    C1RXF7 : longWord;
    C1RXF7CLR : longWord;
    C1RXF7SET : longWord;
    C1RXF7INV : longWord;
    C1RXF8bits : TCAN1_C1RXF8;
    C1RXF8 : longWord;
    C1RXF8CLR : longWord;
    C1RXF8SET : longWord;
    C1RXF8INV : longWord;
    C1RXF9bits : TCAN1_C1RXF9;
    C1RXF9 : longWord;
    C1RXF9CLR : longWord;
    C1RXF9SET : longWord;
    C1RXF9INV : longWord;
    C1RXF10bits : TCAN1_C1RXF10;
    C1RXF10 : longWord;
    C1RXF10CLR : longWord;
    C1RXF10SET : longWord;
    C1RXF10INV : longWord;
    C1RXF11bits : TCAN1_C1RXF11;
    C1RXF11 : longWord;
    C1RXF11CLR : longWord;
    C1RXF11SET : longWord;
    C1RXF11INV : longWord;
    C1RXF12bits : TCAN1_C1RXF12;
    C1RXF12 : longWord;
    C1RXF12CLR : longWord;
    C1RXF12SET : longWord;
    C1RXF12INV : longWord;
    C1RXF13bits : TCAN1_C1RXF13;
    C1RXF13 : longWord;
    C1RXF13CLR : longWord;
    C1RXF13SET : longWord;
    C1RXF13INV : longWord;
    C1RXF14bits : TCAN1_C1RXF14;
    C1RXF14 : longWord;
    C1RXF14CLR : longWord;
    C1RXF14SET : longWord;
    C1RXF14INV : longWord;
    C1RXF15bits : TCAN1_C1RXF15;
    C1RXF15 : longWord;
    C1RXF15CLR : longWord;
    C1RXF15SET : longWord;
    C1RXF15INV : longWord;
    C1RXF16bits : TCAN1_C1RXF16;
    C1RXF16 : longWord;
    C1RXF16CLR : longWord;
    C1RXF16SET : longWord;
    C1RXF16INV : longWord;
    C1RXF17bits : TCAN1_C1RXF17;
    C1RXF17 : longWord;
    C1RXF17CLR : longWord;
    C1RXF17SET : longWord;
    C1RXF17INV : longWord;
    C1RXF18bits : TCAN1_C1RXF18;
    C1RXF18 : longWord;
    C1RXF18CLR : longWord;
    C1RXF18SET : longWord;
    C1RXF18INV : longWord;
    C1RXF19bits : TCAN1_C1RXF19;
    C1RXF19 : longWord;
    C1RXF19CLR : longWord;
    C1RXF19SET : longWord;
    C1RXF19INV : longWord;
    C1RXF20bits : TCAN1_C1RXF20;
    C1RXF20 : longWord;
    C1RXF20CLR : longWord;
    C1RXF20SET : longWord;
    C1RXF20INV : longWord;
    C1RXF21bits : TCAN1_C1RXF21;
    C1RXF21 : longWord;
    C1RXF21CLR : longWord;
    C1RXF21SET : longWord;
    C1RXF21INV : longWord;
    C1RXF22bits : TCAN1_C1RXF22;
    C1RXF22 : longWord;
    C1RXF22CLR : longWord;
    C1RXF22SET : longWord;
    C1RXF22INV : longWord;
    C1RXF23bits : TCAN1_C1RXF23;
    C1RXF23 : longWord;
    C1RXF23CLR : longWord;
    C1RXF23SET : longWord;
    C1RXF23INV : longWord;
    C1RXF24bits : TCAN1_C1RXF24;
    C1RXF24 : longWord;
    C1RXF24CLR : longWord;
    C1RXF24SET : longWord;
    C1RXF24INV : longWord;
    C1RXF25bits : TCAN1_C1RXF25;
    C1RXF25 : longWord;
    C1RXF25CLR : longWord;
    C1RXF25SET : longWord;
    C1RXF25INV : longWord;
    C1RXF26bits : TCAN1_C1RXF26;
    C1RXF26 : longWord;
    C1RXF26CLR : longWord;
    C1RXF26SET : longWord;
    C1RXF26INV : longWord;
    C1RXF27bits : TCAN1_C1RXF27;
    C1RXF27 : longWord;
    C1RXF27CLR : longWord;
    C1RXF27SET : longWord;
    C1RXF27INV : longWord;
    C1RXF28bits : TCAN1_C1RXF28;
    C1RXF28 : longWord;
    C1RXF28CLR : longWord;
    C1RXF28SET : longWord;
    C1RXF28INV : longWord;
    C1RXF29bits : TCAN1_C1RXF29;
    C1RXF29 : longWord;
    C1RXF29CLR : longWord;
    C1RXF29SET : longWord;
    C1RXF29INV : longWord;
    C1RXF30bits : TCAN1_C1RXF30;
    C1RXF30 : longWord;
    C1RXF30CLR : longWord;
    C1RXF30SET : longWord;
    C1RXF30INV : longWord;
    C1RXF31bits : TCAN1_C1RXF31;
    C1RXF31 : longWord;
    C1RXF31CLR : longWord;
    C1RXF31SET : longWord;
    C1RXF31INV : longWord;
    C1FIFOBA : longWord;
    C1FIFOBACLR : longWord;
    C1FIFOBASET : longWord;
    C1FIFOBAINV : longWord;
    C1FIFOCON0bits : TCAN1_C1FIFOCON0;
    C1FIFOCON0 : longWord;
    C1FIFOCON0CLR : longWord;
    C1FIFOCON0SET : longWord;
    C1FIFOCON0INV : longWord;
    C1FIFOINT0bits : TCAN1_C1FIFOINT0;
    C1FIFOINT0 : longWord;
    C1FIFOINT0CLR : longWord;
    C1FIFOINT0SET : longWord;
    C1FIFOINT0INV : longWord;
    C1FIFOUA0 : longWord;
    C1FIFOUA0CLR : longWord;
    C1FIFOUA0SET : longWord;
    C1FIFOUA0INV : longWord;
    C1FIFOCI0bits : TCAN1_C1FIFOCI0;
    C1FIFOCI0 : longWord;
    C1FIFOCI0CLR : longWord;
    C1FIFOCI0SET : longWord;
    C1FIFOCI0INV : longWord;
    C1FIFOCON1bits : TCAN1_C1FIFOCON1;
    C1FIFOCON1 : longWord;
    C1FIFOCON1CLR : longWord;
    C1FIFOCON1SET : longWord;
    C1FIFOCON1INV : longWord;
    C1FIFOINT1bits : TCAN1_C1FIFOINT1;
    C1FIFOINT1 : longWord;
    C1FIFOINT1CLR : longWord;
    C1FIFOINT1SET : longWord;
    C1FIFOINT1INV : longWord;
    C1FIFOUA1 : longWord;
    C1FIFOUA1CLR : longWord;
    C1FIFOUA1SET : longWord;
    C1FIFOUA1INV : longWord;
    C1FIFOCI1bits : TCAN1_C1FIFOCI1;
    C1FIFOCI1 : longWord;
    C1FIFOCI1CLR : longWord;
    C1FIFOCI1SET : longWord;
    C1FIFOCI1INV : longWord;
    C1FIFOCON2bits : TCAN1_C1FIFOCON2;
    C1FIFOCON2 : longWord;
    C1FIFOCON2CLR : longWord;
    C1FIFOCON2SET : longWord;
    C1FIFOCON2INV : longWord;
    C1FIFOINT2bits : TCAN1_C1FIFOINT2;
    C1FIFOINT2 : longWord;
    C1FIFOINT2CLR : longWord;
    C1FIFOINT2SET : longWord;
    C1FIFOINT2INV : longWord;
    C1FIFOUA2 : longWord;
    C1FIFOUA2CLR : longWord;
    C1FIFOUA2SET : longWord;
    C1FIFOUA2INV : longWord;
    C1FIFOCI2bits : TCAN1_C1FIFOCI2;
    C1FIFOCI2 : longWord;
    C1FIFOCI2CLR : longWord;
    C1FIFOCI2SET : longWord;
    C1FIFOCI2INV : longWord;
    C1FIFOCON3bits : TCAN1_C1FIFOCON3;
    C1FIFOCON3 : longWord;
    C1FIFOCON3CLR : longWord;
    C1FIFOCON3SET : longWord;
    C1FIFOCON3INV : longWord;
    C1FIFOINT3bits : TCAN1_C1FIFOINT3;
    C1FIFOINT3 : longWord;
    C1FIFOINT3CLR : longWord;
    C1FIFOINT3SET : longWord;
    C1FIFOINT3INV : longWord;
    C1FIFOUA3 : longWord;
    C1FIFOUA3CLR : longWord;
    C1FIFOUA3SET : longWord;
    C1FIFOUA3INV : longWord;
    C1FIFOCI3bits : TCAN1_C1FIFOCI3;
    C1FIFOCI3 : longWord;
    C1FIFOCI3CLR : longWord;
    C1FIFOCI3SET : longWord;
    C1FIFOCI3INV : longWord;
    C1FIFOCON4bits : TCAN1_C1FIFOCON4;
    C1FIFOCON4 : longWord;
    C1FIFOCON4CLR : longWord;
    C1FIFOCON4SET : longWord;
    C1FIFOCON4INV : longWord;
    C1FIFOINT4bits : TCAN1_C1FIFOINT4;
    C1FIFOINT4 : longWord;
    C1FIFOINT4CLR : longWord;
    C1FIFOINT4SET : longWord;
    C1FIFOINT4INV : longWord;
    C1FIFOUA4 : longWord;
    C1FIFOUA4CLR : longWord;
    C1FIFOUA4SET : longWord;
    C1FIFOUA4INV : longWord;
    C1FIFOCI4bits : TCAN1_C1FIFOCI4;
    C1FIFOCI4 : longWord;
    C1FIFOCI4CLR : longWord;
    C1FIFOCI4SET : longWord;
    C1FIFOCI4INV : longWord;
    C1FIFOCON5bits : TCAN1_C1FIFOCON5;
    C1FIFOCON5 : longWord;
    C1FIFOCON5CLR : longWord;
    C1FIFOCON5SET : longWord;
    C1FIFOCON5INV : longWord;
    C1FIFOINT5bits : TCAN1_C1FIFOINT5;
    C1FIFOINT5 : longWord;
    C1FIFOINT5CLR : longWord;
    C1FIFOINT5SET : longWord;
    C1FIFOINT5INV : longWord;
    C1FIFOUA5 : longWord;
    C1FIFOUA5CLR : longWord;
    C1FIFOUA5SET : longWord;
    C1FIFOUA5INV : longWord;
    C1FIFOCI5bits : TCAN1_C1FIFOCI5;
    C1FIFOCI5 : longWord;
    C1FIFOCI5CLR : longWord;
    C1FIFOCI5SET : longWord;
    C1FIFOCI5INV : longWord;
    C1FIFOCON6bits : TCAN1_C1FIFOCON6;
    C1FIFOCON6 : longWord;
    C1FIFOCON6CLR : longWord;
    C1FIFOCON6SET : longWord;
    C1FIFOCON6INV : longWord;
    C1FIFOINT6bits : TCAN1_C1FIFOINT6;
    C1FIFOINT6 : longWord;
    C1FIFOINT6CLR : longWord;
    C1FIFOINT6SET : longWord;
    C1FIFOINT6INV : longWord;
    C1FIFOUA6 : longWord;
    C1FIFOUA6CLR : longWord;
    C1FIFOUA6SET : longWord;
    C1FIFOUA6INV : longWord;
    C1FIFOCI6bits : TCAN1_C1FIFOCI6;
    C1FIFOCI6 : longWord;
    C1FIFOCI6CLR : longWord;
    C1FIFOCI6SET : longWord;
    C1FIFOCI6INV : longWord;
    C1FIFOCON7bits : TCAN1_C1FIFOCON7;
    C1FIFOCON7 : longWord;
    C1FIFOCON7CLR : longWord;
    C1FIFOCON7SET : longWord;
    C1FIFOCON7INV : longWord;
    C1FIFOINT7bits : TCAN1_C1FIFOINT7;
    C1FIFOINT7 : longWord;
    C1FIFOINT7CLR : longWord;
    C1FIFOINT7SET : longWord;
    C1FIFOINT7INV : longWord;
    C1FIFOUA7 : longWord;
    C1FIFOUA7CLR : longWord;
    C1FIFOUA7SET : longWord;
    C1FIFOUA7INV : longWord;
    C1FIFOCI7bits : TCAN1_C1FIFOCI7;
    C1FIFOCI7 : longWord;
    C1FIFOCI7CLR : longWord;
    C1FIFOCI7SET : longWord;
    C1FIFOCI7INV : longWord;
    C1FIFOCON8bits : TCAN1_C1FIFOCON8;
    C1FIFOCON8 : longWord;
    C1FIFOCON8CLR : longWord;
    C1FIFOCON8SET : longWord;
    C1FIFOCON8INV : longWord;
    C1FIFOINT8bits : TCAN1_C1FIFOINT8;
    C1FIFOINT8 : longWord;
    C1FIFOINT8CLR : longWord;
    C1FIFOINT8SET : longWord;
    C1FIFOINT8INV : longWord;
    C1FIFOUA8 : longWord;
    C1FIFOUA8CLR : longWord;
    C1FIFOUA8SET : longWord;
    C1FIFOUA8INV : longWord;
    C1FIFOCI8bits : TCAN1_C1FIFOCI8;
    C1FIFOCI8 : longWord;
    C1FIFOCI8CLR : longWord;
    C1FIFOCI8SET : longWord;
    C1FIFOCI8INV : longWord;
    C1FIFOCON9bits : TCAN1_C1FIFOCON9;
    C1FIFOCON9 : longWord;
    C1FIFOCON9CLR : longWord;
    C1FIFOCON9SET : longWord;
    C1FIFOCON9INV : longWord;
    C1FIFOINT9bits : TCAN1_C1FIFOINT9;
    C1FIFOINT9 : longWord;
    C1FIFOINT9CLR : longWord;
    C1FIFOINT9SET : longWord;
    C1FIFOINT9INV : longWord;
    C1FIFOUA9 : longWord;
    C1FIFOUA9CLR : longWord;
    C1FIFOUA9SET : longWord;
    C1FIFOUA9INV : longWord;
    C1FIFOCI9bits : TCAN1_C1FIFOCI9;
    C1FIFOCI9 : longWord;
    C1FIFOCI9CLR : longWord;
    C1FIFOCI9SET : longWord;
    C1FIFOCI9INV : longWord;
    C1FIFOCON10bits : TCAN1_C1FIFOCON10;
    C1FIFOCON10 : longWord;
    C1FIFOCON10CLR : longWord;
    C1FIFOCON10SET : longWord;
    C1FIFOCON10INV : longWord;
    C1FIFOINT10bits : TCAN1_C1FIFOINT10;
    C1FIFOINT10 : longWord;
    C1FIFOINT10CLR : longWord;
    C1FIFOINT10SET : longWord;
    C1FIFOINT10INV : longWord;
    C1FIFOUA10 : longWord;
    C1FIFOUA10CLR : longWord;
    C1FIFOUA10SET : longWord;
    C1FIFOUA10INV : longWord;
    C1FIFOCI10bits : TCAN1_C1FIFOCI10;
    C1FIFOCI10 : longWord;
    C1FIFOCI10CLR : longWord;
    C1FIFOCI10SET : longWord;
    C1FIFOCI10INV : longWord;
    C1FIFOCON11bits : TCAN1_C1FIFOCON11;
    C1FIFOCON11 : longWord;
    C1FIFOCON11CLR : longWord;
    C1FIFOCON11SET : longWord;
    C1FIFOCON11INV : longWord;
    C1FIFOINT11bits : TCAN1_C1FIFOINT11;
    C1FIFOINT11 : longWord;
    C1FIFOINT11CLR : longWord;
    C1FIFOINT11SET : longWord;
    C1FIFOINT11INV : longWord;
    C1FIFOUA11 : longWord;
    C1FIFOUA11CLR : longWord;
    C1FIFOUA11SET : longWord;
    C1FIFOUA11INV : longWord;
    C1FIFOCI11bits : TCAN1_C1FIFOCI11;
    C1FIFOCI11 : longWord;
    C1FIFOCI11CLR : longWord;
    C1FIFOCI11SET : longWord;
    C1FIFOCI11INV : longWord;
    C1FIFOCON12bits : TCAN1_C1FIFOCON12;
    C1FIFOCON12 : longWord;
    C1FIFOCON12CLR : longWord;
    C1FIFOCON12SET : longWord;
    C1FIFOCON12INV : longWord;
    C1FIFOINT12bits : TCAN1_C1FIFOINT12;
    C1FIFOINT12 : longWord;
    C1FIFOINT12CLR : longWord;
    C1FIFOINT12SET : longWord;
    C1FIFOINT12INV : longWord;
    C1FIFOUA12 : longWord;
    C1FIFOUA12CLR : longWord;
    C1FIFOUA12SET : longWord;
    C1FIFOUA12INV : longWord;
    C1FIFOCI12bits : TCAN1_C1FIFOCI12;
    C1FIFOCI12 : longWord;
    C1FIFOCI12CLR : longWord;
    C1FIFOCI12SET : longWord;
    C1FIFOCI12INV : longWord;
    C1FIFOCON13bits : TCAN1_C1FIFOCON13;
    C1FIFOCON13 : longWord;
    C1FIFOCON13CLR : longWord;
    C1FIFOCON13SET : longWord;
    C1FIFOCON13INV : longWord;
    C1FIFOINT13bits : TCAN1_C1FIFOINT13;
    C1FIFOINT13 : longWord;
    C1FIFOINT13CLR : longWord;
    C1FIFOINT13SET : longWord;
    C1FIFOINT13INV : longWord;
    C1FIFOUA13 : longWord;
    C1FIFOUA13CLR : longWord;
    C1FIFOUA13SET : longWord;
    C1FIFOUA13INV : longWord;
    C1FIFOCI13bits : TCAN1_C1FIFOCI13;
    C1FIFOCI13 : longWord;
    C1FIFOCI13CLR : longWord;
    C1FIFOCI13SET : longWord;
    C1FIFOCI13INV : longWord;
    C1FIFOCON14bits : TCAN1_C1FIFOCON14;
    C1FIFOCON14 : longWord;
    C1FIFOCON14CLR : longWord;
    C1FIFOCON14SET : longWord;
    C1FIFOCON14INV : longWord;
    C1FIFOINT14bits : TCAN1_C1FIFOINT14;
    C1FIFOINT14 : longWord;
    C1FIFOINT14CLR : longWord;
    C1FIFOINT14SET : longWord;
    C1FIFOINT14INV : longWord;
    C1FIFOUA14 : longWord;
    C1FIFOUA14CLR : longWord;
    C1FIFOUA14SET : longWord;
    C1FIFOUA14INV : longWord;
    C1FIFOCI14bits : TCAN1_C1FIFOCI14;
    C1FIFOCI14 : longWord;
    C1FIFOCI14CLR : longWord;
    C1FIFOCI14SET : longWord;
    C1FIFOCI14INV : longWord;
    C1FIFOCON15bits : TCAN1_C1FIFOCON15;
    C1FIFOCON15 : longWord;
    C1FIFOCON15CLR : longWord;
    C1FIFOCON15SET : longWord;
    C1FIFOCON15INV : longWord;
    C1FIFOINT15bits : TCAN1_C1FIFOINT15;
    C1FIFOINT15 : longWord;
    C1FIFOINT15CLR : longWord;
    C1FIFOINT15SET : longWord;
    C1FIFOINT15INV : longWord;
    C1FIFOUA15 : longWord;
    C1FIFOUA15CLR : longWord;
    C1FIFOUA15SET : longWord;
    C1FIFOUA15INV : longWord;
    C1FIFOCI15bits : TCAN1_C1FIFOCI15;
    C1FIFOCI15 : longWord;
    C1FIFOCI15CLR : longWord;
    C1FIFOCI15SET : longWord;
    C1FIFOCI15INV : longWord;
    C1FIFOCON16bits : TCAN1_C1FIFOCON16;
    C1FIFOCON16 : longWord;
    C1FIFOCON16CLR : longWord;
    C1FIFOCON16SET : longWord;
    C1FIFOCON16INV : longWord;
    C1FIFOINT16bits : TCAN1_C1FIFOINT16;
    C1FIFOINT16 : longWord;
    C1FIFOINT16CLR : longWord;
    C1FIFOINT16SET : longWord;
    C1FIFOINT16INV : longWord;
    C1FIFOUA16 : longWord;
    C1FIFOUA16CLR : longWord;
    C1FIFOUA16SET : longWord;
    C1FIFOUA16INV : longWord;
    C1FIFOCI16bits : TCAN1_C1FIFOCI16;
    C1FIFOCI16 : longWord;
    C1FIFOCI16CLR : longWord;
    C1FIFOCI16SET : longWord;
    C1FIFOCI16INV : longWord;
    C1FIFOCON17bits : TCAN1_C1FIFOCON17;
    C1FIFOCON17 : longWord;
    C1FIFOCON17CLR : longWord;
    C1FIFOCON17SET : longWord;
    C1FIFOCON17INV : longWord;
    C1FIFOINT17bits : TCAN1_C1FIFOINT17;
    C1FIFOINT17 : longWord;
    C1FIFOINT17CLR : longWord;
    C1FIFOINT17SET : longWord;
    C1FIFOINT17INV : longWord;
    C1FIFOUA17 : longWord;
    C1FIFOUA17CLR : longWord;
    C1FIFOUA17SET : longWord;
    C1FIFOUA17INV : longWord;
    C1FIFOCI17bits : TCAN1_C1FIFOCI17;
    C1FIFOCI17 : longWord;
    C1FIFOCI17CLR : longWord;
    C1FIFOCI17SET : longWord;
    C1FIFOCI17INV : longWord;
    C1FIFOCON18bits : TCAN1_C1FIFOCON18;
    C1FIFOCON18 : longWord;
    C1FIFOCON18CLR : longWord;
    C1FIFOCON18SET : longWord;
    C1FIFOCON18INV : longWord;
    C1FIFOINT18bits : TCAN1_C1FIFOINT18;
    C1FIFOINT18 : longWord;
    C1FIFOINT18CLR : longWord;
    C1FIFOINT18SET : longWord;
    C1FIFOINT18INV : longWord;
    C1FIFOUA18 : longWord;
    C1FIFOUA18CLR : longWord;
    C1FIFOUA18SET : longWord;
    C1FIFOUA18INV : longWord;
    C1FIFOCI18bits : TCAN1_C1FIFOCI18;
    C1FIFOCI18 : longWord;
    C1FIFOCI18CLR : longWord;
    C1FIFOCI18SET : longWord;
    C1FIFOCI18INV : longWord;
    C1FIFOCON19bits : TCAN1_C1FIFOCON19;
    C1FIFOCON19 : longWord;
    C1FIFOCON19CLR : longWord;
    C1FIFOCON19SET : longWord;
    C1FIFOCON19INV : longWord;
    C1FIFOINT19bits : TCAN1_C1FIFOINT19;
    C1FIFOINT19 : longWord;
    C1FIFOINT19CLR : longWord;
    C1FIFOINT19SET : longWord;
    C1FIFOINT19INV : longWord;
    C1FIFOUA19 : longWord;
    C1FIFOUA19CLR : longWord;
    C1FIFOUA19SET : longWord;
    C1FIFOUA19INV : longWord;
    C1FIFOCI19bits : TCAN1_C1FIFOCI19;
    C1FIFOCI19 : longWord;
    C1FIFOCI19CLR : longWord;
    C1FIFOCI19SET : longWord;
    C1FIFOCI19INV : longWord;
    C1FIFOCON20bits : TCAN1_C1FIFOCON20;
    C1FIFOCON20 : longWord;
    C1FIFOCON20CLR : longWord;
    C1FIFOCON20SET : longWord;
    C1FIFOCON20INV : longWord;
    C1FIFOINT20bits : TCAN1_C1FIFOINT20;
    C1FIFOINT20 : longWord;
    C1FIFOINT20CLR : longWord;
    C1FIFOINT20SET : longWord;
    C1FIFOINT20INV : longWord;
    C1FIFOUA20 : longWord;
    C1FIFOUA20CLR : longWord;
    C1FIFOUA20SET : longWord;
    C1FIFOUA20INV : longWord;
    C1FIFOCI20bits : TCAN1_C1FIFOCI20;
    C1FIFOCI20 : longWord;
    C1FIFOCI20CLR : longWord;
    C1FIFOCI20SET : longWord;
    C1FIFOCI20INV : longWord;
    C1FIFOCON21bits : TCAN1_C1FIFOCON21;
    C1FIFOCON21 : longWord;
    C1FIFOCON21CLR : longWord;
    C1FIFOCON21SET : longWord;
    C1FIFOCON21INV : longWord;
    C1FIFOINT21bits : TCAN1_C1FIFOINT21;
    C1FIFOINT21 : longWord;
    C1FIFOINT21CLR : longWord;
    C1FIFOINT21SET : longWord;
    C1FIFOINT21INV : longWord;
    C1FIFOUA21 : longWord;
    C1FIFOUA21CLR : longWord;
    C1FIFOUA21SET : longWord;
    C1FIFOUA21INV : longWord;
    C1FIFOCI21bits : TCAN1_C1FIFOCI21;
    C1FIFOCI21 : longWord;
    C1FIFOCI21CLR : longWord;
    C1FIFOCI21SET : longWord;
    C1FIFOCI21INV : longWord;
    C1FIFOCON22bits : TCAN1_C1FIFOCON22;
    C1FIFOCON22 : longWord;
    C1FIFOCON22CLR : longWord;
    C1FIFOCON22SET : longWord;
    C1FIFOCON22INV : longWord;
    C1FIFOINT22bits : TCAN1_C1FIFOINT22;
    C1FIFOINT22 : longWord;
    C1FIFOINT22CLR : longWord;
    C1FIFOINT22SET : longWord;
    C1FIFOINT22INV : longWord;
    C1FIFOUA22 : longWord;
    C1FIFOUA22CLR : longWord;
    C1FIFOUA22SET : longWord;
    C1FIFOUA22INV : longWord;
    C1FIFOCI22bits : TCAN1_C1FIFOCI22;
    C1FIFOCI22 : longWord;
    C1FIFOCI22CLR : longWord;
    C1FIFOCI22SET : longWord;
    C1FIFOCI22INV : longWord;
    C1FIFOCON23bits : TCAN1_C1FIFOCON23;
    C1FIFOCON23 : longWord;
    C1FIFOCON23CLR : longWord;
    C1FIFOCON23SET : longWord;
    C1FIFOCON23INV : longWord;
    C1FIFOINT23bits : TCAN1_C1FIFOINT23;
    C1FIFOINT23 : longWord;
    C1FIFOINT23CLR : longWord;
    C1FIFOINT23SET : longWord;
    C1FIFOINT23INV : longWord;
    C1FIFOUA23 : longWord;
    C1FIFOUA23CLR : longWord;
    C1FIFOUA23SET : longWord;
    C1FIFOUA23INV : longWord;
    C1FIFOCI23bits : TCAN1_C1FIFOCI23;
    C1FIFOCI23 : longWord;
    C1FIFOCI23CLR : longWord;
    C1FIFOCI23SET : longWord;
    C1FIFOCI23INV : longWord;
    C1FIFOCON24bits : TCAN1_C1FIFOCON24;
    C1FIFOCON24 : longWord;
    C1FIFOCON24CLR : longWord;
    C1FIFOCON24SET : longWord;
    C1FIFOCON24INV : longWord;
    C1FIFOINT24bits : TCAN1_C1FIFOINT24;
    C1FIFOINT24 : longWord;
    C1FIFOINT24CLR : longWord;
    C1FIFOINT24SET : longWord;
    C1FIFOINT24INV : longWord;
    C1FIFOUA24 : longWord;
    C1FIFOUA24CLR : longWord;
    C1FIFOUA24SET : longWord;
    C1FIFOUA24INV : longWord;
    C1FIFOCI24bits : TCAN1_C1FIFOCI24;
    C1FIFOCI24 : longWord;
    C1FIFOCI24CLR : longWord;
    C1FIFOCI24SET : longWord;
    C1FIFOCI24INV : longWord;
    C1FIFOCON25bits : TCAN1_C1FIFOCON25;
    C1FIFOCON25 : longWord;
    C1FIFOCON25CLR : longWord;
    C1FIFOCON25SET : longWord;
    C1FIFOCON25INV : longWord;
    C1FIFOINT25bits : TCAN1_C1FIFOINT25;
    C1FIFOINT25 : longWord;
    C1FIFOINT25CLR : longWord;
    C1FIFOINT25SET : longWord;
    C1FIFOINT25INV : longWord;
    C1FIFOUA25 : longWord;
    C1FIFOUA25CLR : longWord;
    C1FIFOUA25SET : longWord;
    C1FIFOUA25INV : longWord;
    C1FIFOCI25bits : TCAN1_C1FIFOCI25;
    C1FIFOCI25 : longWord;
    C1FIFOCI25CLR : longWord;
    C1FIFOCI25SET : longWord;
    C1FIFOCI25INV : longWord;
    C1FIFOCON26bits : TCAN1_C1FIFOCON26;
    C1FIFOCON26 : longWord;
    C1FIFOCON26CLR : longWord;
    C1FIFOCON26SET : longWord;
    C1FIFOCON26INV : longWord;
    C1FIFOINT26bits : TCAN1_C1FIFOINT26;
    C1FIFOINT26 : longWord;
    C1FIFOINT26CLR : longWord;
    C1FIFOINT26SET : longWord;
    C1FIFOINT26INV : longWord;
    C1FIFOUA26 : longWord;
    C1FIFOUA26CLR : longWord;
    C1FIFOUA26SET : longWord;
    C1FIFOUA26INV : longWord;
    C1FIFOCI26bits : TCAN1_C1FIFOCI26;
    C1FIFOCI26 : longWord;
    C1FIFOCI26CLR : longWord;
    C1FIFOCI26SET : longWord;
    C1FIFOCI26INV : longWord;
    C1FIFOCON27bits : TCAN1_C1FIFOCON27;
    C1FIFOCON27 : longWord;
    C1FIFOCON27CLR : longWord;
    C1FIFOCON27SET : longWord;
    C1FIFOCON27INV : longWord;
    C1FIFOINT27bits : TCAN1_C1FIFOINT27;
    C1FIFOINT27 : longWord;
    C1FIFOINT27CLR : longWord;
    C1FIFOINT27SET : longWord;
    C1FIFOINT27INV : longWord;
    C1FIFOUA27 : longWord;
    C1FIFOUA27CLR : longWord;
    C1FIFOUA27SET : longWord;
    C1FIFOUA27INV : longWord;
    C1FIFOCI27bits : TCAN1_C1FIFOCI27;
    C1FIFOCI27 : longWord;
    C1FIFOCI27CLR : longWord;
    C1FIFOCI27SET : longWord;
    C1FIFOCI27INV : longWord;
    C1FIFOCON28bits : TCAN1_C1FIFOCON28;
    C1FIFOCON28 : longWord;
    C1FIFOCON28CLR : longWord;
    C1FIFOCON28SET : longWord;
    C1FIFOCON28INV : longWord;
    C1FIFOINT28bits : TCAN1_C1FIFOINT28;
    C1FIFOINT28 : longWord;
    C1FIFOINT28CLR : longWord;
    C1FIFOINT28SET : longWord;
    C1FIFOINT28INV : longWord;
    C1FIFOUA28 : longWord;
    C1FIFOUA28CLR : longWord;
    C1FIFOUA28SET : longWord;
    C1FIFOUA28INV : longWord;
    C1FIFOCI28bits : TCAN1_C1FIFOCI28;
    C1FIFOCI28 : longWord;
    C1FIFOCI28CLR : longWord;
    C1FIFOCI28SET : longWord;
    C1FIFOCI28INV : longWord;
    C1FIFOCON29bits : TCAN1_C1FIFOCON29;
    C1FIFOCON29 : longWord;
    C1FIFOCON29CLR : longWord;
    C1FIFOCON29SET : longWord;
    C1FIFOCON29INV : longWord;
    C1FIFOINT29bits : TCAN1_C1FIFOINT29;
    C1FIFOINT29 : longWord;
    C1FIFOINT29CLR : longWord;
    C1FIFOINT29SET : longWord;
    C1FIFOINT29INV : longWord;
    C1FIFOUA29 : longWord;
    C1FIFOUA29CLR : longWord;
    C1FIFOUA29SET : longWord;
    C1FIFOUA29INV : longWord;
    C1FIFOCI29bits : TCAN1_C1FIFOCI29;
    C1FIFOCI29 : longWord;
    C1FIFOCI29CLR : longWord;
    C1FIFOCI29SET : longWord;
    C1FIFOCI29INV : longWord;
    C1FIFOCON30bits : TCAN1_C1FIFOCON30;
    C1FIFOCON30 : longWord;
    C1FIFOCON30CLR : longWord;
    C1FIFOCON30SET : longWord;
    C1FIFOCON30INV : longWord;
    C1FIFOINT30bits : TCAN1_C1FIFOINT30;
    C1FIFOINT30 : longWord;
    C1FIFOINT30CLR : longWord;
    C1FIFOINT30SET : longWord;
    C1FIFOINT30INV : longWord;
    C1FIFOUA30 : longWord;
    C1FIFOUA30CLR : longWord;
    C1FIFOUA30SET : longWord;
    C1FIFOUA30INV : longWord;
    C1FIFOCI30bits : TCAN1_C1FIFOCI30;
    C1FIFOCI30 : longWord;
    C1FIFOCI30CLR : longWord;
    C1FIFOCI30SET : longWord;
    C1FIFOCI30INV : longWord;
    C1FIFOCON31bits : TCAN1_C1FIFOCON31;
    C1FIFOCON31 : longWord;
    C1FIFOCON31CLR : longWord;
    C1FIFOCON31SET : longWord;
    C1FIFOCON31INV : longWord;
    C1FIFOINT31bits : TCAN1_C1FIFOINT31;
    C1FIFOINT31 : longWord;
    C1FIFOINT31CLR : longWord;
    C1FIFOINT31SET : longWord;
    C1FIFOINT31INV : longWord;
    C1FIFOUA31 : longWord;
    C1FIFOUA31CLR : longWord;
    C1FIFOUA31SET : longWord;
    C1FIFOUA31INV : longWord;
    C1FIFOCI31bits : TCAN1_C1FIFOCI31;
    C1FIFOCI31 : longWord;
    C1FIFOCI31CLR : longWord;
    C1FIFOCI31SET : longWord;
    C1FIFOCI31INV : longWord;
  end;
  TDEVCFG_DEVCFG3 = record
  private
    function  getFCANIO : TBits_1; inline;
    function  getFSRSSEL : TBits_3; inline;
    function  getFUSBIDIO : TBits_1; inline;
    function  getFVBUSONIO : TBits_1; inline;
    function  getUSERID : TBits_16; inline;
    function  getw : TBits_32; inline;
    procedure setFCANIO(thebits : TBits_1); inline;
    procedure setFSRSSEL(thebits : TBits_3); inline;
    procedure setFUSBIDIO(thebits : TBits_1); inline;
    procedure setFVBUSONIO(thebits : TBits_1); inline;
    procedure setUSERID(thebits : TBits_16); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFCANIO; inline;
    procedure clearFUSBIDIO; inline;
    procedure clearFVBUSONIO; inline;
    procedure setFCANIO; inline;
    procedure setFUSBIDIO; inline;
    procedure setFVBUSONIO; inline;
    property FCANIO : TBits_1 read getFCANIO write setFCANIO;
    property FSRSSEL : TBits_3 read getFSRSSEL write setFSRSSEL;
    property FUSBIDIO : TBits_1 read getFUSBIDIO write setFUSBIDIO;
    property FVBUSONIO : TBits_1 read getFVBUSONIO write setFVBUSONIO;
    property USERID : TBits_16 read getUSERID write setUSERID;
    property w : TBits_32 read getw write setw;
  end;
  TDEVCFG_DEVCFG2 = record
  private
    function  getFPLLIDIV : TBits_3; inline;
    function  getFPLLMUL : TBits_3; inline;
    function  getFPLLODIV : TBits_3; inline;
    function  getUPLLEN : TBits_1; inline;
    function  getUPLLIDIV : TBits_3; inline;
    function  getw : TBits_32; inline;
    procedure setFPLLIDIV(thebits : TBits_3); inline;
    procedure setFPLLMUL(thebits : TBits_3); inline;
    procedure setFPLLODIV(thebits : TBits_3); inline;
    procedure setUPLLEN(thebits : TBits_1); inline;
    procedure setUPLLIDIV(thebits : TBits_3); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearUPLLEN; inline;
    procedure setUPLLEN; inline;
    property FPLLIDIV : TBits_3 read getFPLLIDIV write setFPLLIDIV;
    property FPLLMUL : TBits_3 read getFPLLMUL write setFPLLMUL;
    property FPLLODIV : TBits_3 read getFPLLODIV write setFPLLODIV;
    property UPLLEN : TBits_1 read getUPLLEN write setUPLLEN;
    property UPLLIDIV : TBits_3 read getUPLLIDIV write setUPLLIDIV;
    property w : TBits_32 read getw write setw;
  end;
  TDEVCFG_DEVCFG1 = record
  private
    function  getFCKSM : TBits_2; inline;
    function  getFNOSC : TBits_3; inline;
    function  getFPBDIV : TBits_2; inline;
    function  getFSOSCEN : TBits_1; inline;
    function  getFWDTEN : TBits_1; inline;
    function  getIESO : TBits_1; inline;
    function  getOSCIOFNC : TBits_1; inline;
    function  getPOSCMOD : TBits_2; inline;
    function  getWDTPS : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setFCKSM(thebits : TBits_2); inline;
    procedure setFNOSC(thebits : TBits_3); inline;
    procedure setFPBDIV(thebits : TBits_2); inline;
    procedure setFSOSCEN(thebits : TBits_1); inline;
    procedure setFWDTEN(thebits : TBits_1); inline;
    procedure setIESO(thebits : TBits_1); inline;
    procedure setOSCIOFNC(thebits : TBits_1); inline;
    procedure setPOSCMOD(thebits : TBits_2); inline;
    procedure setWDTPS(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFSOSCEN; inline;
    procedure clearFWDTEN; inline;
    procedure clearIESO; inline;
    procedure clearOSCIOFNC; inline;
    procedure setFSOSCEN; inline;
    procedure setFWDTEN; inline;
    procedure setIESO; inline;
    procedure setOSCIOFNC; inline;
    property FCKSM : TBits_2 read getFCKSM write setFCKSM;
    property FNOSC : TBits_3 read getFNOSC write setFNOSC;
    property FPBDIV : TBits_2 read getFPBDIV write setFPBDIV;
    property FSOSCEN : TBits_1 read getFSOSCEN write setFSOSCEN;
    property FWDTEN : TBits_1 read getFWDTEN write setFWDTEN;
    property IESO : TBits_1 read getIESO write setIESO;
    property OSCIOFNC : TBits_1 read getOSCIOFNC write setOSCIOFNC;
    property POSCMOD : TBits_2 read getPOSCMOD write setPOSCMOD;
    property WDTPS : TBits_5 read getWDTPS write setWDTPS;
    property w : TBits_32 read getw write setw;
  end;
  TDEVCFG_DEVCFG0 = record
  private
    function  getBWP : TBits_1; inline;
    function  getCP : TBits_1; inline;
    function  getDEBUG : TBits_2; inline;
    function  getFDEBUG : TBits_2; inline;
    function  getICESEL : TBits_1; inline;
    function  getPWP : TBits_8; inline;
    function  getw : TBits_32; inline;
    procedure setBWP(thebits : TBits_1); inline;
    procedure setCP(thebits : TBits_1); inline;
    procedure setDEBUG(thebits : TBits_2); inline;
    procedure setFDEBUG(thebits : TBits_2); inline;
    procedure setICESEL(thebits : TBits_1); inline;
    procedure setPWP(thebits : TBits_8); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBWP; inline;
    procedure clearCP; inline;
    procedure clearICESEL; inline;
    procedure setBWP; inline;
    procedure setCP; inline;
    procedure setICESEL; inline;
    property BWP : TBits_1 read getBWP write setBWP;
    property CP : TBits_1 read getCP write setCP;
    property DEBUG : TBits_2 read getDEBUG write setDEBUG;
    property FDEBUG : TBits_2 read getFDEBUG write setFDEBUG;
    property ICESEL : TBits_1 read getICESEL write setICESEL;
    property PWP : TBits_8 read getPWP write setPWP;
    property w : TBits_32 read getw write setw;
  end;
const
  _CORE_TIMER_IRQ = 0;
  _CORE_SOFTWARE_0_IRQ = 1;
  _CORE_SOFTWARE_1_IRQ = 2;
  _EXTERNAL_0_IRQ = 3;
  _TIMER_1_IRQ = 4;
  _INPUT_CAPTURE_1_IRQ = 5;
  _OUTPUT_COMPARE_1_IRQ = 6;
  _EXTERNAL_1_IRQ = 7;
  _TIMER_2_IRQ = 8;
  _INPUT_CAPTURE_2_IRQ = 9;
  _OUTPUT_COMPARE_2_IRQ = 10;
  _EXTERNAL_2_IRQ = 11;
  _TIMER_3_IRQ = 12;
  _INPUT_CAPTURE_3_IRQ = 13;
  _OUTPUT_COMPARE_3_IRQ = 14;
  _EXTERNAL_3_IRQ = 15;
  _TIMER_4_IRQ = 16;
  _INPUT_CAPTURE_4_IRQ = 17;
  _OUTPUT_COMPARE_4_IRQ = 18;
  _EXTERNAL_4_IRQ = 19;
  _TIMER_5_IRQ = 20;
  _INPUT_CAPTURE_5_IRQ = 21;
  _OUTPUT_COMPARE_5_IRQ = 22;
  _I2C1A_ERR_IRQ = 26;
  _I2C3_BUS_IRQ = 26;
  _SPI1A_ERR_IRQ = 26;
  _SPI3_ERR_IRQ = 26;
  _UART1A_ERR_IRQ = 26;
  _UART1_ERR_IRQ = 26;
  _I2C1A_RX_IRQ = 27;
  _I2C3_SLAVE_IRQ = 27;
  _SPI1A_RX_IRQ = 27;
  _SPI3_RX_IRQ = 27;
  _UART1A_RX_IRQ = 27;
  _UART1_RX_IRQ = 27;
  _I2C1A_TX_IRQ = 28;
  _I2C3_MASTER_IRQ = 28;
  _SPI1A_TX_IRQ = 28;
  _SPI3_TX_IRQ = 28;
  _UART1A_TX_IRQ = 28;
  _UART1_TX_IRQ = 28;
  _I2C1_BUS_IRQ = 29;
  _I2C1_SLAVE_IRQ = 30;
  _I2C1_MASTER_IRQ = 31;
  _CHANGE_NOTICE_IRQ = 32;
  _ADC_IRQ = 33;
  _PMP_IRQ = 34;
  _COMPARATOR_1_IRQ = 35;
  _COMPARATOR_2_IRQ = 36;
  _I2C2A_ERR_IRQ = 37;
  _I2C4_BUS_IRQ = 37;
  _SPI2_ERR_IRQ = 37;
  _SPI2A_ERR_IRQ = 37;
  _UART2A_ERR_IRQ = 37;
  _UART3_ERR_IRQ = 37;
  _I2C2A_RX_IRQ = 38;
  _I2C4_SLAVE_IRQ = 38;
  _SPI2_RX_IRQ = 38;
  _SPI2A_RX_IRQ = 38;
  _UART2A_RX_IRQ = 38;
  _UART3_RX_IRQ = 38;
  _I2C2A_TX_IRQ = 39;
  _I2C4_MASTER_IRQ = 39;
  _SPI2A_TX_IRQ = 39;
  _SPI2_TX_IRQ = 39;
  _UART2A_TX_IRQ = 39;
  _UART3_TX_IRQ = 39;
  _I2C3A_ERR_IRQ = 40;
  _I2C5_BUS_IRQ = 40;
  _SPI3A_ERR_IRQ = 40;
  _SPI4_ERR_IRQ = 40;
  _UART2_ERR_IRQ = 40;
  _UART3A_ERR_IRQ = 40;
  _I2C3A_RX_IRQ = 41;
  _I2C5_SLAVE_IRQ = 41;
  _SPI3A_RX_IRQ = 41;
  _SPI4_RX_IRQ = 41;
  _UART2_RX_IRQ = 41;
  _UART3A_RX_IRQ = 41;
  _I2C3A_TX_IRQ = 42;
  _I2C5_MASTER_IRQ = 42;
  _SPI3A_TX_IRQ = 42;
  _SPI4_TX_IRQ = 42;
  _UART2_TX_IRQ = 42;
  _UART3A_TX_IRQ = 42;
  _FAIL_SAFE_MONITOR_IRQ = 46;
  _RTCC_IRQ = 47;
  _DMA0_IRQ = 48;
  _DMA1_IRQ = 49;
  _DMA2_IRQ = 50;
  _DMA3_IRQ = 51;
  _FLASH_CONTROL_IRQ = 56;
  _USB_IRQ = 57;
  _CAN1_IRQ = 58;
  _INPUT_CAPTURE_ERROR_1_IRQ = 61;
  _INPUT_CAPTURE_ERROR_2_IRQ = 62;
  _INPUT_CAPTURE_ERROR_3_IRQ = 63;
  _INPUT_CAPTURE_ERROR_4_IRQ = 64;
  _INPUT_CAPTURE_ERROR_5_IRQ = 65;
  _PMP_ERROR_IRQ = 66;
  _UART1B_ERR_IRQ = 67;
  _UART4_ERR_IRQ = 67;
  _UART1B_RX_IRQ = 68;
  _UART4_RX_IRQ = 68;
  _UART1B_TX_IRQ = 69;
  _UART4_TX_IRQ = 69;
  _UART2B_ERR_IRQ = 70;
  _UART6_ERR_IRQ = 70;
  _UART2B_RX_IRQ = 71;
  _UART6_RX_IRQ = 71;
  _UART2B_TX_IRQ = 72;
  _UART6_TX_IRQ = 72;
  _UART3B_ERR_IRQ = 73;
  _UART5_ERR_IRQ = 73;
  _UART3B_RX_IRQ = 74;
  _UART5_RX_IRQ = 74;
  _UART3B_TX_IRQ = 75;
  _UART5_TX_IRQ = 75;
const
  ADC10_BASE_ADDRESS = $BF809000;
var
  ADC10 : TADC10Registers absolute ADC10_BASE_ADDRESS;
const
  BMX_BASE_ADDRESS = $BF882000;
var
  BMX : TBMXRegisters absolute BMX_BASE_ADDRESS;
const
  CAN1_BASE_ADDRESS = $BF88B000;
var
  CAN1 : TCAN1Registers absolute CAN1_BASE_ADDRESS;
const
  CFG_BASE_ADDRESS = $BF80F200;
var
  CFG : TCFGRegisters absolute CFG_BASE_ADDRESS;
const
  CMP_BASE_ADDRESS = $BF80A000;
var
  CMP : TCMPRegisters absolute CMP_BASE_ADDRESS;
const
  CVR_BASE_ADDRESS = $BF809800;
var
  CVR : TCVRRegisters absolute CVR_BASE_ADDRESS;
const
  DMAC_BASE_ADDRESS = $BF883000;
var
  DMAC : TDMACRegisters absolute DMAC_BASE_ADDRESS;
const
  DMAC0_BASE_ADDRESS = $BF883060;
var
  DMAC0 : TDMAC0Registers absolute DMAC0_BASE_ADDRESS;
const
  DMAC1_BASE_ADDRESS = $BF883120;
var
  DMAC1 : TDMAC1Registers absolute DMAC1_BASE_ADDRESS;
const
  DMAC2_BASE_ADDRESS = $BF8831E0;
var
  DMAC2 : TDMAC2Registers absolute DMAC2_BASE_ADDRESS;
const
  DMAC3_BASE_ADDRESS = $BF8832A0;
var
  DMAC3 : TDMAC3Registers absolute DMAC3_BASE_ADDRESS;
const
  I2C1_BASE_ADDRESS = $BF805300;
var
  I2C1 : TI2C1Registers absolute I2C1_BASE_ADDRESS;
const
  I2C1A_BASE_ADDRESS = $BF805000;
var
  I2C1A : TI2C1ARegisters absolute I2C1A_BASE_ADDRESS;
const
  I2C2A_BASE_ADDRESS = $BF805100;
var
  I2C2A : TI2C2ARegisters absolute I2C2A_BASE_ADDRESS;
const
  I2C5_BASE_ADDRESS = $BF805200;
var
  I2C5 : TI2C5Registers absolute I2C5_BASE_ADDRESS;
const
  ICAP1_BASE_ADDRESS = $BF802000;
var
  ICAP1 : TICAP1Registers absolute ICAP1_BASE_ADDRESS;
const
  ICAP2_BASE_ADDRESS = $BF802200;
var
  ICAP2 : TICAP2Registers absolute ICAP2_BASE_ADDRESS;
const
  ICAP3_BASE_ADDRESS = $BF802400;
var
  ICAP3 : TICAP3Registers absolute ICAP3_BASE_ADDRESS;
const
  ICAP4_BASE_ADDRESS = $BF802600;
var
  ICAP4 : TICAP4Registers absolute ICAP4_BASE_ADDRESS;
const
  ICAP5_BASE_ADDRESS = $BF802800;
var
  ICAP5 : TICAP5Registers absolute ICAP5_BASE_ADDRESS;
const
  INT_BASE_ADDRESS = $BF881000;
var
  INT : TINTRegisters absolute INT_BASE_ADDRESS;
const
  NVM_BASE_ADDRESS = $BF80F400;
var
  NVM : TNVMRegisters absolute NVM_BASE_ADDRESS;
const
  OCMP1_BASE_ADDRESS = $BF803000;
var
  OCMP1 : TOCMP1Registers absolute OCMP1_BASE_ADDRESS;
const
  OCMP2_BASE_ADDRESS = $BF803200;
var
  OCMP2 : TOCMP2Registers absolute OCMP2_BASE_ADDRESS;
const
  OCMP3_BASE_ADDRESS = $BF803400;
var
  OCMP3 : TOCMP3Registers absolute OCMP3_BASE_ADDRESS;
const
  OCMP4_BASE_ADDRESS = $BF803600;
var
  OCMP4 : TOCMP4Registers absolute OCMP4_BASE_ADDRESS;
const
  OCMP5_BASE_ADDRESS = $BF803800;
var
  OCMP5 : TOCMP5Registers absolute OCMP5_BASE_ADDRESS;
const
  OSC_BASE_ADDRESS = $BF80F000;
var
  OSC : TOSCRegisters absolute OSC_BASE_ADDRESS;
const
  PCACHE_BASE_ADDRESS = $BF884000;
var
  PCACHE : TPCACHERegisters absolute PCACHE_BASE_ADDRESS;
const
  PMP_BASE_ADDRESS = $BF807000;
var
  PMP : TPMPRegisters absolute PMP_BASE_ADDRESS;
const
  PORTB_BASE_ADDRESS = $BF886040;
var
  PORTB : TPORTBRegisters absolute PORTB_BASE_ADDRESS;
const
  PORTC_BASE_ADDRESS = $BF886080;
var
  PORTC : TPORTCRegisters absolute PORTC_BASE_ADDRESS;
const
  PORTD_BASE_ADDRESS = $BF8860C0;
var
  PORTD : TPORTDRegisters absolute PORTD_BASE_ADDRESS;
const
  PORTE_BASE_ADDRESS = $BF886100;
var
  PORTE : TPORTERegisters absolute PORTE_BASE_ADDRESS;
const
  PORTF_BASE_ADDRESS = $BF886140;
var
  PORTF : TPORTFRegisters absolute PORTF_BASE_ADDRESS;
const
  PORTG_BASE_ADDRESS = $BF886180;
var
  PORTG : TPORTGRegisters absolute PORTG_BASE_ADDRESS;
const
  RCON_BASE_ADDRESS = $BF80F600;
var
  RCON : TRCONRegisters absolute RCON_BASE_ADDRESS;
const
  RTCC_BASE_ADDRESS = $BF800200;
var
  RTCC : TRTCCRegisters absolute RTCC_BASE_ADDRESS;
const
  SPI2A_BASE_ADDRESS = $BF805A00;
var
  SPI2A : TSPI2ARegisters absolute SPI2A_BASE_ADDRESS;
const
  SPI3_BASE_ADDRESS = $BF805800;
var
  SPI3 : TSPI3Registers absolute SPI3_BASE_ADDRESS;
const
  SPI3A_BASE_ADDRESS = $BF805C00;
var
  SPI3A : TSPI3ARegisters absolute SPI3A_BASE_ADDRESS;
const
  TMR1_BASE_ADDRESS = $BF800600;
var
  TMR1 : TTMR1Registers absolute TMR1_BASE_ADDRESS;
const
  TMR2_BASE_ADDRESS = $BF800800;
var
  TMR2 : TTMR2Registers absolute TMR2_BASE_ADDRESS;
const
  TMR3_BASE_ADDRESS = $BF800A00;
var
  TMR3 : TTMR3Registers absolute TMR3_BASE_ADDRESS;
const
  TMR4_BASE_ADDRESS = $BF800C00;
var
  TMR4 : TTMR4Registers absolute TMR4_BASE_ADDRESS;
const
  TMR5_BASE_ADDRESS = $BF800E00;
var
  TMR5 : TTMR5Registers absolute TMR5_BASE_ADDRESS;
const
  UART1A_BASE_ADDRESS = $BF806000;
var
  UART1A : TUART1ARegisters absolute UART1A_BASE_ADDRESS;
const
  UART2_BASE_ADDRESS = $BF806800;
var
  UART2 : TUART2Registers absolute UART2_BASE_ADDRESS;
const
  UART2A_BASE_ADDRESS = $BF806400;
var
  UART2A : TUART2ARegisters absolute UART2A_BASE_ADDRESS;
const
  UART4_BASE_ADDRESS = $BF806200;
var
  UART4 : TUART4Registers absolute UART4_BASE_ADDRESS;
const
  UART5_BASE_ADDRESS = $BF806A00;
var
  UART5 : TUART5Registers absolute UART5_BASE_ADDRESS;
const
  UART6_BASE_ADDRESS = $BF806600;
var
  UART6 : TUART6Registers absolute UART6_BASE_ADDRESS;
const
  USB_BASE_ADDRESS = $BF885040;
var
  USB : TUSBRegisters absolute USB_BASE_ADDRESS;
const
  WDT_BASE_ADDRESS = $BF800000;
var
  WDT : TWDTRegisters absolute WDT_BASE_ADDRESS;
const
  _APPI_BASE_ADDRESS = $BF880190;
var
  _APPI : T_APPIRegisters absolute _APPI_BASE_ADDRESS;
const
  _APPO_BASE_ADDRESS = $BF880180;
var
  _APPO : T_APPORegisters absolute _APPO_BASE_ADDRESS;
const
  _DDPSTAT_BASE_ADDRESS = $BF880140;
var
  _DDPSTAT : T_DDPSTATRegisters absolute _DDPSTAT_BASE_ADDRESS;
const
  _STRO_BASE_ADDRESS = $BF880170;
var
  _STRO : T_STRORegisters absolute _STRO_BASE_ADDRESS;
implementation
type
  TDefRegMap = record
    val : longWord;
    clr : longWord;
    &set : longWord;
    inv : longWord;
  end;

  pTDefRegMap = ^TDefRegMap;

procedure TWDT_WDTCON.setWDTCLR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TWDT_WDTCON.clearWDTCLR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TWDT_WDTCON.setWDTCLR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TWDT_WDTCON.getWDTCLR : TBits_1; inline;
begin
  getWDTCLR := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TWDT_WDTCON.setSWDTPS(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF83 or ( thebits shl 2 );
end;
function  TWDT_WDTCON.getSWDTPS : TBits_5; inline;
begin
  getSWDTPS := (pTDefRegMap(@Self)^.val and $0000007C) shr 2;
end;
procedure TWDT_WDTCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TWDT_WDTCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TWDT_WDTCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TWDT_WDTCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TWDT_WDTCON.setSWDTPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TWDT_WDTCON.clearSWDTPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TWDT_WDTCON.setSWDTPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TWDT_WDTCON.getSWDTPS0 : TBits_1; inline;
begin
  getSWDTPS0 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TWDT_WDTCON.setSWDTPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TWDT_WDTCON.clearSWDTPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TWDT_WDTCON.setSWDTPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TWDT_WDTCON.getSWDTPS1 : TBits_1; inline;
begin
  getSWDTPS1 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TWDT_WDTCON.setSWDTPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TWDT_WDTCON.clearSWDTPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TWDT_WDTCON.setSWDTPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TWDT_WDTCON.getSWDTPS2 : TBits_1; inline;
begin
  getSWDTPS2 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TWDT_WDTCON.setSWDTPS3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TWDT_WDTCON.clearSWDTPS3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TWDT_WDTCON.setSWDTPS3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TWDT_WDTCON.getSWDTPS3 : TBits_1; inline;
begin
  getSWDTPS3 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TWDT_WDTCON.setSWDTPS4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TWDT_WDTCON.clearSWDTPS4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TWDT_WDTCON.setSWDTPS4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TWDT_WDTCON.getSWDTPS4 : TBits_1; inline;
begin
  getSWDTPS4 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TWDT_WDTCON.setWDTPSTA(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF83 or ( thebits shl 2 );
end;
function  TWDT_WDTCON.getWDTPSTA : TBits_5; inline;
begin
  getWDTPSTA := (pTDefRegMap(@Self)^.val and $0000007C) shr 2;
end;
procedure TWDT_WDTCON.setWDTPS(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF83 or ( thebits shl 2 );
end;
function  TWDT_WDTCON.getWDTPS : TBits_5; inline;
begin
  getWDTPS := (pTDefRegMap(@Self)^.val and $0000007C) shr 2;
end;
procedure TWDT_WDTCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TWDT_WDTCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_RTCCON.setRTCOE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TRTCC_RTCCON.clearRTCOE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TRTCC_RTCCON.setRTCOE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TRTCC_RTCCON.getRTCOE : TBits_1; inline;
begin
  getRTCOE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TRTCC_RTCCON.setHALFSEC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TRTCC_RTCCON.clearHALFSEC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TRTCC_RTCCON.setHALFSEC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TRTCC_RTCCON.getHALFSEC : TBits_1; inline;
begin
  getHALFSEC := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TRTCC_RTCCON.setRTCSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TRTCC_RTCCON.clearRTCSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TRTCC_RTCCON.setRTCSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TRTCC_RTCCON.getRTCSYNC : TBits_1; inline;
begin
  getRTCSYNC := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TRTCC_RTCCON.setRTCWREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TRTCC_RTCCON.clearRTCWREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TRTCC_RTCCON.setRTCWREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TRTCC_RTCCON.getRTCWREN : TBits_1; inline;
begin
  getRTCWREN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TRTCC_RTCCON.setRTCCLKON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TRTCC_RTCCON.clearRTCCLKON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TRTCC_RTCCON.setRTCCLKON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TRTCC_RTCCON.getRTCCLKON : TBits_1; inline;
begin
  getRTCCLKON := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TRTCC_RTCCON.setRTSECSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TRTCC_RTCCON.clearRTSECSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TRTCC_RTCCON.setRTSECSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TRTCC_RTCCON.getRTSECSEL : TBits_1; inline;
begin
  getRTSECSEL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TRTCC_RTCCON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TRTCC_RTCCON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TRTCC_RTCCON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TRTCC_RTCCON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TRTCC_RTCCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TRTCC_RTCCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TRTCC_RTCCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TRTCC_RTCCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TRTCC_RTCCON.setCAL(thebits : TBits_10); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FC00FFFF or ( thebits shl 16 );
end;
function  TRTCC_RTCCON.getCAL : TBits_10; inline;
begin
  getCAL := (pTDefRegMap(@Self)^.val and $03FF0000) shr 16;
end;
procedure TRTCC_RTCCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_RTCCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_RTCALRM.setARPT(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF00 or ( thebits shl 0 );
end;
function  TRTCC_RTCALRM.getARPT : TBits_8; inline;
begin
  getARPT := (pTDefRegMap(@Self)^.val and $000000FF) shr 0;
end;
procedure TRTCC_RTCALRM.setAMASK(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_RTCALRM.getAMASK : TBits_4; inline;
begin
  getAMASK := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_RTCALRM.setALRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TRTCC_RTCALRM.clearALRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TRTCC_RTCALRM.setALRMSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TRTCC_RTCALRM.getALRMSYNC : TBits_1; inline;
begin
  getALRMSYNC := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TRTCC_RTCALRM.setPIV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TRTCC_RTCALRM.clearPIV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TRTCC_RTCALRM.setPIV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TRTCC_RTCALRM.getPIV : TBits_1; inline;
begin
  getPIV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TRTCC_RTCALRM.setCHIME; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TRTCC_RTCALRM.clearCHIME; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TRTCC_RTCALRM.setCHIME(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TRTCC_RTCALRM.getCHIME : TBits_1; inline;
begin
  getCHIME := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TRTCC_RTCALRM.setALRMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TRTCC_RTCALRM.clearALRMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TRTCC_RTCALRM.setALRMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TRTCC_RTCALRM.getALRMEN : TBits_1; inline;
begin
  getALRMEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TRTCC_RTCALRM.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_RTCALRM.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_RTCTIME.setSEC01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_RTCTIME.getSEC01 : TBits_4; inline;
begin
  getSEC01 := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_RTCTIME.setSEC10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0FFF or ( thebits shl 12 );
end;
function  TRTCC_RTCTIME.getSEC10 : TBits_4; inline;
begin
  getSEC10 := (pTDefRegMap(@Self)^.val and $0000F000) shr 12;
end;
procedure TRTCC_RTCTIME.setMIN01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TRTCC_RTCTIME.getMIN01 : TBits_4; inline;
begin
  getMIN01 := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TRTCC_RTCTIME.setMIN10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF0FFFFF or ( thebits shl 20 );
end;
function  TRTCC_RTCTIME.getMIN10 : TBits_4; inline;
begin
  getMIN10 := (pTDefRegMap(@Self)^.val and $00F00000) shr 20;
end;
procedure TRTCC_RTCTIME.setHR01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F0FFFFFF or ( thebits shl 24 );
end;
function  TRTCC_RTCTIME.getHR01 : TBits_4; inline;
begin
  getHR01 := (pTDefRegMap(@Self)^.val and $0F000000) shr 24;
end;
procedure TRTCC_RTCTIME.setHR10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $0FFFFFFF or ( thebits shl 28 );
end;
function  TRTCC_RTCTIME.getHR10 : TBits_4; inline;
begin
  getHR10 := (pTDefRegMap(@Self)^.val and $F0000000) shr 28;
end;
procedure TRTCC_RTCTIME.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_RTCTIME.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_RTCDATE.setWDAY01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TRTCC_RTCDATE.getWDAY01 : TBits_4; inline;
begin
  getWDAY01 := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TRTCC_RTCDATE.setDAY01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_RTCDATE.getDAY01 : TBits_4; inline;
begin
  getDAY01 := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_RTCDATE.setDAY10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0FFF or ( thebits shl 12 );
end;
function  TRTCC_RTCDATE.getDAY10 : TBits_4; inline;
begin
  getDAY10 := (pTDefRegMap(@Self)^.val and $0000F000) shr 12;
end;
procedure TRTCC_RTCDATE.setMONTH01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TRTCC_RTCDATE.getMONTH01 : TBits_4; inline;
begin
  getMONTH01 := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TRTCC_RTCDATE.setMONTH10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF0FFFFF or ( thebits shl 20 );
end;
function  TRTCC_RTCDATE.getMONTH10 : TBits_4; inline;
begin
  getMONTH10 := (pTDefRegMap(@Self)^.val and $00F00000) shr 20;
end;
procedure TRTCC_RTCDATE.setYEAR01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F0FFFFFF or ( thebits shl 24 );
end;
function  TRTCC_RTCDATE.getYEAR01 : TBits_4; inline;
begin
  getYEAR01 := (pTDefRegMap(@Self)^.val and $0F000000) shr 24;
end;
procedure TRTCC_RTCDATE.setYEAR10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $0FFFFFFF or ( thebits shl 28 );
end;
function  TRTCC_RTCDATE.getYEAR10 : TBits_4; inline;
begin
  getYEAR10 := (pTDefRegMap(@Self)^.val and $F0000000) shr 28;
end;
procedure TRTCC_RTCDATE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_RTCDATE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_ALRMTIME.setSEC01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_ALRMTIME.getSEC01 : TBits_4; inline;
begin
  getSEC01 := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_ALRMTIME.setSEC10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0FFF or ( thebits shl 12 );
end;
function  TRTCC_ALRMTIME.getSEC10 : TBits_4; inline;
begin
  getSEC10 := (pTDefRegMap(@Self)^.val and $0000F000) shr 12;
end;
procedure TRTCC_ALRMTIME.setMIN01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TRTCC_ALRMTIME.getMIN01 : TBits_4; inline;
begin
  getMIN01 := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TRTCC_ALRMTIME.setMIN10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF0FFFFF or ( thebits shl 20 );
end;
function  TRTCC_ALRMTIME.getMIN10 : TBits_4; inline;
begin
  getMIN10 := (pTDefRegMap(@Self)^.val and $00F00000) shr 20;
end;
procedure TRTCC_ALRMTIME.setHR01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F0FFFFFF or ( thebits shl 24 );
end;
function  TRTCC_ALRMTIME.getHR01 : TBits_4; inline;
begin
  getHR01 := (pTDefRegMap(@Self)^.val and $0F000000) shr 24;
end;
procedure TRTCC_ALRMTIME.setHR10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $0FFFFFFF or ( thebits shl 28 );
end;
function  TRTCC_ALRMTIME.getHR10 : TBits_4; inline;
begin
  getHR10 := (pTDefRegMap(@Self)^.val and $F0000000) shr 28;
end;
procedure TRTCC_ALRMTIME.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_ALRMTIME.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_ALRMDATE.setWDAY01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TRTCC_ALRMDATE.getWDAY01 : TBits_4; inline;
begin
  getWDAY01 := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TRTCC_ALRMDATE.setDAY01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_ALRMDATE.getDAY01 : TBits_4; inline;
begin
  getDAY01 := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_ALRMDATE.setDAY10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0FFF or ( thebits shl 12 );
end;
function  TRTCC_ALRMDATE.getDAY10 : TBits_4; inline;
begin
  getDAY10 := (pTDefRegMap(@Self)^.val and $0000F000) shr 12;
end;
procedure TRTCC_ALRMDATE.setMONTH01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TRTCC_ALRMDATE.getMONTH01 : TBits_4; inline;
begin
  getMONTH01 := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TRTCC_ALRMDATE.setMONTH10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF0FFFFF or ( thebits shl 20 );
end;
function  TRTCC_ALRMDATE.getMONTH10 : TBits_4; inline;
begin
  getMONTH10 := (pTDefRegMap(@Self)^.val and $00F00000) shr 20;
end;
procedure TRTCC_ALRMDATE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_ALRMDATE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR1_T1CON.setTCS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TTMR1_T1CON.clearTCS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TTMR1_T1CON.setTCS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TTMR1_T1CON.getTCS : TBits_1; inline;
begin
  getTCS := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TTMR1_T1CON.setTSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TTMR1_T1CON.clearTSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TTMR1_T1CON.setTSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TTMR1_T1CON.getTSYNC : TBits_1; inline;
begin
  getTSYNC := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TTMR1_T1CON.setTCKPS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFCF or ( thebits shl 4 );
end;
function  TTMR1_T1CON.getTCKPS : TBits_2; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000030) shr 4;
end;
procedure TTMR1_T1CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR1_T1CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR1_T1CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR1_T1CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR1_T1CON.setTWIP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TTMR1_T1CON.clearTWIP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TTMR1_T1CON.setTWIP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TTMR1_T1CON.getTWIP : TBits_1; inline;
begin
  getTWIP := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TTMR1_T1CON.setTWDIS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TTMR1_T1CON.clearTWDIS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TTMR1_T1CON.setTWDIS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TTMR1_T1CON.getTWDIS : TBits_1; inline;
begin
  getTWDIS := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TTMR1_T1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR1_T1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR1_T1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR1_T1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR1_T1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR1_T1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR1_T1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR1_T1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR1_T1CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR1_T1CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR1_T1CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR1_T1CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR1_T1CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR1_T1CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR1_T1CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR1_T1CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR1_T1CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR1_T1CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR1_T1CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR1_T1CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR1_T1CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR1_T1CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR1_T1CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR1_T1CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR1_T1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR1_T1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR2_T2CON.setT32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TTMR2_T2CON.clearT32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TTMR2_T2CON.setT32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TTMR2_T2CON.getT32 : TBits_1; inline;
begin
  getT32 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TTMR2_T2CON.setTCKPS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TTMR2_T2CON.getTCKPS : TBits_3; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TTMR2_T2CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR2_T2CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR2_T2CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR2_T2CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR2_T2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR2_T2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR2_T2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR2_T2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR2_T2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR2_T2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR2_T2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR2_T2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR2_T2CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR2_T2CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR2_T2CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR2_T2CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR2_T2CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR2_T2CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR2_T2CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR2_T2CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR2_T2CON.setTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TTMR2_T2CON.clearTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TTMR2_T2CON.setTCKPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TTMR2_T2CON.getTCKPS2 : TBits_1; inline;
begin
  getTCKPS2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TTMR2_T2CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR2_T2CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR2_T2CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR2_T2CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR2_T2CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR2_T2CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR2_T2CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR2_T2CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR2_T2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR2_T2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR3_T3CON.setTCKPS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TTMR3_T3CON.getTCKPS : TBits_3; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TTMR3_T3CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR3_T3CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR3_T3CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR3_T3CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR3_T3CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR3_T3CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR3_T3CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR3_T3CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR3_T3CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR3_T3CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR3_T3CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR3_T3CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR3_T3CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR3_T3CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR3_T3CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR3_T3CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR3_T3CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR3_T3CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR3_T3CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR3_T3CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR3_T3CON.setTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TTMR3_T3CON.clearTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TTMR3_T3CON.setTCKPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TTMR3_T3CON.getTCKPS2 : TBits_1; inline;
begin
  getTCKPS2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TTMR3_T3CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR3_T3CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR3_T3CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR3_T3CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR3_T3CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR3_T3CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR3_T3CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR3_T3CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR3_T3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR3_T3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR4_T4CON.setT32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TTMR4_T4CON.clearT32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TTMR4_T4CON.setT32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TTMR4_T4CON.getT32 : TBits_1; inline;
begin
  getT32 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TTMR4_T4CON.setTCKPS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TTMR4_T4CON.getTCKPS : TBits_3; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TTMR4_T4CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR4_T4CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR4_T4CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR4_T4CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR4_T4CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR4_T4CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR4_T4CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR4_T4CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR4_T4CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR4_T4CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR4_T4CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR4_T4CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR4_T4CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR4_T4CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR4_T4CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR4_T4CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR4_T4CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR4_T4CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR4_T4CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR4_T4CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR4_T4CON.setTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TTMR4_T4CON.clearTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TTMR4_T4CON.setTCKPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TTMR4_T4CON.getTCKPS2 : TBits_1; inline;
begin
  getTCKPS2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TTMR4_T4CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR4_T4CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR4_T4CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR4_T4CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR4_T4CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR4_T4CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR4_T4CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR4_T4CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR4_T4CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR4_T4CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR5_T5CON.setTCKPS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TTMR5_T5CON.getTCKPS : TBits_3; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TTMR5_T5CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR5_T5CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR5_T5CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR5_T5CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR5_T5CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR5_T5CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR5_T5CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR5_T5CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR5_T5CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR5_T5CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR5_T5CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR5_T5CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR5_T5CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR5_T5CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR5_T5CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR5_T5CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR5_T5CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR5_T5CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR5_T5CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR5_T5CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR5_T5CON.setTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TTMR5_T5CON.clearTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TTMR5_T5CON.setTCKPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TTMR5_T5CON.getTCKPS2 : TBits_1; inline;
begin
  getTCKPS2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TTMR5_T5CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR5_T5CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR5_T5CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR5_T5CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR5_T5CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR5_T5CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR5_T5CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR5_T5CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR5_T5CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR5_T5CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP1_IC1CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP1_IC1CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP1_IC1CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP1_IC1CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP1_IC1CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP1_IC1CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP1_IC1CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP1_IC1CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP1_IC1CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP1_IC1CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP1_IC1CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP1_IC1CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP1_IC1CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP1_IC1CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP1_IC1CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP1_IC1CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP1_IC1CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP1_IC1CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP1_IC1CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP1_IC1CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP1_IC1CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP1_IC1CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP1_IC1CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP1_IC1CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP1_IC1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP1_IC1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP1_IC1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP1_IC1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP1_IC1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP1_IC1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP1_IC1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP1_IC1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP1_IC1CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP1_IC1CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP1_IC1CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP1_IC1CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP1_IC1CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP1_IC1CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP1_IC1CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP1_IC1CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP1_IC1CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP1_IC1CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP1_IC1CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP1_IC1CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP1_IC1CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP1_IC1CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP1_IC1CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP1_IC1CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP1_IC1CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP1_IC1CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP1_IC1CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP1_IC1CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP1_IC1CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP1_IC1CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP1_IC1CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP1_IC1CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP1_IC1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP1_IC1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP2_IC2CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP2_IC2CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP2_IC2CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP2_IC2CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP2_IC2CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP2_IC2CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP2_IC2CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP2_IC2CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP2_IC2CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP2_IC2CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP2_IC2CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP2_IC2CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP2_IC2CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP2_IC2CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP2_IC2CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP2_IC2CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP2_IC2CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP2_IC2CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP2_IC2CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP2_IC2CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP2_IC2CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP2_IC2CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP2_IC2CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP2_IC2CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP2_IC2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP2_IC2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP2_IC2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP2_IC2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP2_IC2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP2_IC2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP2_IC2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP2_IC2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP2_IC2CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP2_IC2CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP2_IC2CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP2_IC2CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP2_IC2CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP2_IC2CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP2_IC2CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP2_IC2CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP2_IC2CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP2_IC2CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP2_IC2CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP2_IC2CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP2_IC2CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP2_IC2CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP2_IC2CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP2_IC2CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP2_IC2CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP2_IC2CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP2_IC2CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP2_IC2CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP2_IC2CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP2_IC2CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP2_IC2CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP2_IC2CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP2_IC2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP2_IC2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP3_IC3CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP3_IC3CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP3_IC3CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP3_IC3CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP3_IC3CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP3_IC3CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP3_IC3CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP3_IC3CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP3_IC3CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP3_IC3CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP3_IC3CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP3_IC3CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP3_IC3CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP3_IC3CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP3_IC3CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP3_IC3CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP3_IC3CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP3_IC3CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP3_IC3CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP3_IC3CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP3_IC3CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP3_IC3CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP3_IC3CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP3_IC3CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP3_IC3CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP3_IC3CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP3_IC3CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP3_IC3CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP3_IC3CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP3_IC3CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP3_IC3CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP3_IC3CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP3_IC3CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP3_IC3CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP3_IC3CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP3_IC3CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP3_IC3CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP3_IC3CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP3_IC3CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP3_IC3CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP3_IC3CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP3_IC3CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP3_IC3CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP3_IC3CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP3_IC3CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP3_IC3CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP3_IC3CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP3_IC3CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP3_IC3CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP3_IC3CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP3_IC3CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP3_IC3CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP3_IC3CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP3_IC3CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP3_IC3CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP3_IC3CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP3_IC3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP3_IC3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP4_IC4CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP4_IC4CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP4_IC4CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP4_IC4CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP4_IC4CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP4_IC4CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP4_IC4CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP4_IC4CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP4_IC4CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP4_IC4CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP4_IC4CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP4_IC4CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP4_IC4CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP4_IC4CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP4_IC4CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP4_IC4CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP4_IC4CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP4_IC4CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP4_IC4CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP4_IC4CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP4_IC4CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP4_IC4CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP4_IC4CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP4_IC4CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP4_IC4CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP4_IC4CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP4_IC4CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP4_IC4CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP4_IC4CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP4_IC4CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP4_IC4CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP4_IC4CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP4_IC4CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP4_IC4CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP4_IC4CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP4_IC4CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP4_IC4CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP4_IC4CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP4_IC4CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP4_IC4CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP4_IC4CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP4_IC4CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP4_IC4CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP4_IC4CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP4_IC4CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP4_IC4CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP4_IC4CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP4_IC4CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP4_IC4CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP4_IC4CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP4_IC4CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP4_IC4CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP4_IC4CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP4_IC4CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP4_IC4CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP4_IC4CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP4_IC4CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP4_IC4CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP5_IC5CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP5_IC5CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP5_IC5CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP5_IC5CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP5_IC5CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP5_IC5CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP5_IC5CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP5_IC5CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP5_IC5CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP5_IC5CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP5_IC5CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP5_IC5CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP5_IC5CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP5_IC5CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP5_IC5CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP5_IC5CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP5_IC5CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP5_IC5CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP5_IC5CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP5_IC5CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP5_IC5CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP5_IC5CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP5_IC5CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP5_IC5CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP5_IC5CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP5_IC5CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP5_IC5CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP5_IC5CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP5_IC5CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP5_IC5CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP5_IC5CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP5_IC5CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP5_IC5CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP5_IC5CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP5_IC5CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP5_IC5CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP5_IC5CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP5_IC5CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP5_IC5CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP5_IC5CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP5_IC5CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP5_IC5CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP5_IC5CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP5_IC5CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP5_IC5CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP5_IC5CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP5_IC5CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP5_IC5CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP5_IC5CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP5_IC5CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP5_IC5CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP5_IC5CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP5_IC5CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP5_IC5CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP5_IC5CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP5_IC5CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP5_IC5CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP5_IC5CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP1_OC1CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP1_OC1CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP1_OC1CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP1_OC1CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP1_OC1CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP1_OC1CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP1_OC1CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP1_OC1CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP1_OC1CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP1_OC1CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP1_OC1CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP1_OC1CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP1_OC1CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP1_OC1CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP1_OC1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP1_OC1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP1_OC1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP1_OC1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP1_OC1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP1_OC1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP1_OC1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP1_OC1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP1_OC1CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP1_OC1CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP1_OC1CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP1_OC1CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP1_OC1CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP1_OC1CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP1_OC1CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP1_OC1CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP1_OC1CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP1_OC1CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP1_OC1CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP1_OC1CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP1_OC1CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP1_OC1CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP1_OC1CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP1_OC1CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP1_OC1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP1_OC1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP2_OC2CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP2_OC2CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP2_OC2CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP2_OC2CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP2_OC2CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP2_OC2CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP2_OC2CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP2_OC2CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP2_OC2CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP2_OC2CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP2_OC2CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP2_OC2CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP2_OC2CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP2_OC2CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP2_OC2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP2_OC2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP2_OC2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP2_OC2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP2_OC2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP2_OC2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP2_OC2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP2_OC2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP2_OC2CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP2_OC2CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP2_OC2CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP2_OC2CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP2_OC2CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP2_OC2CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP2_OC2CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP2_OC2CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP2_OC2CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP2_OC2CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP2_OC2CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP2_OC2CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP2_OC2CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP2_OC2CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP2_OC2CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP2_OC2CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP2_OC2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP2_OC2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP3_OC3CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP3_OC3CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP3_OC3CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP3_OC3CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP3_OC3CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP3_OC3CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP3_OC3CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP3_OC3CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP3_OC3CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP3_OC3CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP3_OC3CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP3_OC3CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP3_OC3CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP3_OC3CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP3_OC3CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP3_OC3CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP3_OC3CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP3_OC3CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP3_OC3CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP3_OC3CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP3_OC3CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP3_OC3CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP3_OC3CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP3_OC3CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP3_OC3CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP3_OC3CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP3_OC3CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP3_OC3CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP3_OC3CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP3_OC3CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP3_OC3CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP3_OC3CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP3_OC3CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP3_OC3CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP3_OC3CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP3_OC3CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP3_OC3CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP3_OC3CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP3_OC3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP3_OC3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP4_OC4CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP4_OC4CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP4_OC4CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP4_OC4CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP4_OC4CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP4_OC4CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP4_OC4CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP4_OC4CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP4_OC4CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP4_OC4CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP4_OC4CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP4_OC4CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP4_OC4CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP4_OC4CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP4_OC4CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP4_OC4CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP4_OC4CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP4_OC4CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP4_OC4CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP4_OC4CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP4_OC4CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP4_OC4CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP4_OC4CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP4_OC4CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP4_OC4CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP4_OC4CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP4_OC4CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP4_OC4CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP4_OC4CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP4_OC4CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP4_OC4CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP4_OC4CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP4_OC4CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP4_OC4CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP4_OC4CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP4_OC4CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP4_OC4CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP4_OC4CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP4_OC4CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP4_OC4CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP5_OC5CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP5_OC5CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP5_OC5CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP5_OC5CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP5_OC5CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP5_OC5CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP5_OC5CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP5_OC5CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP5_OC5CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP5_OC5CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP5_OC5CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP5_OC5CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP5_OC5CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP5_OC5CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP5_OC5CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP5_OC5CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP5_OC5CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP5_OC5CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP5_OC5CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP5_OC5CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP5_OC5CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP5_OC5CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP5_OC5CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP5_OC5CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP5_OC5CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP5_OC5CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP5_OC5CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP5_OC5CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP5_OC5CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP5_OC5CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP5_OC5CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP5_OC5CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP5_OC5CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP5_OC5CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP5_OC5CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP5_OC5CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP5_OC5CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP5_OC5CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP5_OC5CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP5_OC5CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1A_I2C1ACON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1A_I2C1ACON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1A_I2C1ACON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1A_I2C1ACON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1A_I2C1ACON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1A_I2C1ACON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1A_I2C1ACON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1A_I2C1ACON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1A_I2C1ACON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1A_I2C1ACON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1A_I2C1ACON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1A_I2C1ACON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1A_I2C1ACON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1A_I2C1ACON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1A_I2C1ACON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1A_I2C1ACON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1A_I2C1ACON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1A_I2C1ACON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1A_I2C1ACON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1A_I2C1ACON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1A_I2C1ACON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1A_I2C1ACON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1A_I2C1ACON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1A_I2C1ACON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1A_I2C1ACON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1A_I2C1ACON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1A_I2C1ACON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1A_I2C1ACON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1A_I2C1ACON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1A_I2C1ACON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1A_I2C1ACON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1A_I2C1ACON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1A_I2C1ACON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1A_I2C1ACON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1A_I2C1ACON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1A_I2C1ACON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1A_I2C1ACON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1A_I2C1ACON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1A_I2C1ACON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1A_I2C1ACON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1A_I2C1ACON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1A_I2C1ACON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1A_I2C1ACON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1A_I2C1ACON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1A_I2C1ACON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1A_I2C1ACON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1A_I2C1ACON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1A_I2C1ACON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1A_I2C1ACON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C1A_I2C1ACON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C1A_I2C1ACON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C1A_I2C1ACON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C1A_I2C1ACON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1A_I2C1ACON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1A_I2C1ACON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1A_I2C1ACON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1A_I2C1ACON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1A_I2C1ACON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1A_I2C1ACON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1A_I2C1ACON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1A_I2C1ACON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1A_I2C1ACON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1A_I2C1ACON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1A_I2C1ACON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1A_I2C1ACON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1A_I2C1ACON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1A_I2C1ACON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1A_I2C1ACON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1A_I2C1ACON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1A_I2C1ACON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1A_I2C1ACON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1A_I2C1ACON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1A_I2C1ACON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1A_I2C1ACON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1A_I2C3CON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1A_I2C3CON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1A_I2C3CON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1A_I2C3CON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1A_I2C3CON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1A_I2C3CON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1A_I2C3CON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1A_I2C3CON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1A_I2C3CON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1A_I2C3CON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1A_I2C3CON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1A_I2C3CON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1A_I2C3CON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1A_I2C3CON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1A_I2C3CON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1A_I2C3CON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1A_I2C3CON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1A_I2C3CON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1A_I2C3CON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1A_I2C3CON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1A_I2C3CON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1A_I2C3CON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1A_I2C3CON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1A_I2C3CON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1A_I2C3CON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1A_I2C3CON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1A_I2C3CON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1A_I2C3CON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1A_I2C3CON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1A_I2C3CON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1A_I2C3CON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1A_I2C3CON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1A_I2C3CON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1A_I2C3CON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1A_I2C3CON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1A_I2C3CON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1A_I2C3CON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1A_I2C3CON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1A_I2C3CON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1A_I2C3CON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1A_I2C3CON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1A_I2C3CON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1A_I2C3CON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1A_I2C3CON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1A_I2C3CON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1A_I2C3CON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1A_I2C3CON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1A_I2C3CON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1A_I2C3CON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C1A_I2C3CON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C1A_I2C3CON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C1A_I2C3CON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C1A_I2C3CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1A_I2C3CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1A_I2C3CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1A_I2C3CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1A_I2C3CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1A_I2C3CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1A_I2C3CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1A_I2C3CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1A_I2C3CON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1A_I2C3CON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1A_I2C3CON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1A_I2C3CON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1A_I2C3CON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1A_I2C3CON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1A_I2C3CON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1A_I2C3CON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1A_I2C3CON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1A_I2C3CON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1A_I2C3CON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1A_I2C3CON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1A_I2C3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1A_I2C3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1A_I2C1ASTAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1A_I2C1ASTAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1A_I2C1ASTAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1A_I2C1ASTAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1A_I2C1ASTAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1A_I2C1ASTAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1A_I2C1ASTAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1A_I2C1ASTAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1A_I2C1ASTAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1A_I2C1ASTAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1A_I2C1ASTAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1A_I2C1ASTAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1A_I2C1ASTAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1A_I2C1ASTAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1A_I2C1ASTAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1A_I2C1ASTAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1A_I2C1ASTAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1A_I2C1ASTAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1A_I2C1ASTAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1A_I2C1ASTAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1A_I2C1ASTAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1A_I2C1ASTAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1A_I2C1ASTAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1A_I2C1ASTAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1A_I2C1ASTAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1A_I2C1ASTAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1A_I2C1ASTAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1A_I2C1ASTAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1A_I2C1ASTAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1A_I2C1ASTAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1A_I2C1ASTAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1A_I2C1ASTAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1A_I2C1ASTAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1A_I2C1ASTAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1A_I2C1ASTAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1A_I2C1ASTAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1A_I2C1ASTAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1A_I2C1ASTAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1A_I2C1ASTAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1A_I2C1ASTAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1A_I2C1ASTAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1A_I2C1ASTAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1A_I2C1ASTAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1A_I2C1ASTAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1A_I2C1ASTAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C1A_I2C1ASTAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C1A_I2C1ASTAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C1A_I2C1ASTAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C1A_I2C1ASTAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1A_I2C1ASTAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1A_I2C1ASTAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1A_I2C1ASTAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1A_I2C1ASTAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1A_I2C1ASTAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1A_I2C1ASTAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1A_I2C1ASTAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1A_I2C1ASTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1A_I2C1ASTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1A_I2C3STAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1A_I2C3STAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1A_I2C3STAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1A_I2C3STAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1A_I2C3STAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1A_I2C3STAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1A_I2C3STAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1A_I2C3STAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1A_I2C3STAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1A_I2C3STAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1A_I2C3STAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1A_I2C3STAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1A_I2C3STAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1A_I2C3STAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1A_I2C3STAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1A_I2C3STAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1A_I2C3STAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1A_I2C3STAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1A_I2C3STAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1A_I2C3STAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1A_I2C3STAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1A_I2C3STAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1A_I2C3STAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1A_I2C3STAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1A_I2C3STAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1A_I2C3STAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1A_I2C3STAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1A_I2C3STAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1A_I2C3STAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1A_I2C3STAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1A_I2C3STAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1A_I2C3STAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1A_I2C3STAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1A_I2C3STAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1A_I2C3STAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1A_I2C3STAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1A_I2C3STAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1A_I2C3STAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1A_I2C3STAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1A_I2C3STAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1A_I2C3STAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1A_I2C3STAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1A_I2C3STAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1A_I2C3STAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1A_I2C3STAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C1A_I2C3STAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C1A_I2C3STAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C1A_I2C3STAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C1A_I2C3STAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1A_I2C3STAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1A_I2C3STAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1A_I2C3STAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1A_I2C3STAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1A_I2C3STAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1A_I2C3STAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1A_I2C3STAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1A_I2C3STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1A_I2C3STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C2A_I2C2ACON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C2A_I2C2ACON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C2A_I2C2ACON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C2A_I2C2ACON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C2A_I2C2ACON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C2A_I2C2ACON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C2A_I2C2ACON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C2A_I2C2ACON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C2A_I2C2ACON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C2A_I2C2ACON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C2A_I2C2ACON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C2A_I2C2ACON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C2A_I2C2ACON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C2A_I2C2ACON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C2A_I2C2ACON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C2A_I2C2ACON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C2A_I2C2ACON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C2A_I2C2ACON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C2A_I2C2ACON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C2A_I2C2ACON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C2A_I2C2ACON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C2A_I2C2ACON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C2A_I2C2ACON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C2A_I2C2ACON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C2A_I2C2ACON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2A_I2C2ACON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2A_I2C2ACON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2A_I2C2ACON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2A_I2C2ACON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C2A_I2C2ACON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C2A_I2C2ACON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C2A_I2C2ACON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C2A_I2C2ACON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C2A_I2C2ACON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C2A_I2C2ACON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C2A_I2C2ACON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C2A_I2C2ACON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C2A_I2C2ACON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C2A_I2C2ACON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C2A_I2C2ACON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C2A_I2C2ACON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C2A_I2C2ACON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C2A_I2C2ACON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C2A_I2C2ACON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C2A_I2C2ACON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C2A_I2C2ACON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C2A_I2C2ACON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C2A_I2C2ACON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C2A_I2C2ACON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C2A_I2C2ACON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C2A_I2C2ACON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C2A_I2C2ACON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C2A_I2C2ACON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C2A_I2C2ACON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C2A_I2C2ACON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C2A_I2C2ACON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C2A_I2C2ACON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2A_I2C2ACON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2A_I2C2ACON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2A_I2C2ACON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2A_I2C2ACON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C2A_I2C2ACON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C2A_I2C2ACON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C2A_I2C2ACON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C2A_I2C2ACON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C2A_I2C2ACON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C2A_I2C2ACON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C2A_I2C2ACON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C2A_I2C2ACON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2A_I2C2ACON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2A_I2C2ACON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2A_I2C2ACON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2A_I2C2ACON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C2A_I2C2ACON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C2A_I2C4CON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C2A_I2C4CON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C2A_I2C4CON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C2A_I2C4CON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C2A_I2C4CON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C2A_I2C4CON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C2A_I2C4CON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C2A_I2C4CON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C2A_I2C4CON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C2A_I2C4CON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C2A_I2C4CON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C2A_I2C4CON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C2A_I2C4CON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C2A_I2C4CON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C2A_I2C4CON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C2A_I2C4CON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C2A_I2C4CON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C2A_I2C4CON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C2A_I2C4CON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C2A_I2C4CON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C2A_I2C4CON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C2A_I2C4CON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C2A_I2C4CON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C2A_I2C4CON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C2A_I2C4CON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2A_I2C4CON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2A_I2C4CON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2A_I2C4CON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2A_I2C4CON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C2A_I2C4CON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C2A_I2C4CON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C2A_I2C4CON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C2A_I2C4CON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C2A_I2C4CON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C2A_I2C4CON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C2A_I2C4CON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C2A_I2C4CON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C2A_I2C4CON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C2A_I2C4CON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C2A_I2C4CON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C2A_I2C4CON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C2A_I2C4CON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C2A_I2C4CON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C2A_I2C4CON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C2A_I2C4CON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C2A_I2C4CON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C2A_I2C4CON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C2A_I2C4CON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C2A_I2C4CON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C2A_I2C4CON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C2A_I2C4CON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C2A_I2C4CON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C2A_I2C4CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C2A_I2C4CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C2A_I2C4CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C2A_I2C4CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C2A_I2C4CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2A_I2C4CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2A_I2C4CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2A_I2C4CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2A_I2C4CON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C2A_I2C4CON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C2A_I2C4CON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C2A_I2C4CON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C2A_I2C4CON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C2A_I2C4CON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C2A_I2C4CON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C2A_I2C4CON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C2A_I2C4CON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2A_I2C4CON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2A_I2C4CON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2A_I2C4CON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2A_I2C4CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C2A_I2C4CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C2A_I2C2ASTAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C2A_I2C2ASTAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C2A_I2C2ASTAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C2A_I2C2ASTAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C2A_I2C2ASTAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C2A_I2C2ASTAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C2A_I2C2ASTAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C2A_I2C2ASTAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C2A_I2C2ASTAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C2A_I2C2ASTAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C2A_I2C2ASTAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C2A_I2C2ASTAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C2A_I2C2ASTAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C2A_I2C2ASTAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C2A_I2C2ASTAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C2A_I2C2ASTAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C2A_I2C2ASTAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C2A_I2C2ASTAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C2A_I2C2ASTAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C2A_I2C2ASTAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C2A_I2C2ASTAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C2A_I2C2ASTAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C2A_I2C2ASTAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C2A_I2C2ASTAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C2A_I2C2ASTAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2A_I2C2ASTAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2A_I2C2ASTAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2A_I2C2ASTAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2A_I2C2ASTAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C2A_I2C2ASTAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C2A_I2C2ASTAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C2A_I2C2ASTAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C2A_I2C2ASTAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C2A_I2C2ASTAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C2A_I2C2ASTAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C2A_I2C2ASTAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C2A_I2C2ASTAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C2A_I2C2ASTAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C2A_I2C2ASTAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C2A_I2C2ASTAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C2A_I2C2ASTAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C2A_I2C2ASTAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C2A_I2C2ASTAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C2A_I2C2ASTAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C2A_I2C2ASTAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C2A_I2C2ASTAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C2A_I2C2ASTAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C2A_I2C2ASTAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C2A_I2C2ASTAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2A_I2C2ASTAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2A_I2C2ASTAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2A_I2C2ASTAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2A_I2C2ASTAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2A_I2C2ASTAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2A_I2C2ASTAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2A_I2C2ASTAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2A_I2C2ASTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C2A_I2C2ASTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C2A_I2C4STAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C2A_I2C4STAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C2A_I2C4STAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C2A_I2C4STAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C2A_I2C4STAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C2A_I2C4STAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C2A_I2C4STAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C2A_I2C4STAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C2A_I2C4STAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C2A_I2C4STAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C2A_I2C4STAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C2A_I2C4STAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C2A_I2C4STAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C2A_I2C4STAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C2A_I2C4STAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C2A_I2C4STAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C2A_I2C4STAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C2A_I2C4STAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C2A_I2C4STAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C2A_I2C4STAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C2A_I2C4STAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C2A_I2C4STAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C2A_I2C4STAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C2A_I2C4STAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C2A_I2C4STAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2A_I2C4STAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2A_I2C4STAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2A_I2C4STAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2A_I2C4STAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C2A_I2C4STAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C2A_I2C4STAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C2A_I2C4STAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C2A_I2C4STAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C2A_I2C4STAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C2A_I2C4STAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C2A_I2C4STAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C2A_I2C4STAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C2A_I2C4STAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C2A_I2C4STAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C2A_I2C4STAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C2A_I2C4STAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C2A_I2C4STAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C2A_I2C4STAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C2A_I2C4STAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C2A_I2C4STAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C2A_I2C4STAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C2A_I2C4STAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C2A_I2C4STAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C2A_I2C4STAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2A_I2C4STAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2A_I2C4STAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2A_I2C4STAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2A_I2C4STAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2A_I2C4STAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2A_I2C4STAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2A_I2C4STAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2A_I2C4STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C2A_I2C4STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C5_I2C3ACON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C5_I2C3ACON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C5_I2C3ACON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C5_I2C3ACON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C5_I2C3ACON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C5_I2C3ACON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C5_I2C3ACON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C5_I2C3ACON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C5_I2C3ACON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C5_I2C3ACON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C5_I2C3ACON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C5_I2C3ACON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C5_I2C3ACON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C5_I2C3ACON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C5_I2C3ACON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C5_I2C3ACON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C5_I2C3ACON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C5_I2C3ACON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C5_I2C3ACON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C5_I2C3ACON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C5_I2C3ACON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C5_I2C3ACON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C5_I2C3ACON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C5_I2C3ACON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C5_I2C3ACON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C5_I2C3ACON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C5_I2C3ACON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C5_I2C3ACON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C5_I2C3ACON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C5_I2C3ACON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C5_I2C3ACON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C5_I2C3ACON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C5_I2C3ACON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C5_I2C3ACON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C5_I2C3ACON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C5_I2C3ACON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C5_I2C3ACON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C5_I2C3ACON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C5_I2C3ACON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C5_I2C3ACON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C5_I2C3ACON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C5_I2C3ACON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C5_I2C3ACON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C5_I2C3ACON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C5_I2C3ACON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C5_I2C3ACON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C5_I2C3ACON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C5_I2C3ACON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C5_I2C3ACON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C5_I2C3ACON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C5_I2C3ACON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C5_I2C3ACON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C5_I2C3ACON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C5_I2C3ACON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C5_I2C3ACON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C5_I2C3ACON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C5_I2C3ACON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C5_I2C3ACON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C5_I2C3ACON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C5_I2C3ACON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C5_I2C3ACON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C5_I2C3ACON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C5_I2C3ACON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C5_I2C3ACON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C5_I2C3ACON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C5_I2C3ACON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C5_I2C3ACON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C5_I2C3ACON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C5_I2C3ACON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C5_I2C3ACON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C5_I2C3ACON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C5_I2C3ACON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C5_I2C3ACON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C5_I2C3ACON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C5_I2C5CON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C5_I2C5CON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C5_I2C5CON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C5_I2C5CON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C5_I2C5CON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C5_I2C5CON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C5_I2C5CON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C5_I2C5CON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C5_I2C5CON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C5_I2C5CON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C5_I2C5CON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C5_I2C5CON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C5_I2C5CON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C5_I2C5CON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C5_I2C5CON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C5_I2C5CON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C5_I2C5CON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C5_I2C5CON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C5_I2C5CON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C5_I2C5CON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C5_I2C5CON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C5_I2C5CON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C5_I2C5CON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C5_I2C5CON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C5_I2C5CON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C5_I2C5CON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C5_I2C5CON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C5_I2C5CON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C5_I2C5CON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C5_I2C5CON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C5_I2C5CON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C5_I2C5CON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C5_I2C5CON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C5_I2C5CON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C5_I2C5CON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C5_I2C5CON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C5_I2C5CON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C5_I2C5CON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C5_I2C5CON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C5_I2C5CON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C5_I2C5CON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C5_I2C5CON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C5_I2C5CON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C5_I2C5CON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C5_I2C5CON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C5_I2C5CON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C5_I2C5CON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C5_I2C5CON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C5_I2C5CON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C5_I2C5CON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C5_I2C5CON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C5_I2C5CON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C5_I2C5CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C5_I2C5CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C5_I2C5CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C5_I2C5CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C5_I2C5CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C5_I2C5CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C5_I2C5CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C5_I2C5CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C5_I2C5CON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C5_I2C5CON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C5_I2C5CON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C5_I2C5CON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C5_I2C5CON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C5_I2C5CON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C5_I2C5CON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C5_I2C5CON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C5_I2C5CON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C5_I2C5CON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C5_I2C5CON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C5_I2C5CON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C5_I2C5CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C5_I2C5CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C5_I2C3ASTAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C5_I2C3ASTAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C5_I2C3ASTAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C5_I2C3ASTAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C5_I2C3ASTAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C5_I2C3ASTAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C5_I2C3ASTAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C5_I2C3ASTAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C5_I2C3ASTAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C5_I2C3ASTAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C5_I2C3ASTAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C5_I2C3ASTAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C5_I2C3ASTAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C5_I2C3ASTAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C5_I2C3ASTAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C5_I2C3ASTAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C5_I2C3ASTAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C5_I2C3ASTAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C5_I2C3ASTAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C5_I2C3ASTAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C5_I2C3ASTAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C5_I2C3ASTAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C5_I2C3ASTAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C5_I2C3ASTAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C5_I2C3ASTAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C5_I2C3ASTAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C5_I2C3ASTAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C5_I2C3ASTAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C5_I2C3ASTAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C5_I2C3ASTAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C5_I2C3ASTAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C5_I2C3ASTAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C5_I2C3ASTAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C5_I2C3ASTAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C5_I2C3ASTAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C5_I2C3ASTAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C5_I2C3ASTAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C5_I2C3ASTAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C5_I2C3ASTAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C5_I2C3ASTAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C5_I2C3ASTAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C5_I2C3ASTAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C5_I2C3ASTAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C5_I2C3ASTAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C5_I2C3ASTAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C5_I2C3ASTAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C5_I2C3ASTAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C5_I2C3ASTAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C5_I2C3ASTAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C5_I2C3ASTAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C5_I2C3ASTAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C5_I2C3ASTAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C5_I2C3ASTAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C5_I2C3ASTAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C5_I2C3ASTAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C5_I2C3ASTAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C5_I2C3ASTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C5_I2C3ASTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C5_I2C5STAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C5_I2C5STAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C5_I2C5STAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C5_I2C5STAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C5_I2C5STAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C5_I2C5STAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C5_I2C5STAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C5_I2C5STAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C5_I2C5STAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C5_I2C5STAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C5_I2C5STAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C5_I2C5STAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C5_I2C5STAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C5_I2C5STAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C5_I2C5STAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C5_I2C5STAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C5_I2C5STAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C5_I2C5STAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C5_I2C5STAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C5_I2C5STAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C5_I2C5STAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C5_I2C5STAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C5_I2C5STAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C5_I2C5STAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C5_I2C5STAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C5_I2C5STAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C5_I2C5STAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C5_I2C5STAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C5_I2C5STAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C5_I2C5STAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C5_I2C5STAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C5_I2C5STAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C5_I2C5STAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C5_I2C5STAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C5_I2C5STAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C5_I2C5STAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C5_I2C5STAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C5_I2C5STAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C5_I2C5STAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C5_I2C5STAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C5_I2C5STAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C5_I2C5STAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C5_I2C5STAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C5_I2C5STAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C5_I2C5STAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C5_I2C5STAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C5_I2C5STAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C5_I2C5STAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C5_I2C5STAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C5_I2C5STAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C5_I2C5STAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C5_I2C5STAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C5_I2C5STAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C5_I2C5STAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C5_I2C5STAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C5_I2C5STAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C5_I2C5STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C5_I2C5STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1_I2C1CON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1_I2C1CON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1_I2C1CON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1_I2C1CON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1_I2C1CON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1_I2C1CON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1_I2C1CON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1_I2C1CON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1_I2C1CON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1_I2C1CON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1_I2C1CON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1_I2C1CON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1_I2C1CON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1_I2C1CON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1_I2C1CON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1_I2C1CON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1_I2C1CON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1_I2C1CON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1_I2C1CON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1_I2C1CON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1_I2C1CON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1_I2C1CON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1_I2C1CON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1_I2C1CON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1_I2C1CON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1CON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1CON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1CON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1CON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1_I2C1CON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1_I2C1CON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1_I2C1CON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1_I2C1CON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1_I2C1CON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1_I2C1CON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1_I2C1CON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1_I2C1CON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1_I2C1CON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1_I2C1CON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1_I2C1CON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1_I2C1CON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1_I2C1CON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1_I2C1CON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1_I2C1CON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1_I2C1CON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1_I2C1CON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1_I2C1CON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1_I2C1CON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1_I2C1CON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C1_I2C1CON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C1_I2C1CON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C1_I2C1CON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C1_I2C1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1_I2C1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1_I2C1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1_I2C1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1_I2C1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1CON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1_I2C1CON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1_I2C1CON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1_I2C1CON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1_I2C1CON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1_I2C1CON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1_I2C1CON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1_I2C1CON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1_I2C1CON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1CON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1CON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1CON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1_I2C1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1_I2C1STAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1_I2C1STAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1_I2C1STAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1_I2C1STAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1_I2C1STAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1_I2C1STAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1_I2C1STAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1_I2C1STAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1_I2C1STAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1_I2C1STAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1_I2C1STAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1_I2C1STAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1_I2C1STAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1_I2C1STAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1_I2C1STAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1_I2C1STAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1_I2C1STAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1_I2C1STAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1_I2C1STAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1_I2C1STAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1_I2C1STAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1_I2C1STAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1_I2C1STAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1_I2C1STAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1_I2C1STAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1STAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1STAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1STAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1STAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1_I2C1STAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1_I2C1STAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1_I2C1STAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1_I2C1STAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1_I2C1STAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1_I2C1STAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1_I2C1STAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1_I2C1STAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1_I2C1STAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1_I2C1STAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1_I2C1STAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1_I2C1STAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1_I2C1STAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1_I2C1STAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1_I2C1STAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1_I2C1STAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C1_I2C1STAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C1_I2C1STAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C1_I2C1STAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C1_I2C1STAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1STAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1STAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1STAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1STAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1STAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1STAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1STAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1_I2C1STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI3_SPI1ACON.setSRXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI3_SPI1ACON.getSRXISEL : TBits_2; inline;
begin
  getSRXISEL := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI3_SPI1ACON.setSTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF3 or ( thebits shl 2 );
end;
function  TSPI3_SPI1ACON.getSTXISEL : TBits_2; inline;
begin
  getSTXISEL := (pTDefRegMap(@Self)^.val and $0000000C) shr 2;
end;
procedure TSPI3_SPI1ACON.setMSTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI3_SPI1ACON.clearMSTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI3_SPI1ACON.setMSTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI3_SPI1ACON.getMSTEN : TBits_1; inline;
begin
  getMSTEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI3_SPI1ACON.setCKP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI3_SPI1ACON.clearCKP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI3_SPI1ACON.setCKP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI3_SPI1ACON.getCKP : TBits_1; inline;
begin
  getCKP := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI3_SPI1ACON.setSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI3_SPI1ACON.clearSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI3_SPI1ACON.setSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI3_SPI1ACON.getSSEN : TBits_1; inline;
begin
  getSSEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI3_SPI1ACON.setCKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI3_SPI1ACON.clearCKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI3_SPI1ACON.setCKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI3_SPI1ACON.getCKE : TBits_1; inline;
begin
  getCKE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI3_SPI1ACON.setSMP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI3_SPI1ACON.clearSMP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI3_SPI1ACON.setSMP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI3_SPI1ACON.getSMP : TBits_1; inline;
begin
  getSMP := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI3_SPI1ACON.setMODE16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI3_SPI1ACON.clearMODE16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI3_SPI1ACON.setMODE16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI3_SPI1ACON.getMODE16 : TBits_1; inline;
begin
  getMODE16 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI3_SPI1ACON.setMODE32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI3_SPI1ACON.clearMODE32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI3_SPI1ACON.setMODE32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI3_SPI1ACON.getMODE32 : TBits_1; inline;
begin
  getMODE32 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI3_SPI1ACON.setDISSDO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI3_SPI1ACON.clearDISSDO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI3_SPI1ACON.setDISSDO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI3_SPI1ACON.getDISSDO : TBits_1; inline;
begin
  getDISSDO := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI3_SPI1ACON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TSPI3_SPI1ACON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TSPI3_SPI1ACON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TSPI3_SPI1ACON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TSPI3_SPI1ACON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI3_SPI1ACON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI3_SPI1ACON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI3_SPI1ACON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI3_SPI1ACON.setENHBUF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TSPI3_SPI1ACON.clearENHBUF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TSPI3_SPI1ACON.setENHBUF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TSPI3_SPI1ACON.getENHBUF : TBits_1; inline;
begin
  getENHBUF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TSPI3_SPI1ACON.setSPIFE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TSPI3_SPI1ACON.clearSPIFE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TSPI3_SPI1ACON.setSPIFE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TSPI3_SPI1ACON.getSPIFE : TBits_1; inline;
begin
  getSPIFE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TSPI3_SPI1ACON.setFRMCNT(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TSPI3_SPI1ACON.getFRMCNT : TBits_3; inline;
begin
  getFRMCNT := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TSPI3_SPI1ACON.setFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TSPI3_SPI1ACON.clearFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TSPI3_SPI1ACON.setFRMSYPW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TSPI3_SPI1ACON.getFRMSYPW : TBits_1; inline;
begin
  getFRMSYPW := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TSPI3_SPI1ACON.setMSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TSPI3_SPI1ACON.clearMSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TSPI3_SPI1ACON.setMSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TSPI3_SPI1ACON.getMSSEN : TBits_1; inline;
begin
  getMSSEN := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TSPI3_SPI1ACON.setFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TSPI3_SPI1ACON.clearFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TSPI3_SPI1ACON.setFRMPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TSPI3_SPI1ACON.getFRMPOL : TBits_1; inline;
begin
  getFRMPOL := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TSPI3_SPI1ACON.setFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TSPI3_SPI1ACON.clearFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TSPI3_SPI1ACON.setFRMSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TSPI3_SPI1ACON.getFRMSYNC : TBits_1; inline;
begin
  getFRMSYNC := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TSPI3_SPI1ACON.setFRMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TSPI3_SPI1ACON.clearFRMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TSPI3_SPI1ACON.setFRMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TSPI3_SPI1ACON.getFRMEN : TBits_1; inline;
begin
  getFRMEN := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TSPI3_SPI1ACON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI3_SPI1ACON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI3_SPI3CON.setSRXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI3_SPI3CON.getSRXISEL : TBits_2; inline;
begin
  getSRXISEL := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI3_SPI3CON.setSTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF3 or ( thebits shl 2 );
end;
function  TSPI3_SPI3CON.getSTXISEL : TBits_2; inline;
begin
  getSTXISEL := (pTDefRegMap(@Self)^.val and $0000000C) shr 2;
end;
procedure TSPI3_SPI3CON.setMSTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI3_SPI3CON.clearMSTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI3_SPI3CON.setMSTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI3_SPI3CON.getMSTEN : TBits_1; inline;
begin
  getMSTEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI3_SPI3CON.setCKP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI3_SPI3CON.clearCKP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI3_SPI3CON.setCKP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI3_SPI3CON.getCKP : TBits_1; inline;
begin
  getCKP := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI3_SPI3CON.setSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI3_SPI3CON.clearSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI3_SPI3CON.setSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI3_SPI3CON.getSSEN : TBits_1; inline;
begin
  getSSEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI3_SPI3CON.setCKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI3_SPI3CON.clearCKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI3_SPI3CON.setCKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI3_SPI3CON.getCKE : TBits_1; inline;
begin
  getCKE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI3_SPI3CON.setSMP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI3_SPI3CON.clearSMP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI3_SPI3CON.setSMP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI3_SPI3CON.getSMP : TBits_1; inline;
begin
  getSMP := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI3_SPI3CON.setMODE16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI3_SPI3CON.clearMODE16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI3_SPI3CON.setMODE16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI3_SPI3CON.getMODE16 : TBits_1; inline;
begin
  getMODE16 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI3_SPI3CON.setMODE32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI3_SPI3CON.clearMODE32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI3_SPI3CON.setMODE32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI3_SPI3CON.getMODE32 : TBits_1; inline;
begin
  getMODE32 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI3_SPI3CON.setDISSDO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI3_SPI3CON.clearDISSDO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI3_SPI3CON.setDISSDO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI3_SPI3CON.getDISSDO : TBits_1; inline;
begin
  getDISSDO := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI3_SPI3CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TSPI3_SPI3CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TSPI3_SPI3CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TSPI3_SPI3CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TSPI3_SPI3CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI3_SPI3CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI3_SPI3CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI3_SPI3CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI3_SPI3CON.setENHBUF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TSPI3_SPI3CON.clearENHBUF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TSPI3_SPI3CON.setENHBUF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TSPI3_SPI3CON.getENHBUF : TBits_1; inline;
begin
  getENHBUF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TSPI3_SPI3CON.setSPIFE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TSPI3_SPI3CON.clearSPIFE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TSPI3_SPI3CON.setSPIFE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TSPI3_SPI3CON.getSPIFE : TBits_1; inline;
begin
  getSPIFE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TSPI3_SPI3CON.setFRMCNT(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TSPI3_SPI3CON.getFRMCNT : TBits_3; inline;
begin
  getFRMCNT := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TSPI3_SPI3CON.setFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TSPI3_SPI3CON.clearFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TSPI3_SPI3CON.setFRMSYPW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TSPI3_SPI3CON.getFRMSYPW : TBits_1; inline;
begin
  getFRMSYPW := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TSPI3_SPI3CON.setMSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TSPI3_SPI3CON.clearMSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TSPI3_SPI3CON.setMSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TSPI3_SPI3CON.getMSSEN : TBits_1; inline;
begin
  getMSSEN := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TSPI3_SPI3CON.setFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TSPI3_SPI3CON.clearFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TSPI3_SPI3CON.setFRMPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TSPI3_SPI3CON.getFRMPOL : TBits_1; inline;
begin
  getFRMPOL := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TSPI3_SPI3CON.setFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TSPI3_SPI3CON.clearFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TSPI3_SPI3CON.setFRMSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TSPI3_SPI3CON.getFRMSYNC : TBits_1; inline;
begin
  getFRMSYNC := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TSPI3_SPI3CON.setFRMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TSPI3_SPI3CON.clearFRMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TSPI3_SPI3CON.setFRMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TSPI3_SPI3CON.getFRMEN : TBits_1; inline;
begin
  getFRMEN := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TSPI3_SPI3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI3_SPI3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI3_SPI1ASTAT.setSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI3_SPI1ASTAT.clearSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI3_SPI1ASTAT.setSPIRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI3_SPI1ASTAT.getSPIRBF : TBits_1; inline;
begin
  getSPIRBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI3_SPI1ASTAT.setSPITBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI3_SPI1ASTAT.clearSPITBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI3_SPI1ASTAT.setSPITBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI3_SPI1ASTAT.getSPITBF : TBits_1; inline;
begin
  getSPITBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI3_SPI1ASTAT.setSPITBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI3_SPI1ASTAT.clearSPITBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI3_SPI1ASTAT.setSPITBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI3_SPI1ASTAT.getSPITBE : TBits_1; inline;
begin
  getSPITBE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI3_SPI1ASTAT.setSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI3_SPI1ASTAT.clearSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI3_SPI1ASTAT.setSPIRBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI3_SPI1ASTAT.getSPIRBE : TBits_1; inline;
begin
  getSPIRBE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI3_SPI1ASTAT.setSPIROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI3_SPI1ASTAT.clearSPIROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI3_SPI1ASTAT.setSPIROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI3_SPI1ASTAT.getSPIROV : TBits_1; inline;
begin
  getSPIROV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI3_SPI1ASTAT.setSRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI3_SPI1ASTAT.clearSRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI3_SPI1ASTAT.setSRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI3_SPI1ASTAT.getSRMT : TBits_1; inline;
begin
  getSRMT := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI3_SPI1ASTAT.setSPITUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI3_SPI1ASTAT.clearSPITUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI3_SPI1ASTAT.setSPITUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI3_SPI1ASTAT.getSPITUR : TBits_1; inline;
begin
  getSPITUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI3_SPI1ASTAT.setSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI3_SPI1ASTAT.clearSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI3_SPI1ASTAT.setSPIBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI3_SPI1ASTAT.getSPIBUSY : TBits_1; inline;
begin
  getSPIBUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI3_SPI1ASTAT.setTXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TSPI3_SPI1ASTAT.getTXBUFELM : TBits_5; inline;
begin
  getTXBUFELM := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TSPI3_SPI1ASTAT.setRXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TSPI3_SPI1ASTAT.getRXBUFELM : TBits_5; inline;
begin
  getRXBUFELM := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TSPI3_SPI1ASTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI3_SPI1ASTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI3_SPI3STAT.setSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI3_SPI3STAT.clearSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI3_SPI3STAT.setSPIRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI3_SPI3STAT.getSPIRBF : TBits_1; inline;
begin
  getSPIRBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI3_SPI3STAT.setSPITBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI3_SPI3STAT.clearSPITBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI3_SPI3STAT.setSPITBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI3_SPI3STAT.getSPITBF : TBits_1; inline;
begin
  getSPITBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI3_SPI3STAT.setSPITBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI3_SPI3STAT.clearSPITBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI3_SPI3STAT.setSPITBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI3_SPI3STAT.getSPITBE : TBits_1; inline;
begin
  getSPITBE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI3_SPI3STAT.setSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI3_SPI3STAT.clearSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI3_SPI3STAT.setSPIRBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI3_SPI3STAT.getSPIRBE : TBits_1; inline;
begin
  getSPIRBE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI3_SPI3STAT.setSPIROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI3_SPI3STAT.clearSPIROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI3_SPI3STAT.setSPIROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI3_SPI3STAT.getSPIROV : TBits_1; inline;
begin
  getSPIROV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI3_SPI3STAT.setSRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI3_SPI3STAT.clearSRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI3_SPI3STAT.setSRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI3_SPI3STAT.getSRMT : TBits_1; inline;
begin
  getSRMT := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI3_SPI3STAT.setSPITUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI3_SPI3STAT.clearSPITUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI3_SPI3STAT.setSPITUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI3_SPI3STAT.getSPITUR : TBits_1; inline;
begin
  getSPITUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI3_SPI3STAT.setSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI3_SPI3STAT.clearSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI3_SPI3STAT.setSPIBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI3_SPI3STAT.getSPIBUSY : TBits_1; inline;
begin
  getSPIBUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI3_SPI3STAT.setTXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TSPI3_SPI3STAT.getTXBUFELM : TBits_5; inline;
begin
  getTXBUFELM := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TSPI3_SPI3STAT.setRXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TSPI3_SPI3STAT.getRXBUFELM : TBits_5; inline;
begin
  getRXBUFELM := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TSPI3_SPI3STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI3_SPI3STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI2A_SPI2ACON.setSRXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI2A_SPI2ACON.getSRXISEL : TBits_2; inline;
begin
  getSRXISEL := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI2A_SPI2ACON.setSTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF3 or ( thebits shl 2 );
end;
function  TSPI2A_SPI2ACON.getSTXISEL : TBits_2; inline;
begin
  getSTXISEL := (pTDefRegMap(@Self)^.val and $0000000C) shr 2;
end;
procedure TSPI2A_SPI2ACON.setMSTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI2A_SPI2ACON.clearMSTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI2A_SPI2ACON.setMSTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI2A_SPI2ACON.getMSTEN : TBits_1; inline;
begin
  getMSTEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI2A_SPI2ACON.setCKP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI2A_SPI2ACON.clearCKP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI2A_SPI2ACON.setCKP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI2A_SPI2ACON.getCKP : TBits_1; inline;
begin
  getCKP := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI2A_SPI2ACON.setSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI2A_SPI2ACON.clearSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI2A_SPI2ACON.setSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI2A_SPI2ACON.getSSEN : TBits_1; inline;
begin
  getSSEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI2A_SPI2ACON.setCKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI2A_SPI2ACON.clearCKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI2A_SPI2ACON.setCKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI2A_SPI2ACON.getCKE : TBits_1; inline;
begin
  getCKE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI2A_SPI2ACON.setSMP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI2A_SPI2ACON.clearSMP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI2A_SPI2ACON.setSMP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI2A_SPI2ACON.getSMP : TBits_1; inline;
begin
  getSMP := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI2A_SPI2ACON.setMODE16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI2A_SPI2ACON.clearMODE16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI2A_SPI2ACON.setMODE16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI2A_SPI2ACON.getMODE16 : TBits_1; inline;
begin
  getMODE16 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI2A_SPI2ACON.setMODE32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI2A_SPI2ACON.clearMODE32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI2A_SPI2ACON.setMODE32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI2A_SPI2ACON.getMODE32 : TBits_1; inline;
begin
  getMODE32 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI2A_SPI2ACON.setDISSDO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI2A_SPI2ACON.clearDISSDO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI2A_SPI2ACON.setDISSDO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI2A_SPI2ACON.getDISSDO : TBits_1; inline;
begin
  getDISSDO := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI2A_SPI2ACON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TSPI2A_SPI2ACON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TSPI2A_SPI2ACON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TSPI2A_SPI2ACON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TSPI2A_SPI2ACON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI2A_SPI2ACON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI2A_SPI2ACON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI2A_SPI2ACON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI2A_SPI2ACON.setENHBUF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TSPI2A_SPI2ACON.clearENHBUF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TSPI2A_SPI2ACON.setENHBUF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TSPI2A_SPI2ACON.getENHBUF : TBits_1; inline;
begin
  getENHBUF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TSPI2A_SPI2ACON.setSPIFE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TSPI2A_SPI2ACON.clearSPIFE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TSPI2A_SPI2ACON.setSPIFE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TSPI2A_SPI2ACON.getSPIFE : TBits_1; inline;
begin
  getSPIFE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TSPI2A_SPI2ACON.setFRMCNT(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TSPI2A_SPI2ACON.getFRMCNT : TBits_3; inline;
begin
  getFRMCNT := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TSPI2A_SPI2ACON.setFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TSPI2A_SPI2ACON.clearFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TSPI2A_SPI2ACON.setFRMSYPW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TSPI2A_SPI2ACON.getFRMSYPW : TBits_1; inline;
begin
  getFRMSYPW := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TSPI2A_SPI2ACON.setMSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TSPI2A_SPI2ACON.clearMSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TSPI2A_SPI2ACON.setMSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TSPI2A_SPI2ACON.getMSSEN : TBits_1; inline;
begin
  getMSSEN := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TSPI2A_SPI2ACON.setFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TSPI2A_SPI2ACON.clearFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TSPI2A_SPI2ACON.setFRMPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TSPI2A_SPI2ACON.getFRMPOL : TBits_1; inline;
begin
  getFRMPOL := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TSPI2A_SPI2ACON.setFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TSPI2A_SPI2ACON.clearFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TSPI2A_SPI2ACON.setFRMSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TSPI2A_SPI2ACON.getFRMSYNC : TBits_1; inline;
begin
  getFRMSYNC := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TSPI2A_SPI2ACON.setFRMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TSPI2A_SPI2ACON.clearFRMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TSPI2A_SPI2ACON.setFRMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TSPI2A_SPI2ACON.getFRMEN : TBits_1; inline;
begin
  getFRMEN := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TSPI2A_SPI2ACON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI2A_SPI2ACON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI2A_SPI2CON.setSRXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI2A_SPI2CON.getSRXISEL : TBits_2; inline;
begin
  getSRXISEL := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI2A_SPI2CON.setSTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF3 or ( thebits shl 2 );
end;
function  TSPI2A_SPI2CON.getSTXISEL : TBits_2; inline;
begin
  getSTXISEL := (pTDefRegMap(@Self)^.val and $0000000C) shr 2;
end;
procedure TSPI2A_SPI2CON.setMSTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI2A_SPI2CON.clearMSTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI2A_SPI2CON.setMSTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI2A_SPI2CON.getMSTEN : TBits_1; inline;
begin
  getMSTEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI2A_SPI2CON.setCKP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI2A_SPI2CON.clearCKP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI2A_SPI2CON.setCKP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI2A_SPI2CON.getCKP : TBits_1; inline;
begin
  getCKP := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI2A_SPI2CON.setSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI2A_SPI2CON.clearSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI2A_SPI2CON.setSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI2A_SPI2CON.getSSEN : TBits_1; inline;
begin
  getSSEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI2A_SPI2CON.setCKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI2A_SPI2CON.clearCKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI2A_SPI2CON.setCKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI2A_SPI2CON.getCKE : TBits_1; inline;
begin
  getCKE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI2A_SPI2CON.setSMP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI2A_SPI2CON.clearSMP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI2A_SPI2CON.setSMP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI2A_SPI2CON.getSMP : TBits_1; inline;
begin
  getSMP := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI2A_SPI2CON.setMODE16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI2A_SPI2CON.clearMODE16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI2A_SPI2CON.setMODE16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI2A_SPI2CON.getMODE16 : TBits_1; inline;
begin
  getMODE16 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI2A_SPI2CON.setMODE32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI2A_SPI2CON.clearMODE32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI2A_SPI2CON.setMODE32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI2A_SPI2CON.getMODE32 : TBits_1; inline;
begin
  getMODE32 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI2A_SPI2CON.setDISSDO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI2A_SPI2CON.clearDISSDO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI2A_SPI2CON.setDISSDO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI2A_SPI2CON.getDISSDO : TBits_1; inline;
begin
  getDISSDO := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI2A_SPI2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TSPI2A_SPI2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TSPI2A_SPI2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TSPI2A_SPI2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TSPI2A_SPI2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI2A_SPI2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI2A_SPI2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI2A_SPI2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI2A_SPI2CON.setENHBUF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TSPI2A_SPI2CON.clearENHBUF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TSPI2A_SPI2CON.setENHBUF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TSPI2A_SPI2CON.getENHBUF : TBits_1; inline;
begin
  getENHBUF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TSPI2A_SPI2CON.setSPIFE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TSPI2A_SPI2CON.clearSPIFE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TSPI2A_SPI2CON.setSPIFE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TSPI2A_SPI2CON.getSPIFE : TBits_1; inline;
begin
  getSPIFE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TSPI2A_SPI2CON.setFRMCNT(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TSPI2A_SPI2CON.getFRMCNT : TBits_3; inline;
begin
  getFRMCNT := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TSPI2A_SPI2CON.setFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TSPI2A_SPI2CON.clearFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TSPI2A_SPI2CON.setFRMSYPW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TSPI2A_SPI2CON.getFRMSYPW : TBits_1; inline;
begin
  getFRMSYPW := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TSPI2A_SPI2CON.setMSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TSPI2A_SPI2CON.clearMSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TSPI2A_SPI2CON.setMSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TSPI2A_SPI2CON.getMSSEN : TBits_1; inline;
begin
  getMSSEN := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TSPI2A_SPI2CON.setFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TSPI2A_SPI2CON.clearFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TSPI2A_SPI2CON.setFRMPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TSPI2A_SPI2CON.getFRMPOL : TBits_1; inline;
begin
  getFRMPOL := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TSPI2A_SPI2CON.setFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TSPI2A_SPI2CON.clearFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TSPI2A_SPI2CON.setFRMSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TSPI2A_SPI2CON.getFRMSYNC : TBits_1; inline;
begin
  getFRMSYNC := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TSPI2A_SPI2CON.setFRMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TSPI2A_SPI2CON.clearFRMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TSPI2A_SPI2CON.setFRMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TSPI2A_SPI2CON.getFRMEN : TBits_1; inline;
begin
  getFRMEN := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TSPI2A_SPI2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI2A_SPI2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI2A_SPI2ASTAT.setSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI2A_SPI2ASTAT.clearSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI2A_SPI2ASTAT.setSPIRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI2A_SPI2ASTAT.getSPIRBF : TBits_1; inline;
begin
  getSPIRBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI2A_SPI2ASTAT.setSPITBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI2A_SPI2ASTAT.clearSPITBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI2A_SPI2ASTAT.setSPITBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI2A_SPI2ASTAT.getSPITBF : TBits_1; inline;
begin
  getSPITBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI2A_SPI2ASTAT.setSPITBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI2A_SPI2ASTAT.clearSPITBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI2A_SPI2ASTAT.setSPITBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI2A_SPI2ASTAT.getSPITBE : TBits_1; inline;
begin
  getSPITBE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI2A_SPI2ASTAT.setSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI2A_SPI2ASTAT.clearSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI2A_SPI2ASTAT.setSPIRBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI2A_SPI2ASTAT.getSPIRBE : TBits_1; inline;
begin
  getSPIRBE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI2A_SPI2ASTAT.setSPIROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI2A_SPI2ASTAT.clearSPIROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI2A_SPI2ASTAT.setSPIROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI2A_SPI2ASTAT.getSPIROV : TBits_1; inline;
begin
  getSPIROV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI2A_SPI2ASTAT.setSRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI2A_SPI2ASTAT.clearSRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI2A_SPI2ASTAT.setSRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI2A_SPI2ASTAT.getSRMT : TBits_1; inline;
begin
  getSRMT := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI2A_SPI2ASTAT.setSPITUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI2A_SPI2ASTAT.clearSPITUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI2A_SPI2ASTAT.setSPITUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI2A_SPI2ASTAT.getSPITUR : TBits_1; inline;
begin
  getSPITUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI2A_SPI2ASTAT.setSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI2A_SPI2ASTAT.clearSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI2A_SPI2ASTAT.setSPIBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI2A_SPI2ASTAT.getSPIBUSY : TBits_1; inline;
begin
  getSPIBUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI2A_SPI2ASTAT.setTXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TSPI2A_SPI2ASTAT.getTXBUFELM : TBits_5; inline;
begin
  getTXBUFELM := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TSPI2A_SPI2ASTAT.setRXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TSPI2A_SPI2ASTAT.getRXBUFELM : TBits_5; inline;
begin
  getRXBUFELM := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TSPI2A_SPI2ASTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI2A_SPI2ASTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI2A_SPI2STAT.setSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI2A_SPI2STAT.clearSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI2A_SPI2STAT.setSPIRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI2A_SPI2STAT.getSPIRBF : TBits_1; inline;
begin
  getSPIRBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI2A_SPI2STAT.setSPITBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI2A_SPI2STAT.clearSPITBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI2A_SPI2STAT.setSPITBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI2A_SPI2STAT.getSPITBF : TBits_1; inline;
begin
  getSPITBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI2A_SPI2STAT.setSPITBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI2A_SPI2STAT.clearSPITBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI2A_SPI2STAT.setSPITBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI2A_SPI2STAT.getSPITBE : TBits_1; inline;
begin
  getSPITBE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI2A_SPI2STAT.setSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI2A_SPI2STAT.clearSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI2A_SPI2STAT.setSPIRBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI2A_SPI2STAT.getSPIRBE : TBits_1; inline;
begin
  getSPIRBE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI2A_SPI2STAT.setSPIROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI2A_SPI2STAT.clearSPIROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI2A_SPI2STAT.setSPIROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI2A_SPI2STAT.getSPIROV : TBits_1; inline;
begin
  getSPIROV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI2A_SPI2STAT.setSRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI2A_SPI2STAT.clearSRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI2A_SPI2STAT.setSRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI2A_SPI2STAT.getSRMT : TBits_1; inline;
begin
  getSRMT := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI2A_SPI2STAT.setSPITUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI2A_SPI2STAT.clearSPITUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI2A_SPI2STAT.setSPITUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI2A_SPI2STAT.getSPITUR : TBits_1; inline;
begin
  getSPITUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI2A_SPI2STAT.setSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI2A_SPI2STAT.clearSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI2A_SPI2STAT.setSPIBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI2A_SPI2STAT.getSPIBUSY : TBits_1; inline;
begin
  getSPIBUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI2A_SPI2STAT.setTXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TSPI2A_SPI2STAT.getTXBUFELM : TBits_5; inline;
begin
  getTXBUFELM := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TSPI2A_SPI2STAT.setRXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TSPI2A_SPI2STAT.getRXBUFELM : TBits_5; inline;
begin
  getRXBUFELM := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TSPI2A_SPI2STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI2A_SPI2STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI3A_SPI3ACON.setSRXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI3A_SPI3ACON.getSRXISEL : TBits_2; inline;
begin
  getSRXISEL := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI3A_SPI3ACON.setSTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF3 or ( thebits shl 2 );
end;
function  TSPI3A_SPI3ACON.getSTXISEL : TBits_2; inline;
begin
  getSTXISEL := (pTDefRegMap(@Self)^.val and $0000000C) shr 2;
end;
procedure TSPI3A_SPI3ACON.setMSTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI3A_SPI3ACON.clearMSTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI3A_SPI3ACON.setMSTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI3A_SPI3ACON.getMSTEN : TBits_1; inline;
begin
  getMSTEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI3A_SPI3ACON.setCKP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI3A_SPI3ACON.clearCKP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI3A_SPI3ACON.setCKP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI3A_SPI3ACON.getCKP : TBits_1; inline;
begin
  getCKP := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI3A_SPI3ACON.setSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI3A_SPI3ACON.clearSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI3A_SPI3ACON.setSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI3A_SPI3ACON.getSSEN : TBits_1; inline;
begin
  getSSEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI3A_SPI3ACON.setCKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI3A_SPI3ACON.clearCKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI3A_SPI3ACON.setCKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI3A_SPI3ACON.getCKE : TBits_1; inline;
begin
  getCKE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI3A_SPI3ACON.setSMP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI3A_SPI3ACON.clearSMP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI3A_SPI3ACON.setSMP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI3A_SPI3ACON.getSMP : TBits_1; inline;
begin
  getSMP := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI3A_SPI3ACON.setMODE16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI3A_SPI3ACON.clearMODE16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI3A_SPI3ACON.setMODE16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI3A_SPI3ACON.getMODE16 : TBits_1; inline;
begin
  getMODE16 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI3A_SPI3ACON.setMODE32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI3A_SPI3ACON.clearMODE32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI3A_SPI3ACON.setMODE32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI3A_SPI3ACON.getMODE32 : TBits_1; inline;
begin
  getMODE32 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI3A_SPI3ACON.setDISSDO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI3A_SPI3ACON.clearDISSDO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI3A_SPI3ACON.setDISSDO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI3A_SPI3ACON.getDISSDO : TBits_1; inline;
begin
  getDISSDO := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI3A_SPI3ACON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TSPI3A_SPI3ACON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TSPI3A_SPI3ACON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TSPI3A_SPI3ACON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TSPI3A_SPI3ACON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI3A_SPI3ACON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI3A_SPI3ACON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI3A_SPI3ACON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI3A_SPI3ACON.setENHBUF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TSPI3A_SPI3ACON.clearENHBUF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TSPI3A_SPI3ACON.setENHBUF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TSPI3A_SPI3ACON.getENHBUF : TBits_1; inline;
begin
  getENHBUF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TSPI3A_SPI3ACON.setSPIFE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TSPI3A_SPI3ACON.clearSPIFE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TSPI3A_SPI3ACON.setSPIFE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TSPI3A_SPI3ACON.getSPIFE : TBits_1; inline;
begin
  getSPIFE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TSPI3A_SPI3ACON.setFRMCNT(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TSPI3A_SPI3ACON.getFRMCNT : TBits_3; inline;
begin
  getFRMCNT := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TSPI3A_SPI3ACON.setFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TSPI3A_SPI3ACON.clearFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TSPI3A_SPI3ACON.setFRMSYPW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TSPI3A_SPI3ACON.getFRMSYPW : TBits_1; inline;
begin
  getFRMSYPW := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TSPI3A_SPI3ACON.setMSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TSPI3A_SPI3ACON.clearMSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TSPI3A_SPI3ACON.setMSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TSPI3A_SPI3ACON.getMSSEN : TBits_1; inline;
begin
  getMSSEN := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TSPI3A_SPI3ACON.setFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TSPI3A_SPI3ACON.clearFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TSPI3A_SPI3ACON.setFRMPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TSPI3A_SPI3ACON.getFRMPOL : TBits_1; inline;
begin
  getFRMPOL := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TSPI3A_SPI3ACON.setFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TSPI3A_SPI3ACON.clearFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TSPI3A_SPI3ACON.setFRMSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TSPI3A_SPI3ACON.getFRMSYNC : TBits_1; inline;
begin
  getFRMSYNC := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TSPI3A_SPI3ACON.setFRMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TSPI3A_SPI3ACON.clearFRMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TSPI3A_SPI3ACON.setFRMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TSPI3A_SPI3ACON.getFRMEN : TBits_1; inline;
begin
  getFRMEN := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TSPI3A_SPI3ACON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI3A_SPI3ACON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI3A_SPI4CON.setSRXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI3A_SPI4CON.getSRXISEL : TBits_2; inline;
begin
  getSRXISEL := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI3A_SPI4CON.setSTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF3 or ( thebits shl 2 );
end;
function  TSPI3A_SPI4CON.getSTXISEL : TBits_2; inline;
begin
  getSTXISEL := (pTDefRegMap(@Self)^.val and $0000000C) shr 2;
end;
procedure TSPI3A_SPI4CON.setMSTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI3A_SPI4CON.clearMSTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI3A_SPI4CON.setMSTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI3A_SPI4CON.getMSTEN : TBits_1; inline;
begin
  getMSTEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI3A_SPI4CON.setCKP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI3A_SPI4CON.clearCKP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI3A_SPI4CON.setCKP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI3A_SPI4CON.getCKP : TBits_1; inline;
begin
  getCKP := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI3A_SPI4CON.setSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI3A_SPI4CON.clearSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI3A_SPI4CON.setSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI3A_SPI4CON.getSSEN : TBits_1; inline;
begin
  getSSEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI3A_SPI4CON.setCKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI3A_SPI4CON.clearCKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI3A_SPI4CON.setCKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI3A_SPI4CON.getCKE : TBits_1; inline;
begin
  getCKE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI3A_SPI4CON.setSMP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI3A_SPI4CON.clearSMP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI3A_SPI4CON.setSMP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI3A_SPI4CON.getSMP : TBits_1; inline;
begin
  getSMP := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI3A_SPI4CON.setMODE16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI3A_SPI4CON.clearMODE16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI3A_SPI4CON.setMODE16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI3A_SPI4CON.getMODE16 : TBits_1; inline;
begin
  getMODE16 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI3A_SPI4CON.setMODE32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI3A_SPI4CON.clearMODE32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI3A_SPI4CON.setMODE32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI3A_SPI4CON.getMODE32 : TBits_1; inline;
begin
  getMODE32 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI3A_SPI4CON.setDISSDO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI3A_SPI4CON.clearDISSDO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI3A_SPI4CON.setDISSDO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI3A_SPI4CON.getDISSDO : TBits_1; inline;
begin
  getDISSDO := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI3A_SPI4CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TSPI3A_SPI4CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TSPI3A_SPI4CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TSPI3A_SPI4CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TSPI3A_SPI4CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI3A_SPI4CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI3A_SPI4CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI3A_SPI4CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI3A_SPI4CON.setENHBUF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TSPI3A_SPI4CON.clearENHBUF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TSPI3A_SPI4CON.setENHBUF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TSPI3A_SPI4CON.getENHBUF : TBits_1; inline;
begin
  getENHBUF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TSPI3A_SPI4CON.setSPIFE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TSPI3A_SPI4CON.clearSPIFE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TSPI3A_SPI4CON.setSPIFE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TSPI3A_SPI4CON.getSPIFE : TBits_1; inline;
begin
  getSPIFE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TSPI3A_SPI4CON.setFRMCNT(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TSPI3A_SPI4CON.getFRMCNT : TBits_3; inline;
begin
  getFRMCNT := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TSPI3A_SPI4CON.setFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TSPI3A_SPI4CON.clearFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TSPI3A_SPI4CON.setFRMSYPW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TSPI3A_SPI4CON.getFRMSYPW : TBits_1; inline;
begin
  getFRMSYPW := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TSPI3A_SPI4CON.setMSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TSPI3A_SPI4CON.clearMSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TSPI3A_SPI4CON.setMSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TSPI3A_SPI4CON.getMSSEN : TBits_1; inline;
begin
  getMSSEN := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TSPI3A_SPI4CON.setFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TSPI3A_SPI4CON.clearFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TSPI3A_SPI4CON.setFRMPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TSPI3A_SPI4CON.getFRMPOL : TBits_1; inline;
begin
  getFRMPOL := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TSPI3A_SPI4CON.setFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TSPI3A_SPI4CON.clearFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TSPI3A_SPI4CON.setFRMSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TSPI3A_SPI4CON.getFRMSYNC : TBits_1; inline;
begin
  getFRMSYNC := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TSPI3A_SPI4CON.setFRMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TSPI3A_SPI4CON.clearFRMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TSPI3A_SPI4CON.setFRMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TSPI3A_SPI4CON.getFRMEN : TBits_1; inline;
begin
  getFRMEN := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TSPI3A_SPI4CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI3A_SPI4CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI3A_SPI3ASTAT.setSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI3A_SPI3ASTAT.clearSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI3A_SPI3ASTAT.setSPIRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI3A_SPI3ASTAT.getSPIRBF : TBits_1; inline;
begin
  getSPIRBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI3A_SPI3ASTAT.setSPITBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI3A_SPI3ASTAT.clearSPITBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI3A_SPI3ASTAT.setSPITBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI3A_SPI3ASTAT.getSPITBF : TBits_1; inline;
begin
  getSPITBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI3A_SPI3ASTAT.setSPITBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI3A_SPI3ASTAT.clearSPITBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI3A_SPI3ASTAT.setSPITBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI3A_SPI3ASTAT.getSPITBE : TBits_1; inline;
begin
  getSPITBE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI3A_SPI3ASTAT.setSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI3A_SPI3ASTAT.clearSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI3A_SPI3ASTAT.setSPIRBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI3A_SPI3ASTAT.getSPIRBE : TBits_1; inline;
begin
  getSPIRBE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI3A_SPI3ASTAT.setSPIROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI3A_SPI3ASTAT.clearSPIROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI3A_SPI3ASTAT.setSPIROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI3A_SPI3ASTAT.getSPIROV : TBits_1; inline;
begin
  getSPIROV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI3A_SPI3ASTAT.setSRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI3A_SPI3ASTAT.clearSRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI3A_SPI3ASTAT.setSRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI3A_SPI3ASTAT.getSRMT : TBits_1; inline;
begin
  getSRMT := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI3A_SPI3ASTAT.setSPITUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI3A_SPI3ASTAT.clearSPITUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI3A_SPI3ASTAT.setSPITUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI3A_SPI3ASTAT.getSPITUR : TBits_1; inline;
begin
  getSPITUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI3A_SPI3ASTAT.setSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI3A_SPI3ASTAT.clearSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI3A_SPI3ASTAT.setSPIBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI3A_SPI3ASTAT.getSPIBUSY : TBits_1; inline;
begin
  getSPIBUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI3A_SPI3ASTAT.setTXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TSPI3A_SPI3ASTAT.getTXBUFELM : TBits_5; inline;
begin
  getTXBUFELM := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TSPI3A_SPI3ASTAT.setRXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TSPI3A_SPI3ASTAT.getRXBUFELM : TBits_5; inline;
begin
  getRXBUFELM := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TSPI3A_SPI3ASTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI3A_SPI3ASTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI3A_SPI4STAT.setSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI3A_SPI4STAT.clearSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI3A_SPI4STAT.setSPIRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI3A_SPI4STAT.getSPIRBF : TBits_1; inline;
begin
  getSPIRBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI3A_SPI4STAT.setSPITBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI3A_SPI4STAT.clearSPITBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI3A_SPI4STAT.setSPITBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI3A_SPI4STAT.getSPITBF : TBits_1; inline;
begin
  getSPITBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI3A_SPI4STAT.setSPITBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI3A_SPI4STAT.clearSPITBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI3A_SPI4STAT.setSPITBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI3A_SPI4STAT.getSPITBE : TBits_1; inline;
begin
  getSPITBE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI3A_SPI4STAT.setSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI3A_SPI4STAT.clearSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI3A_SPI4STAT.setSPIRBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI3A_SPI4STAT.getSPIRBE : TBits_1; inline;
begin
  getSPIRBE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI3A_SPI4STAT.setSPIROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI3A_SPI4STAT.clearSPIROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI3A_SPI4STAT.setSPIROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI3A_SPI4STAT.getSPIROV : TBits_1; inline;
begin
  getSPIROV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI3A_SPI4STAT.setSRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI3A_SPI4STAT.clearSRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI3A_SPI4STAT.setSRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI3A_SPI4STAT.getSRMT : TBits_1; inline;
begin
  getSRMT := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI3A_SPI4STAT.setSPITUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI3A_SPI4STAT.clearSPITUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI3A_SPI4STAT.setSPITUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI3A_SPI4STAT.getSPITUR : TBits_1; inline;
begin
  getSPITUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI3A_SPI4STAT.setSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI3A_SPI4STAT.clearSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI3A_SPI4STAT.setSPIBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI3A_SPI4STAT.getSPIBUSY : TBits_1; inline;
begin
  getSPIBUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI3A_SPI4STAT.setTXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TSPI3A_SPI4STAT.getTXBUFELM : TBits_5; inline;
begin
  getTXBUFELM := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TSPI3A_SPI4STAT.setRXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TSPI3A_SPI4STAT.getRXBUFELM : TBits_5; inline;
begin
  getRXBUFELM := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TSPI3A_SPI4STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI3A_SPI4STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART1A_U1AMODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART1A_U1AMODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART1A_U1AMODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART1A_U1AMODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART1A_U1AMODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART1A_U1AMODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART1A_U1AMODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART1A_U1AMODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART1A_U1AMODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART1A_U1AMODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART1A_U1AMODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART1A_U1AMODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART1A_U1AMODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART1A_U1AMODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART1A_U1AMODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART1A_U1AMODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART1A_U1AMODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART1A_U1AMODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART1A_U1AMODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART1A_U1AMODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART1A_U1AMODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART1A_U1AMODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART1A_U1AMODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART1A_U1AMODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART1A_U1AMODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART1A_U1AMODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART1A_U1AMODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART1A_U1AMODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART1A_U1AMODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART1A_U1AMODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART1A_U1AMODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART1A_U1AMODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART1A_U1AMODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART1A_U1AMODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART1A_U1AMODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART1A_U1AMODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART1A_U1AMODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1A_U1AMODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1A_U1AMODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1A_U1AMODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1A_U1AMODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1A_U1AMODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1A_U1AMODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1A_U1AMODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1A_U1AMODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART1A_U1AMODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART1A_U1AMODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART1A_U1AMODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART1A_U1AMODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART1A_U1AMODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART1A_U1AMODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART1A_U1AMODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART1A_U1AMODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART1A_U1AMODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART1A_U1AMODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART1A_U1AMODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART1A_U1AMODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART1A_U1AMODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART1A_U1AMODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART1A_U1AMODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART1A_U1AMODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1A_U1AMODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1A_U1AMODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1A_U1AMODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1A_U1AMODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1A_U1AMODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1A_U1AMODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1A_U1AMODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1A_U1AMODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART1A_U1AMODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART1A_U1MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART1A_U1MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART1A_U1MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART1A_U1MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART1A_U1MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART1A_U1MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART1A_U1MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART1A_U1MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART1A_U1MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART1A_U1MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART1A_U1MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART1A_U1MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART1A_U1MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART1A_U1MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART1A_U1MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART1A_U1MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART1A_U1MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART1A_U1MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART1A_U1MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART1A_U1MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART1A_U1MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART1A_U1MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART1A_U1MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART1A_U1MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART1A_U1MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART1A_U1MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART1A_U1MODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART1A_U1MODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART1A_U1MODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART1A_U1MODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART1A_U1MODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART1A_U1MODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART1A_U1MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART1A_U1MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART1A_U1MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART1A_U1MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART1A_U1MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1A_U1MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1A_U1MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1A_U1MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1A_U1MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1A_U1MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1A_U1MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1A_U1MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1A_U1MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART1A_U1MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART1A_U1MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART1A_U1MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART1A_U1MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART1A_U1MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART1A_U1MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART1A_U1MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART1A_U1MODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART1A_U1MODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART1A_U1MODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART1A_U1MODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART1A_U1MODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART1A_U1MODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART1A_U1MODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART1A_U1MODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART1A_U1MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1A_U1MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1A_U1MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1A_U1MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1A_U1MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1A_U1MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1A_U1MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1A_U1MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1A_U1MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART1A_U1MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART1A_U1ASTA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART1A_U1ASTA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART1A_U1ASTA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART1A_U1ASTA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART1A_U1ASTA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART1A_U1ASTA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART1A_U1ASTA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART1A_U1ASTA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART1A_U1ASTA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART1A_U1ASTA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART1A_U1ASTA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART1A_U1ASTA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART1A_U1ASTA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART1A_U1ASTA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART1A_U1ASTA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART1A_U1ASTA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART1A_U1ASTA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART1A_U1ASTA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART1A_U1ASTA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART1A_U1ASTA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART1A_U1ASTA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART1A_U1ASTA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART1A_U1ASTA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART1A_U1ASTA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART1A_U1ASTA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART1A_U1ASTA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART1A_U1ASTA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART1A_U1ASTA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART1A_U1ASTA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART1A_U1ASTA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART1A_U1ASTA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART1A_U1ASTA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART1A_U1ASTA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART1A_U1ASTA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART1A_U1ASTA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART1A_U1ASTA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART1A_U1ASTA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART1A_U1ASTA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART1A_U1ASTA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART1A_U1ASTA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART1A_U1ASTA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART1A_U1ASTA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART1A_U1ASTA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART1A_U1ASTA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART1A_U1ASTA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART1A_U1ASTA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART1A_U1ASTA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1A_U1ASTA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1A_U1ASTA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1A_U1ASTA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1A_U1ASTA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART1A_U1ASTA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART1A_U1ASTA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART1A_U1ASTA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART1A_U1ASTA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART1A_U1ASTA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART1A_U1ASTA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART1A_U1ASTA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART1A_U1ASTA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART1A_U1ASTA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART1A_U1ASTA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART1A_U1ASTA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART1A_U1ASTA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART1A_U1ASTA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART1A_U1ASTA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART1A_U1ASTA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART1A_U1ASTA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART1A_U1ASTA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART1A_U1ASTA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART1A_U1ASTA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART1A_U1ASTA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1A_U1ASTA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1A_U1ASTA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1A_U1ASTA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1A_U1ASTA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART1A_U1ASTA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART1A_U1ASTA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART1A_U1ASTA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART1A_U1STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART1A_U1STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART1A_U1STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART1A_U1STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART1A_U1STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART1A_U1STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART1A_U1STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART1A_U1STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART1A_U1STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART1A_U1STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART1A_U1STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART1A_U1STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART1A_U1STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART1A_U1STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART1A_U1STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART1A_U1STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART1A_U1STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART1A_U1STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART1A_U1STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART1A_U1STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART1A_U1STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART1A_U1STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART1A_U1STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART1A_U1STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART1A_U1STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART1A_U1STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART1A_U1STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART1A_U1STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART1A_U1STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART1A_U1STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART1A_U1STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART1A_U1STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART1A_U1STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART1A_U1STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART1A_U1STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART1A_U1STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART1A_U1STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART1A_U1STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART1A_U1STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART1A_U1STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART1A_U1STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART1A_U1STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART1A_U1STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART1A_U1STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART1A_U1STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART1A_U1STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART1A_U1STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1A_U1STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1A_U1STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1A_U1STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1A_U1STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART1A_U1STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART1A_U1STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART1A_U1STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART1A_U1STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART1A_U1STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART1A_U1STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART1A_U1STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART1A_U1STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART1A_U1STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART1A_U1STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART1A_U1STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART1A_U1STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART1A_U1STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART1A_U1STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART1A_U1STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART1A_U1STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART1A_U1STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART1A_U1STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART1A_U1STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART1A_U1STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1A_U1STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1A_U1STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1A_U1STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1A_U1STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART1A_U1STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART1A_U1STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART1A_U1STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART4_U1BMODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART4_U1BMODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART4_U1BMODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART4_U1BMODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART4_U1BMODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART4_U1BMODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART4_U1BMODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART4_U1BMODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART4_U1BMODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART4_U1BMODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART4_U1BMODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART4_U1BMODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART4_U1BMODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART4_U1BMODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART4_U1BMODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART4_U1BMODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART4_U1BMODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART4_U1BMODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART4_U1BMODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART4_U1BMODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART4_U1BMODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART4_U1BMODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART4_U1BMODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART4_U1BMODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART4_U1BMODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART4_U1BMODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART4_U1BMODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART4_U1BMODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART4_U1BMODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART4_U1BMODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART4_U1BMODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART4_U1BMODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART4_U1BMODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART4_U1BMODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART4_U1BMODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART4_U1BMODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART4_U1BMODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART4_U1BMODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART4_U1BMODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART4_U1BMODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART4_U1BMODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART4_U1BMODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART4_U1BMODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART4_U1BMODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART4_U1BMODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART4_U1BMODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART4_U1BMODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART4_U1BMODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART4_U1BMODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART4_U1BMODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART4_U1BMODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART4_U1BMODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART4_U1BMODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART4_U1BMODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART4_U1BMODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART4_U1BMODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART4_U4MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART4_U4MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART4_U4MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART4_U4MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART4_U4MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART4_U4MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART4_U4MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART4_U4MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART4_U4MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART4_U4MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART4_U4MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART4_U4MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART4_U4MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART4_U4MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART4_U4MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART4_U4MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART4_U4MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART4_U4MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART4_U4MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART4_U4MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART4_U4MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART4_U4MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART4_U4MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART4_U4MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART4_U4MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART4_U4MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART4_U4MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART4_U4MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART4_U4MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART4_U4MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART4_U4MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART4_U4MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART4_U4MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART4_U4MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART4_U4MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART4_U4MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART4_U4MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART4_U4MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART4_U4MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART4_U4MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART4_U4MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART4_U4MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART4_U4MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART4_U4MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART4_U4MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART4_U4MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART4_U4MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART4_U4MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART4_U4MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART4_U4MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART4_U4MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART4_U4MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART4_U4MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART4_U4MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART4_U4MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART4_U4MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART4_U1BSTA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART4_U1BSTA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART4_U1BSTA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART4_U1BSTA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART4_U1BSTA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART4_U1BSTA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART4_U1BSTA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART4_U1BSTA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART4_U1BSTA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART4_U1BSTA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART4_U1BSTA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART4_U1BSTA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART4_U1BSTA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART4_U1BSTA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART4_U1BSTA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART4_U1BSTA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART4_U1BSTA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART4_U1BSTA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART4_U1BSTA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART4_U1BSTA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART4_U1BSTA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART4_U1BSTA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART4_U1BSTA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART4_U1BSTA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART4_U1BSTA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART4_U1BSTA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART4_U1BSTA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART4_U1BSTA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART4_U1BSTA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART4_U1BSTA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART4_U1BSTA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART4_U1BSTA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART4_U1BSTA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART4_U1BSTA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART4_U1BSTA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART4_U1BSTA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART4_U1BSTA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART4_U1BSTA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART4_U1BSTA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART4_U1BSTA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART4_U1BSTA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART4_U1BSTA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART4_U1BSTA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART4_U1BSTA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART4_U1BSTA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART4_U1BSTA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART4_U1BSTA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART4_U1BSTA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART4_U1BSTA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART4_U1BSTA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART4_U1BSTA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART4_U1BSTA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART4_U1BSTA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART4_U1BSTA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART4_U1BSTA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART4_U1BSTA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART4_U1BSTA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART4_U1BSTA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART4_U1BSTA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART4_U1BSTA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART4_U1BSTA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART4_U1BSTA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART4_U1BSTA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART4_U1BSTA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART4_U1BSTA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART4_U1BSTA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART4_U1BSTA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART4_U1BSTA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART4_U1BSTA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART4_U1BSTA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART4_U1BSTA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART4_U1BSTA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART4_U1BSTA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART4_U1BSTA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART4_U1BSTA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART4_U1BSTA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART4_U1BSTA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART4_U1BSTA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART4_U4STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART4_U4STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART4_U4STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART4_U4STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART4_U4STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART4_U4STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART4_U4STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART4_U4STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART4_U4STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART4_U4STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART4_U4STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART4_U4STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART4_U4STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART4_U4STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART4_U4STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART4_U4STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART4_U4STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART4_U4STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART4_U4STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART4_U4STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART4_U4STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART4_U4STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART4_U4STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART4_U4STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART4_U4STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART4_U4STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART4_U4STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART4_U4STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART4_U4STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART4_U4STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART4_U4STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART4_U4STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART4_U4STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART4_U4STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART4_U4STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART4_U4STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART4_U4STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART4_U4STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART4_U4STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART4_U4STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART4_U4STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART4_U4STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART4_U4STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART4_U4STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART4_U4STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART4_U4STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART4_U4STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART4_U4STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART4_U4STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART4_U4STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART4_U4STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART4_U4STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART4_U4STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART4_U4STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART4_U4STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART4_U4STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART4_U4STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART4_U4STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART4_U4STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART4_U4STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART4_U4STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART4_U4STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART4_U4STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART4_U4STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART4_U4STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART4_U4STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART4_U4STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART4_U4STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART4_U4STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART4_U4STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART4_U4STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART4_U4STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART4_U4STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART4_U4STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART4_U4STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART4_U4STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART4_U4STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART4_U4STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2A_U2AMODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2A_U2AMODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2A_U2AMODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2A_U2AMODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2A_U2AMODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART2A_U2AMODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART2A_U2AMODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2A_U2AMODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2A_U2AMODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2A_U2AMODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2A_U2AMODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2A_U2AMODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2A_U2AMODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2A_U2AMODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2A_U2AMODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2A_U2AMODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2A_U2AMODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2A_U2AMODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2A_U2AMODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2A_U2AMODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2A_U2AMODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2A_U2AMODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2A_U2AMODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2A_U2AMODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2A_U2AMODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2A_U2AMODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2A_U2AMODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART2A_U2AMODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART2A_U2AMODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2A_U2AMODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2A_U2AMODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2A_U2AMODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2A_U2AMODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2A_U2AMODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2A_U2AMODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2A_U2AMODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2A_U2AMODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2A_U2AMODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2A_U2AMODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2A_U2AMODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2A_U2AMODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2A_U2AMODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2A_U2AMODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2A_U2AMODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2A_U2AMODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2A_U2AMODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2A_U2AMODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2A_U2AMODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2A_U2AMODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2A_U2AMODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2A_U2AMODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2A_U2AMODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2A_U2AMODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2A_U2AMODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2A_U2AMODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2A_U2AMODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2A_U2AMODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2A_U2AMODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2A_U2AMODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2A_U2AMODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2A_U2AMODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2A_U2AMODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2A_U2AMODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2A_U2AMODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2A_U2AMODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2A_U2AMODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2A_U2AMODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2A_U2AMODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2A_U2AMODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2A_U2AMODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2A_U3MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2A_U3MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2A_U3MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2A_U3MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2A_U3MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART2A_U3MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART2A_U3MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2A_U3MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2A_U3MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2A_U3MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2A_U3MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2A_U3MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2A_U3MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2A_U3MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2A_U3MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2A_U3MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2A_U3MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2A_U3MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2A_U3MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2A_U3MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2A_U3MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2A_U3MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2A_U3MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2A_U3MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2A_U3MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2A_U3MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2A_U3MODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART2A_U3MODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART2A_U3MODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2A_U3MODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2A_U3MODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2A_U3MODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2A_U3MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2A_U3MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2A_U3MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2A_U3MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2A_U3MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2A_U3MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2A_U3MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2A_U3MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2A_U3MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2A_U3MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2A_U3MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2A_U3MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2A_U3MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2A_U3MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2A_U3MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2A_U3MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2A_U3MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2A_U3MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2A_U3MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2A_U3MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2A_U3MODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2A_U3MODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2A_U3MODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2A_U3MODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2A_U3MODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2A_U3MODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2A_U3MODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2A_U3MODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2A_U3MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2A_U3MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2A_U3MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2A_U3MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2A_U3MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2A_U3MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2A_U3MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2A_U3MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2A_U3MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2A_U3MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2A_U2ASTA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2A_U2ASTA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2A_U2ASTA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2A_U2ASTA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2A_U2ASTA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2A_U2ASTA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2A_U2ASTA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2A_U2ASTA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2A_U2ASTA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2A_U2ASTA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2A_U2ASTA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2A_U2ASTA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2A_U2ASTA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2A_U2ASTA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2A_U2ASTA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2A_U2ASTA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2A_U2ASTA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2A_U2ASTA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2A_U2ASTA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2A_U2ASTA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2A_U2ASTA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2A_U2ASTA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2A_U2ASTA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2A_U2ASTA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2A_U2ASTA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART2A_U2ASTA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART2A_U2ASTA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2A_U2ASTA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2A_U2ASTA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2A_U2ASTA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2A_U2ASTA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2A_U2ASTA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2A_U2ASTA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2A_U2ASTA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2A_U2ASTA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART2A_U2ASTA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART2A_U2ASTA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART2A_U2ASTA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART2A_U2ASTA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2A_U2ASTA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2A_U2ASTA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2A_U2ASTA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2A_U2ASTA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2A_U2ASTA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2A_U2ASTA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2A_U2ASTA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2A_U2ASTA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2A_U2ASTA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2A_U2ASTA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2A_U2ASTA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2A_U2ASTA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2A_U2ASTA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2A_U2ASTA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART2A_U2ASTA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART2A_U2ASTA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART2A_U2ASTA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART2A_U2ASTA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART2A_U2ASTA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART2A_U2ASTA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2A_U2ASTA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2A_U2ASTA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2A_U2ASTA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2A_U2ASTA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2A_U2ASTA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2A_U2ASTA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2A_U2ASTA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2A_U2ASTA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART2A_U2ASTA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART2A_U2ASTA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART2A_U2ASTA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART2A_U2ASTA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2A_U2ASTA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2A_U2ASTA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2A_U2ASTA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2A_U2ASTA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2A_U2ASTA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2A_U2ASTA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2A_U2ASTA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2A_U3STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2A_U3STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2A_U3STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2A_U3STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2A_U3STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2A_U3STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2A_U3STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2A_U3STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2A_U3STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2A_U3STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2A_U3STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2A_U3STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2A_U3STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2A_U3STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2A_U3STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2A_U3STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2A_U3STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2A_U3STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2A_U3STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2A_U3STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2A_U3STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2A_U3STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2A_U3STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2A_U3STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2A_U3STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART2A_U3STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART2A_U3STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2A_U3STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2A_U3STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2A_U3STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2A_U3STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2A_U3STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2A_U3STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2A_U3STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2A_U3STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART2A_U3STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART2A_U3STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART2A_U3STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART2A_U3STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2A_U3STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2A_U3STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2A_U3STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2A_U3STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2A_U3STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2A_U3STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2A_U3STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2A_U3STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2A_U3STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2A_U3STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2A_U3STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2A_U3STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2A_U3STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2A_U3STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART2A_U3STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART2A_U3STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART2A_U3STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART2A_U3STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART2A_U3STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART2A_U3STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2A_U3STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2A_U3STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2A_U3STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2A_U3STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2A_U3STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2A_U3STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2A_U3STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2A_U3STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART2A_U3STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART2A_U3STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART2A_U3STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART2A_U3STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2A_U3STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2A_U3STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2A_U3STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2A_U3STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2A_U3STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2A_U3STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2A_U3STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART6_U2BMODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART6_U2BMODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART6_U2BMODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART6_U2BMODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART6_U2BMODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART6_U2BMODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART6_U2BMODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART6_U2BMODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART6_U2BMODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART6_U2BMODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART6_U2BMODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART6_U2BMODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART6_U2BMODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART6_U2BMODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART6_U2BMODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART6_U2BMODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART6_U2BMODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART6_U2BMODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART6_U2BMODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART6_U2BMODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART6_U2BMODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART6_U2BMODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART6_U2BMODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART6_U2BMODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART6_U2BMODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART6_U2BMODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART6_U2BMODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART6_U2BMODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART6_U2BMODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART6_U2BMODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART6_U2BMODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART6_U2BMODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART6_U2BMODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART6_U2BMODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART6_U2BMODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART6_U2BMODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART6_U2BMODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART6_U2BMODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART6_U2BMODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART6_U2BMODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART6_U2BMODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART6_U2BMODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART6_U2BMODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART6_U2BMODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART6_U2BMODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART6_U2BMODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART6_U2BMODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART6_U2BMODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART6_U2BMODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART6_U2BMODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART6_U2BMODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART6_U2BMODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART6_U2BMODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART6_U2BMODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART6_U2BMODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART6_U2BMODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART6_U6MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART6_U6MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART6_U6MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART6_U6MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART6_U6MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART6_U6MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART6_U6MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART6_U6MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART6_U6MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART6_U6MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART6_U6MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART6_U6MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART6_U6MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART6_U6MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART6_U6MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART6_U6MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART6_U6MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART6_U6MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART6_U6MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART6_U6MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART6_U6MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART6_U6MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART6_U6MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART6_U6MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART6_U6MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART6_U6MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART6_U6MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART6_U6MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART6_U6MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART6_U6MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART6_U6MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART6_U6MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART6_U6MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART6_U6MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART6_U6MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART6_U6MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART6_U6MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART6_U6MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART6_U6MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART6_U6MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART6_U6MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART6_U6MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART6_U6MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART6_U6MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART6_U6MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART6_U6MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART6_U6MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART6_U6MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART6_U6MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART6_U6MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART6_U6MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART6_U6MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART6_U6MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART6_U6MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART6_U6MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART6_U6MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART6_U2BSTA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART6_U2BSTA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART6_U2BSTA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART6_U2BSTA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART6_U2BSTA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART6_U2BSTA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART6_U2BSTA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART6_U2BSTA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART6_U2BSTA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART6_U2BSTA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART6_U2BSTA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART6_U2BSTA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART6_U2BSTA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART6_U2BSTA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART6_U2BSTA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART6_U2BSTA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART6_U2BSTA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART6_U2BSTA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART6_U2BSTA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART6_U2BSTA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART6_U2BSTA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART6_U2BSTA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART6_U2BSTA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART6_U2BSTA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART6_U2BSTA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART6_U2BSTA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART6_U2BSTA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART6_U2BSTA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART6_U2BSTA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART6_U2BSTA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART6_U2BSTA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART6_U2BSTA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART6_U2BSTA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART6_U2BSTA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART6_U2BSTA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART6_U2BSTA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART6_U2BSTA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART6_U2BSTA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART6_U2BSTA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART6_U2BSTA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART6_U2BSTA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART6_U2BSTA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART6_U2BSTA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART6_U2BSTA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART6_U2BSTA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART6_U2BSTA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART6_U2BSTA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART6_U2BSTA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART6_U2BSTA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART6_U2BSTA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART6_U2BSTA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART6_U2BSTA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART6_U2BSTA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART6_U2BSTA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART6_U2BSTA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART6_U2BSTA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART6_U2BSTA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART6_U2BSTA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART6_U2BSTA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART6_U2BSTA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART6_U2BSTA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART6_U2BSTA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART6_U2BSTA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART6_U2BSTA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART6_U2BSTA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART6_U2BSTA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART6_U2BSTA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART6_U2BSTA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART6_U2BSTA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART6_U2BSTA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART6_U2BSTA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART6_U2BSTA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART6_U2BSTA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART6_U2BSTA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART6_U2BSTA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART6_U2BSTA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART6_U2BSTA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART6_U2BSTA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART6_U6STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART6_U6STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART6_U6STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART6_U6STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART6_U6STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART6_U6STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART6_U6STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART6_U6STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART6_U6STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART6_U6STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART6_U6STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART6_U6STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART6_U6STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART6_U6STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART6_U6STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART6_U6STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART6_U6STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART6_U6STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART6_U6STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART6_U6STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART6_U6STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART6_U6STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART6_U6STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART6_U6STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART6_U6STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART6_U6STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART6_U6STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART6_U6STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART6_U6STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART6_U6STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART6_U6STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART6_U6STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART6_U6STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART6_U6STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART6_U6STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART6_U6STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART6_U6STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART6_U6STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART6_U6STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART6_U6STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART6_U6STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART6_U6STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART6_U6STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART6_U6STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART6_U6STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART6_U6STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART6_U6STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART6_U6STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART6_U6STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART6_U6STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART6_U6STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART6_U6STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART6_U6STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART6_U6STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART6_U6STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART6_U6STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART6_U6STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART6_U6STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART6_U6STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART6_U6STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART6_U6STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART6_U6STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART6_U6STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART6_U6STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART6_U6STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART6_U6STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART6_U6STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART6_U6STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART6_U6STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART6_U6STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART6_U6STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART6_U6STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART6_U6STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART6_U6STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART6_U6STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART6_U6STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART6_U6STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART6_U6STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2_U2MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2_U2MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2_U2MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2_U2MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2_U2MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART2_U2MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART2_U2MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2_U2MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2_U2MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2_U2MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2_U2MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2_U2MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2_U2MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2_U2MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2_U2MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2_U2MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2_U2MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2_U2MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2_U2MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2_U2MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2_U2MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2_U2MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2_U2MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2_U2MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2_U2MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2_U2MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2_U2MODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART2_U2MODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART2_U2MODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2_U2MODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2_U2MODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2_U2MODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2_U2MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2_U2MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2_U2MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2_U2MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2_U2MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U2MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U2MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U2MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U2MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U2MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U2MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U2MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U2MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2_U2MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2_U2MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2_U2MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2_U2MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2_U2MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2_U2MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2_U2MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2_U2MODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2_U2MODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2_U2MODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2_U2MODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2_U2MODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2_U2MODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2_U2MODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2_U2MODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2_U2MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U2MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U2MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U2MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U2MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U2MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U2MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U2MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U2MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2_U2MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2_U3AMODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2_U3AMODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2_U3AMODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2_U3AMODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2_U3AMODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART2_U3AMODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART2_U3AMODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2_U3AMODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2_U3AMODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2_U3AMODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2_U3AMODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2_U3AMODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2_U3AMODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2_U3AMODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2_U3AMODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2_U3AMODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2_U3AMODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2_U3AMODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2_U3AMODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2_U3AMODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2_U3AMODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2_U3AMODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2_U3AMODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2_U3AMODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2_U3AMODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2_U3AMODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2_U3AMODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART2_U3AMODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART2_U3AMODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2_U3AMODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2_U3AMODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2_U3AMODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2_U3AMODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2_U3AMODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2_U3AMODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2_U3AMODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2_U3AMODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U3AMODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U3AMODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U3AMODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U3AMODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U3AMODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U3AMODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U3AMODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U3AMODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2_U3AMODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2_U3AMODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2_U3AMODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2_U3AMODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2_U3AMODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2_U3AMODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2_U3AMODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2_U3AMODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2_U3AMODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2_U3AMODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2_U3AMODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2_U3AMODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2_U3AMODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2_U3AMODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2_U3AMODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2_U3AMODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U3AMODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U3AMODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U3AMODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U3AMODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U3AMODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U3AMODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U3AMODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U3AMODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2_U3AMODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2_U2STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2_U2STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2_U2STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2_U2STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2_U2STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2_U2STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2_U2STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2_U2STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2_U2STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2_U2STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2_U2STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2_U2STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2_U2STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2_U2STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2_U2STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2_U2STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2_U2STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2_U2STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2_U2STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2_U2STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2_U2STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2_U2STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2_U2STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2_U2STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2_U2STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART2_U2STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART2_U2STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2_U2STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2_U2STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2_U2STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2_U2STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2_U2STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2_U2STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2_U2STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2_U2STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART2_U2STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART2_U2STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART2_U2STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART2_U2STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2_U2STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2_U2STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2_U2STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2_U2STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2_U2STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2_U2STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2_U2STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2_U2STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U2STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U2STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U2STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U2STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2_U2STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2_U2STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART2_U2STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART2_U2STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART2_U2STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART2_U2STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART2_U2STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART2_U2STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2_U2STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2_U2STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2_U2STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2_U2STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2_U2STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2_U2STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2_U2STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2_U2STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART2_U2STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART2_U2STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART2_U2STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART2_U2STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U2STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U2STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U2STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U2STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2_U2STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2_U2STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2_U2STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2_U3ASTA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2_U3ASTA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2_U3ASTA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2_U3ASTA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2_U3ASTA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2_U3ASTA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2_U3ASTA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2_U3ASTA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2_U3ASTA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2_U3ASTA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2_U3ASTA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2_U3ASTA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2_U3ASTA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2_U3ASTA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2_U3ASTA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2_U3ASTA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2_U3ASTA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2_U3ASTA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2_U3ASTA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2_U3ASTA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2_U3ASTA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2_U3ASTA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2_U3ASTA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2_U3ASTA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2_U3ASTA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART2_U3ASTA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART2_U3ASTA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2_U3ASTA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2_U3ASTA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2_U3ASTA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2_U3ASTA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2_U3ASTA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2_U3ASTA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2_U3ASTA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2_U3ASTA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART2_U3ASTA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART2_U3ASTA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART2_U3ASTA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART2_U3ASTA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2_U3ASTA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2_U3ASTA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2_U3ASTA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2_U3ASTA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2_U3ASTA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2_U3ASTA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2_U3ASTA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2_U3ASTA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U3ASTA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U3ASTA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U3ASTA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U3ASTA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2_U3ASTA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2_U3ASTA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART2_U3ASTA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART2_U3ASTA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART2_U3ASTA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART2_U3ASTA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART2_U3ASTA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART2_U3ASTA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2_U3ASTA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2_U3ASTA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2_U3ASTA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2_U3ASTA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2_U3ASTA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2_U3ASTA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2_U3ASTA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2_U3ASTA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART2_U3ASTA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART2_U3ASTA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART2_U3ASTA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART2_U3ASTA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U3ASTA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U3ASTA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U3ASTA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U3ASTA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2_U3ASTA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2_U3ASTA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2_U3ASTA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART5_U3BMODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART5_U3BMODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART5_U3BMODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART5_U3BMODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART5_U3BMODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART5_U3BMODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART5_U3BMODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART5_U3BMODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART5_U3BMODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART5_U3BMODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART5_U3BMODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART5_U3BMODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART5_U3BMODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART5_U3BMODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART5_U3BMODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART5_U3BMODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART5_U3BMODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART5_U3BMODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART5_U3BMODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART5_U3BMODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART5_U3BMODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART5_U3BMODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART5_U3BMODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART5_U3BMODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART5_U3BMODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART5_U3BMODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART5_U3BMODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART5_U3BMODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART5_U3BMODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART5_U3BMODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART5_U3BMODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART5_U3BMODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART5_U3BMODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART5_U3BMODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART5_U3BMODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART5_U3BMODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART5_U3BMODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART5_U3BMODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART5_U3BMODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART5_U3BMODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART5_U3BMODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART5_U3BMODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART5_U3BMODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART5_U3BMODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART5_U3BMODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART5_U3BMODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART5_U3BMODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART5_U3BMODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART5_U3BMODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART5_U3BMODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART5_U3BMODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART5_U3BMODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART5_U3BMODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART5_U3BMODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART5_U3BMODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART5_U3BMODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART5_U5MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART5_U5MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART5_U5MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART5_U5MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART5_U5MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART5_U5MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART5_U5MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART5_U5MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART5_U5MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART5_U5MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART5_U5MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART5_U5MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART5_U5MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART5_U5MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART5_U5MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART5_U5MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART5_U5MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART5_U5MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART5_U5MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART5_U5MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART5_U5MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART5_U5MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART5_U5MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART5_U5MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART5_U5MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART5_U5MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART5_U5MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART5_U5MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART5_U5MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART5_U5MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART5_U5MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART5_U5MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART5_U5MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART5_U5MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART5_U5MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART5_U5MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART5_U5MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART5_U5MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART5_U5MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART5_U5MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART5_U5MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART5_U5MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART5_U5MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART5_U5MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART5_U5MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART5_U5MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART5_U5MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART5_U5MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART5_U5MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART5_U5MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART5_U5MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART5_U5MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART5_U5MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART5_U5MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART5_U5MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART5_U5MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART5_U3BSTA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART5_U3BSTA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART5_U3BSTA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART5_U3BSTA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART5_U3BSTA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART5_U3BSTA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART5_U3BSTA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART5_U3BSTA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART5_U3BSTA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART5_U3BSTA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART5_U3BSTA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART5_U3BSTA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART5_U3BSTA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART5_U3BSTA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART5_U3BSTA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART5_U3BSTA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART5_U3BSTA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART5_U3BSTA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART5_U3BSTA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART5_U3BSTA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART5_U3BSTA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART5_U3BSTA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART5_U3BSTA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART5_U3BSTA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART5_U3BSTA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART5_U3BSTA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART5_U3BSTA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART5_U3BSTA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART5_U3BSTA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART5_U3BSTA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART5_U3BSTA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART5_U3BSTA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART5_U3BSTA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART5_U3BSTA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART5_U3BSTA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART5_U3BSTA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART5_U3BSTA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART5_U3BSTA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART5_U3BSTA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART5_U3BSTA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART5_U3BSTA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART5_U3BSTA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART5_U3BSTA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART5_U3BSTA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART5_U3BSTA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART5_U3BSTA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART5_U3BSTA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART5_U3BSTA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART5_U3BSTA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART5_U3BSTA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART5_U3BSTA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART5_U3BSTA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART5_U3BSTA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART5_U3BSTA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART5_U3BSTA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART5_U3BSTA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART5_U3BSTA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART5_U3BSTA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART5_U3BSTA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART5_U3BSTA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART5_U3BSTA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART5_U3BSTA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART5_U3BSTA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART5_U3BSTA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART5_U3BSTA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART5_U3BSTA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART5_U3BSTA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART5_U3BSTA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART5_U3BSTA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART5_U3BSTA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART5_U3BSTA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART5_U3BSTA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART5_U3BSTA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART5_U3BSTA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART5_U3BSTA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART5_U3BSTA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART5_U3BSTA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART5_U3BSTA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART5_U5STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART5_U5STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART5_U5STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART5_U5STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART5_U5STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART5_U5STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART5_U5STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART5_U5STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART5_U5STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART5_U5STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART5_U5STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART5_U5STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART5_U5STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART5_U5STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART5_U5STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART5_U5STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART5_U5STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART5_U5STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART5_U5STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART5_U5STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART5_U5STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART5_U5STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART5_U5STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART5_U5STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART5_U5STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART5_U5STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART5_U5STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART5_U5STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART5_U5STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART5_U5STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART5_U5STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART5_U5STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART5_U5STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART5_U5STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART5_U5STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART5_U5STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART5_U5STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART5_U5STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART5_U5STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART5_U5STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART5_U5STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART5_U5STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART5_U5STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART5_U5STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART5_U5STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART5_U5STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART5_U5STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART5_U5STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART5_U5STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART5_U5STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART5_U5STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART5_U5STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART5_U5STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART5_U5STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART5_U5STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART5_U5STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART5_U5STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART5_U5STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART5_U5STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART5_U5STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART5_U5STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART5_U5STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART5_U5STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART5_U5STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART5_U5STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART5_U5STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART5_U5STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART5_U5STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART5_U5STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART5_U5STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART5_U5STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART5_U5STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART5_U5STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART5_U5STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART5_U5STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART5_U5STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART5_U5STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART5_U5STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMCON.setRDSP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPMP_PMCON.clearRDSP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPMP_PMCON.setRDSP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPMP_PMCON.getRDSP : TBits_1; inline;
begin
  getRDSP := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPMP_PMCON.setWRSP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPMP_PMCON.clearWRSP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPMP_PMCON.setWRSP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPMP_PMCON.getWRSP : TBits_1; inline;
begin
  getWRSP := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPMP_PMCON.setCS1P; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPMP_PMCON.clearCS1P; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPMP_PMCON.setCS1P(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPMP_PMCON.getCS1P : TBits_1; inline;
begin
  getCS1P := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPMP_PMCON.setCS2P; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPMP_PMCON.clearCS2P; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPMP_PMCON.setCS2P(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPMP_PMCON.getCS2P : TBits_1; inline;
begin
  getCS2P := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPMP_PMCON.setALP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPMP_PMCON.clearALP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPMP_PMCON.setALP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPMP_PMCON.getALP : TBits_1; inline;
begin
  getALP := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPMP_PMCON.setCSF(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TPMP_PMCON.getCSF : TBits_2; inline;
begin
  getCSF := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TPMP_PMCON.setPTRDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPMP_PMCON.clearPTRDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPMP_PMCON.setPTRDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPMP_PMCON.getPTRDEN : TBits_1; inline;
begin
  getPTRDEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPMP_PMCON.setPTWREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPMP_PMCON.clearPTWREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPMP_PMCON.setPTWREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPMP_PMCON.getPTWREN : TBits_1; inline;
begin
  getPTWREN := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPMP_PMCON.setPMPTTL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPMP_PMCON.clearPMPTTL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPMP_PMCON.setPMPTTL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPMP_PMCON.getPMPTTL : TBits_1; inline;
begin
  getPMPTTL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPMP_PMCON.setADRMUX(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE7FF or ( thebits shl 11 );
end;
function  TPMP_PMCON.getADRMUX : TBits_2; inline;
begin
  getADRMUX := (pTDefRegMap(@Self)^.val and $00001800) shr 11;
end;
procedure TPMP_PMCON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPMP_PMCON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPMP_PMCON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPMP_PMCON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPMP_PMCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMCON.setCSF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPMP_PMCON.clearCSF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPMP_PMCON.setCSF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPMP_PMCON.getCSF0 : TBits_1; inline;
begin
  getCSF0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPMP_PMCON.setCSF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPMP_PMCON.clearCSF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPMP_PMCON.setCSF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPMP_PMCON.getCSF1 : TBits_1; inline;
begin
  getCSF1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPMP_PMCON.setADRMUX0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPMP_PMCON.clearADRMUX0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPMP_PMCON.setADRMUX0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPMP_PMCON.getADRMUX0 : TBits_1; inline;
begin
  getADRMUX0 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPMP_PMCON.setADRMUX1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPMP_PMCON.clearADRMUX1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPMP_PMCON.setADRMUX1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPMP_PMCON.getADRMUX1 : TBits_1; inline;
begin
  getADRMUX1 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPMP_PMCON.setPSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPMP_PMCON.clearPSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPMP_PMCON.setPSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPMP_PMCON.getPSIDL : TBits_1; inline;
begin
  getPSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPMP_PMCON.setPMPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMCON.clearPMPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMCON.setPMPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMCON.getPMPEN : TBits_1; inline;
begin
  getPMPEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMMODE.setWAITE(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TPMP_PMMODE.getWAITE : TBits_2; inline;
begin
  getWAITE := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TPMP_PMMODE.setWAITM(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFC3 or ( thebits shl 2 );
end;
function  TPMP_PMMODE.getWAITM : TBits_4; inline;
begin
  getWAITM := (pTDefRegMap(@Self)^.val and $0000003C) shr 2;
end;
procedure TPMP_PMMODE.setWAITB(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TPMP_PMMODE.getWAITB : TBits_2; inline;
begin
  getWAITB := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TPMP_PMMODE.setMODE(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TPMP_PMMODE.getMODE : TBits_2; inline;
begin
  getMODE := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TPMP_PMMODE.setMODE16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPMP_PMMODE.clearMODE16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPMP_PMMODE.setMODE16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPMP_PMMODE.getMODE16 : TBits_1; inline;
begin
  getMODE16 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPMP_PMMODE.setINCM(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE7FF or ( thebits shl 11 );
end;
function  TPMP_PMMODE.getINCM : TBits_2; inline;
begin
  getINCM := (pTDefRegMap(@Self)^.val and $00001800) shr 11;
end;
procedure TPMP_PMMODE.setIRQM(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF9FFF or ( thebits shl 13 );
end;
function  TPMP_PMMODE.getIRQM : TBits_2; inline;
begin
  getIRQM := (pTDefRegMap(@Self)^.val and $00006000) shr 13;
end;
procedure TPMP_PMMODE.setBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMMODE.clearBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMMODE.setBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMMODE.getBUSY : TBits_1; inline;
begin
  getBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMMODE.setWAITE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPMP_PMMODE.clearWAITE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPMP_PMMODE.setWAITE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPMP_PMMODE.getWAITE0 : TBits_1; inline;
begin
  getWAITE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPMP_PMMODE.setWAITE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPMP_PMMODE.clearWAITE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPMP_PMMODE.setWAITE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPMP_PMMODE.getWAITE1 : TBits_1; inline;
begin
  getWAITE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPMP_PMMODE.setWAITM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPMP_PMMODE.clearWAITM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPMP_PMMODE.setWAITM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPMP_PMMODE.getWAITM0 : TBits_1; inline;
begin
  getWAITM0 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPMP_PMMODE.setWAITM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPMP_PMMODE.clearWAITM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPMP_PMMODE.setWAITM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPMP_PMMODE.getWAITM1 : TBits_1; inline;
begin
  getWAITM1 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPMP_PMMODE.setWAITM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPMP_PMMODE.clearWAITM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPMP_PMMODE.setWAITM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPMP_PMMODE.getWAITM2 : TBits_1; inline;
begin
  getWAITM2 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPMP_PMMODE.setWAITM3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPMP_PMMODE.clearWAITM3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPMP_PMMODE.setWAITM3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPMP_PMMODE.getWAITM3 : TBits_1; inline;
begin
  getWAITM3 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPMP_PMMODE.setWAITB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPMP_PMMODE.clearWAITB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPMP_PMMODE.setWAITB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPMP_PMMODE.getWAITB0 : TBits_1; inline;
begin
  getWAITB0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPMP_PMMODE.setWAITB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPMP_PMMODE.clearWAITB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPMP_PMMODE.setWAITB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPMP_PMMODE.getWAITB1 : TBits_1; inline;
begin
  getWAITB1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPMP_PMMODE.setMODE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPMP_PMMODE.clearMODE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPMP_PMMODE.setMODE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPMP_PMMODE.getMODE0 : TBits_1; inline;
begin
  getMODE0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPMP_PMMODE.setMODE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPMP_PMMODE.clearMODE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPMP_PMMODE.setMODE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPMP_PMMODE.getMODE1 : TBits_1; inline;
begin
  getMODE1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPMP_PMMODE.setINCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPMP_PMMODE.clearINCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPMP_PMMODE.setINCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPMP_PMMODE.getINCM0 : TBits_1; inline;
begin
  getINCM0 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPMP_PMMODE.setINCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPMP_PMMODE.clearINCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPMP_PMMODE.setINCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPMP_PMMODE.getINCM1 : TBits_1; inline;
begin
  getINCM1 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPMP_PMMODE.setIRQM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPMP_PMMODE.clearIRQM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPMP_PMMODE.setIRQM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPMP_PMMODE.getIRQM0 : TBits_1; inline;
begin
  getIRQM0 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPMP_PMMODE.setIRQM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPMP_PMMODE.clearIRQM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPMP_PMMODE.setIRQM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPMP_PMMODE.getIRQM1 : TBits_1; inline;
begin
  getIRQM1 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPMP_PMMODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMMODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMADDR.setADDR(thebits : TBits_14); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFC000 or ( thebits shl 0 );
end;
function  TPMP_PMADDR.getADDR : TBits_14; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00003FFF) shr 0;
end;
procedure TPMP_PMADDR.setCS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TPMP_PMADDR.getCS : TBits_2; inline;
begin
  getCS := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TPMP_PMADDR.setPADDR(thebits : TBits_14); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFC000 or ( thebits shl 0 );
end;
function  TPMP_PMADDR.getPADDR : TBits_14; inline;
begin
  getPADDR := (pTDefRegMap(@Self)^.val and $00003FFF) shr 0;
end;
procedure TPMP_PMADDR.setCS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPMP_PMADDR.clearCS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPMP_PMADDR.setCS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPMP_PMADDR.getCS1 : TBits_1; inline;
begin
  getCS1 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPMP_PMADDR.setCS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMADDR.clearCS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMADDR.setCS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMADDR.getCS2 : TBits_1; inline;
begin
  getCS2 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMADDR.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMADDR.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMDOUT.setDATAOUT(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMDOUT.getDATAOUT : TBits_32; inline;
begin
  getDATAOUT := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMDOUT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMDOUT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMDIN.setDATAIN(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMDIN.getDATAIN : TBits_32; inline;
begin
  getDATAIN := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMDIN.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMDIN.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMAEN.setPTEN(thebits : TBits_16); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0000 or ( thebits shl 0 );
end;
function  TPMP_PMAEN.getPTEN : TBits_16; inline;
begin
  getPTEN := (pTDefRegMap(@Self)^.val and $0000FFFF) shr 0;
end;
procedure TPMP_PMAEN.setPTEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPMP_PMAEN.clearPTEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPMP_PMAEN.setPTEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPMP_PMAEN.getPTEN0 : TBits_1; inline;
begin
  getPTEN0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPMP_PMAEN.setPTEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPMP_PMAEN.clearPTEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPMP_PMAEN.setPTEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPMP_PMAEN.getPTEN1 : TBits_1; inline;
begin
  getPTEN1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPMP_PMAEN.setPTEN2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPMP_PMAEN.clearPTEN2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPMP_PMAEN.setPTEN2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPMP_PMAEN.getPTEN2 : TBits_1; inline;
begin
  getPTEN2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPMP_PMAEN.setPTEN3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPMP_PMAEN.clearPTEN3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPMP_PMAEN.setPTEN3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPMP_PMAEN.getPTEN3 : TBits_1; inline;
begin
  getPTEN3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPMP_PMAEN.setPTEN4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPMP_PMAEN.clearPTEN4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPMP_PMAEN.setPTEN4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPMP_PMAEN.getPTEN4 : TBits_1; inline;
begin
  getPTEN4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPMP_PMAEN.setPTEN5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPMP_PMAEN.clearPTEN5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPMP_PMAEN.setPTEN5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPMP_PMAEN.getPTEN5 : TBits_1; inline;
begin
  getPTEN5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPMP_PMAEN.setPTEN6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPMP_PMAEN.clearPTEN6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPMP_PMAEN.setPTEN6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPMP_PMAEN.getPTEN6 : TBits_1; inline;
begin
  getPTEN6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPMP_PMAEN.setPTEN7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPMP_PMAEN.clearPTEN7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPMP_PMAEN.setPTEN7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPMP_PMAEN.getPTEN7 : TBits_1; inline;
begin
  getPTEN7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPMP_PMAEN.setPTEN8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPMP_PMAEN.clearPTEN8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPMP_PMAEN.setPTEN8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPMP_PMAEN.getPTEN8 : TBits_1; inline;
begin
  getPTEN8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPMP_PMAEN.setPTEN9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPMP_PMAEN.clearPTEN9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPMP_PMAEN.setPTEN9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPMP_PMAEN.getPTEN9 : TBits_1; inline;
begin
  getPTEN9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPMP_PMAEN.setPTEN10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPMP_PMAEN.clearPTEN10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPMP_PMAEN.setPTEN10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPMP_PMAEN.getPTEN10 : TBits_1; inline;
begin
  getPTEN10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPMP_PMAEN.setPTEN11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPMP_PMAEN.clearPTEN11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPMP_PMAEN.setPTEN11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPMP_PMAEN.getPTEN11 : TBits_1; inline;
begin
  getPTEN11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPMP_PMAEN.setPTEN12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPMP_PMAEN.clearPTEN12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPMP_PMAEN.setPTEN12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPMP_PMAEN.getPTEN12 : TBits_1; inline;
begin
  getPTEN12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPMP_PMAEN.setPTEN13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPMP_PMAEN.clearPTEN13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPMP_PMAEN.setPTEN13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPMP_PMAEN.getPTEN13 : TBits_1; inline;
begin
  getPTEN13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPMP_PMAEN.setPTEN14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPMP_PMAEN.clearPTEN14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPMP_PMAEN.setPTEN14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPMP_PMAEN.getPTEN14 : TBits_1; inline;
begin
  getPTEN14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPMP_PMAEN.setPTEN15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMAEN.clearPTEN15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMAEN.setPTEN15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMAEN.getPTEN15 : TBits_1; inline;
begin
  getPTEN15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMAEN.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMAEN.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMSTAT.setOB0E; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPMP_PMSTAT.clearOB0E; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPMP_PMSTAT.setOB0E(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPMP_PMSTAT.getOB0E : TBits_1; inline;
begin
  getOB0E := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPMP_PMSTAT.setOB1E; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPMP_PMSTAT.clearOB1E; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPMP_PMSTAT.setOB1E(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPMP_PMSTAT.getOB1E : TBits_1; inline;
begin
  getOB1E := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPMP_PMSTAT.setOB2E; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPMP_PMSTAT.clearOB2E; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPMP_PMSTAT.setOB2E(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPMP_PMSTAT.getOB2E : TBits_1; inline;
begin
  getOB2E := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPMP_PMSTAT.setOB3E; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPMP_PMSTAT.clearOB3E; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPMP_PMSTAT.setOB3E(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPMP_PMSTAT.getOB3E : TBits_1; inline;
begin
  getOB3E := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPMP_PMSTAT.setOBUF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPMP_PMSTAT.clearOBUF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPMP_PMSTAT.setOBUF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPMP_PMSTAT.getOBUF : TBits_1; inline;
begin
  getOBUF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPMP_PMSTAT.setOBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPMP_PMSTAT.clearOBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPMP_PMSTAT.setOBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPMP_PMSTAT.getOBE : TBits_1; inline;
begin
  getOBE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPMP_PMSTAT.setIB0F; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPMP_PMSTAT.clearIB0F; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPMP_PMSTAT.setIB0F(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPMP_PMSTAT.getIB0F : TBits_1; inline;
begin
  getIB0F := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPMP_PMSTAT.setIB1F; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPMP_PMSTAT.clearIB1F; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPMP_PMSTAT.setIB1F(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPMP_PMSTAT.getIB1F : TBits_1; inline;
begin
  getIB1F := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPMP_PMSTAT.setIB2F; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPMP_PMSTAT.clearIB2F; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPMP_PMSTAT.setIB2F(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPMP_PMSTAT.getIB2F : TBits_1; inline;
begin
  getIB2F := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPMP_PMSTAT.setIB3F; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPMP_PMSTAT.clearIB3F; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPMP_PMSTAT.setIB3F(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPMP_PMSTAT.getIB3F : TBits_1; inline;
begin
  getIB3F := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPMP_PMSTAT.setIBOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPMP_PMSTAT.clearIBOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPMP_PMSTAT.setIBOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPMP_PMSTAT.getIBOV : TBits_1; inline;
begin
  getIBOV := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPMP_PMSTAT.setIBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMSTAT.clearIBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMSTAT.setIBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMSTAT.getIBF : TBits_1; inline;
begin
  getIBF := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMSTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMSTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CON1.setDONE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TADC10_AD1CON1.clearDONE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TADC10_AD1CON1.setDONE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TADC10_AD1CON1.getDONE : TBits_1; inline;
begin
  getDONE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TADC10_AD1CON1.setSAMP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TADC10_AD1CON1.clearSAMP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TADC10_AD1CON1.setSAMP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TADC10_AD1CON1.getSAMP : TBits_1; inline;
begin
  getSAMP := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TADC10_AD1CON1.setASAM; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TADC10_AD1CON1.clearASAM; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TADC10_AD1CON1.setASAM(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TADC10_AD1CON1.getASAM : TBits_1; inline;
begin
  getASAM := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TADC10_AD1CON1.setCLRASAM; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TADC10_AD1CON1.clearCLRASAM; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TADC10_AD1CON1.setCLRASAM(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TADC10_AD1CON1.getCLRASAM : TBits_1; inline;
begin
  getCLRASAM := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TADC10_AD1CON1.setSSRC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF1F or ( thebits shl 5 );
end;
function  TADC10_AD1CON1.getSSRC : TBits_3; inline;
begin
  getSSRC := (pTDefRegMap(@Self)^.val and $000000E0) shr 5;
end;
procedure TADC10_AD1CON1.setFORM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF8FF or ( thebits shl 8 );
end;
function  TADC10_AD1CON1.getFORM : TBits_3; inline;
begin
  getFORM := (pTDefRegMap(@Self)^.val and $00000700) shr 8;
end;
procedure TADC10_AD1CON1.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TADC10_AD1CON1.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TADC10_AD1CON1.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TADC10_AD1CON1.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TADC10_AD1CON1.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CON1.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CON1.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CON1.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CON1.setSSRC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TADC10_AD1CON1.clearSSRC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TADC10_AD1CON1.setSSRC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TADC10_AD1CON1.getSSRC0 : TBits_1; inline;
begin
  getSSRC0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TADC10_AD1CON1.setSSRC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TADC10_AD1CON1.clearSSRC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TADC10_AD1CON1.setSSRC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TADC10_AD1CON1.getSSRC1 : TBits_1; inline;
begin
  getSSRC1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TADC10_AD1CON1.setSSRC2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TADC10_AD1CON1.clearSSRC2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TADC10_AD1CON1.setSSRC2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TADC10_AD1CON1.getSSRC2 : TBits_1; inline;
begin
  getSSRC2 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TADC10_AD1CON1.setFORM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TADC10_AD1CON1.clearFORM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TADC10_AD1CON1.setFORM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TADC10_AD1CON1.getFORM0 : TBits_1; inline;
begin
  getFORM0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TADC10_AD1CON1.setFORM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TADC10_AD1CON1.clearFORM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TADC10_AD1CON1.setFORM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TADC10_AD1CON1.getFORM1 : TBits_1; inline;
begin
  getFORM1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TADC10_AD1CON1.setFORM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TADC10_AD1CON1.clearFORM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TADC10_AD1CON1.setFORM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TADC10_AD1CON1.getFORM2 : TBits_1; inline;
begin
  getFORM2 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TADC10_AD1CON1.setADSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TADC10_AD1CON1.clearADSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TADC10_AD1CON1.setADSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TADC10_AD1CON1.getADSIDL : TBits_1; inline;
begin
  getADSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TADC10_AD1CON1.setADON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CON1.clearADON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CON1.setADON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CON1.getADON : TBits_1; inline;
begin
  getADON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CON1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CON1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CON2.setALTS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TADC10_AD1CON2.clearALTS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TADC10_AD1CON2.setALTS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TADC10_AD1CON2.getALTS : TBits_1; inline;
begin
  getALTS := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TADC10_AD1CON2.setBUFM; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TADC10_AD1CON2.clearBUFM; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TADC10_AD1CON2.setBUFM(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TADC10_AD1CON2.getBUFM : TBits_1; inline;
begin
  getBUFM := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TADC10_AD1CON2.setSMPI(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFC3 or ( thebits shl 2 );
end;
function  TADC10_AD1CON2.getSMPI : TBits_4; inline;
begin
  getSMPI := (pTDefRegMap(@Self)^.val and $0000003C) shr 2;
end;
procedure TADC10_AD1CON2.setBUFS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TADC10_AD1CON2.clearBUFS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TADC10_AD1CON2.setBUFS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TADC10_AD1CON2.getBUFS : TBits_1; inline;
begin
  getBUFS := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TADC10_AD1CON2.setCSCNA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TADC10_AD1CON2.clearCSCNA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TADC10_AD1CON2.setCSCNA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TADC10_AD1CON2.getCSCNA : TBits_1; inline;
begin
  getCSCNA := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TADC10_AD1CON2.setOFFCAL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TADC10_AD1CON2.clearOFFCAL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TADC10_AD1CON2.setOFFCAL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TADC10_AD1CON2.getOFFCAL : TBits_1; inline;
begin
  getOFFCAL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TADC10_AD1CON2.setVCFG(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF1FFF or ( thebits shl 13 );
end;
function  TADC10_AD1CON2.getVCFG : TBits_3; inline;
begin
  getVCFG := (pTDefRegMap(@Self)^.val and $0000E000) shr 13;
end;
procedure TADC10_AD1CON2.setSMPI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TADC10_AD1CON2.clearSMPI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TADC10_AD1CON2.setSMPI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TADC10_AD1CON2.getSMPI0 : TBits_1; inline;
begin
  getSMPI0 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TADC10_AD1CON2.setSMPI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TADC10_AD1CON2.clearSMPI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TADC10_AD1CON2.setSMPI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TADC10_AD1CON2.getSMPI1 : TBits_1; inline;
begin
  getSMPI1 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TADC10_AD1CON2.setSMPI2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TADC10_AD1CON2.clearSMPI2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TADC10_AD1CON2.setSMPI2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TADC10_AD1CON2.getSMPI2 : TBits_1; inline;
begin
  getSMPI2 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TADC10_AD1CON2.setSMPI3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TADC10_AD1CON2.clearSMPI3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TADC10_AD1CON2.setSMPI3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TADC10_AD1CON2.getSMPI3 : TBits_1; inline;
begin
  getSMPI3 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TADC10_AD1CON2.setVCFG0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TADC10_AD1CON2.clearVCFG0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TADC10_AD1CON2.setVCFG0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TADC10_AD1CON2.getVCFG0 : TBits_1; inline;
begin
  getVCFG0 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TADC10_AD1CON2.setVCFG1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TADC10_AD1CON2.clearVCFG1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TADC10_AD1CON2.setVCFG1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TADC10_AD1CON2.getVCFG1 : TBits_1; inline;
begin
  getVCFG1 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TADC10_AD1CON2.setVCFG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CON2.clearVCFG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CON2.setVCFG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CON2.getVCFG2 : TBits_1; inline;
begin
  getVCFG2 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CON2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CON2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CON3.setADCS(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF00 or ( thebits shl 0 );
end;
function  TADC10_AD1CON3.getADCS : TBits_8; inline;
begin
  getADCS := (pTDefRegMap(@Self)^.val and $000000FF) shr 0;
end;
procedure TADC10_AD1CON3.setSAMC(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TADC10_AD1CON3.getSAMC : TBits_5; inline;
begin
  getSAMC := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TADC10_AD1CON3.setADRC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CON3.clearADRC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CON3.setADRC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CON3.getADRC : TBits_1; inline;
begin
  getADRC := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CON3.setADCS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TADC10_AD1CON3.clearADCS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TADC10_AD1CON3.setADCS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TADC10_AD1CON3.getADCS0 : TBits_1; inline;
begin
  getADCS0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TADC10_AD1CON3.setADCS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TADC10_AD1CON3.clearADCS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TADC10_AD1CON3.setADCS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TADC10_AD1CON3.getADCS1 : TBits_1; inline;
begin
  getADCS1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TADC10_AD1CON3.setADCS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TADC10_AD1CON3.clearADCS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TADC10_AD1CON3.setADCS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TADC10_AD1CON3.getADCS2 : TBits_1; inline;
begin
  getADCS2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TADC10_AD1CON3.setADCS3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TADC10_AD1CON3.clearADCS3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TADC10_AD1CON3.setADCS3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TADC10_AD1CON3.getADCS3 : TBits_1; inline;
begin
  getADCS3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TADC10_AD1CON3.setADCS4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TADC10_AD1CON3.clearADCS4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TADC10_AD1CON3.setADCS4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TADC10_AD1CON3.getADCS4 : TBits_1; inline;
begin
  getADCS4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TADC10_AD1CON3.setADCS5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TADC10_AD1CON3.clearADCS5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TADC10_AD1CON3.setADCS5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TADC10_AD1CON3.getADCS5 : TBits_1; inline;
begin
  getADCS5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TADC10_AD1CON3.setADCS6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TADC10_AD1CON3.clearADCS6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TADC10_AD1CON3.setADCS6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TADC10_AD1CON3.getADCS6 : TBits_1; inline;
begin
  getADCS6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TADC10_AD1CON3.setADCS7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TADC10_AD1CON3.clearADCS7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TADC10_AD1CON3.setADCS7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TADC10_AD1CON3.getADCS7 : TBits_1; inline;
begin
  getADCS7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TADC10_AD1CON3.setSAMC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TADC10_AD1CON3.clearSAMC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TADC10_AD1CON3.setSAMC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TADC10_AD1CON3.getSAMC0 : TBits_1; inline;
begin
  getSAMC0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TADC10_AD1CON3.setSAMC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TADC10_AD1CON3.clearSAMC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TADC10_AD1CON3.setSAMC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TADC10_AD1CON3.getSAMC1 : TBits_1; inline;
begin
  getSAMC1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TADC10_AD1CON3.setSAMC2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TADC10_AD1CON3.clearSAMC2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TADC10_AD1CON3.setSAMC2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TADC10_AD1CON3.getSAMC2 : TBits_1; inline;
begin
  getSAMC2 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TADC10_AD1CON3.setSAMC3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TADC10_AD1CON3.clearSAMC3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TADC10_AD1CON3.setSAMC3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TADC10_AD1CON3.getSAMC3 : TBits_1; inline;
begin
  getSAMC3 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TADC10_AD1CON3.setSAMC4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TADC10_AD1CON3.clearSAMC4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TADC10_AD1CON3.setSAMC4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TADC10_AD1CON3.getSAMC4 : TBits_1; inline;
begin
  getSAMC4 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TADC10_AD1CON3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CON3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CHS.setCH0SA(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TADC10_AD1CHS.getCH0SA : TBits_4; inline;
begin
  getCH0SA := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TADC10_AD1CHS.setCH0NA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TADC10_AD1CHS.clearCH0NA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TADC10_AD1CHS.setCH0NA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TADC10_AD1CHS.getCH0NA : TBits_1; inline;
begin
  getCH0NA := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TADC10_AD1CHS.setCH0SB(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F0FFFFFF or ( thebits shl 24 );
end;
function  TADC10_AD1CHS.getCH0SB : TBits_4; inline;
begin
  getCH0SB := (pTDefRegMap(@Self)^.val and $0F000000) shr 24;
end;
procedure TADC10_AD1CHS.setCH0NB; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TADC10_AD1CHS.clearCH0NB; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TADC10_AD1CHS.setCH0NB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TADC10_AD1CHS.getCH0NB : TBits_1; inline;
begin
  getCH0NB := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TADC10_AD1CHS.setCH0SA0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TADC10_AD1CHS.clearCH0SA0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TADC10_AD1CHS.setCH0SA0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TADC10_AD1CHS.getCH0SA0 : TBits_1; inline;
begin
  getCH0SA0 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TADC10_AD1CHS.setCH0SA1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TADC10_AD1CHS.clearCH0SA1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TADC10_AD1CHS.setCH0SA1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TADC10_AD1CHS.getCH0SA1 : TBits_1; inline;
begin
  getCH0SA1 := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TADC10_AD1CHS.setCH0SA2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TADC10_AD1CHS.clearCH0SA2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TADC10_AD1CHS.setCH0SA2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TADC10_AD1CHS.getCH0SA2 : TBits_1; inline;
begin
  getCH0SA2 := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TADC10_AD1CHS.setCH0SA3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TADC10_AD1CHS.clearCH0SA3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TADC10_AD1CHS.setCH0SA3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TADC10_AD1CHS.getCH0SA3 : TBits_1; inline;
begin
  getCH0SA3 := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TADC10_AD1CHS.setCH0SB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TADC10_AD1CHS.clearCH0SB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TADC10_AD1CHS.setCH0SB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TADC10_AD1CHS.getCH0SB0 : TBits_1; inline;
begin
  getCH0SB0 := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TADC10_AD1CHS.setCH0SB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TADC10_AD1CHS.clearCH0SB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TADC10_AD1CHS.setCH0SB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TADC10_AD1CHS.getCH0SB1 : TBits_1; inline;
begin
  getCH0SB1 := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TADC10_AD1CHS.setCH0SB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TADC10_AD1CHS.clearCH0SB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TADC10_AD1CHS.setCH0SB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TADC10_AD1CHS.getCH0SB2 : TBits_1; inline;
begin
  getCH0SB2 := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TADC10_AD1CHS.setCH0SB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TADC10_AD1CHS.clearCH0SB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TADC10_AD1CHS.setCH0SB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TADC10_AD1CHS.getCH0SB3 : TBits_1; inline;
begin
  getCH0SB3 := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TADC10_AD1CHS.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CHS.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CSSL.setCSSL(thebits : TBits_16); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0000 or ( thebits shl 0 );
end;
function  TADC10_AD1CSSL.getCSSL : TBits_16; inline;
begin
  getCSSL := (pTDefRegMap(@Self)^.val and $0000FFFF) shr 0;
end;
procedure TADC10_AD1CSSL.setCSSL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TADC10_AD1CSSL.clearCSSL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TADC10_AD1CSSL.setCSSL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TADC10_AD1CSSL.getCSSL0 : TBits_1; inline;
begin
  getCSSL0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TADC10_AD1CSSL.setCSSL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TADC10_AD1CSSL.clearCSSL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TADC10_AD1CSSL.setCSSL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TADC10_AD1CSSL.getCSSL1 : TBits_1; inline;
begin
  getCSSL1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TADC10_AD1CSSL.setCSSL2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TADC10_AD1CSSL.clearCSSL2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TADC10_AD1CSSL.setCSSL2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TADC10_AD1CSSL.getCSSL2 : TBits_1; inline;
begin
  getCSSL2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TADC10_AD1CSSL.setCSSL3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TADC10_AD1CSSL.clearCSSL3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TADC10_AD1CSSL.setCSSL3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TADC10_AD1CSSL.getCSSL3 : TBits_1; inline;
begin
  getCSSL3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TADC10_AD1CSSL.setCSSL4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TADC10_AD1CSSL.clearCSSL4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TADC10_AD1CSSL.setCSSL4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TADC10_AD1CSSL.getCSSL4 : TBits_1; inline;
begin
  getCSSL4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TADC10_AD1CSSL.setCSSL5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TADC10_AD1CSSL.clearCSSL5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TADC10_AD1CSSL.setCSSL5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TADC10_AD1CSSL.getCSSL5 : TBits_1; inline;
begin
  getCSSL5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TADC10_AD1CSSL.setCSSL6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TADC10_AD1CSSL.clearCSSL6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TADC10_AD1CSSL.setCSSL6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TADC10_AD1CSSL.getCSSL6 : TBits_1; inline;
begin
  getCSSL6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TADC10_AD1CSSL.setCSSL7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TADC10_AD1CSSL.clearCSSL7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TADC10_AD1CSSL.setCSSL7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TADC10_AD1CSSL.getCSSL7 : TBits_1; inline;
begin
  getCSSL7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TADC10_AD1CSSL.setCSSL8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TADC10_AD1CSSL.clearCSSL8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TADC10_AD1CSSL.setCSSL8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TADC10_AD1CSSL.getCSSL8 : TBits_1; inline;
begin
  getCSSL8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TADC10_AD1CSSL.setCSSL9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TADC10_AD1CSSL.clearCSSL9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TADC10_AD1CSSL.setCSSL9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TADC10_AD1CSSL.getCSSL9 : TBits_1; inline;
begin
  getCSSL9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TADC10_AD1CSSL.setCSSL10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TADC10_AD1CSSL.clearCSSL10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TADC10_AD1CSSL.setCSSL10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TADC10_AD1CSSL.getCSSL10 : TBits_1; inline;
begin
  getCSSL10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TADC10_AD1CSSL.setCSSL11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TADC10_AD1CSSL.clearCSSL11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TADC10_AD1CSSL.setCSSL11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TADC10_AD1CSSL.getCSSL11 : TBits_1; inline;
begin
  getCSSL11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TADC10_AD1CSSL.setCSSL12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TADC10_AD1CSSL.clearCSSL12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TADC10_AD1CSSL.setCSSL12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TADC10_AD1CSSL.getCSSL12 : TBits_1; inline;
begin
  getCSSL12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TADC10_AD1CSSL.setCSSL13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TADC10_AD1CSSL.clearCSSL13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TADC10_AD1CSSL.setCSSL13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TADC10_AD1CSSL.getCSSL13 : TBits_1; inline;
begin
  getCSSL13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TADC10_AD1CSSL.setCSSL14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TADC10_AD1CSSL.clearCSSL14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TADC10_AD1CSSL.setCSSL14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TADC10_AD1CSSL.getCSSL14 : TBits_1; inline;
begin
  getCSSL14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TADC10_AD1CSSL.setCSSL15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CSSL.clearCSSL15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CSSL.setCSSL15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CSSL.getCSSL15 : TBits_1; inline;
begin
  getCSSL15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CSSL.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CSSL.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1PCFG.setPCFG(thebits : TBits_16); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0000 or ( thebits shl 0 );
end;
function  TADC10_AD1PCFG.getPCFG : TBits_16; inline;
begin
  getPCFG := (pTDefRegMap(@Self)^.val and $0000FFFF) shr 0;
end;
procedure TADC10_AD1PCFG.setPCFG0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TADC10_AD1PCFG.clearPCFG0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TADC10_AD1PCFG.setPCFG0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TADC10_AD1PCFG.getPCFG0 : TBits_1; inline;
begin
  getPCFG0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TADC10_AD1PCFG.setPCFG1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TADC10_AD1PCFG.clearPCFG1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TADC10_AD1PCFG.setPCFG1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TADC10_AD1PCFG.getPCFG1 : TBits_1; inline;
begin
  getPCFG1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TADC10_AD1PCFG.setPCFG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TADC10_AD1PCFG.clearPCFG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TADC10_AD1PCFG.setPCFG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TADC10_AD1PCFG.getPCFG2 : TBits_1; inline;
begin
  getPCFG2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TADC10_AD1PCFG.setPCFG3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TADC10_AD1PCFG.clearPCFG3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TADC10_AD1PCFG.setPCFG3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TADC10_AD1PCFG.getPCFG3 : TBits_1; inline;
begin
  getPCFG3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TADC10_AD1PCFG.setPCFG4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TADC10_AD1PCFG.clearPCFG4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TADC10_AD1PCFG.setPCFG4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TADC10_AD1PCFG.getPCFG4 : TBits_1; inline;
begin
  getPCFG4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TADC10_AD1PCFG.setPCFG5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TADC10_AD1PCFG.clearPCFG5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TADC10_AD1PCFG.setPCFG5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TADC10_AD1PCFG.getPCFG5 : TBits_1; inline;
begin
  getPCFG5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TADC10_AD1PCFG.setPCFG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TADC10_AD1PCFG.clearPCFG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TADC10_AD1PCFG.setPCFG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TADC10_AD1PCFG.getPCFG6 : TBits_1; inline;
begin
  getPCFG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TADC10_AD1PCFG.setPCFG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TADC10_AD1PCFG.clearPCFG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TADC10_AD1PCFG.setPCFG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TADC10_AD1PCFG.getPCFG7 : TBits_1; inline;
begin
  getPCFG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TADC10_AD1PCFG.setPCFG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TADC10_AD1PCFG.clearPCFG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TADC10_AD1PCFG.setPCFG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TADC10_AD1PCFG.getPCFG8 : TBits_1; inline;
begin
  getPCFG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TADC10_AD1PCFG.setPCFG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TADC10_AD1PCFG.clearPCFG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TADC10_AD1PCFG.setPCFG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TADC10_AD1PCFG.getPCFG9 : TBits_1; inline;
begin
  getPCFG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TADC10_AD1PCFG.setPCFG10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TADC10_AD1PCFG.clearPCFG10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TADC10_AD1PCFG.setPCFG10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TADC10_AD1PCFG.getPCFG10 : TBits_1; inline;
begin
  getPCFG10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TADC10_AD1PCFG.setPCFG11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TADC10_AD1PCFG.clearPCFG11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TADC10_AD1PCFG.setPCFG11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TADC10_AD1PCFG.getPCFG11 : TBits_1; inline;
begin
  getPCFG11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TADC10_AD1PCFG.setPCFG12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TADC10_AD1PCFG.clearPCFG12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TADC10_AD1PCFG.setPCFG12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TADC10_AD1PCFG.getPCFG12 : TBits_1; inline;
begin
  getPCFG12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TADC10_AD1PCFG.setPCFG13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TADC10_AD1PCFG.clearPCFG13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TADC10_AD1PCFG.setPCFG13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TADC10_AD1PCFG.getPCFG13 : TBits_1; inline;
begin
  getPCFG13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TADC10_AD1PCFG.setPCFG14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TADC10_AD1PCFG.clearPCFG14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TADC10_AD1PCFG.setPCFG14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TADC10_AD1PCFG.getPCFG14 : TBits_1; inline;
begin
  getPCFG14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TADC10_AD1PCFG.setPCFG15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1PCFG.clearPCFG15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1PCFG.setPCFG15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1PCFG.getPCFG15 : TBits_1; inline;
begin
  getPCFG15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1PCFG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1PCFG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCVR_CVRCON.setCVR(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TCVR_CVRCON.getCVR : TBits_4; inline;
begin
  getCVR := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TCVR_CVRCON.setCVRSS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCVR_CVRCON.clearCVRSS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCVR_CVRCON.setCVRSS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCVR_CVRCON.getCVRSS : TBits_1; inline;
begin
  getCVRSS := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCVR_CVRCON.setCVRR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCVR_CVRCON.clearCVRR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCVR_CVRCON.setCVRR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCVR_CVRCON.getCVRR : TBits_1; inline;
begin
  getCVRR := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCVR_CVRCON.setCVROE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCVR_CVRCON.clearCVROE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCVR_CVRCON.setCVROE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCVR_CVRCON.getCVROE : TBits_1; inline;
begin
  getCVROE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCVR_CVRCON.setBGSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TCVR_CVRCON.getBGSEL : TBits_2; inline;
begin
  getBGSEL := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TCVR_CVRCON.setVREFSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCVR_CVRCON.clearVREFSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCVR_CVRCON.setVREFSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCVR_CVRCON.getVREFSEL : TBits_1; inline;
begin
  getVREFSEL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCVR_CVRCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCVR_CVRCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCVR_CVRCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCVR_CVRCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCVR_CVRCON.setCVR0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCVR_CVRCON.clearCVR0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCVR_CVRCON.setCVR0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCVR_CVRCON.getCVR0 : TBits_1; inline;
begin
  getCVR0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCVR_CVRCON.setCVR1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCVR_CVRCON.clearCVR1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCVR_CVRCON.setCVR1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCVR_CVRCON.getCVR1 : TBits_1; inline;
begin
  getCVR1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCVR_CVRCON.setCVR2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCVR_CVRCON.clearCVR2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCVR_CVRCON.setCVR2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCVR_CVRCON.getCVR2 : TBits_1; inline;
begin
  getCVR2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCVR_CVRCON.setCVR3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCVR_CVRCON.clearCVR3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCVR_CVRCON.setCVR3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCVR_CVRCON.getCVR3 : TBits_1; inline;
begin
  getCVR3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCVR_CVRCON.setBGSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCVR_CVRCON.clearBGSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCVR_CVRCON.setBGSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCVR_CVRCON.getBGSEL0 : TBits_1; inline;
begin
  getBGSEL0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCVR_CVRCON.setBGSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCVR_CVRCON.clearBGSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCVR_CVRCON.setBGSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCVR_CVRCON.getBGSEL1 : TBits_1; inline;
begin
  getBGSEL1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCVR_CVRCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCVR_CVRCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCMP_CM1CON.setCCH(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCMP_CM1CON.getCCH : TBits_2; inline;
begin
  getCCH := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCMP_CM1CON.setCREF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCMP_CM1CON.clearCREF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCMP_CM1CON.setCREF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCMP_CM1CON.getCREF : TBits_1; inline;
begin
  getCREF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCMP_CM1CON.setEVPOL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TCMP_CM1CON.getEVPOL : TBits_2; inline;
begin
  getEVPOL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TCMP_CM1CON.setCOUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCMP_CM1CON.clearCOUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCMP_CM1CON.setCOUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCMP_CM1CON.getCOUT : TBits_1; inline;
begin
  getCOUT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCMP_CM1CON.setCPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCMP_CM1CON.clearCPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCMP_CM1CON.setCPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCMP_CM1CON.getCPOL : TBits_1; inline;
begin
  getCPOL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCMP_CM1CON.setCOE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCMP_CM1CON.clearCOE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCMP_CM1CON.setCOE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCMP_CM1CON.getCOE : TBits_1; inline;
begin
  getCOE := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCMP_CM1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCMP_CM1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCMP_CM1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCMP_CM1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCMP_CM1CON.setCCH0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCMP_CM1CON.clearCCH0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCMP_CM1CON.setCCH0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCMP_CM1CON.getCCH0 : TBits_1; inline;
begin
  getCCH0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCMP_CM1CON.setCCH1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCMP_CM1CON.clearCCH1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCMP_CM1CON.setCCH1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCMP_CM1CON.getCCH1 : TBits_1; inline;
begin
  getCCH1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCMP_CM1CON.setEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCMP_CM1CON.clearEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCMP_CM1CON.setEVPOL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCMP_CM1CON.getEVPOL0 : TBits_1; inline;
begin
  getEVPOL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCMP_CM1CON.setEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCMP_CM1CON.clearEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCMP_CM1CON.setEVPOL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCMP_CM1CON.getEVPOL1 : TBits_1; inline;
begin
  getEVPOL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCMP_CM1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCMP_CM1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCMP_CM2CON.setCCH(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCMP_CM2CON.getCCH : TBits_2; inline;
begin
  getCCH := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCMP_CM2CON.setCREF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCMP_CM2CON.clearCREF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCMP_CM2CON.setCREF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCMP_CM2CON.getCREF : TBits_1; inline;
begin
  getCREF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCMP_CM2CON.setEVPOL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TCMP_CM2CON.getEVPOL : TBits_2; inline;
begin
  getEVPOL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TCMP_CM2CON.setCOUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCMP_CM2CON.clearCOUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCMP_CM2CON.setCOUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCMP_CM2CON.getCOUT : TBits_1; inline;
begin
  getCOUT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCMP_CM2CON.setCPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCMP_CM2CON.clearCPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCMP_CM2CON.setCPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCMP_CM2CON.getCPOL : TBits_1; inline;
begin
  getCPOL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCMP_CM2CON.setCOE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCMP_CM2CON.clearCOE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCMP_CM2CON.setCOE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCMP_CM2CON.getCOE : TBits_1; inline;
begin
  getCOE := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCMP_CM2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCMP_CM2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCMP_CM2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCMP_CM2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCMP_CM2CON.setCCH0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCMP_CM2CON.clearCCH0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCMP_CM2CON.setCCH0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCMP_CM2CON.getCCH0 : TBits_1; inline;
begin
  getCCH0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCMP_CM2CON.setCCH1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCMP_CM2CON.clearCCH1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCMP_CM2CON.setCCH1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCMP_CM2CON.getCCH1 : TBits_1; inline;
begin
  getCCH1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCMP_CM2CON.setEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCMP_CM2CON.clearEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCMP_CM2CON.setEVPOL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCMP_CM2CON.getEVPOL0 : TBits_1; inline;
begin
  getEVPOL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCMP_CM2CON.setEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCMP_CM2CON.clearEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCMP_CM2CON.setEVPOL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCMP_CM2CON.getEVPOL1 : TBits_1; inline;
begin
  getEVPOL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCMP_CM2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCMP_CM2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCMP_CMSTAT.setC1OUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCMP_CMSTAT.clearC1OUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCMP_CMSTAT.setC1OUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCMP_CMSTAT.getC1OUT : TBits_1; inline;
begin
  getC1OUT := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCMP_CMSTAT.setC2OUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCMP_CMSTAT.clearC2OUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCMP_CMSTAT.setC2OUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCMP_CMSTAT.getC2OUT : TBits_1; inline;
begin
  getC2OUT := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCMP_CMSTAT.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCMP_CMSTAT.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCMP_CMSTAT.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCMP_CMSTAT.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCMP_CMSTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCMP_CMSTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOSC_OSCCON.setOSWEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOSC_OSCCON.clearOSWEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOSC_OSCCON.setOSWEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOSC_OSCCON.getOSWEN : TBits_1; inline;
begin
  getOSWEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOSC_OSCCON.setSOSCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOSC_OSCCON.clearSOSCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOSC_OSCCON.setSOSCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOSC_OSCCON.getSOSCEN : TBits_1; inline;
begin
  getSOSCEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOSC_OSCCON.setUFRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOSC_OSCCON.clearUFRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOSC_OSCCON.setUFRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOSC_OSCCON.getUFRCEN : TBits_1; inline;
begin
  getUFRCEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOSC_OSCCON.setCF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOSC_OSCCON.clearCF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOSC_OSCCON.setCF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOSC_OSCCON.getCF : TBits_1; inline;
begin
  getCF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOSC_OSCCON.setSLPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOSC_OSCCON.clearSLPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOSC_OSCCON.setSLPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOSC_OSCCON.getSLPEN : TBits_1; inline;
begin
  getSLPEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOSC_OSCCON.setSLOCK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOSC_OSCCON.clearSLOCK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOSC_OSCCON.setSLOCK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOSC_OSCCON.getSLOCK : TBits_1; inline;
begin
  getSLOCK := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOSC_OSCCON.setULOCK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TOSC_OSCCON.clearULOCK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TOSC_OSCCON.setULOCK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TOSC_OSCCON.getULOCK : TBits_1; inline;
begin
  getULOCK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TOSC_OSCCON.setCLKLOCK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TOSC_OSCCON.clearCLKLOCK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TOSC_OSCCON.setCLKLOCK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TOSC_OSCCON.getCLKLOCK : TBits_1; inline;
begin
  getCLKLOCK := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TOSC_OSCCON.setNOSC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF8FF or ( thebits shl 8 );
end;
function  TOSC_OSCCON.getNOSC : TBits_3; inline;
begin
  getNOSC := (pTDefRegMap(@Self)^.val and $00000700) shr 8;
end;
procedure TOSC_OSCCON.setCOSC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF8FFF or ( thebits shl 12 );
end;
function  TOSC_OSCCON.getCOSC : TBits_3; inline;
begin
  getCOSC := (pTDefRegMap(@Self)^.val and $00007000) shr 12;
end;
procedure TOSC_OSCCON.setPLLMULT(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF8FFFF or ( thebits shl 16 );
end;
function  TOSC_OSCCON.getPLLMULT : TBits_3; inline;
begin
  getPLLMULT := (pTDefRegMap(@Self)^.val and $00070000) shr 16;
end;
procedure TOSC_OSCCON.setPBDIV(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE7FFFF or ( thebits shl 19 );
end;
function  TOSC_OSCCON.getPBDIV : TBits_2; inline;
begin
  getPBDIV := (pTDefRegMap(@Self)^.val and $00180000) shr 19;
end;
procedure TOSC_OSCCON.setSOSCRDY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TOSC_OSCCON.clearSOSCRDY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TOSC_OSCCON.setSOSCRDY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TOSC_OSCCON.getSOSCRDY : TBits_1; inline;
begin
  getSOSCRDY := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TOSC_OSCCON.setFRCDIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TOSC_OSCCON.getFRCDIV : TBits_3; inline;
begin
  getFRCDIV := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TOSC_OSCCON.setPLLODIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $C7FFFFFF or ( thebits shl 27 );
end;
function  TOSC_OSCCON.getPLLODIV : TBits_3; inline;
begin
  getPLLODIV := (pTDefRegMap(@Self)^.val and $38000000) shr 27;
end;
procedure TOSC_OSCCON.setNOSC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TOSC_OSCCON.clearNOSC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TOSC_OSCCON.setNOSC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TOSC_OSCCON.getNOSC0 : TBits_1; inline;
begin
  getNOSC0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TOSC_OSCCON.setNOSC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TOSC_OSCCON.clearNOSC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TOSC_OSCCON.setNOSC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TOSC_OSCCON.getNOSC1 : TBits_1; inline;
begin
  getNOSC1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TOSC_OSCCON.setNOSC2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TOSC_OSCCON.clearNOSC2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TOSC_OSCCON.setNOSC2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TOSC_OSCCON.getNOSC2 : TBits_1; inline;
begin
  getNOSC2 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TOSC_OSCCON.setCOSC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TOSC_OSCCON.clearCOSC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TOSC_OSCCON.setCOSC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TOSC_OSCCON.getCOSC0 : TBits_1; inline;
begin
  getCOSC0 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TOSC_OSCCON.setCOSC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOSC_OSCCON.clearCOSC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOSC_OSCCON.setCOSC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOSC_OSCCON.getCOSC1 : TBits_1; inline;
begin
  getCOSC1 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOSC_OSCCON.setCOSC2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TOSC_OSCCON.clearCOSC2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TOSC_OSCCON.setCOSC2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TOSC_OSCCON.getCOSC2 : TBits_1; inline;
begin
  getCOSC2 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TOSC_OSCCON.setPLLMULT0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TOSC_OSCCON.clearPLLMULT0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TOSC_OSCCON.setPLLMULT0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TOSC_OSCCON.getPLLMULT0 : TBits_1; inline;
begin
  getPLLMULT0 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TOSC_OSCCON.setPLLMULT1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TOSC_OSCCON.clearPLLMULT1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TOSC_OSCCON.setPLLMULT1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TOSC_OSCCON.getPLLMULT1 : TBits_1; inline;
begin
  getPLLMULT1 := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TOSC_OSCCON.setPLLMULT2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TOSC_OSCCON.clearPLLMULT2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TOSC_OSCCON.setPLLMULT2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TOSC_OSCCON.getPLLMULT2 : TBits_1; inline;
begin
  getPLLMULT2 := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TOSC_OSCCON.setPBDIV0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TOSC_OSCCON.clearPBDIV0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TOSC_OSCCON.setPBDIV0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TOSC_OSCCON.getPBDIV0 : TBits_1; inline;
begin
  getPBDIV0 := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TOSC_OSCCON.setPBDIV1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TOSC_OSCCON.clearPBDIV1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TOSC_OSCCON.setPBDIV1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TOSC_OSCCON.getPBDIV1 : TBits_1; inline;
begin
  getPBDIV1 := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TOSC_OSCCON.setFRCDIV0; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TOSC_OSCCON.clearFRCDIV0; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TOSC_OSCCON.setFRCDIV0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TOSC_OSCCON.getFRCDIV0 : TBits_1; inline;
begin
  getFRCDIV0 := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TOSC_OSCCON.setFRCDIV1; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TOSC_OSCCON.clearFRCDIV1; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TOSC_OSCCON.setFRCDIV1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TOSC_OSCCON.getFRCDIV1 : TBits_1; inline;
begin
  getFRCDIV1 := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TOSC_OSCCON.setFRCDIV2; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TOSC_OSCCON.clearFRCDIV2; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TOSC_OSCCON.setFRCDIV2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TOSC_OSCCON.getFRCDIV2 : TBits_1; inline;
begin
  getFRCDIV2 := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TOSC_OSCCON.setPLLODIV0; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TOSC_OSCCON.clearPLLODIV0; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TOSC_OSCCON.setPLLODIV0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TOSC_OSCCON.getPLLODIV0 : TBits_1; inline;
begin
  getPLLODIV0 := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TOSC_OSCCON.setPLLODIV1; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TOSC_OSCCON.clearPLLODIV1; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TOSC_OSCCON.setPLLODIV1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TOSC_OSCCON.getPLLODIV1 : TBits_1; inline;
begin
  getPLLODIV1 := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TOSC_OSCCON.setPLLODIV2; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TOSC_OSCCON.clearPLLODIV2; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TOSC_OSCCON.setPLLODIV2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TOSC_OSCCON.getPLLODIV2 : TBits_1; inline;
begin
  getPLLODIV2 := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TOSC_OSCCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOSC_OSCCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOSC_OSCTUN.setTUN(thebits : TBits_6); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFC0 or ( thebits shl 0 );
end;
function  TOSC_OSCTUN.getTUN : TBits_6; inline;
begin
  getTUN := (pTDefRegMap(@Self)^.val and $0000003F) shr 0;
end;
procedure TOSC_OSCTUN.setTUN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOSC_OSCTUN.clearTUN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOSC_OSCTUN.setTUN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOSC_OSCTUN.getTUN0 : TBits_1; inline;
begin
  getTUN0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOSC_OSCTUN.setTUN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOSC_OSCTUN.clearTUN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOSC_OSCTUN.setTUN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOSC_OSCTUN.getTUN1 : TBits_1; inline;
begin
  getTUN1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOSC_OSCTUN.setTUN2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOSC_OSCTUN.clearTUN2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOSC_OSCTUN.setTUN2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOSC_OSCTUN.getTUN2 : TBits_1; inline;
begin
  getTUN2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOSC_OSCTUN.setTUN3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOSC_OSCTUN.clearTUN3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOSC_OSCTUN.setTUN3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOSC_OSCTUN.getTUN3 : TBits_1; inline;
begin
  getTUN3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOSC_OSCTUN.setTUN4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOSC_OSCTUN.clearTUN4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOSC_OSCTUN.setTUN4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOSC_OSCTUN.getTUN4 : TBits_1; inline;
begin
  getTUN4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOSC_OSCTUN.setTUN5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOSC_OSCTUN.clearTUN5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOSC_OSCTUN.setTUN5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOSC_OSCTUN.getTUN5 : TBits_1; inline;
begin
  getTUN5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOSC_OSCTUN.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOSC_OSCTUN.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TNVM_NVMCON.setNVMOP(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TNVM_NVMCON.getNVMOP : TBits_4; inline;
begin
  getNVMOP := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TNVM_NVMCON.setLVDSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TNVM_NVMCON.clearLVDSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TNVM_NVMCON.setLVDSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TNVM_NVMCON.getLVDSTAT : TBits_1; inline;
begin
  getLVDSTAT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TNVM_NVMCON.setLVDERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TNVM_NVMCON.clearLVDERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TNVM_NVMCON.setLVDERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TNVM_NVMCON.getLVDERR : TBits_1; inline;
begin
  getLVDERR := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TNVM_NVMCON.setWRERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TNVM_NVMCON.clearWRERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TNVM_NVMCON.setWRERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TNVM_NVMCON.getWRERR : TBits_1; inline;
begin
  getWRERR := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TNVM_NVMCON.setWREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TNVM_NVMCON.clearWREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TNVM_NVMCON.setWREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TNVM_NVMCON.getWREN : TBits_1; inline;
begin
  getWREN := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TNVM_NVMCON.setWR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TNVM_NVMCON.clearWR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TNVM_NVMCON.setWR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TNVM_NVMCON.getWR : TBits_1; inline;
begin
  getWR := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TNVM_NVMCON.setNVMOP0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TNVM_NVMCON.clearNVMOP0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TNVM_NVMCON.setNVMOP0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TNVM_NVMCON.getNVMOP0 : TBits_1; inline;
begin
  getNVMOP0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TNVM_NVMCON.setNVMOP1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TNVM_NVMCON.clearNVMOP1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TNVM_NVMCON.setNVMOP1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TNVM_NVMCON.getNVMOP1 : TBits_1; inline;
begin
  getNVMOP1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TNVM_NVMCON.setNVMOP2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TNVM_NVMCON.clearNVMOP2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TNVM_NVMCON.setNVMOP2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TNVM_NVMCON.getNVMOP2 : TBits_1; inline;
begin
  getNVMOP2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TNVM_NVMCON.setNVMOP3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TNVM_NVMCON.clearNVMOP3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TNVM_NVMCON.setNVMOP3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TNVM_NVMCON.getNVMOP3 : TBits_1; inline;
begin
  getNVMOP3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TNVM_NVMCON.setPROGOP(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TNVM_NVMCON.getPROGOP : TBits_4; inline;
begin
  getPROGOP := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TNVM_NVMCON.setPROGOP0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TNVM_NVMCON.clearPROGOP0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TNVM_NVMCON.setPROGOP0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TNVM_NVMCON.getPROGOP0 : TBits_1; inline;
begin
  getPROGOP0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TNVM_NVMCON.setPROGOP1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TNVM_NVMCON.clearPROGOP1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TNVM_NVMCON.setPROGOP1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TNVM_NVMCON.getPROGOP1 : TBits_1; inline;
begin
  getPROGOP1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TNVM_NVMCON.setPROGOP2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TNVM_NVMCON.clearPROGOP2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TNVM_NVMCON.setPROGOP2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TNVM_NVMCON.getPROGOP2 : TBits_1; inline;
begin
  getPROGOP2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TNVM_NVMCON.setPROGOP3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TNVM_NVMCON.clearPROGOP3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TNVM_NVMCON.setPROGOP3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TNVM_NVMCON.getPROGOP3 : TBits_1; inline;
begin
  getPROGOP3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TNVM_NVMCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TNVM_NVMCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRCON_RCON.setPOR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TRCON_RCON.clearPOR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TRCON_RCON.setPOR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TRCON_RCON.getPOR : TBits_1; inline;
begin
  getPOR := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TRCON_RCON.setBOR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TRCON_RCON.clearBOR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TRCON_RCON.setBOR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TRCON_RCON.getBOR : TBits_1; inline;
begin
  getBOR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TRCON_RCON.setIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TRCON_RCON.clearIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TRCON_RCON.setIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TRCON_RCON.getIDLE : TBits_1; inline;
begin
  getIDLE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TRCON_RCON.setSLEEP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TRCON_RCON.clearSLEEP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TRCON_RCON.setSLEEP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TRCON_RCON.getSLEEP : TBits_1; inline;
begin
  getSLEEP := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TRCON_RCON.setWDTO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TRCON_RCON.clearWDTO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TRCON_RCON.setWDTO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TRCON_RCON.getWDTO : TBits_1; inline;
begin
  getWDTO := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TRCON_RCON.setSWR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TRCON_RCON.clearSWR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TRCON_RCON.setSWR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TRCON_RCON.getSWR : TBits_1; inline;
begin
  getSWR := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TRCON_RCON.setEXTR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TRCON_RCON.clearEXTR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TRCON_RCON.setEXTR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TRCON_RCON.getEXTR : TBits_1; inline;
begin
  getEXTR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TRCON_RCON.setVREGS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TRCON_RCON.clearVREGS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TRCON_RCON.setVREGS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TRCON_RCON.getVREGS : TBits_1; inline;
begin
  getVREGS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TRCON_RCON.setCMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TRCON_RCON.clearCMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TRCON_RCON.setCMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TRCON_RCON.getCMR : TBits_1; inline;
begin
  getCMR := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TRCON_RCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRCON_RCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRCON_RSWRST.setSWRST; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TRCON_RSWRST.clearSWRST; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TRCON_RSWRST.setSWRST(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TRCON_RSWRST.getSWRST : TBits_1; inline;
begin
  getSWRST := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TRCON_RSWRST.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRCON_RSWRST.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_INTCON.setINT0EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_INTCON.clearINT0EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_INTCON.setINT0EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_INTCON.getINT0EP : TBits_1; inline;
begin
  getINT0EP := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_INTCON.setINT1EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_INTCON.clearINT1EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_INTCON.setINT1EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_INTCON.getINT1EP : TBits_1; inline;
begin
  getINT1EP := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_INTCON.setINT2EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_INTCON.clearINT2EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_INTCON.setINT2EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_INTCON.getINT2EP : TBits_1; inline;
begin
  getINT2EP := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_INTCON.setINT3EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_INTCON.clearINT3EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_INTCON.setINT3EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_INTCON.getINT3EP : TBits_1; inline;
begin
  getINT3EP := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_INTCON.setINT4EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_INTCON.clearINT4EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_INTCON.setINT4EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_INTCON.getINT4EP : TBits_1; inline;
begin
  getINT4EP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_INTCON.setTPC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF8FF or ( thebits shl 8 );
end;
function  TINT_INTCON.getTPC : TBits_3; inline;
begin
  getTPC := (pTDefRegMap(@Self)^.val and $00000700) shr 8;
end;
procedure TINT_INTCON.setMVEC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TINT_INTCON.clearMVEC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TINT_INTCON.setMVEC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TINT_INTCON.getMVEC : TBits_1; inline;
begin
  getMVEC := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TINT_INTCON.setFRZ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TINT_INTCON.clearFRZ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TINT_INTCON.setFRZ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TINT_INTCON.getFRZ : TBits_1; inline;
begin
  getFRZ := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TINT_INTCON.setSS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_INTCON.clearSS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_INTCON.setSS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_INTCON.getSS0 : TBits_1; inline;
begin
  getSS0 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_INTCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_INTCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IFS0.setCTIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IFS0.clearCTIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IFS0.setCTIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IFS0.getCTIF : TBits_1; inline;
begin
  getCTIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IFS0.setCS0IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IFS0.clearCS0IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IFS0.setCS0IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IFS0.getCS0IF : TBits_1; inline;
begin
  getCS0IF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IFS0.setCS1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IFS0.clearCS1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IFS0.setCS1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IFS0.getCS1IF : TBits_1; inline;
begin
  getCS1IF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IFS0.setINT0IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IFS0.clearINT0IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IFS0.setINT0IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IFS0.getINT0IF : TBits_1; inline;
begin
  getINT0IF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IFS0.setT1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IFS0.clearT1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IFS0.setT1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IFS0.getT1IF : TBits_1; inline;
begin
  getT1IF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IFS0.setIC1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IFS0.clearIC1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IFS0.setIC1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IFS0.getIC1IF : TBits_1; inline;
begin
  getIC1IF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IFS0.setOC1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IFS0.clearOC1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IFS0.setOC1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IFS0.getOC1IF : TBits_1; inline;
begin
  getOC1IF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IFS0.setINT1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IFS0.clearINT1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IFS0.setINT1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IFS0.getINT1IF : TBits_1; inline;
begin
  getINT1IF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IFS0.setT2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IFS0.clearT2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IFS0.setT2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IFS0.getT2IF : TBits_1; inline;
begin
  getT2IF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IFS0.setIC2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IFS0.clearIC2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IFS0.setIC2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IFS0.getIC2IF : TBits_1; inline;
begin
  getIC2IF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IFS0.setOC2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IFS0.clearOC2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IFS0.setOC2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IFS0.getOC2IF : TBits_1; inline;
begin
  getOC2IF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IFS0.setINT2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IFS0.clearINT2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IFS0.setINT2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IFS0.getINT2IF : TBits_1; inline;
begin
  getINT2IF := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IFS0.setT3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TINT_IFS0.clearT3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TINT_IFS0.setT3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TINT_IFS0.getT3IF : TBits_1; inline;
begin
  getT3IF := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TINT_IFS0.setIC3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TINT_IFS0.clearIC3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TINT_IFS0.setIC3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TINT_IFS0.getIC3IF : TBits_1; inline;
begin
  getIC3IF := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TINT_IFS0.setOC3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TINT_IFS0.clearOC3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TINT_IFS0.setOC3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TINT_IFS0.getOC3IF : TBits_1; inline;
begin
  getOC3IF := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TINT_IFS0.setINT3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TINT_IFS0.clearINT3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TINT_IFS0.setINT3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TINT_IFS0.getINT3IF : TBits_1; inline;
begin
  getINT3IF := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TINT_IFS0.setT4IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_IFS0.clearT4IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_IFS0.setT4IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_IFS0.getT4IF : TBits_1; inline;
begin
  getT4IF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_IFS0.setIC4IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TINT_IFS0.clearIC4IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TINT_IFS0.setIC4IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TINT_IFS0.getIC4IF : TBits_1; inline;
begin
  getIC4IF := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TINT_IFS0.setOC4IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TINT_IFS0.clearOC4IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TINT_IFS0.setOC4IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TINT_IFS0.getOC4IF : TBits_1; inline;
begin
  getOC4IF := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TINT_IFS0.setINT4IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TINT_IFS0.clearINT4IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TINT_IFS0.setINT4IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TINT_IFS0.getINT4IF : TBits_1; inline;
begin
  getINT4IF := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TINT_IFS0.setT5IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TINT_IFS0.clearT5IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TINT_IFS0.setT5IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TINT_IFS0.getT5IF : TBits_1; inline;
begin
  getT5IF := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TINT_IFS0.setIC5IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TINT_IFS0.clearIC5IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TINT_IFS0.setIC5IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TINT_IFS0.getIC5IF : TBits_1; inline;
begin
  getIC5IF := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TINT_IFS0.setOC5IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TINT_IFS0.clearOC5IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TINT_IFS0.setOC5IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TINT_IFS0.getOC5IF : TBits_1; inline;
begin
  getOC5IF := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TINT_IFS0.setU1EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IFS0.clearU1EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IFS0.setU1EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IFS0.getU1EIF : TBits_1; inline;
begin
  getU1EIF := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IFS0.setU1RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IFS0.clearU1RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IFS0.setU1RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IFS0.getU1RXIF : TBits_1; inline;
begin
  getU1RXIF := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IFS0.setU1TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IFS0.clearU1TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IFS0.setU1TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IFS0.getU1TXIF : TBits_1; inline;
begin
  getU1TXIF := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IFS0.setI2C1BIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TINT_IFS0.clearI2C1BIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TINT_IFS0.setI2C1BIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TINT_IFS0.getI2C1BIF : TBits_1; inline;
begin
  getI2C1BIF := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TINT_IFS0.setI2C1SIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TINT_IFS0.clearI2C1SIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TINT_IFS0.setI2C1SIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TINT_IFS0.getI2C1SIF : TBits_1; inline;
begin
  getI2C1SIF := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TINT_IFS0.setI2C1MIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TINT_IFS0.clearI2C1MIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TINT_IFS0.setI2C1MIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TINT_IFS0.getI2C1MIF : TBits_1; inline;
begin
  getI2C1MIF := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TINT_IFS0.setU1AEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IFS0.clearU1AEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IFS0.setU1AEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IFS0.getU1AEIF : TBits_1; inline;
begin
  getU1AEIF := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IFS0.setU1ARXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IFS0.clearU1ARXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IFS0.setU1ARXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IFS0.getU1ARXIF : TBits_1; inline;
begin
  getU1ARXIF := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IFS0.setU1ATXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IFS0.clearU1ATXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IFS0.setU1ATXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IFS0.getU1ATXIF : TBits_1; inline;
begin
  getU1ATXIF := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IFS0.setSPI3EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IFS0.clearSPI3EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IFS0.setSPI3EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IFS0.getSPI3EIF : TBits_1; inline;
begin
  getSPI3EIF := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IFS0.setSPI3RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IFS0.clearSPI3RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IFS0.setSPI3RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IFS0.getSPI3RXIF : TBits_1; inline;
begin
  getSPI3RXIF := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IFS0.setSPI3TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IFS0.clearSPI3TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IFS0.setSPI3TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IFS0.getSPI3TXIF : TBits_1; inline;
begin
  getSPI3TXIF := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IFS0.setSPI1AEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IFS0.clearSPI1AEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IFS0.setSPI1AEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IFS0.getSPI1AEIF : TBits_1; inline;
begin
  getSPI1AEIF := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IFS0.setSPI1ARXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IFS0.clearSPI1ARXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IFS0.setSPI1ARXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IFS0.getSPI1ARXIF : TBits_1; inline;
begin
  getSPI1ARXIF := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IFS0.setSPI1ATXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IFS0.clearSPI1ATXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IFS0.setSPI1ATXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IFS0.getSPI1ATXIF : TBits_1; inline;
begin
  getSPI1ATXIF := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IFS0.setI2C3BIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IFS0.clearI2C3BIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IFS0.setI2C3BIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IFS0.getI2C3BIF : TBits_1; inline;
begin
  getI2C3BIF := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IFS0.setI2C3SIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IFS0.clearI2C3SIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IFS0.setI2C3SIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IFS0.getI2C3SIF : TBits_1; inline;
begin
  getI2C3SIF := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IFS0.setI2C3MIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IFS0.clearI2C3MIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IFS0.setI2C3MIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IFS0.getI2C3MIF : TBits_1; inline;
begin
  getI2C3MIF := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IFS0.setI2C1ABIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IFS0.clearI2C1ABIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IFS0.setI2C1ABIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IFS0.getI2C1ABIF : TBits_1; inline;
begin
  getI2C1ABIF := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IFS0.setI2C1ASIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IFS0.clearI2C1ASIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IFS0.setI2C1ASIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IFS0.getI2C1ASIF : TBits_1; inline;
begin
  getI2C1ASIF := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IFS0.setI2C1AMIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IFS0.clearI2C1AMIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IFS0.setI2C1AMIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IFS0.getI2C1AMIF : TBits_1; inline;
begin
  getI2C1AMIF := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IFS0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IFS0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IFS1.setCNIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IFS1.clearCNIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IFS1.setCNIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IFS1.getCNIF : TBits_1; inline;
begin
  getCNIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IFS1.setAD1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IFS1.clearAD1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IFS1.setAD1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IFS1.getAD1IF : TBits_1; inline;
begin
  getAD1IF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IFS1.setPMPIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IFS1.clearPMPIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IFS1.setPMPIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IFS1.getPMPIF : TBits_1; inline;
begin
  getPMPIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IFS1.setCMP1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IFS1.clearCMP1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IFS1.setCMP1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IFS1.getCMP1IF : TBits_1; inline;
begin
  getCMP1IF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IFS1.setCMP2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IFS1.clearCMP2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IFS1.setCMP2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IFS1.getCMP2IF : TBits_1; inline;
begin
  getCMP2IF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IFS1.setU3EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IFS1.clearU3EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IFS1.setU3EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IFS1.getU3EIF : TBits_1; inline;
begin
  getU3EIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IFS1.setU3RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IFS1.clearU3RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IFS1.setU3RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IFS1.getU3RXIF : TBits_1; inline;
begin
  getU3RXIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IFS1.setU3TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IFS1.clearU3TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IFS1.setU3TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IFS1.getU3TXIF : TBits_1; inline;
begin
  getU3TXIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IFS1.setU2EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IFS1.clearU2EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IFS1.setU2EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IFS1.getU2EIF : TBits_1; inline;
begin
  getU2EIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IFS1.setU2RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IFS1.clearU2RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IFS1.setU2RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IFS1.getU2RXIF : TBits_1; inline;
begin
  getU2RXIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IFS1.setU2TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IFS1.clearU2TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IFS1.setU2TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IFS1.getU2TXIF : TBits_1; inline;
begin
  getU2TXIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IFS1.setFSCMIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TINT_IFS1.clearFSCMIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TINT_IFS1.setFSCMIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TINT_IFS1.getFSCMIF : TBits_1; inline;
begin
  getFSCMIF := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TINT_IFS1.setRTCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TINT_IFS1.clearRTCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TINT_IFS1.setRTCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TINT_IFS1.getRTCCIF : TBits_1; inline;
begin
  getRTCCIF := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TINT_IFS1.setDMA0IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_IFS1.clearDMA0IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_IFS1.setDMA0IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_IFS1.getDMA0IF : TBits_1; inline;
begin
  getDMA0IF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_IFS1.setDMA1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TINT_IFS1.clearDMA1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TINT_IFS1.setDMA1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TINT_IFS1.getDMA1IF : TBits_1; inline;
begin
  getDMA1IF := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TINT_IFS1.setDMA2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TINT_IFS1.clearDMA2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TINT_IFS1.setDMA2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TINT_IFS1.getDMA2IF : TBits_1; inline;
begin
  getDMA2IF := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TINT_IFS1.setDMA3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TINT_IFS1.clearDMA3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TINT_IFS1.setDMA3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TINT_IFS1.getDMA3IF : TBits_1; inline;
begin
  getDMA3IF := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TINT_IFS1.setFCEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TINT_IFS1.clearFCEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TINT_IFS1.setFCEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TINT_IFS1.getFCEIF : TBits_1; inline;
begin
  getFCEIF := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TINT_IFS1.setUSBIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TINT_IFS1.clearUSBIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TINT_IFS1.setUSBIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TINT_IFS1.getUSBIF : TBits_1; inline;
begin
  getUSBIF := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TINT_IFS1.setCAN1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IFS1.clearCAN1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IFS1.setCAN1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IFS1.getCAN1IF : TBits_1; inline;
begin
  getCAN1IF := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IFS1.setIC1EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TINT_IFS1.clearIC1EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TINT_IFS1.setIC1EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TINT_IFS1.getIC1EIF : TBits_1; inline;
begin
  getIC1EIF := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TINT_IFS1.setIC2EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TINT_IFS1.clearIC2EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TINT_IFS1.setIC2EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TINT_IFS1.getIC2EIF : TBits_1; inline;
begin
  getIC2EIF := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TINT_IFS1.setIC3EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TINT_IFS1.clearIC3EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TINT_IFS1.setIC3EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TINT_IFS1.getIC3EIF : TBits_1; inline;
begin
  getIC3EIF := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TINT_IFS1.setU2AEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IFS1.clearU2AEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IFS1.setU2AEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IFS1.getU2AEIF : TBits_1; inline;
begin
  getU2AEIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IFS1.setU2ARXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IFS1.clearU2ARXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IFS1.setU2ARXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IFS1.getU2ARXIF : TBits_1; inline;
begin
  getU2ARXIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IFS1.setU2ATXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IFS1.clearU2ATXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IFS1.setU2ATXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IFS1.getU2ATXIF : TBits_1; inline;
begin
  getU2ATXIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IFS1.setU3AEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IFS1.clearU3AEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IFS1.setU3AEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IFS1.getU3AEIF : TBits_1; inline;
begin
  getU3AEIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IFS1.setU3ARXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IFS1.clearU3ARXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IFS1.setU3ARXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IFS1.getU3ARXIF : TBits_1; inline;
begin
  getU3ARXIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IFS1.setU3ATXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IFS1.clearU3ATXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IFS1.setU3ATXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IFS1.getU3ATXIF : TBits_1; inline;
begin
  getU3ATXIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IFS1.setSPI2EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IFS1.clearSPI2EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IFS1.setSPI2EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IFS1.getSPI2EIF : TBits_1; inline;
begin
  getSPI2EIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IFS1.setSPI2RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IFS1.clearSPI2RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IFS1.setSPI2RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IFS1.getSPI2RXIF : TBits_1; inline;
begin
  getSPI2RXIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IFS1.setSPI2TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IFS1.clearSPI2TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IFS1.setSPI2TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IFS1.getSPI2TXIF : TBits_1; inline;
begin
  getSPI2TXIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IFS1.setSPI4EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IFS1.clearSPI4EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IFS1.setSPI4EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IFS1.getSPI4EIF : TBits_1; inline;
begin
  getSPI4EIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IFS1.setSPI4RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IFS1.clearSPI4RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IFS1.setSPI4RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IFS1.getSPI4RXIF : TBits_1; inline;
begin
  getSPI4RXIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IFS1.setSPI4TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IFS1.clearSPI4TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IFS1.setSPI4TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IFS1.getSPI4TXIF : TBits_1; inline;
begin
  getSPI4TXIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IFS1.setSPI2AEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IFS1.clearSPI2AEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IFS1.setSPI2AEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IFS1.getSPI2AEIF : TBits_1; inline;
begin
  getSPI2AEIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IFS1.setSPI2ARXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IFS1.clearSPI2ARXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IFS1.setSPI2ARXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IFS1.getSPI2ARXIF : TBits_1; inline;
begin
  getSPI2ARXIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IFS1.setSPI2ATXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IFS1.clearSPI2ATXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IFS1.setSPI2ATXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IFS1.getSPI2ATXIF : TBits_1; inline;
begin
  getSPI2ATXIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IFS1.setSPI3AEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IFS1.clearSPI3AEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IFS1.setSPI3AEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IFS1.getSPI3AEIF : TBits_1; inline;
begin
  getSPI3AEIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IFS1.setSPI3ARXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IFS1.clearSPI3ARXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IFS1.setSPI3ARXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IFS1.getSPI3ARXIF : TBits_1; inline;
begin
  getSPI3ARXIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IFS1.setSPI3ATXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IFS1.clearSPI3ATXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IFS1.setSPI3ATXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IFS1.getSPI3ATXIF : TBits_1; inline;
begin
  getSPI3ATXIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IFS1.setI2C4BIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IFS1.clearI2C4BIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IFS1.setI2C4BIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IFS1.getI2C4BIF : TBits_1; inline;
begin
  getI2C4BIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IFS1.setI2C4SIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IFS1.clearI2C4SIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IFS1.setI2C4SIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IFS1.getI2C4SIF : TBits_1; inline;
begin
  getI2C4SIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IFS1.setI2C4MIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IFS1.clearI2C4MIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IFS1.setI2C4MIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IFS1.getI2C4MIF : TBits_1; inline;
begin
  getI2C4MIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IFS1.setI2C5BIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IFS1.clearI2C5BIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IFS1.setI2C5BIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IFS1.getI2C5BIF : TBits_1; inline;
begin
  getI2C5BIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IFS1.setI2C5SIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IFS1.clearI2C5SIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IFS1.setI2C5SIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IFS1.getI2C5SIF : TBits_1; inline;
begin
  getI2C5SIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IFS1.setI2C5MIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IFS1.clearI2C5MIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IFS1.setI2C5MIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IFS1.getI2C5MIF : TBits_1; inline;
begin
  getI2C5MIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IFS1.setI2C2ABIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IFS1.clearI2C2ABIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IFS1.setI2C2ABIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IFS1.getI2C2ABIF : TBits_1; inline;
begin
  getI2C2ABIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IFS1.setI2C2ASIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IFS1.clearI2C2ASIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IFS1.setI2C2ASIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IFS1.getI2C2ASIF : TBits_1; inline;
begin
  getI2C2ASIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IFS1.setI2C2AMIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IFS1.clearI2C2AMIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IFS1.setI2C2AMIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IFS1.getI2C2AMIF : TBits_1; inline;
begin
  getI2C2AMIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IFS1.setI2C3ABIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IFS1.clearI2C3ABIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IFS1.setI2C3ABIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IFS1.getI2C3ABIF : TBits_1; inline;
begin
  getI2C3ABIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IFS1.setI2C3ASIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IFS1.clearI2C3ASIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IFS1.setI2C3ASIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IFS1.getI2C3ASIF : TBits_1; inline;
begin
  getI2C3ASIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IFS1.setI2C3AMIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IFS1.clearI2C3AMIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IFS1.setI2C3AMIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IFS1.getI2C3AMIF : TBits_1; inline;
begin
  getI2C3AMIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IFS1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IFS1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IFS2.setIC4EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IFS2.clearIC4EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IFS2.setIC4EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IFS2.getIC4EIF : TBits_1; inline;
begin
  getIC4EIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IFS2.setIC5EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IFS2.clearIC5EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IFS2.setIC5EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IFS2.getIC5EIF : TBits_1; inline;
begin
  getIC5EIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IFS2.setPMPEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IFS2.clearPMPEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IFS2.setPMPEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IFS2.getPMPEIF : TBits_1; inline;
begin
  getPMPEIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IFS2.setU1BEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IFS2.clearU1BEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IFS2.setU1BEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IFS2.getU1BEIF : TBits_1; inline;
begin
  getU1BEIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IFS2.setU1BRXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IFS2.clearU1BRXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IFS2.setU1BRXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IFS2.getU1BRXIF : TBits_1; inline;
begin
  getU1BRXIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IFS2.setU1BTXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IFS2.clearU1BTXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IFS2.setU1BTXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IFS2.getU1BTXIF : TBits_1; inline;
begin
  getU1BTXIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IFS2.setU2BEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IFS2.clearU2BEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IFS2.setU2BEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IFS2.getU2BEIF : TBits_1; inline;
begin
  getU2BEIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IFS2.setU2BRXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IFS2.clearU2BRXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IFS2.setU2BRXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IFS2.getU2BRXIF : TBits_1; inline;
begin
  getU2BRXIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IFS2.setU2BTXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IFS2.clearU2BTXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IFS2.setU2BTXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IFS2.getU2BTXIF : TBits_1; inline;
begin
  getU2BTXIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IFS2.setU3BEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IFS2.clearU3BEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IFS2.setU3BEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IFS2.getU3BEIF : TBits_1; inline;
begin
  getU3BEIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IFS2.setU3BRXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IFS2.clearU3BRXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IFS2.setU3BRXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IFS2.getU3BRXIF : TBits_1; inline;
begin
  getU3BRXIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IFS2.setU3BTXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IFS2.clearU3BTXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IFS2.setU3BTXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IFS2.getU3BTXIF : TBits_1; inline;
begin
  getU3BTXIF := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IFS2.setU4EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IFS2.clearU4EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IFS2.setU4EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IFS2.getU4EIF : TBits_1; inline;
begin
  getU4EIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IFS2.setU4RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IFS2.clearU4RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IFS2.setU4RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IFS2.getU4RXIF : TBits_1; inline;
begin
  getU4RXIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IFS2.setU4TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IFS2.clearU4TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IFS2.setU4TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IFS2.getU4TXIF : TBits_1; inline;
begin
  getU4TXIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IFS2.setU6EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IFS2.clearU6EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IFS2.setU6EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IFS2.getU6EIF : TBits_1; inline;
begin
  getU6EIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IFS2.setU6RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IFS2.clearU6RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IFS2.setU6RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IFS2.getU6RXIF : TBits_1; inline;
begin
  getU6RXIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IFS2.setU6TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IFS2.clearU6TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IFS2.setU6TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IFS2.getU6TXIF : TBits_1; inline;
begin
  getU6TXIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IFS2.setU5EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IFS2.clearU5EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IFS2.setU5EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IFS2.getU5EIF : TBits_1; inline;
begin
  getU5EIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IFS2.setU5RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IFS2.clearU5RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IFS2.setU5RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IFS2.getU5RXIF : TBits_1; inline;
begin
  getU5RXIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IFS2.setU5TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IFS2.clearU5TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IFS2.setU5TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IFS2.getU5TXIF : TBits_1; inline;
begin
  getU5TXIF := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IFS2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IFS2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IEC0.setCTIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IEC0.clearCTIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IEC0.setCTIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IEC0.getCTIE : TBits_1; inline;
begin
  getCTIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IEC0.setCS0IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IEC0.clearCS0IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IEC0.setCS0IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IEC0.getCS0IE : TBits_1; inline;
begin
  getCS0IE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IEC0.setCS1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IEC0.clearCS1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IEC0.setCS1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IEC0.getCS1IE : TBits_1; inline;
begin
  getCS1IE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IEC0.setINT0IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IEC0.clearINT0IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IEC0.setINT0IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IEC0.getINT0IE : TBits_1; inline;
begin
  getINT0IE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IEC0.setT1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IEC0.clearT1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IEC0.setT1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IEC0.getT1IE : TBits_1; inline;
begin
  getT1IE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IEC0.setIC1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IEC0.clearIC1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IEC0.setIC1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IEC0.getIC1IE : TBits_1; inline;
begin
  getIC1IE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IEC0.setOC1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IEC0.clearOC1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IEC0.setOC1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IEC0.getOC1IE : TBits_1; inline;
begin
  getOC1IE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IEC0.setINT1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IEC0.clearINT1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IEC0.setINT1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IEC0.getINT1IE : TBits_1; inline;
begin
  getINT1IE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IEC0.setT2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IEC0.clearT2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IEC0.setT2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IEC0.getT2IE : TBits_1; inline;
begin
  getT2IE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IEC0.setIC2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IEC0.clearIC2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IEC0.setIC2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IEC0.getIC2IE : TBits_1; inline;
begin
  getIC2IE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IEC0.setOC2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IEC0.clearOC2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IEC0.setOC2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IEC0.getOC2IE : TBits_1; inline;
begin
  getOC2IE := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IEC0.setINT2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IEC0.clearINT2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IEC0.setINT2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IEC0.getINT2IE : TBits_1; inline;
begin
  getINT2IE := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IEC0.setT3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TINT_IEC0.clearT3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TINT_IEC0.setT3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TINT_IEC0.getT3IE : TBits_1; inline;
begin
  getT3IE := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TINT_IEC0.setIC3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TINT_IEC0.clearIC3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TINT_IEC0.setIC3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TINT_IEC0.getIC3IE : TBits_1; inline;
begin
  getIC3IE := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TINT_IEC0.setOC3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TINT_IEC0.clearOC3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TINT_IEC0.setOC3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TINT_IEC0.getOC3IE : TBits_1; inline;
begin
  getOC3IE := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TINT_IEC0.setINT3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TINT_IEC0.clearINT3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TINT_IEC0.setINT3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TINT_IEC0.getINT3IE : TBits_1; inline;
begin
  getINT3IE := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TINT_IEC0.setT4IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_IEC0.clearT4IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_IEC0.setT4IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_IEC0.getT4IE : TBits_1; inline;
begin
  getT4IE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_IEC0.setIC4IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TINT_IEC0.clearIC4IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TINT_IEC0.setIC4IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TINT_IEC0.getIC4IE : TBits_1; inline;
begin
  getIC4IE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TINT_IEC0.setOC4IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TINT_IEC0.clearOC4IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TINT_IEC0.setOC4IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TINT_IEC0.getOC4IE : TBits_1; inline;
begin
  getOC4IE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TINT_IEC0.setINT4IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TINT_IEC0.clearINT4IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TINT_IEC0.setINT4IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TINT_IEC0.getINT4IE : TBits_1; inline;
begin
  getINT4IE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TINT_IEC0.setT5IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TINT_IEC0.clearT5IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TINT_IEC0.setT5IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TINT_IEC0.getT5IE : TBits_1; inline;
begin
  getT5IE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TINT_IEC0.setIC5IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TINT_IEC0.clearIC5IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TINT_IEC0.setIC5IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TINT_IEC0.getIC5IE : TBits_1; inline;
begin
  getIC5IE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TINT_IEC0.setOC5IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TINT_IEC0.clearOC5IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TINT_IEC0.setOC5IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TINT_IEC0.getOC5IE : TBits_1; inline;
begin
  getOC5IE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TINT_IEC0.setU1EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IEC0.clearU1EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IEC0.setU1EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IEC0.getU1EIE : TBits_1; inline;
begin
  getU1EIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IEC0.setU1RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IEC0.clearU1RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IEC0.setU1RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IEC0.getU1RXIE : TBits_1; inline;
begin
  getU1RXIE := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IEC0.setU1TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IEC0.clearU1TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IEC0.setU1TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IEC0.getU1TXIE : TBits_1; inline;
begin
  getU1TXIE := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IEC0.setI2C1BIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TINT_IEC0.clearI2C1BIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TINT_IEC0.setI2C1BIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TINT_IEC0.getI2C1BIE : TBits_1; inline;
begin
  getI2C1BIE := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TINT_IEC0.setI2C1SIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TINT_IEC0.clearI2C1SIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TINT_IEC0.setI2C1SIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TINT_IEC0.getI2C1SIE : TBits_1; inline;
begin
  getI2C1SIE := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TINT_IEC0.setI2C1MIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TINT_IEC0.clearI2C1MIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TINT_IEC0.setI2C1MIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TINT_IEC0.getI2C1MIE : TBits_1; inline;
begin
  getI2C1MIE := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TINT_IEC0.setU1AEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IEC0.clearU1AEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IEC0.setU1AEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IEC0.getU1AEIE : TBits_1; inline;
begin
  getU1AEIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IEC0.setU1ARXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IEC0.clearU1ARXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IEC0.setU1ARXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IEC0.getU1ARXIE : TBits_1; inline;
begin
  getU1ARXIE := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IEC0.setU1ATXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IEC0.clearU1ATXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IEC0.setU1ATXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IEC0.getU1ATXIE : TBits_1; inline;
begin
  getU1ATXIE := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IEC0.setSPI3EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IEC0.clearSPI3EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IEC0.setSPI3EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IEC0.getSPI3EIE : TBits_1; inline;
begin
  getSPI3EIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IEC0.setSPI3RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IEC0.clearSPI3RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IEC0.setSPI3RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IEC0.getSPI3RXIE : TBits_1; inline;
begin
  getSPI3RXIE := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IEC0.setSPI3TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IEC0.clearSPI3TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IEC0.setSPI3TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IEC0.getSPI3TXIE : TBits_1; inline;
begin
  getSPI3TXIE := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IEC0.setSPI1AEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IEC0.clearSPI1AEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IEC0.setSPI1AEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IEC0.getSPI1AEIE : TBits_1; inline;
begin
  getSPI1AEIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IEC0.setSPI1ARXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IEC0.clearSPI1ARXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IEC0.setSPI1ARXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IEC0.getSPI1ARXIE : TBits_1; inline;
begin
  getSPI1ARXIE := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IEC0.setSPI1ATXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IEC0.clearSPI1ATXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IEC0.setSPI1ATXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IEC0.getSPI1ATXIE : TBits_1; inline;
begin
  getSPI1ATXIE := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IEC0.setI2C3BIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IEC0.clearI2C3BIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IEC0.setI2C3BIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IEC0.getI2C3BIE : TBits_1; inline;
begin
  getI2C3BIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IEC0.setI2C3SIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IEC0.clearI2C3SIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IEC0.setI2C3SIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IEC0.getI2C3SIE : TBits_1; inline;
begin
  getI2C3SIE := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IEC0.setI2C3MIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IEC0.clearI2C3MIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IEC0.setI2C3MIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IEC0.getI2C3MIE : TBits_1; inline;
begin
  getI2C3MIE := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IEC0.setI2C1ABIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IEC0.clearI2C1ABIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IEC0.setI2C1ABIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IEC0.getI2C1ABIE : TBits_1; inline;
begin
  getI2C1ABIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IEC0.setI2C1ASIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IEC0.clearI2C1ASIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IEC0.setI2C1ASIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IEC0.getI2C1ASIE : TBits_1; inline;
begin
  getI2C1ASIE := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IEC0.setI2C1AMIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IEC0.clearI2C1AMIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IEC0.setI2C1AMIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IEC0.getI2C1AMIE : TBits_1; inline;
begin
  getI2C1AMIE := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IEC0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IEC0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IEC1.setCNIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IEC1.clearCNIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IEC1.setCNIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IEC1.getCNIE : TBits_1; inline;
begin
  getCNIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IEC1.setAD1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IEC1.clearAD1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IEC1.setAD1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IEC1.getAD1IE : TBits_1; inline;
begin
  getAD1IE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IEC1.setPMPIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IEC1.clearPMPIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IEC1.setPMPIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IEC1.getPMPIE : TBits_1; inline;
begin
  getPMPIE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IEC1.setCMP1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IEC1.clearCMP1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IEC1.setCMP1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IEC1.getCMP1IE : TBits_1; inline;
begin
  getCMP1IE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IEC1.setCMP2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IEC1.clearCMP2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IEC1.setCMP2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IEC1.getCMP2IE : TBits_1; inline;
begin
  getCMP2IE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IEC1.setU3EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IEC1.clearU3EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IEC1.setU3EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IEC1.getU3EIE : TBits_1; inline;
begin
  getU3EIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IEC1.setU3RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IEC1.clearU3RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IEC1.setU3RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IEC1.getU3RXIE : TBits_1; inline;
begin
  getU3RXIE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IEC1.setU3TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IEC1.clearU3TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IEC1.setU3TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IEC1.getU3TXIE : TBits_1; inline;
begin
  getU3TXIE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IEC1.setU2EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IEC1.clearU2EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IEC1.setU2EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IEC1.getU2EIE : TBits_1; inline;
begin
  getU2EIE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IEC1.setU2RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IEC1.clearU2RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IEC1.setU2RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IEC1.getU2RXIE : TBits_1; inline;
begin
  getU2RXIE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IEC1.setU2TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IEC1.clearU2TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IEC1.setU2TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IEC1.getU2TXIE : TBits_1; inline;
begin
  getU2TXIE := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IEC1.setFSCMIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TINT_IEC1.clearFSCMIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TINT_IEC1.setFSCMIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TINT_IEC1.getFSCMIE : TBits_1; inline;
begin
  getFSCMIE := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TINT_IEC1.setRTCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TINT_IEC1.clearRTCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TINT_IEC1.setRTCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TINT_IEC1.getRTCCIE : TBits_1; inline;
begin
  getRTCCIE := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TINT_IEC1.setDMA0IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_IEC1.clearDMA0IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_IEC1.setDMA0IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_IEC1.getDMA0IE : TBits_1; inline;
begin
  getDMA0IE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_IEC1.setDMA1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TINT_IEC1.clearDMA1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TINT_IEC1.setDMA1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TINT_IEC1.getDMA1IE : TBits_1; inline;
begin
  getDMA1IE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TINT_IEC1.setDMA2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TINT_IEC1.clearDMA2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TINT_IEC1.setDMA2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TINT_IEC1.getDMA2IE : TBits_1; inline;
begin
  getDMA2IE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TINT_IEC1.setDMA3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TINT_IEC1.clearDMA3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TINT_IEC1.setDMA3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TINT_IEC1.getDMA3IE : TBits_1; inline;
begin
  getDMA3IE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TINT_IEC1.setFCEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TINT_IEC1.clearFCEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TINT_IEC1.setFCEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TINT_IEC1.getFCEIE : TBits_1; inline;
begin
  getFCEIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TINT_IEC1.setUSBIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TINT_IEC1.clearUSBIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TINT_IEC1.setUSBIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TINT_IEC1.getUSBIE : TBits_1; inline;
begin
  getUSBIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TINT_IEC1.setCAN1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IEC1.clearCAN1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IEC1.setCAN1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IEC1.getCAN1IE : TBits_1; inline;
begin
  getCAN1IE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IEC1.setIC1EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TINT_IEC1.clearIC1EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TINT_IEC1.setIC1EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TINT_IEC1.getIC1EIE : TBits_1; inline;
begin
  getIC1EIE := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TINT_IEC1.setIC2EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TINT_IEC1.clearIC2EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TINT_IEC1.setIC2EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TINT_IEC1.getIC2EIE : TBits_1; inline;
begin
  getIC2EIE := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TINT_IEC1.setIC3EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TINT_IEC1.clearIC3EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TINT_IEC1.setIC3EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TINT_IEC1.getIC3EIE : TBits_1; inline;
begin
  getIC3EIE := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TINT_IEC1.setU2AEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IEC1.clearU2AEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IEC1.setU2AEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IEC1.getU2AEIE : TBits_1; inline;
begin
  getU2AEIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IEC1.setU2ARXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IEC1.clearU2ARXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IEC1.setU2ARXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IEC1.getU2ARXIE : TBits_1; inline;
begin
  getU2ARXIE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IEC1.setU2ATXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IEC1.clearU2ATXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IEC1.setU2ATXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IEC1.getU2ATXIE : TBits_1; inline;
begin
  getU2ATXIE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IEC1.setU3AEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IEC1.clearU3AEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IEC1.setU3AEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IEC1.getU3AEIE : TBits_1; inline;
begin
  getU3AEIE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IEC1.setU3ARXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IEC1.clearU3ARXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IEC1.setU3ARXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IEC1.getU3ARXIE : TBits_1; inline;
begin
  getU3ARXIE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IEC1.setU3ATXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IEC1.clearU3ATXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IEC1.setU3ATXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IEC1.getU3ATXIE : TBits_1; inline;
begin
  getU3ATXIE := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IEC1.setSPI2EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IEC1.clearSPI2EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IEC1.setSPI2EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IEC1.getSPI2EIE : TBits_1; inline;
begin
  getSPI2EIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IEC1.setSPI2RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IEC1.clearSPI2RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IEC1.setSPI2RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IEC1.getSPI2RXIE : TBits_1; inline;
begin
  getSPI2RXIE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IEC1.setSPI2TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IEC1.clearSPI2TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IEC1.setSPI2TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IEC1.getSPI2TXIE : TBits_1; inline;
begin
  getSPI2TXIE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IEC1.setSPI4EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IEC1.clearSPI4EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IEC1.setSPI4EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IEC1.getSPI4EIE : TBits_1; inline;
begin
  getSPI4EIE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IEC1.setSPI4RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IEC1.clearSPI4RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IEC1.setSPI4RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IEC1.getSPI4RXIE : TBits_1; inline;
begin
  getSPI4RXIE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IEC1.setSPI4TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IEC1.clearSPI4TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IEC1.setSPI4TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IEC1.getSPI4TXIE : TBits_1; inline;
begin
  getSPI4TXIE := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IEC1.setSPI2AEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IEC1.clearSPI2AEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IEC1.setSPI2AEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IEC1.getSPI2AEIE : TBits_1; inline;
begin
  getSPI2AEIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IEC1.setSPI2ARXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IEC1.clearSPI2ARXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IEC1.setSPI2ARXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IEC1.getSPI2ARXIE : TBits_1; inline;
begin
  getSPI2ARXIE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IEC1.setSPI2ATXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IEC1.clearSPI2ATXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IEC1.setSPI2ATXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IEC1.getSPI2ATXIE : TBits_1; inline;
begin
  getSPI2ATXIE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IEC1.setSPI3AEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IEC1.clearSPI3AEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IEC1.setSPI3AEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IEC1.getSPI3AEIE : TBits_1; inline;
begin
  getSPI3AEIE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IEC1.setSPI3ARXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IEC1.clearSPI3ARXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IEC1.setSPI3ARXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IEC1.getSPI3ARXIE : TBits_1; inline;
begin
  getSPI3ARXIE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IEC1.setSPI3ATXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IEC1.clearSPI3ATXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IEC1.setSPI3ATXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IEC1.getSPI3ATXIE : TBits_1; inline;
begin
  getSPI3ATXIE := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IEC1.setI2C4BIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IEC1.clearI2C4BIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IEC1.setI2C4BIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IEC1.getI2C4BIE : TBits_1; inline;
begin
  getI2C4BIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IEC1.setI2C4SIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IEC1.clearI2C4SIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IEC1.setI2C4SIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IEC1.getI2C4SIE : TBits_1; inline;
begin
  getI2C4SIE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IEC1.setI2C4MIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IEC1.clearI2C4MIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IEC1.setI2C4MIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IEC1.getI2C4MIE : TBits_1; inline;
begin
  getI2C4MIE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IEC1.setI2C5BIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IEC1.clearI2C5BIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IEC1.setI2C5BIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IEC1.getI2C5BIE : TBits_1; inline;
begin
  getI2C5BIE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IEC1.setI2C5SIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IEC1.clearI2C5SIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IEC1.setI2C5SIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IEC1.getI2C5SIE : TBits_1; inline;
begin
  getI2C5SIE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IEC1.setI2C5MIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IEC1.clearI2C5MIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IEC1.setI2C5MIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IEC1.getI2C5MIE : TBits_1; inline;
begin
  getI2C5MIE := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IEC1.setI2C2ABIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IEC1.clearI2C2ABIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IEC1.setI2C2ABIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IEC1.getI2C2ABIE : TBits_1; inline;
begin
  getI2C2ABIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IEC1.setI2C2ASIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IEC1.clearI2C2ASIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IEC1.setI2C2ASIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IEC1.getI2C2ASIE : TBits_1; inline;
begin
  getI2C2ASIE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IEC1.setI2C2AMIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IEC1.clearI2C2AMIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IEC1.setI2C2AMIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IEC1.getI2C2AMIE : TBits_1; inline;
begin
  getI2C2AMIE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IEC1.setI2C3ABIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IEC1.clearI2C3ABIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IEC1.setI2C3ABIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IEC1.getI2C3ABIE : TBits_1; inline;
begin
  getI2C3ABIE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IEC1.setI2C3ASIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IEC1.clearI2C3ASIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IEC1.setI2C3ASIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IEC1.getI2C3ASIE : TBits_1; inline;
begin
  getI2C3ASIE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IEC1.setI2C3AMIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IEC1.clearI2C3AMIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IEC1.setI2C3AMIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IEC1.getI2C3AMIE : TBits_1; inline;
begin
  getI2C3AMIE := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IEC1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IEC1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IEC2.setIC4EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IEC2.clearIC4EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IEC2.setIC4EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IEC2.getIC4EIE : TBits_1; inline;
begin
  getIC4EIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IEC2.setIC5EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IEC2.clearIC5EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IEC2.setIC5EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IEC2.getIC5EIE : TBits_1; inline;
begin
  getIC5EIE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IEC2.setPMPEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IEC2.clearPMPEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IEC2.setPMPEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IEC2.getPMPEIE : TBits_1; inline;
begin
  getPMPEIE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IEC2.setU1BEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IEC2.clearU1BEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IEC2.setU1BEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IEC2.getU1BEIE : TBits_1; inline;
begin
  getU1BEIE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IEC2.setU1BRXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IEC2.clearU1BRXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IEC2.setU1BRXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IEC2.getU1BRXIE : TBits_1; inline;
begin
  getU1BRXIE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IEC2.setU1BTXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IEC2.clearU1BTXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IEC2.setU1BTXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IEC2.getU1BTXIE : TBits_1; inline;
begin
  getU1BTXIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IEC2.setU2BEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IEC2.clearU2BEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IEC2.setU2BEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IEC2.getU2BEIE : TBits_1; inline;
begin
  getU2BEIE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IEC2.setU2BRXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IEC2.clearU2BRXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IEC2.setU2BRXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IEC2.getU2BRXIE : TBits_1; inline;
begin
  getU2BRXIE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IEC2.setU2BTXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IEC2.clearU2BTXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IEC2.setU2BTXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IEC2.getU2BTXIE : TBits_1; inline;
begin
  getU2BTXIE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IEC2.setU3BEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IEC2.clearU3BEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IEC2.setU3BEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IEC2.getU3BEIE : TBits_1; inline;
begin
  getU3BEIE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IEC2.setU3BRXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IEC2.clearU3BRXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IEC2.setU3BRXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IEC2.getU3BRXIE : TBits_1; inline;
begin
  getU3BRXIE := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IEC2.setU3BTXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IEC2.clearU3BTXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IEC2.setU3BTXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IEC2.getU3BTXIE : TBits_1; inline;
begin
  getU3BTXIE := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IEC2.setU4EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IEC2.clearU4EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IEC2.setU4EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IEC2.getU4EIE : TBits_1; inline;
begin
  getU4EIE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IEC2.setU4RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IEC2.clearU4RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IEC2.setU4RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IEC2.getU4RXIE : TBits_1; inline;
begin
  getU4RXIE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IEC2.setU4TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IEC2.clearU4TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IEC2.setU4TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IEC2.getU4TXIE : TBits_1; inline;
begin
  getU4TXIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IEC2.setU6EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IEC2.clearU6EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IEC2.setU6EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IEC2.getU6EIE : TBits_1; inline;
begin
  getU6EIE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IEC2.setU6RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IEC2.clearU6RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IEC2.setU6RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IEC2.getU6RXIE : TBits_1; inline;
begin
  getU6RXIE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IEC2.setU6TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IEC2.clearU6TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IEC2.setU6TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IEC2.getU6TXIE : TBits_1; inline;
begin
  getU6TXIE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IEC2.setU5EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IEC2.clearU5EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IEC2.setU5EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IEC2.getU5EIE : TBits_1; inline;
begin
  getU5EIE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IEC2.setU5RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IEC2.clearU5RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IEC2.setU5RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IEC2.getU5RXIE : TBits_1; inline;
begin
  getU5RXIE := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IEC2.setU5TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IEC2.clearU5TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IEC2.setU5TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IEC2.getU5TXIE : TBits_1; inline;
begin
  getU5TXIE := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IEC2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IEC2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC0.setCTIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC0.getCTIS : TBits_2; inline;
begin
  getCTIS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC0.setCTIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC0.getCTIP : TBits_3; inline;
begin
  getCTIP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC0.setCS0IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC0.getCS0IS : TBits_2; inline;
begin
  getCS0IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC0.setCS0IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC0.getCS0IP : TBits_3; inline;
begin
  getCS0IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC0.setCS1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC0.getCS1IS : TBits_2; inline;
begin
  getCS1IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC0.setCS1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC0.getCS1IP : TBits_3; inline;
begin
  getCS1IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC0.setINT0IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC0.getINT0IS : TBits_2; inline;
begin
  getINT0IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC0.setINT0IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC0.getINT0IP : TBits_3; inline;
begin
  getINT0IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC1.setT1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC1.getT1IS : TBits_2; inline;
begin
  getT1IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC1.setT1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC1.getT1IP : TBits_3; inline;
begin
  getT1IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC1.setIC1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC1.getIC1IS : TBits_2; inline;
begin
  getIC1IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC1.setIC1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC1.getIC1IP : TBits_3; inline;
begin
  getIC1IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC1.setOC1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC1.getOC1IS : TBits_2; inline;
begin
  getOC1IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC1.setOC1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC1.getOC1IP : TBits_3; inline;
begin
  getOC1IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC1.setINT1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC1.getINT1IS : TBits_2; inline;
begin
  getINT1IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC1.setINT1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC1.getINT1IP : TBits_3; inline;
begin
  getINT1IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC2.setT2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC2.getT2IS : TBits_2; inline;
begin
  getT2IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC2.setT2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC2.getT2IP : TBits_3; inline;
begin
  getT2IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC2.setIC2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC2.getIC2IS : TBits_2; inline;
begin
  getIC2IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC2.setIC2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC2.getIC2IP : TBits_3; inline;
begin
  getIC2IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC2.setOC2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC2.getOC2IS : TBits_2; inline;
begin
  getOC2IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC2.setOC2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC2.getOC2IP : TBits_3; inline;
begin
  getOC2IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC2.setINT2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC2.getINT2IS : TBits_2; inline;
begin
  getINT2IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC2.setINT2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC2.getINT2IP : TBits_3; inline;
begin
  getINT2IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC3.setT3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC3.getT3IS : TBits_2; inline;
begin
  getT3IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC3.setT3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC3.getT3IP : TBits_3; inline;
begin
  getT3IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC3.setIC3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC3.getIC3IS : TBits_2; inline;
begin
  getIC3IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC3.setIC3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC3.getIC3IP : TBits_3; inline;
begin
  getIC3IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC3.setOC3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC3.getOC3IS : TBits_2; inline;
begin
  getOC3IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC3.setOC3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC3.getOC3IP : TBits_3; inline;
begin
  getOC3IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC3.setINT3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC3.getINT3IS : TBits_2; inline;
begin
  getINT3IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC3.setINT3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC3.getINT3IP : TBits_3; inline;
begin
  getINT3IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC4.setT4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC4.getT4IS : TBits_2; inline;
begin
  getT4IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC4.setT4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC4.getT4IP : TBits_3; inline;
begin
  getT4IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC4.setIC4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC4.getIC4IS : TBits_2; inline;
begin
  getIC4IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC4.setIC4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC4.getIC4IP : TBits_3; inline;
begin
  getIC4IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC4.setOC4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC4.getOC4IS : TBits_2; inline;
begin
  getOC4IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC4.setOC4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC4.getOC4IP : TBits_3; inline;
begin
  getOC4IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC4.setINT4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC4.getINT4IS : TBits_2; inline;
begin
  getINT4IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC4.setINT4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC4.getINT4IP : TBits_3; inline;
begin
  getINT4IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC4.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC4.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC5.setT5IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC5.getT5IS : TBits_2; inline;
begin
  getT5IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC5.setT5IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC5.getT5IP : TBits_3; inline;
begin
  getT5IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC5.setIC5IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC5.getIC5IS : TBits_2; inline;
begin
  getIC5IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC5.setIC5IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC5.getIC5IP : TBits_3; inline;
begin
  getIC5IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC5.setOC5IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC5.getOC5IS : TBits_2; inline;
begin
  getOC5IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC5.setOC5IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC5.getOC5IP : TBits_3; inline;
begin
  getOC5IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC5.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC5.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC6.setU1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC6.getU1IS : TBits_2; inline;
begin
  getU1IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC6.setU1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC6.getU1IP : TBits_3; inline;
begin
  getU1IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC6.setI2C1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC6.getI2C1IS : TBits_2; inline;
begin
  getI2C1IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC6.setI2C1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC6.getI2C1IP : TBits_3; inline;
begin
  getI2C1IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC6.setCNIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC6.getCNIS : TBits_2; inline;
begin
  getCNIS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC6.setCNIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC6.getCNIP : TBits_3; inline;
begin
  getCNIP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC6.setAD1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC6.getAD1IS : TBits_2; inline;
begin
  getAD1IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC6.setAD1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC6.getAD1IP : TBits_3; inline;
begin
  getAD1IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC6.setU1AIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC6.getU1AIS : TBits_2; inline;
begin
  getU1AIS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC6.setU1AIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC6.getU1AIP : TBits_3; inline;
begin
  getU1AIP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC6.setSPI3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC6.getSPI3IS : TBits_2; inline;
begin
  getSPI3IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC6.setSPI3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC6.getSPI3IP : TBits_3; inline;
begin
  getSPI3IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC6.setSPI1AIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC6.getSPI1AIS : TBits_2; inline;
begin
  getSPI1AIS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC6.setSPI1AIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC6.getSPI1AIP : TBits_3; inline;
begin
  getSPI1AIP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC6.setI2C3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC6.getI2C3IS : TBits_2; inline;
begin
  getI2C3IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC6.setI2C3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC6.getI2C3IP : TBits_3; inline;
begin
  getI2C3IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC6.setI2C1AIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC6.getI2C1AIS : TBits_2; inline;
begin
  getI2C1AIS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC6.setI2C1AIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC6.getI2C1AIP : TBits_3; inline;
begin
  getI2C1AIP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC6.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC6.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC7.setPMPIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC7.getPMPIS : TBits_2; inline;
begin
  getPMPIS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC7.setPMPIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC7.getPMPIP : TBits_3; inline;
begin
  getPMPIP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC7.setCMP1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC7.getCMP1IS : TBits_2; inline;
begin
  getCMP1IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC7.setCMP1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC7.getCMP1IP : TBits_3; inline;
begin
  getCMP1IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC7.setCMP2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC7.getCMP2IS : TBits_2; inline;
begin
  getCMP2IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC7.setCMP2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC7.getCMP2IP : TBits_3; inline;
begin
  getCMP2IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC7.setU3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC7.getU3IS : TBits_2; inline;
begin
  getU3IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC7.setU3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC7.getU3IP : TBits_3; inline;
begin
  getU3IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC7.setU2AIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC7.getU2AIS : TBits_2; inline;
begin
  getU2AIS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC7.setU2AIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC7.getU2AIP : TBits_3; inline;
begin
  getU2AIP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC7.setSPI2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC7.getSPI2IS : TBits_2; inline;
begin
  getSPI2IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC7.setSPI2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC7.getSPI2IP : TBits_3; inline;
begin
  getSPI2IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC7.setSPI2AIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC7.getSPI2AIS : TBits_2; inline;
begin
  getSPI2AIS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC7.setSPI2AIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC7.getSPI2AIP : TBits_3; inline;
begin
  getSPI2AIP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC7.setI2C4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC7.getI2C4IS : TBits_2; inline;
begin
  getI2C4IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC7.setI2C4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC7.getI2C4IP : TBits_3; inline;
begin
  getI2C4IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC7.setI2C2AIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC7.getI2C2AIS : TBits_2; inline;
begin
  getI2C2AIS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC7.setI2C2AIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC7.getI2C2AIP : TBits_3; inline;
begin
  getI2C2AIP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC7.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC7.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC8.setU2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC8.getU2IS : TBits_2; inline;
begin
  getU2IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC8.setU2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC8.getU2IP : TBits_3; inline;
begin
  getU2IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC8.setFSCMIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC8.getFSCMIS : TBits_2; inline;
begin
  getFSCMIS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC8.setFSCMIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC8.getFSCMIP : TBits_3; inline;
begin
  getFSCMIP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC8.setRTCCIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC8.getRTCCIS : TBits_2; inline;
begin
  getRTCCIS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC8.setRTCCIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC8.getRTCCIP : TBits_3; inline;
begin
  getRTCCIP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC8.setU3AIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC8.getU3AIS : TBits_2; inline;
begin
  getU3AIS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC8.setU3AIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC8.getU3AIP : TBits_3; inline;
begin
  getU3AIP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC8.setSPI4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC8.getSPI4IS : TBits_2; inline;
begin
  getSPI4IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC8.setSPI4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC8.getSPI4IP : TBits_3; inline;
begin
  getSPI4IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC8.setSPI3AIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC8.getSPI3AIS : TBits_2; inline;
begin
  getSPI3AIS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC8.setSPI3AIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC8.getSPI3AIP : TBits_3; inline;
begin
  getSPI3AIP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC8.setI2C5IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC8.getI2C5IS : TBits_2; inline;
begin
  getI2C5IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC8.setI2C5IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC8.getI2C5IP : TBits_3; inline;
begin
  getI2C5IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC8.setI2C3AIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC8.getI2C3AIS : TBits_2; inline;
begin
  getI2C3AIS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC8.setI2C3AIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC8.getI2C3AIP : TBits_3; inline;
begin
  getI2C3AIP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC8.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC8.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC9.setDMA0IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC9.getDMA0IS : TBits_2; inline;
begin
  getDMA0IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC9.setDMA0IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC9.getDMA0IP : TBits_3; inline;
begin
  getDMA0IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC9.setDMA1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC9.getDMA1IS : TBits_2; inline;
begin
  getDMA1IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC9.setDMA1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC9.getDMA1IP : TBits_3; inline;
begin
  getDMA1IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC9.setDMA2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC9.getDMA2IS : TBits_2; inline;
begin
  getDMA2IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC9.setDMA2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC9.getDMA2IP : TBits_3; inline;
begin
  getDMA2IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC9.setDMA3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC9.getDMA3IS : TBits_2; inline;
begin
  getDMA3IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC9.setDMA3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC9.getDMA3IP : TBits_3; inline;
begin
  getDMA3IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC9.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC9.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC11.setFCEIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC11.getFCEIS : TBits_2; inline;
begin
  getFCEIS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC11.setFCEIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC11.getFCEIP : TBits_3; inline;
begin
  getFCEIP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC11.setUSBIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC11.getUSBIS : TBits_2; inline;
begin
  getUSBIS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC11.setUSBIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC11.getUSBIP : TBits_3; inline;
begin
  getUSBIP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC11.setCAN1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC11.getCAN1IS : TBits_2; inline;
begin
  getCAN1IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC11.setCAN1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC11.getCAN1IP : TBits_3; inline;
begin
  getCAN1IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC11.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC11.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC12.setU4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC12.getU4IS : TBits_2; inline;
begin
  getU4IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC12.setU4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC12.getU4IP : TBits_3; inline;
begin
  getU4IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC12.setU6IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC12.getU6IS : TBits_2; inline;
begin
  getU6IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC12.setU6IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC12.getU6IP : TBits_3; inline;
begin
  getU6IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC12.setU5IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC12.getU5IS : TBits_2; inline;
begin
  getU5IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC12.setU5IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC12.getU5IP : TBits_3; inline;
begin
  getU5IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC12.setU1BIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC12.getU1BIS : TBits_2; inline;
begin
  getU1BIS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC12.setU1BIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC12.getU1BIP : TBits_3; inline;
begin
  getU1BIP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC12.setU2BIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC12.getU2BIS : TBits_2; inline;
begin
  getU2BIS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC12.setU2BIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC12.getU2BIP : TBits_3; inline;
begin
  getU2BIP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC12.setU3BIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC12.getU3BIS : TBits_2; inline;
begin
  getU3BIS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC12.setU3BIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC12.getU3BIP : TBits_3; inline;
begin
  getU3BIP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC12.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC12.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TBMX_BMXCON.setBMXARB(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TBMX_BMXCON.getBMXARB : TBits_3; inline;
begin
  getBMXARB := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TBMX_BMXCON.setBMXWSDRM; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TBMX_BMXCON.clearBMXWSDRM; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TBMX_BMXCON.setBMXWSDRM(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TBMX_BMXCON.getBMXWSDRM : TBits_1; inline;
begin
  getBMXWSDRM := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TBMX_BMXCON.setBMXERRIS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TBMX_BMXCON.clearBMXERRIS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TBMX_BMXCON.setBMXERRIS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TBMX_BMXCON.getBMXERRIS : TBits_1; inline;
begin
  getBMXERRIS := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TBMX_BMXCON.setBMXERRDS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TBMX_BMXCON.clearBMXERRDS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TBMX_BMXCON.setBMXERRDS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TBMX_BMXCON.getBMXERRDS : TBits_1; inline;
begin
  getBMXERRDS := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TBMX_BMXCON.setBMXERRDMA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TBMX_BMXCON.clearBMXERRDMA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TBMX_BMXCON.setBMXERRDMA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TBMX_BMXCON.getBMXERRDMA : TBits_1; inline;
begin
  getBMXERRDMA := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TBMX_BMXCON.setBMXERRICD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TBMX_BMXCON.clearBMXERRICD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TBMX_BMXCON.setBMXERRICD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TBMX_BMXCON.getBMXERRICD : TBits_1; inline;
begin
  getBMXERRICD := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TBMX_BMXCON.setBMXERRIXI; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TBMX_BMXCON.clearBMXERRIXI; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TBMX_BMXCON.setBMXERRIXI(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TBMX_BMXCON.getBMXERRIXI : TBits_1; inline;
begin
  getBMXERRIXI := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TBMX_BMXCON.setBMXCHEDMA; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TBMX_BMXCON.clearBMXCHEDMA; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TBMX_BMXCON.setBMXCHEDMA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TBMX_BMXCON.getBMXCHEDMA : TBits_1; inline;
begin
  getBMXCHEDMA := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TBMX_BMXCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TBMX_BMXCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC_DMACON.setDMABUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TDMAC_DMACON.clearDMABUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TDMAC_DMACON.setDMABUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TDMAC_DMACON.getDMABUSY : TBits_1; inline;
begin
  getDMABUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TDMAC_DMACON.setSUSPEND; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TDMAC_DMACON.clearSUSPEND; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TDMAC_DMACON.setSUSPEND(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TDMAC_DMACON.getSUSPEND : TBits_1; inline;
begin
  getSUSPEND := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TDMAC_DMACON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC_DMACON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC_DMACON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC_DMACON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC_DMACON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC_DMACON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC_DMASTAT.setDMACH(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TDMAC_DMASTAT.getDMACH : TBits_3; inline;
begin
  getDMACH := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TDMAC_DMASTAT.setRDWR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC_DMASTAT.clearRDWR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC_DMASTAT.setRDWR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC_DMASTAT.getRDWR : TBits_1; inline;
begin
  getRDWR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC_DMASTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC_DMASTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC_DCRCCON.setCRCCH(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TDMAC_DCRCCON.getCRCCH : TBits_3; inline;
begin
  getCRCCH := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TDMAC_DCRCCON.setCRCTYP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC_DCRCCON.clearCRCTYP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC_DCRCCON.setCRCTYP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC_DCRCCON.getCRCTYP : TBits_1; inline;
begin
  getCRCTYP := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC_DCRCCON.setCRCAPP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC_DCRCCON.clearCRCAPP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC_DCRCCON.setCRCAPP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC_DCRCCON.getCRCAPP : TBits_1; inline;
begin
  getCRCAPP := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC_DCRCCON.setCRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC_DCRCCON.clearCRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC_DCRCCON.setCRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC_DCRCCON.getCRCEN : TBits_1; inline;
begin
  getCRCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC_DCRCCON.setPLEN(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TDMAC_DCRCCON.getPLEN : TBits_5; inline;
begin
  getPLEN := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TDMAC_DCRCCON.setBITO; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TDMAC_DCRCCON.clearBITO; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TDMAC_DCRCCON.setBITO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TDMAC_DCRCCON.getBITO : TBits_1; inline;
begin
  getBITO := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TDMAC_DCRCCON.setWBO; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TDMAC_DCRCCON.clearWBO; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TDMAC_DCRCCON.setWBO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TDMAC_DCRCCON.getWBO : TBits_1; inline;
begin
  getWBO := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TDMAC_DCRCCON.setBYTO(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $CFFFFFFF or ( thebits shl 28 );
end;
function  TDMAC_DCRCCON.getBYTO : TBits_2; inline;
begin
  getBYTO := (pTDefRegMap(@Self)^.val and $30000000) shr 28;
end;
procedure TDMAC_DCRCCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC_DCRCCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC0_DCH0CON.setCHPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDMAC0_DCH0CON.getCHPRI : TBits_2; inline;
begin
  getCHPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDMAC0_DCH0CON.setCHEDET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC0_DCH0CON.clearCHEDET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC0_DCH0CON.setCHEDET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC0_DCH0CON.getCHEDET : TBits_1; inline;
begin
  getCHEDET := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC0_DCH0CON.setCHAEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC0_DCH0CON.clearCHAEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC0_DCH0CON.setCHAEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC0_DCH0CON.getCHAEN : TBits_1; inline;
begin
  getCHAEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC0_DCH0CON.setCHCHN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC0_DCH0CON.clearCHCHN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC0_DCH0CON.setCHCHN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC0_DCH0CON.getCHCHN : TBits_1; inline;
begin
  getCHCHN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC0_DCH0CON.setCHAED; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC0_DCH0CON.clearCHAED; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC0_DCH0CON.setCHAED(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC0_DCH0CON.getCHAED : TBits_1; inline;
begin
  getCHAED := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC0_DCH0CON.setCHEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC0_DCH0CON.clearCHEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC0_DCH0CON.setCHEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC0_DCH0CON.getCHEN : TBits_1; inline;
begin
  getCHEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC0_DCH0CON.setCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TDMAC0_DCH0CON.clearCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TDMAC0_DCH0CON.setCHCHNS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TDMAC0_DCH0CON.getCHCHNS : TBits_1; inline;
begin
  getCHCHNS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TDMAC0_DCH0CON.setCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC0_DCH0CON.clearCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC0_DCH0CON.setCHBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC0_DCH0CON.getCHBUSY : TBits_1; inline;
begin
  getCHBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC0_DCH0CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC0_DCH0CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC0_DCH0ECON.setAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC0_DCH0ECON.clearAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC0_DCH0ECON.setAIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC0_DCH0ECON.getAIRQEN : TBits_1; inline;
begin
  getAIRQEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC0_DCH0ECON.setSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC0_DCH0ECON.clearSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC0_DCH0ECON.setSIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC0_DCH0ECON.getSIRQEN : TBits_1; inline;
begin
  getSIRQEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC0_DCH0ECON.setPATEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC0_DCH0ECON.clearPATEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC0_DCH0ECON.setPATEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC0_DCH0ECON.getPATEN : TBits_1; inline;
begin
  getPATEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC0_DCH0ECON.setCABORT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC0_DCH0ECON.clearCABORT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC0_DCH0ECON.setCABORT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC0_DCH0ECON.getCABORT : TBits_1; inline;
begin
  getCABORT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC0_DCH0ECON.setCFORCE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC0_DCH0ECON.clearCFORCE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC0_DCH0ECON.setCFORCE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC0_DCH0ECON.getCFORCE : TBits_1; inline;
begin
  getCFORCE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC0_DCH0ECON.setCHSIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF00FF or ( thebits shl 8 );
end;
function  TDMAC0_DCH0ECON.getCHSIRQ : TBits_8; inline;
begin
  getCHSIRQ := (pTDefRegMap(@Self)^.val and $0000FF00) shr 8;
end;
procedure TDMAC0_DCH0ECON.setCHAIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TDMAC0_DCH0ECON.getCHAIRQ : TBits_8; inline;
begin
  getCHAIRQ := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TDMAC0_DCH0ECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC0_DCH0ECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC0_DCH0INT.setCHERIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TDMAC0_DCH0INT.clearCHERIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TDMAC0_DCH0INT.setCHERIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TDMAC0_DCH0INT.getCHERIF : TBits_1; inline;
begin
  getCHERIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TDMAC0_DCH0INT.setCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TDMAC0_DCH0INT.clearCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TDMAC0_DCH0INT.setCHTAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TDMAC0_DCH0INT.getCHTAIF : TBits_1; inline;
begin
  getCHTAIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TDMAC0_DCH0INT.setCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC0_DCH0INT.clearCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC0_DCH0INT.setCHCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC0_DCH0INT.getCHCCIF : TBits_1; inline;
begin
  getCHCCIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC0_DCH0INT.setCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC0_DCH0INT.clearCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC0_DCH0INT.setCHBCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC0_DCH0INT.getCHBCIF : TBits_1; inline;
begin
  getCHBCIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC0_DCH0INT.setCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC0_DCH0INT.clearCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC0_DCH0INT.setCHDHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC0_DCH0INT.getCHDHIF : TBits_1; inline;
begin
  getCHDHIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC0_DCH0INT.setCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC0_DCH0INT.clearCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC0_DCH0INT.setCHDDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC0_DCH0INT.getCHDDIF : TBits_1; inline;
begin
  getCHDDIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC0_DCH0INT.setCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC0_DCH0INT.clearCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC0_DCH0INT.setCHSHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC0_DCH0INT.getCHSHIF : TBits_1; inline;
begin
  getCHSHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC0_DCH0INT.setCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC0_DCH0INT.clearCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC0_DCH0INT.setCHSDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC0_DCH0INT.getCHSDIF : TBits_1; inline;
begin
  getCHSDIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC0_DCH0INT.setCHERIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TDMAC0_DCH0INT.clearCHERIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TDMAC0_DCH0INT.setCHERIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TDMAC0_DCH0INT.getCHERIE : TBits_1; inline;
begin
  getCHERIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TDMAC0_DCH0INT.setCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TDMAC0_DCH0INT.clearCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TDMAC0_DCH0INT.setCHTAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TDMAC0_DCH0INT.getCHTAIE : TBits_1; inline;
begin
  getCHTAIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TDMAC0_DCH0INT.setCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TDMAC0_DCH0INT.clearCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TDMAC0_DCH0INT.setCHCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TDMAC0_DCH0INT.getCHCCIE : TBits_1; inline;
begin
  getCHCCIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TDMAC0_DCH0INT.setCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TDMAC0_DCH0INT.clearCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TDMAC0_DCH0INT.setCHBCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TDMAC0_DCH0INT.getCHBCIE : TBits_1; inline;
begin
  getCHBCIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TDMAC0_DCH0INT.setCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TDMAC0_DCH0INT.clearCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TDMAC0_DCH0INT.setCHDHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TDMAC0_DCH0INT.getCHDHIE : TBits_1; inline;
begin
  getCHDHIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TDMAC0_DCH0INT.setCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TDMAC0_DCH0INT.clearCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TDMAC0_DCH0INT.setCHDDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TDMAC0_DCH0INT.getCHDDIE : TBits_1; inline;
begin
  getCHDDIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TDMAC0_DCH0INT.setCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDMAC0_DCH0INT.clearCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDMAC0_DCH0INT.setCHSHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDMAC0_DCH0INT.getCHSHIE : TBits_1; inline;
begin
  getCHSHIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDMAC0_DCH0INT.setCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDMAC0_DCH0INT.clearCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDMAC0_DCH0INT.setCHSDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDMAC0_DCH0INT.getCHSDIE : TBits_1; inline;
begin
  getCHSDIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDMAC0_DCH0INT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC0_DCH0INT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC1_DCH1CON.setCHPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDMAC1_DCH1CON.getCHPRI : TBits_2; inline;
begin
  getCHPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDMAC1_DCH1CON.setCHEDET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC1_DCH1CON.clearCHEDET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC1_DCH1CON.setCHEDET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC1_DCH1CON.getCHEDET : TBits_1; inline;
begin
  getCHEDET := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC1_DCH1CON.setCHAEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC1_DCH1CON.clearCHAEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC1_DCH1CON.setCHAEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC1_DCH1CON.getCHAEN : TBits_1; inline;
begin
  getCHAEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC1_DCH1CON.setCHCHN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC1_DCH1CON.clearCHCHN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC1_DCH1CON.setCHCHN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC1_DCH1CON.getCHCHN : TBits_1; inline;
begin
  getCHCHN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC1_DCH1CON.setCHAED; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC1_DCH1CON.clearCHAED; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC1_DCH1CON.setCHAED(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC1_DCH1CON.getCHAED : TBits_1; inline;
begin
  getCHAED := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC1_DCH1CON.setCHEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC1_DCH1CON.clearCHEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC1_DCH1CON.setCHEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC1_DCH1CON.getCHEN : TBits_1; inline;
begin
  getCHEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC1_DCH1CON.setCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TDMAC1_DCH1CON.clearCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TDMAC1_DCH1CON.setCHCHNS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TDMAC1_DCH1CON.getCHCHNS : TBits_1; inline;
begin
  getCHCHNS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TDMAC1_DCH1CON.setCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC1_DCH1CON.clearCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC1_DCH1CON.setCHBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC1_DCH1CON.getCHBUSY : TBits_1; inline;
begin
  getCHBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC1_DCH1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC1_DCH1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC1_DCH1ECON.setAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC1_DCH1ECON.clearAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC1_DCH1ECON.setAIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC1_DCH1ECON.getAIRQEN : TBits_1; inline;
begin
  getAIRQEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC1_DCH1ECON.setSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC1_DCH1ECON.clearSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC1_DCH1ECON.setSIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC1_DCH1ECON.getSIRQEN : TBits_1; inline;
begin
  getSIRQEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC1_DCH1ECON.setPATEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC1_DCH1ECON.clearPATEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC1_DCH1ECON.setPATEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC1_DCH1ECON.getPATEN : TBits_1; inline;
begin
  getPATEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC1_DCH1ECON.setCABORT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC1_DCH1ECON.clearCABORT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC1_DCH1ECON.setCABORT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC1_DCH1ECON.getCABORT : TBits_1; inline;
begin
  getCABORT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC1_DCH1ECON.setCFORCE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC1_DCH1ECON.clearCFORCE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC1_DCH1ECON.setCFORCE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC1_DCH1ECON.getCFORCE : TBits_1; inline;
begin
  getCFORCE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC1_DCH1ECON.setCHSIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF00FF or ( thebits shl 8 );
end;
function  TDMAC1_DCH1ECON.getCHSIRQ : TBits_8; inline;
begin
  getCHSIRQ := (pTDefRegMap(@Self)^.val and $0000FF00) shr 8;
end;
procedure TDMAC1_DCH1ECON.setCHAIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TDMAC1_DCH1ECON.getCHAIRQ : TBits_8; inline;
begin
  getCHAIRQ := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TDMAC1_DCH1ECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC1_DCH1ECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC1_DCH1INT.setCHERIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TDMAC1_DCH1INT.clearCHERIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TDMAC1_DCH1INT.setCHERIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TDMAC1_DCH1INT.getCHERIF : TBits_1; inline;
begin
  getCHERIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TDMAC1_DCH1INT.setCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TDMAC1_DCH1INT.clearCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TDMAC1_DCH1INT.setCHTAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TDMAC1_DCH1INT.getCHTAIF : TBits_1; inline;
begin
  getCHTAIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TDMAC1_DCH1INT.setCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC1_DCH1INT.clearCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC1_DCH1INT.setCHCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC1_DCH1INT.getCHCCIF : TBits_1; inline;
begin
  getCHCCIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC1_DCH1INT.setCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC1_DCH1INT.clearCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC1_DCH1INT.setCHBCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC1_DCH1INT.getCHBCIF : TBits_1; inline;
begin
  getCHBCIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC1_DCH1INT.setCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC1_DCH1INT.clearCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC1_DCH1INT.setCHDHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC1_DCH1INT.getCHDHIF : TBits_1; inline;
begin
  getCHDHIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC1_DCH1INT.setCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC1_DCH1INT.clearCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC1_DCH1INT.setCHDDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC1_DCH1INT.getCHDDIF : TBits_1; inline;
begin
  getCHDDIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC1_DCH1INT.setCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC1_DCH1INT.clearCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC1_DCH1INT.setCHSHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC1_DCH1INT.getCHSHIF : TBits_1; inline;
begin
  getCHSHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC1_DCH1INT.setCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC1_DCH1INT.clearCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC1_DCH1INT.setCHSDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC1_DCH1INT.getCHSDIF : TBits_1; inline;
begin
  getCHSDIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC1_DCH1INT.setCHERIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TDMAC1_DCH1INT.clearCHERIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TDMAC1_DCH1INT.setCHERIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TDMAC1_DCH1INT.getCHERIE : TBits_1; inline;
begin
  getCHERIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TDMAC1_DCH1INT.setCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TDMAC1_DCH1INT.clearCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TDMAC1_DCH1INT.setCHTAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TDMAC1_DCH1INT.getCHTAIE : TBits_1; inline;
begin
  getCHTAIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TDMAC1_DCH1INT.setCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TDMAC1_DCH1INT.clearCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TDMAC1_DCH1INT.setCHCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TDMAC1_DCH1INT.getCHCCIE : TBits_1; inline;
begin
  getCHCCIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TDMAC1_DCH1INT.setCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TDMAC1_DCH1INT.clearCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TDMAC1_DCH1INT.setCHBCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TDMAC1_DCH1INT.getCHBCIE : TBits_1; inline;
begin
  getCHBCIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TDMAC1_DCH1INT.setCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TDMAC1_DCH1INT.clearCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TDMAC1_DCH1INT.setCHDHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TDMAC1_DCH1INT.getCHDHIE : TBits_1; inline;
begin
  getCHDHIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TDMAC1_DCH1INT.setCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TDMAC1_DCH1INT.clearCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TDMAC1_DCH1INT.setCHDDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TDMAC1_DCH1INT.getCHDDIE : TBits_1; inline;
begin
  getCHDDIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TDMAC1_DCH1INT.setCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDMAC1_DCH1INT.clearCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDMAC1_DCH1INT.setCHSHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDMAC1_DCH1INT.getCHSHIE : TBits_1; inline;
begin
  getCHSHIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDMAC1_DCH1INT.setCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDMAC1_DCH1INT.clearCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDMAC1_DCH1INT.setCHSDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDMAC1_DCH1INT.getCHSDIE : TBits_1; inline;
begin
  getCHSDIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDMAC1_DCH1INT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC1_DCH1INT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC2_DCH2CON.setCHPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDMAC2_DCH2CON.getCHPRI : TBits_2; inline;
begin
  getCHPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDMAC2_DCH2CON.setCHEDET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC2_DCH2CON.clearCHEDET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC2_DCH2CON.setCHEDET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC2_DCH2CON.getCHEDET : TBits_1; inline;
begin
  getCHEDET := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC2_DCH2CON.setCHAEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC2_DCH2CON.clearCHAEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC2_DCH2CON.setCHAEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC2_DCH2CON.getCHAEN : TBits_1; inline;
begin
  getCHAEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC2_DCH2CON.setCHCHN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC2_DCH2CON.clearCHCHN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC2_DCH2CON.setCHCHN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC2_DCH2CON.getCHCHN : TBits_1; inline;
begin
  getCHCHN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC2_DCH2CON.setCHAED; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC2_DCH2CON.clearCHAED; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC2_DCH2CON.setCHAED(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC2_DCH2CON.getCHAED : TBits_1; inline;
begin
  getCHAED := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC2_DCH2CON.setCHEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC2_DCH2CON.clearCHEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC2_DCH2CON.setCHEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC2_DCH2CON.getCHEN : TBits_1; inline;
begin
  getCHEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC2_DCH2CON.setCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TDMAC2_DCH2CON.clearCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TDMAC2_DCH2CON.setCHCHNS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TDMAC2_DCH2CON.getCHCHNS : TBits_1; inline;
begin
  getCHCHNS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TDMAC2_DCH2CON.setCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC2_DCH2CON.clearCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC2_DCH2CON.setCHBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC2_DCH2CON.getCHBUSY : TBits_1; inline;
begin
  getCHBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC2_DCH2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC2_DCH2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC2_DCH2ECON.setAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC2_DCH2ECON.clearAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC2_DCH2ECON.setAIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC2_DCH2ECON.getAIRQEN : TBits_1; inline;
begin
  getAIRQEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC2_DCH2ECON.setSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC2_DCH2ECON.clearSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC2_DCH2ECON.setSIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC2_DCH2ECON.getSIRQEN : TBits_1; inline;
begin
  getSIRQEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC2_DCH2ECON.setPATEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC2_DCH2ECON.clearPATEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC2_DCH2ECON.setPATEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC2_DCH2ECON.getPATEN : TBits_1; inline;
begin
  getPATEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC2_DCH2ECON.setCABORT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC2_DCH2ECON.clearCABORT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC2_DCH2ECON.setCABORT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC2_DCH2ECON.getCABORT : TBits_1; inline;
begin
  getCABORT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC2_DCH2ECON.setCFORCE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC2_DCH2ECON.clearCFORCE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC2_DCH2ECON.setCFORCE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC2_DCH2ECON.getCFORCE : TBits_1; inline;
begin
  getCFORCE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC2_DCH2ECON.setCHSIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF00FF or ( thebits shl 8 );
end;
function  TDMAC2_DCH2ECON.getCHSIRQ : TBits_8; inline;
begin
  getCHSIRQ := (pTDefRegMap(@Self)^.val and $0000FF00) shr 8;
end;
procedure TDMAC2_DCH2ECON.setCHAIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TDMAC2_DCH2ECON.getCHAIRQ : TBits_8; inline;
begin
  getCHAIRQ := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TDMAC2_DCH2ECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC2_DCH2ECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC2_DCH2INT.setCHERIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TDMAC2_DCH2INT.clearCHERIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TDMAC2_DCH2INT.setCHERIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TDMAC2_DCH2INT.getCHERIF : TBits_1; inline;
begin
  getCHERIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TDMAC2_DCH2INT.setCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TDMAC2_DCH2INT.clearCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TDMAC2_DCH2INT.setCHTAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TDMAC2_DCH2INT.getCHTAIF : TBits_1; inline;
begin
  getCHTAIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TDMAC2_DCH2INT.setCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC2_DCH2INT.clearCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC2_DCH2INT.setCHCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC2_DCH2INT.getCHCCIF : TBits_1; inline;
begin
  getCHCCIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC2_DCH2INT.setCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC2_DCH2INT.clearCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC2_DCH2INT.setCHBCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC2_DCH2INT.getCHBCIF : TBits_1; inline;
begin
  getCHBCIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC2_DCH2INT.setCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC2_DCH2INT.clearCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC2_DCH2INT.setCHDHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC2_DCH2INT.getCHDHIF : TBits_1; inline;
begin
  getCHDHIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC2_DCH2INT.setCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC2_DCH2INT.clearCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC2_DCH2INT.setCHDDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC2_DCH2INT.getCHDDIF : TBits_1; inline;
begin
  getCHDDIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC2_DCH2INT.setCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC2_DCH2INT.clearCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC2_DCH2INT.setCHSHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC2_DCH2INT.getCHSHIF : TBits_1; inline;
begin
  getCHSHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC2_DCH2INT.setCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC2_DCH2INT.clearCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC2_DCH2INT.setCHSDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC2_DCH2INT.getCHSDIF : TBits_1; inline;
begin
  getCHSDIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC2_DCH2INT.setCHERIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TDMAC2_DCH2INT.clearCHERIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TDMAC2_DCH2INT.setCHERIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TDMAC2_DCH2INT.getCHERIE : TBits_1; inline;
begin
  getCHERIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TDMAC2_DCH2INT.setCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TDMAC2_DCH2INT.clearCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TDMAC2_DCH2INT.setCHTAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TDMAC2_DCH2INT.getCHTAIE : TBits_1; inline;
begin
  getCHTAIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TDMAC2_DCH2INT.setCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TDMAC2_DCH2INT.clearCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TDMAC2_DCH2INT.setCHCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TDMAC2_DCH2INT.getCHCCIE : TBits_1; inline;
begin
  getCHCCIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TDMAC2_DCH2INT.setCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TDMAC2_DCH2INT.clearCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TDMAC2_DCH2INT.setCHBCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TDMAC2_DCH2INT.getCHBCIE : TBits_1; inline;
begin
  getCHBCIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TDMAC2_DCH2INT.setCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TDMAC2_DCH2INT.clearCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TDMAC2_DCH2INT.setCHDHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TDMAC2_DCH2INT.getCHDHIE : TBits_1; inline;
begin
  getCHDHIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TDMAC2_DCH2INT.setCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TDMAC2_DCH2INT.clearCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TDMAC2_DCH2INT.setCHDDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TDMAC2_DCH2INT.getCHDDIE : TBits_1; inline;
begin
  getCHDDIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TDMAC2_DCH2INT.setCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDMAC2_DCH2INT.clearCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDMAC2_DCH2INT.setCHSHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDMAC2_DCH2INT.getCHSHIE : TBits_1; inline;
begin
  getCHSHIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDMAC2_DCH2INT.setCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDMAC2_DCH2INT.clearCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDMAC2_DCH2INT.setCHSDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDMAC2_DCH2INT.getCHSDIE : TBits_1; inline;
begin
  getCHSDIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDMAC2_DCH2INT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC2_DCH2INT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC3_DCH3CON.setCHPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDMAC3_DCH3CON.getCHPRI : TBits_2; inline;
begin
  getCHPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDMAC3_DCH3CON.setCHEDET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC3_DCH3CON.clearCHEDET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC3_DCH3CON.setCHEDET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC3_DCH3CON.getCHEDET : TBits_1; inline;
begin
  getCHEDET := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC3_DCH3CON.setCHAEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC3_DCH3CON.clearCHAEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC3_DCH3CON.setCHAEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC3_DCH3CON.getCHAEN : TBits_1; inline;
begin
  getCHAEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC3_DCH3CON.setCHCHN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC3_DCH3CON.clearCHCHN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC3_DCH3CON.setCHCHN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC3_DCH3CON.getCHCHN : TBits_1; inline;
begin
  getCHCHN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC3_DCH3CON.setCHAED; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC3_DCH3CON.clearCHAED; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC3_DCH3CON.setCHAED(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC3_DCH3CON.getCHAED : TBits_1; inline;
begin
  getCHAED := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC3_DCH3CON.setCHEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC3_DCH3CON.clearCHEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC3_DCH3CON.setCHEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC3_DCH3CON.getCHEN : TBits_1; inline;
begin
  getCHEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC3_DCH3CON.setCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TDMAC3_DCH3CON.clearCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TDMAC3_DCH3CON.setCHCHNS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TDMAC3_DCH3CON.getCHCHNS : TBits_1; inline;
begin
  getCHCHNS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TDMAC3_DCH3CON.setCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC3_DCH3CON.clearCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC3_DCH3CON.setCHBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC3_DCH3CON.getCHBUSY : TBits_1; inline;
begin
  getCHBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC3_DCH3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC3_DCH3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC3_DCH3ECON.setAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC3_DCH3ECON.clearAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC3_DCH3ECON.setAIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC3_DCH3ECON.getAIRQEN : TBits_1; inline;
begin
  getAIRQEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC3_DCH3ECON.setSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC3_DCH3ECON.clearSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC3_DCH3ECON.setSIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC3_DCH3ECON.getSIRQEN : TBits_1; inline;
begin
  getSIRQEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC3_DCH3ECON.setPATEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC3_DCH3ECON.clearPATEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC3_DCH3ECON.setPATEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC3_DCH3ECON.getPATEN : TBits_1; inline;
begin
  getPATEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC3_DCH3ECON.setCABORT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC3_DCH3ECON.clearCABORT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC3_DCH3ECON.setCABORT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC3_DCH3ECON.getCABORT : TBits_1; inline;
begin
  getCABORT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC3_DCH3ECON.setCFORCE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC3_DCH3ECON.clearCFORCE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC3_DCH3ECON.setCFORCE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC3_DCH3ECON.getCFORCE : TBits_1; inline;
begin
  getCFORCE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC3_DCH3ECON.setCHSIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF00FF or ( thebits shl 8 );
end;
function  TDMAC3_DCH3ECON.getCHSIRQ : TBits_8; inline;
begin
  getCHSIRQ := (pTDefRegMap(@Self)^.val and $0000FF00) shr 8;
end;
procedure TDMAC3_DCH3ECON.setCHAIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TDMAC3_DCH3ECON.getCHAIRQ : TBits_8; inline;
begin
  getCHAIRQ := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TDMAC3_DCH3ECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC3_DCH3ECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC3_DCH3INT.setCHERIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TDMAC3_DCH3INT.clearCHERIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TDMAC3_DCH3INT.setCHERIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TDMAC3_DCH3INT.getCHERIF : TBits_1; inline;
begin
  getCHERIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TDMAC3_DCH3INT.setCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TDMAC3_DCH3INT.clearCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TDMAC3_DCH3INT.setCHTAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TDMAC3_DCH3INT.getCHTAIF : TBits_1; inline;
begin
  getCHTAIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TDMAC3_DCH3INT.setCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC3_DCH3INT.clearCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC3_DCH3INT.setCHCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC3_DCH3INT.getCHCCIF : TBits_1; inline;
begin
  getCHCCIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC3_DCH3INT.setCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC3_DCH3INT.clearCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC3_DCH3INT.setCHBCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC3_DCH3INT.getCHBCIF : TBits_1; inline;
begin
  getCHBCIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC3_DCH3INT.setCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC3_DCH3INT.clearCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC3_DCH3INT.setCHDHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC3_DCH3INT.getCHDHIF : TBits_1; inline;
begin
  getCHDHIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC3_DCH3INT.setCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC3_DCH3INT.clearCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC3_DCH3INT.setCHDDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC3_DCH3INT.getCHDDIF : TBits_1; inline;
begin
  getCHDDIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC3_DCH3INT.setCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC3_DCH3INT.clearCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC3_DCH3INT.setCHSHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC3_DCH3INT.getCHSHIF : TBits_1; inline;
begin
  getCHSHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC3_DCH3INT.setCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC3_DCH3INT.clearCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC3_DCH3INT.setCHSDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC3_DCH3INT.getCHSDIF : TBits_1; inline;
begin
  getCHSDIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC3_DCH3INT.setCHERIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TDMAC3_DCH3INT.clearCHERIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TDMAC3_DCH3INT.setCHERIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TDMAC3_DCH3INT.getCHERIE : TBits_1; inline;
begin
  getCHERIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TDMAC3_DCH3INT.setCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TDMAC3_DCH3INT.clearCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TDMAC3_DCH3INT.setCHTAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TDMAC3_DCH3INT.getCHTAIE : TBits_1; inline;
begin
  getCHTAIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TDMAC3_DCH3INT.setCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TDMAC3_DCH3INT.clearCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TDMAC3_DCH3INT.setCHCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TDMAC3_DCH3INT.getCHCCIE : TBits_1; inline;
begin
  getCHCCIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TDMAC3_DCH3INT.setCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TDMAC3_DCH3INT.clearCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TDMAC3_DCH3INT.setCHBCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TDMAC3_DCH3INT.getCHBCIE : TBits_1; inline;
begin
  getCHBCIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TDMAC3_DCH3INT.setCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TDMAC3_DCH3INT.clearCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TDMAC3_DCH3INT.setCHDHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TDMAC3_DCH3INT.getCHDHIE : TBits_1; inline;
begin
  getCHDHIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TDMAC3_DCH3INT.setCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TDMAC3_DCH3INT.clearCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TDMAC3_DCH3INT.setCHDDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TDMAC3_DCH3INT.getCHDDIE : TBits_1; inline;
begin
  getCHDDIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TDMAC3_DCH3INT.setCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDMAC3_DCH3INT.clearCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDMAC3_DCH3INT.setCHSHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDMAC3_DCH3INT.getCHSHIE : TBits_1; inline;
begin
  getCHSHIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDMAC3_DCH3INT.setCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDMAC3_DCH3INT.clearCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDMAC3_DCH3INT.setCHSDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDMAC3_DCH3INT.getCHSDIE : TBits_1; inline;
begin
  getCHSDIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDMAC3_DCH3INT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC3_DCH3INT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPCACHE_CHECON.setPFMWS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TPCACHE_CHECON.getPFMWS : TBits_3; inline;
begin
  getPFMWS := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TPCACHE_CHECON.setPREFEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFCF or ( thebits shl 4 );
end;
function  TPCACHE_CHECON.getPREFEN : TBits_2; inline;
begin
  getPREFEN := (pTDefRegMap(@Self)^.val and $00000030) shr 4;
end;
procedure TPCACHE_CHECON.setDCSZ(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TPCACHE_CHECON.getDCSZ : TBits_2; inline;
begin
  getDCSZ := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TPCACHE_CHECON.setCHECOH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TPCACHE_CHECON.clearCHECOH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TPCACHE_CHECON.setCHECOH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TPCACHE_CHECON.getCHECOH : TBits_1; inline;
begin
  getCHECOH := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TPCACHE_CHECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPCACHE_CHECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPCACHE_CHETAG.setLTYPE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPCACHE_CHETAG.clearLTYPE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPCACHE_CHETAG.setLTYPE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPCACHE_CHETAG.getLTYPE : TBits_1; inline;
begin
  getLTYPE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPCACHE_CHETAG.setLLOCK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPCACHE_CHETAG.clearLLOCK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPCACHE_CHETAG.setLLOCK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPCACHE_CHETAG.getLLOCK : TBits_1; inline;
begin
  getLLOCK := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPCACHE_CHETAG.setLVALID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPCACHE_CHETAG.clearLVALID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPCACHE_CHETAG.setLVALID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPCACHE_CHETAG.getLVALID : TBits_1; inline;
begin
  getLVALID := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPCACHE_CHETAG.setLTAG(thebits : TBits_20); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00000F or ( thebits shl 4 );
end;
function  TPCACHE_CHETAG.getLTAG : TBits_20; inline;
begin
  getLTAG := (pTDefRegMap(@Self)^.val and $00FFFFF0) shr 4;
end;
procedure TPCACHE_CHETAG.setLTAGBOOT; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TPCACHE_CHETAG.clearLTAGBOOT; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TPCACHE_CHETAG.setLTAGBOOT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TPCACHE_CHETAG.getLTAGBOOT : TBits_1; inline;
begin
  getLTAGBOOT := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TPCACHE_CHETAG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPCACHE_CHETAG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUSB_U1IR.setURSTIF_DETACHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IR.clearURSTIF_DETACHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IR.setURSTIF_DETACHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IR.getURSTIF_DETACHIF : TBits_1; inline;
begin
  getURSTIF_DETACHIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IR.setUERRIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1IR.clearUERRIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1IR.setUERRIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1IR.getUERRIF : TBits_1; inline;
begin
  getUERRIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1IR.setSOFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1IR.clearSOFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1IR.setSOFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1IR.getSOFIF : TBits_1; inline;
begin
  getSOFIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1IR.setTRNIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1IR.clearTRNIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1IR.setTRNIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1IR.getTRNIF : TBits_1; inline;
begin
  getTRNIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1IR.setIDLEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1IR.clearIDLEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1IR.setIDLEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1IR.getIDLEIF : TBits_1; inline;
begin
  getIDLEIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1IR.setRESUMEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1IR.clearRESUMEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1IR.setRESUMEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1IR.getRESUMEIF : TBits_1; inline;
begin
  getRESUMEIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1IR.setATTACHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1IR.clearATTACHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1IR.setATTACHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1IR.getATTACHIF : TBits_1; inline;
begin
  getATTACHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1IR.setSTALLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1IR.clearSTALLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1IR.setSTALLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1IR.getSTALLIF : TBits_1; inline;
begin
  getSTALLIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1IR.setDETACHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IR.clearDETACHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IR.setDETACHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IR.getDETACHIF : TBits_1; inline;
begin
  getDETACHIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IR.setURSTIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IR.clearURSTIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IR.setURSTIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IR.getURSTIF : TBits_1; inline;
begin
  getURSTIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IE.setURSTIE_DETACHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IE.clearURSTIE_DETACHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IE.setURSTIE_DETACHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IE.getURSTIE_DETACHIE : TBits_1; inline;
begin
  getURSTIE_DETACHIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IE.setUERRIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1IE.clearUERRIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1IE.setUERRIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1IE.getUERRIE : TBits_1; inline;
begin
  getUERRIE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1IE.setSOFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1IE.clearSOFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1IE.setSOFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1IE.getSOFIE : TBits_1; inline;
begin
  getSOFIE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1IE.setTRNIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1IE.clearTRNIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1IE.setTRNIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1IE.getTRNIE : TBits_1; inline;
begin
  getTRNIE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1IE.setIDLEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1IE.clearIDLEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1IE.setIDLEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1IE.getIDLEIE : TBits_1; inline;
begin
  getIDLEIE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1IE.setRESUMEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1IE.clearRESUMEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1IE.setRESUMEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1IE.getRESUMEIE : TBits_1; inline;
begin
  getRESUMEIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1IE.setATTACHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1IE.clearATTACHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1IE.setATTACHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1IE.getATTACHIE : TBits_1; inline;
begin
  getATTACHIE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1IE.setSTALLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1IE.clearSTALLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1IE.setSTALLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1IE.getSTALLIE : TBits_1; inline;
begin
  getSTALLIE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1IE.setDETACHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IE.clearDETACHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IE.setDETACHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IE.getDETACHIE : TBits_1; inline;
begin
  getDETACHIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IE.setURSTIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IE.clearURSTIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IE.setURSTIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IE.getURSTIE : TBits_1; inline;
begin
  getURSTIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1EIR.setPIDEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1EIR.clearPIDEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1EIR.setPIDEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1EIR.getPIDEF : TBits_1; inline;
begin
  getPIDEF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1EIR.setCRC5EF_EOFEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIR.clearCRC5EF_EOFEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIR.setCRC5EF_EOFEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIR.getCRC5EF_EOFEF : TBits_1; inline;
begin
  getCRC5EF_EOFEF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIR.setCRC16EF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1EIR.clearCRC16EF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1EIR.setCRC16EF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1EIR.getCRC16EF : TBits_1; inline;
begin
  getCRC16EF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1EIR.setDFN8EF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1EIR.clearDFN8EF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1EIR.setDFN8EF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1EIR.getDFN8EF : TBits_1; inline;
begin
  getDFN8EF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1EIR.setBTOEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1EIR.clearBTOEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1EIR.setBTOEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1EIR.getBTOEF : TBits_1; inline;
begin
  getBTOEF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1EIR.setDMAEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1EIR.clearDMAEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1EIR.setDMAEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1EIR.getDMAEF : TBits_1; inline;
begin
  getDMAEF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1EIR.setBMXEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1EIR.clearBMXEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1EIR.setBMXEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1EIR.getBMXEF : TBits_1; inline;
begin
  getBMXEF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1EIR.setBTSEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1EIR.clearBTSEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1EIR.setBTSEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1EIR.getBTSEF : TBits_1; inline;
begin
  getBTSEF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1EIR.setCRC5EF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIR.clearCRC5EF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIR.setCRC5EF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIR.getCRC5EF : TBits_1; inline;
begin
  getCRC5EF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIR.setEOFEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIR.clearEOFEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIR.setEOFEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIR.getEOFEF : TBits_1; inline;
begin
  getEOFEF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIE.setPIDEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1EIE.clearPIDEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1EIE.setPIDEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1EIE.getPIDEE : TBits_1; inline;
begin
  getPIDEE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1EIE.setCRC5EE_EOFEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIE.clearCRC5EE_EOFEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIE.setCRC5EE_EOFEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIE.getCRC5EE_EOFEE : TBits_1; inline;
begin
  getCRC5EE_EOFEE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIE.setCRC16EE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1EIE.clearCRC16EE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1EIE.setCRC16EE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1EIE.getCRC16EE : TBits_1; inline;
begin
  getCRC16EE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1EIE.setDFN8EE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1EIE.clearDFN8EE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1EIE.setDFN8EE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1EIE.getDFN8EE : TBits_1; inline;
begin
  getDFN8EE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1EIE.setBTOEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1EIE.clearBTOEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1EIE.setBTOEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1EIE.getBTOEE : TBits_1; inline;
begin
  getBTOEE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1EIE.setDMAEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1EIE.clearDMAEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1EIE.setDMAEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1EIE.getDMAEE : TBits_1; inline;
begin
  getDMAEE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1EIE.setBMXEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1EIE.clearBMXEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1EIE.setBMXEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1EIE.getBMXEE : TBits_1; inline;
begin
  getBMXEE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1EIE.setBTSEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1EIE.clearBTSEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1EIE.setBTSEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1EIE.getBTSEE : TBits_1; inline;
begin
  getBTSEE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1EIE.setCRC5EE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIE.clearCRC5EE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIE.setCRC5EE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIE.getCRC5EE : TBits_1; inline;
begin
  getCRC5EE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIE.setEOFEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIE.clearEOFEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIE.setEOFEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIE.getEOFEE : TBits_1; inline;
begin
  getEOFEE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1STAT.setPPBI; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1STAT.clearPPBI; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1STAT.setPPBI(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1STAT.getPPBI : TBits_1; inline;
begin
  getPPBI := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1STAT.setDIR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1STAT.clearDIR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1STAT.setDIR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1STAT.getDIR : TBits_1; inline;
begin
  getDIR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1STAT.setENDPT(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF0F or ( thebits shl 4 );
end;
function  TUSB_U1STAT.getENDPT : TBits_4; inline;
begin
  getENDPT := (pTDefRegMap(@Self)^.val and $000000F0) shr 4;
end;
procedure TUSB_U1STAT.setENDPT0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1STAT.clearENDPT0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1STAT.setENDPT0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1STAT.getENDPT0 : TBits_1; inline;
begin
  getENDPT0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1STAT.setENDPT1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1STAT.clearENDPT1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1STAT.setENDPT1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1STAT.getENDPT1 : TBits_1; inline;
begin
  getENDPT1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1STAT.setENDPT2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1STAT.clearENDPT2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1STAT.setENDPT2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1STAT.getENDPT2 : TBits_1; inline;
begin
  getENDPT2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1STAT.setENDPT3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1STAT.clearENDPT3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1STAT.setENDPT3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1STAT.getENDPT3 : TBits_1; inline;
begin
  getENDPT3 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1CON.setUSBEN_SOFEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1CON.clearUSBEN_SOFEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1CON.setUSBEN_SOFEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1CON.getUSBEN_SOFEN : TBits_1; inline;
begin
  getUSBEN_SOFEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1CON.setPPBRST; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1CON.clearPPBRST; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1CON.setPPBRST(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1CON.getPPBRST : TBits_1; inline;
begin
  getPPBRST := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1CON.setRESUME; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1CON.clearRESUME; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1CON.setRESUME(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1CON.getRESUME : TBits_1; inline;
begin
  getRESUME := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1CON.setHOSTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1CON.clearHOSTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1CON.setHOSTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1CON.getHOSTEN : TBits_1; inline;
begin
  getHOSTEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1CON.setUSBRST; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1CON.clearUSBRST; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1CON.setUSBRST(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1CON.getUSBRST : TBits_1; inline;
begin
  getUSBRST := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1CON.setPKTDIS_TOKBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1CON.clearPKTDIS_TOKBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1CON.setPKTDIS_TOKBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1CON.getPKTDIS_TOKBUSY : TBits_1; inline;
begin
  getPKTDIS_TOKBUSY := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1CON.setSE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1CON.clearSE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1CON.setSE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1CON.getSE0 : TBits_1; inline;
begin
  getSE0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1CON.setJSTATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1CON.clearJSTATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1CON.setJSTATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1CON.getJSTATE : TBits_1; inline;
begin
  getJSTATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1CON.setUSBEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1CON.clearUSBEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1CON.setUSBEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1CON.getUSBEN : TBits_1; inline;
begin
  getUSBEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1CON.setSOFEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1CON.clearSOFEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1CON.setSOFEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1CON.getSOFEN : TBits_1; inline;
begin
  getSOFEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1CON.setPKTDIS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1CON.clearPKTDIS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1CON.setPKTDIS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1CON.getPKTDIS : TBits_1; inline;
begin
  getPKTDIS := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1CON.setTOKBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1CON.clearTOKBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1CON.setTOKBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1CON.getTOKBUSY : TBits_1; inline;
begin
  getTOKBUSY := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1ADDR.setDEVADDR(thebits : TBits_7); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF80 or ( thebits shl 0 );
end;
function  TUSB_U1ADDR.getDEVADDR : TBits_7; inline;
begin
  getDEVADDR := (pTDefRegMap(@Self)^.val and $0000007F) shr 0;
end;
procedure TUSB_U1ADDR.setLSPDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1ADDR.clearLSPDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1ADDR.setLSPDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1ADDR.getLSPDEN : TBits_1; inline;
begin
  getLSPDEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1ADDR.setDEVADDR0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1ADDR.clearDEVADDR0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1ADDR.setDEVADDR0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1ADDR.getDEVADDR0 : TBits_1; inline;
begin
  getDEVADDR0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1ADDR.setDEVADDR1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1ADDR.clearDEVADDR1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1ADDR.setDEVADDR1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1ADDR.getDEVADDR1 : TBits_1; inline;
begin
  getDEVADDR1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1ADDR.setDEVADDR2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1ADDR.clearDEVADDR2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1ADDR.setDEVADDR2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1ADDR.getDEVADDR2 : TBits_1; inline;
begin
  getDEVADDR2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1ADDR.setDEVADDR3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1ADDR.clearDEVADDR3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1ADDR.setDEVADDR3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1ADDR.getDEVADDR3 : TBits_1; inline;
begin
  getDEVADDR3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1ADDR.setDEVADDR4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1ADDR.clearDEVADDR4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1ADDR.setDEVADDR4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1ADDR.getDEVADDR4 : TBits_1; inline;
begin
  getDEVADDR4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1ADDR.setDEVADDR5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1ADDR.clearDEVADDR5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1ADDR.setDEVADDR5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1ADDR.getDEVADDR5 : TBits_1; inline;
begin
  getDEVADDR5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1ADDR.setDEVADDR6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1ADDR.clearDEVADDR6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1ADDR.setDEVADDR6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1ADDR.getDEVADDR6 : TBits_1; inline;
begin
  getDEVADDR6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1FRML.setFRML(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF00 or ( thebits shl 0 );
end;
function  TUSB_U1FRML.getFRML : TBits_8; inline;
begin
  getFRML := (pTDefRegMap(@Self)^.val and $000000FF) shr 0;
end;
procedure TUSB_U1FRML.setFRM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1FRML.clearFRM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1FRML.setFRM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1FRML.getFRM0 : TBits_1; inline;
begin
  getFRM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1FRML.setFRM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1FRML.clearFRM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1FRML.setFRM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1FRML.getFRM1 : TBits_1; inline;
begin
  getFRM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1FRML.setFRM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1FRML.clearFRM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1FRML.setFRM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1FRML.getFRM2 : TBits_1; inline;
begin
  getFRM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1FRML.setFRM3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1FRML.clearFRM3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1FRML.setFRM3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1FRML.getFRM3 : TBits_1; inline;
begin
  getFRM3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1FRML.setFRM4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1FRML.clearFRM4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1FRML.setFRM4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1FRML.getFRM4 : TBits_1; inline;
begin
  getFRM4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1FRML.setFRM5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1FRML.clearFRM5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1FRML.setFRM5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1FRML.getFRM5 : TBits_1; inline;
begin
  getFRM5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1FRML.setFRM6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1FRML.clearFRM6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1FRML.setFRM6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1FRML.getFRM6 : TBits_1; inline;
begin
  getFRM6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1FRML.setFRM7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1FRML.clearFRM7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1FRML.setFRM7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1FRML.getFRM7 : TBits_1; inline;
begin
  getFRM7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1FRMH.setFRMH(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TUSB_U1FRMH.getFRMH : TBits_3; inline;
begin
  getFRMH := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TUSB_U1FRMH.setFRM8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1FRMH.clearFRM8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1FRMH.setFRM8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1FRMH.getFRM8 : TBits_1; inline;
begin
  getFRM8 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1FRMH.setFRM9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1FRMH.clearFRM9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1FRMH.setFRM9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1FRMH.getFRM9 : TBits_1; inline;
begin
  getFRM9 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1FRMH.setFRM10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1FRMH.clearFRM10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1FRMH.setFRM10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1FRMH.getFRM10 : TBits_1; inline;
begin
  getFRM10 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1TOK.setEP(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TUSB_U1TOK.getEP : TBits_4; inline;
begin
  getEP := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TUSB_U1TOK.setPID(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF0F or ( thebits shl 4 );
end;
function  TUSB_U1TOK.getPID : TBits_4; inline;
begin
  getPID := (pTDefRegMap(@Self)^.val and $000000F0) shr 4;
end;
procedure TUSB_U1TOK.setEP0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1TOK.clearEP0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1TOK.setEP0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1TOK.getEP0 : TBits_1; inline;
begin
  getEP0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1TOK.setEP1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1TOK.clearEP1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1TOK.setEP1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1TOK.getEP1 : TBits_1; inline;
begin
  getEP1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1TOK.setEP2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1TOK.clearEP2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1TOK.setEP2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1TOK.getEP2 : TBits_1; inline;
begin
  getEP2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1TOK.setEP3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1TOK.clearEP3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1TOK.setEP3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1TOK.getEP3 : TBits_1; inline;
begin
  getEP3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1TOK.setPID0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1TOK.clearPID0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1TOK.setPID0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1TOK.getPID0 : TBits_1; inline;
begin
  getPID0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1TOK.setPID1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1TOK.clearPID1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1TOK.setPID1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1TOK.getPID1 : TBits_1; inline;
begin
  getPID1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1TOK.setPID2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1TOK.clearPID2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1TOK.setPID2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1TOK.getPID2 : TBits_1; inline;
begin
  getPID2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1TOK.setPID3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1TOK.clearPID3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1TOK.setPID3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1TOK.getPID3 : TBits_1; inline;
begin
  getPID3 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_TRISB.setTRISB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_TRISB.clearTRISB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_TRISB.setTRISB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_TRISB.getTRISB0 : TBits_1; inline;
begin
  getTRISB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_TRISB.setTRISB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_TRISB.clearTRISB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_TRISB.setTRISB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_TRISB.getTRISB1 : TBits_1; inline;
begin
  getTRISB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_TRISB.setTRISB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_TRISB.clearTRISB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_TRISB.setTRISB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_TRISB.getTRISB2 : TBits_1; inline;
begin
  getTRISB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_TRISB.setTRISB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_TRISB.clearTRISB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_TRISB.setTRISB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_TRISB.getTRISB3 : TBits_1; inline;
begin
  getTRISB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_TRISB.setTRISB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_TRISB.clearTRISB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_TRISB.setTRISB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_TRISB.getTRISB4 : TBits_1; inline;
begin
  getTRISB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_TRISB.setTRISB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_TRISB.clearTRISB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_TRISB.setTRISB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_TRISB.getTRISB5 : TBits_1; inline;
begin
  getTRISB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_TRISB.setTRISB6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTB_TRISB.clearTRISB6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTB_TRISB.setTRISB6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTB_TRISB.getTRISB6 : TBits_1; inline;
begin
  getTRISB6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTB_TRISB.setTRISB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_TRISB.clearTRISB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_TRISB.setTRISB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_TRISB.getTRISB7 : TBits_1; inline;
begin
  getTRISB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_TRISB.setTRISB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_TRISB.clearTRISB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_TRISB.setTRISB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_TRISB.getTRISB8 : TBits_1; inline;
begin
  getTRISB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_TRISB.setTRISB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_TRISB.clearTRISB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_TRISB.setTRISB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_TRISB.getTRISB9 : TBits_1; inline;
begin
  getTRISB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_TRISB.setTRISB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_TRISB.clearTRISB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_TRISB.setTRISB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_TRISB.getTRISB10 : TBits_1; inline;
begin
  getTRISB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_TRISB.setTRISB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_TRISB.clearTRISB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_TRISB.setTRISB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_TRISB.getTRISB11 : TBits_1; inline;
begin
  getTRISB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_TRISB.setTRISB12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTB_TRISB.clearTRISB12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTB_TRISB.setTRISB12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTB_TRISB.getTRISB12 : TBits_1; inline;
begin
  getTRISB12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTB_TRISB.setTRISB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_TRISB.clearTRISB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_TRISB.setTRISB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_TRISB.getTRISB13 : TBits_1; inline;
begin
  getTRISB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_TRISB.setTRISB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_TRISB.clearTRISB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_TRISB.setTRISB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_TRISB.getTRISB14 : TBits_1; inline;
begin
  getTRISB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_TRISB.setTRISB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_TRISB.clearTRISB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_TRISB.setTRISB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_TRISB.getTRISB15 : TBits_1; inline;
begin
  getTRISB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_TRISB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_TRISB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_PORTB.setRB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_PORTB.clearRB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_PORTB.setRB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_PORTB.getRB0 : TBits_1; inline;
begin
  getRB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_PORTB.setRB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_PORTB.clearRB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_PORTB.setRB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_PORTB.getRB1 : TBits_1; inline;
begin
  getRB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_PORTB.setRB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_PORTB.clearRB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_PORTB.setRB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_PORTB.getRB2 : TBits_1; inline;
begin
  getRB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_PORTB.setRB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_PORTB.clearRB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_PORTB.setRB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_PORTB.getRB3 : TBits_1; inline;
begin
  getRB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_PORTB.setRB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_PORTB.clearRB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_PORTB.setRB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_PORTB.getRB4 : TBits_1; inline;
begin
  getRB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_PORTB.setRB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_PORTB.clearRB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_PORTB.setRB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_PORTB.getRB5 : TBits_1; inline;
begin
  getRB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_PORTB.setRB6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTB_PORTB.clearRB6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTB_PORTB.setRB6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTB_PORTB.getRB6 : TBits_1; inline;
begin
  getRB6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTB_PORTB.setRB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_PORTB.clearRB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_PORTB.setRB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_PORTB.getRB7 : TBits_1; inline;
begin
  getRB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_PORTB.setRB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_PORTB.clearRB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_PORTB.setRB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_PORTB.getRB8 : TBits_1; inline;
begin
  getRB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_PORTB.setRB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_PORTB.clearRB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_PORTB.setRB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_PORTB.getRB9 : TBits_1; inline;
begin
  getRB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_PORTB.setRB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_PORTB.clearRB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_PORTB.setRB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_PORTB.getRB10 : TBits_1; inline;
begin
  getRB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_PORTB.setRB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_PORTB.clearRB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_PORTB.setRB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_PORTB.getRB11 : TBits_1; inline;
begin
  getRB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_PORTB.setRB12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTB_PORTB.clearRB12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTB_PORTB.setRB12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTB_PORTB.getRB12 : TBits_1; inline;
begin
  getRB12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTB_PORTB.setRB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_PORTB.clearRB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_PORTB.setRB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_PORTB.getRB13 : TBits_1; inline;
begin
  getRB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_PORTB.setRB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_PORTB.clearRB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_PORTB.setRB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_PORTB.getRB14 : TBits_1; inline;
begin
  getRB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_PORTB.setRB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_PORTB.clearRB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_PORTB.setRB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_PORTB.getRB15 : TBits_1; inline;
begin
  getRB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_PORTB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_PORTB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_LATB.setLATB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_LATB.clearLATB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_LATB.setLATB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_LATB.getLATB0 : TBits_1; inline;
begin
  getLATB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_LATB.setLATB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_LATB.clearLATB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_LATB.setLATB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_LATB.getLATB1 : TBits_1; inline;
begin
  getLATB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_LATB.setLATB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_LATB.clearLATB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_LATB.setLATB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_LATB.getLATB2 : TBits_1; inline;
begin
  getLATB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_LATB.setLATB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_LATB.clearLATB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_LATB.setLATB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_LATB.getLATB3 : TBits_1; inline;
begin
  getLATB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_LATB.setLATB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_LATB.clearLATB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_LATB.setLATB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_LATB.getLATB4 : TBits_1; inline;
begin
  getLATB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_LATB.setLATB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_LATB.clearLATB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_LATB.setLATB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_LATB.getLATB5 : TBits_1; inline;
begin
  getLATB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_LATB.setLATB6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTB_LATB.clearLATB6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTB_LATB.setLATB6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTB_LATB.getLATB6 : TBits_1; inline;
begin
  getLATB6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTB_LATB.setLATB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_LATB.clearLATB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_LATB.setLATB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_LATB.getLATB7 : TBits_1; inline;
begin
  getLATB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_LATB.setLATB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_LATB.clearLATB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_LATB.setLATB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_LATB.getLATB8 : TBits_1; inline;
begin
  getLATB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_LATB.setLATB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_LATB.clearLATB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_LATB.setLATB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_LATB.getLATB9 : TBits_1; inline;
begin
  getLATB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_LATB.setLATB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_LATB.clearLATB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_LATB.setLATB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_LATB.getLATB10 : TBits_1; inline;
begin
  getLATB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_LATB.setLATB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_LATB.clearLATB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_LATB.setLATB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_LATB.getLATB11 : TBits_1; inline;
begin
  getLATB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_LATB.setLATB12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTB_LATB.clearLATB12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTB_LATB.setLATB12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTB_LATB.getLATB12 : TBits_1; inline;
begin
  getLATB12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTB_LATB.setLATB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_LATB.clearLATB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_LATB.setLATB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_LATB.getLATB13 : TBits_1; inline;
begin
  getLATB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_LATB.setLATB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_LATB.clearLATB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_LATB.setLATB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_LATB.getLATB14 : TBits_1; inline;
begin
  getLATB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_LATB.setLATB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_LATB.clearLATB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_LATB.setLATB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_LATB.getLATB15 : TBits_1; inline;
begin
  getLATB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_LATB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_LATB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_ODCB.setODCB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_ODCB.clearODCB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_ODCB.setODCB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_ODCB.getODCB0 : TBits_1; inline;
begin
  getODCB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_ODCB.setODCB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_ODCB.clearODCB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_ODCB.setODCB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_ODCB.getODCB1 : TBits_1; inline;
begin
  getODCB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_ODCB.setODCB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_ODCB.clearODCB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_ODCB.setODCB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_ODCB.getODCB2 : TBits_1; inline;
begin
  getODCB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_ODCB.setODCB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_ODCB.clearODCB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_ODCB.setODCB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_ODCB.getODCB3 : TBits_1; inline;
begin
  getODCB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_ODCB.setODCB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_ODCB.clearODCB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_ODCB.setODCB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_ODCB.getODCB4 : TBits_1; inline;
begin
  getODCB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_ODCB.setODCB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_ODCB.clearODCB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_ODCB.setODCB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_ODCB.getODCB5 : TBits_1; inline;
begin
  getODCB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_ODCB.setODCB6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTB_ODCB.clearODCB6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTB_ODCB.setODCB6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTB_ODCB.getODCB6 : TBits_1; inline;
begin
  getODCB6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTB_ODCB.setODCB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_ODCB.clearODCB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_ODCB.setODCB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_ODCB.getODCB7 : TBits_1; inline;
begin
  getODCB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_ODCB.setODCB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_ODCB.clearODCB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_ODCB.setODCB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_ODCB.getODCB8 : TBits_1; inline;
begin
  getODCB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_ODCB.setODCB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_ODCB.clearODCB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_ODCB.setODCB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_ODCB.getODCB9 : TBits_1; inline;
begin
  getODCB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_ODCB.setODCB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_ODCB.clearODCB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_ODCB.setODCB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_ODCB.getODCB10 : TBits_1; inline;
begin
  getODCB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_ODCB.setODCB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_ODCB.clearODCB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_ODCB.setODCB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_ODCB.getODCB11 : TBits_1; inline;
begin
  getODCB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_ODCB.setODCB12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTB_ODCB.clearODCB12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTB_ODCB.setODCB12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTB_ODCB.getODCB12 : TBits_1; inline;
begin
  getODCB12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTB_ODCB.setODCB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_ODCB.clearODCB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_ODCB.setODCB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_ODCB.getODCB13 : TBits_1; inline;
begin
  getODCB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_ODCB.setODCB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_ODCB.clearODCB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_ODCB.setODCB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_ODCB.getODCB14 : TBits_1; inline;
begin
  getODCB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_ODCB.setODCB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_ODCB.clearODCB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_ODCB.setODCB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_ODCB.getODCB15 : TBits_1; inline;
begin
  getODCB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_ODCB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_ODCB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_TRISC.setTRISC12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTC_TRISC.clearTRISC12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTC_TRISC.setTRISC12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTC_TRISC.getTRISC12 : TBits_1; inline;
begin
  getTRISC12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTC_TRISC.setTRISC13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTC_TRISC.clearTRISC13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTC_TRISC.setTRISC13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTC_TRISC.getTRISC13 : TBits_1; inline;
begin
  getTRISC13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTC_TRISC.setTRISC14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTC_TRISC.clearTRISC14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTC_TRISC.setTRISC14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTC_TRISC.getTRISC14 : TBits_1; inline;
begin
  getTRISC14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTC_TRISC.setTRISC15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTC_TRISC.clearTRISC15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTC_TRISC.setTRISC15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTC_TRISC.getTRISC15 : TBits_1; inline;
begin
  getTRISC15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTC_TRISC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_TRISC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_PORTC.setRC12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTC_PORTC.clearRC12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTC_PORTC.setRC12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTC_PORTC.getRC12 : TBits_1; inline;
begin
  getRC12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTC_PORTC.setRC13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTC_PORTC.clearRC13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTC_PORTC.setRC13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTC_PORTC.getRC13 : TBits_1; inline;
begin
  getRC13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTC_PORTC.setRC14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTC_PORTC.clearRC14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTC_PORTC.setRC14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTC_PORTC.getRC14 : TBits_1; inline;
begin
  getRC14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTC_PORTC.setRC15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTC_PORTC.clearRC15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTC_PORTC.setRC15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTC_PORTC.getRC15 : TBits_1; inline;
begin
  getRC15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTC_PORTC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_PORTC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_LATC.setLATC12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTC_LATC.clearLATC12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTC_LATC.setLATC12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTC_LATC.getLATC12 : TBits_1; inline;
begin
  getLATC12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTC_LATC.setLATC13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTC_LATC.clearLATC13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTC_LATC.setLATC13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTC_LATC.getLATC13 : TBits_1; inline;
begin
  getLATC13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTC_LATC.setLATC14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTC_LATC.clearLATC14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTC_LATC.setLATC14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTC_LATC.getLATC14 : TBits_1; inline;
begin
  getLATC14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTC_LATC.setLATC15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTC_LATC.clearLATC15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTC_LATC.setLATC15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTC_LATC.getLATC15 : TBits_1; inline;
begin
  getLATC15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTC_LATC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_LATC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_ODCC.setODCC12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTC_ODCC.clearODCC12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTC_ODCC.setODCC12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTC_ODCC.getODCC12 : TBits_1; inline;
begin
  getODCC12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTC_ODCC.setODCC13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTC_ODCC.clearODCC13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTC_ODCC.setODCC13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTC_ODCC.getODCC13 : TBits_1; inline;
begin
  getODCC13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTC_ODCC.setODCC14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTC_ODCC.clearODCC14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTC_ODCC.setODCC14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTC_ODCC.getODCC14 : TBits_1; inline;
begin
  getODCC14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTC_ODCC.setODCC15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTC_ODCC.clearODCC15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTC_ODCC.setODCC15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTC_ODCC.getODCC15 : TBits_1; inline;
begin
  getODCC15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTC_ODCC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_ODCC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_TRISD.setTRISD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTD_TRISD.clearTRISD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTD_TRISD.setTRISD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTD_TRISD.getTRISD0 : TBits_1; inline;
begin
  getTRISD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTD_TRISD.setTRISD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTD_TRISD.clearTRISD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTD_TRISD.setTRISD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTD_TRISD.getTRISD1 : TBits_1; inline;
begin
  getTRISD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTD_TRISD.setTRISD2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTD_TRISD.clearTRISD2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTD_TRISD.setTRISD2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTD_TRISD.getTRISD2 : TBits_1; inline;
begin
  getTRISD2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTD_TRISD.setTRISD3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTD_TRISD.clearTRISD3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTD_TRISD.setTRISD3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTD_TRISD.getTRISD3 : TBits_1; inline;
begin
  getTRISD3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTD_TRISD.setTRISD4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTD_TRISD.clearTRISD4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTD_TRISD.setTRISD4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTD_TRISD.getTRISD4 : TBits_1; inline;
begin
  getTRISD4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTD_TRISD.setTRISD5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTD_TRISD.clearTRISD5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTD_TRISD.setTRISD5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTD_TRISD.getTRISD5 : TBits_1; inline;
begin
  getTRISD5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTD_TRISD.setTRISD6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTD_TRISD.clearTRISD6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTD_TRISD.setTRISD6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTD_TRISD.getTRISD6 : TBits_1; inline;
begin
  getTRISD6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTD_TRISD.setTRISD7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTD_TRISD.clearTRISD7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTD_TRISD.setTRISD7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTD_TRISD.getTRISD7 : TBits_1; inline;
begin
  getTRISD7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTD_TRISD.setTRISD8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTD_TRISD.clearTRISD8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTD_TRISD.setTRISD8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTD_TRISD.getTRISD8 : TBits_1; inline;
begin
  getTRISD8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTD_TRISD.setTRISD9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTD_TRISD.clearTRISD9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTD_TRISD.setTRISD9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTD_TRISD.getTRISD9 : TBits_1; inline;
begin
  getTRISD9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTD_TRISD.setTRISD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTD_TRISD.clearTRISD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTD_TRISD.setTRISD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTD_TRISD.getTRISD10 : TBits_1; inline;
begin
  getTRISD10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTD_TRISD.setTRISD11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTD_TRISD.clearTRISD11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTD_TRISD.setTRISD11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTD_TRISD.getTRISD11 : TBits_1; inline;
begin
  getTRISD11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTD_TRISD.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_TRISD.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_PORTD.setRD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTD_PORTD.clearRD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTD_PORTD.setRD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTD_PORTD.getRD0 : TBits_1; inline;
begin
  getRD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTD_PORTD.setRD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTD_PORTD.clearRD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTD_PORTD.setRD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTD_PORTD.getRD1 : TBits_1; inline;
begin
  getRD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTD_PORTD.setRD2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTD_PORTD.clearRD2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTD_PORTD.setRD2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTD_PORTD.getRD2 : TBits_1; inline;
begin
  getRD2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTD_PORTD.setRD3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTD_PORTD.clearRD3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTD_PORTD.setRD3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTD_PORTD.getRD3 : TBits_1; inline;
begin
  getRD3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTD_PORTD.setRD4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTD_PORTD.clearRD4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTD_PORTD.setRD4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTD_PORTD.getRD4 : TBits_1; inline;
begin
  getRD4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTD_PORTD.setRD5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTD_PORTD.clearRD5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTD_PORTD.setRD5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTD_PORTD.getRD5 : TBits_1; inline;
begin
  getRD5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTD_PORTD.setRD6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTD_PORTD.clearRD6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTD_PORTD.setRD6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTD_PORTD.getRD6 : TBits_1; inline;
begin
  getRD6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTD_PORTD.setRD7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTD_PORTD.clearRD7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTD_PORTD.setRD7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTD_PORTD.getRD7 : TBits_1; inline;
begin
  getRD7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTD_PORTD.setRD8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTD_PORTD.clearRD8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTD_PORTD.setRD8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTD_PORTD.getRD8 : TBits_1; inline;
begin
  getRD8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTD_PORTD.setRD9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTD_PORTD.clearRD9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTD_PORTD.setRD9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTD_PORTD.getRD9 : TBits_1; inline;
begin
  getRD9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTD_PORTD.setRD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTD_PORTD.clearRD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTD_PORTD.setRD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTD_PORTD.getRD10 : TBits_1; inline;
begin
  getRD10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTD_PORTD.setRD11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTD_PORTD.clearRD11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTD_PORTD.setRD11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTD_PORTD.getRD11 : TBits_1; inline;
begin
  getRD11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTD_PORTD.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_PORTD.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_LATD.setLATD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTD_LATD.clearLATD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTD_LATD.setLATD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTD_LATD.getLATD0 : TBits_1; inline;
begin
  getLATD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTD_LATD.setLATD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTD_LATD.clearLATD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTD_LATD.setLATD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTD_LATD.getLATD1 : TBits_1; inline;
begin
  getLATD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTD_LATD.setLATD2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTD_LATD.clearLATD2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTD_LATD.setLATD2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTD_LATD.getLATD2 : TBits_1; inline;
begin
  getLATD2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTD_LATD.setLATD3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTD_LATD.clearLATD3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTD_LATD.setLATD3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTD_LATD.getLATD3 : TBits_1; inline;
begin
  getLATD3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTD_LATD.setLATD4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTD_LATD.clearLATD4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTD_LATD.setLATD4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTD_LATD.getLATD4 : TBits_1; inline;
begin
  getLATD4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTD_LATD.setLATD5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTD_LATD.clearLATD5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTD_LATD.setLATD5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTD_LATD.getLATD5 : TBits_1; inline;
begin
  getLATD5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTD_LATD.setLATD6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTD_LATD.clearLATD6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTD_LATD.setLATD6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTD_LATD.getLATD6 : TBits_1; inline;
begin
  getLATD6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTD_LATD.setLATD7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTD_LATD.clearLATD7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTD_LATD.setLATD7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTD_LATD.getLATD7 : TBits_1; inline;
begin
  getLATD7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTD_LATD.setLATD8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTD_LATD.clearLATD8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTD_LATD.setLATD8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTD_LATD.getLATD8 : TBits_1; inline;
begin
  getLATD8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTD_LATD.setLATD9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTD_LATD.clearLATD9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTD_LATD.setLATD9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTD_LATD.getLATD9 : TBits_1; inline;
begin
  getLATD9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTD_LATD.setLATD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTD_LATD.clearLATD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTD_LATD.setLATD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTD_LATD.getLATD10 : TBits_1; inline;
begin
  getLATD10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTD_LATD.setLATD11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTD_LATD.clearLATD11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTD_LATD.setLATD11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTD_LATD.getLATD11 : TBits_1; inline;
begin
  getLATD11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTD_LATD.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_LATD.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTD_ODCD.setODCD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTD_ODCD.clearODCD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTD_ODCD.setODCD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTD_ODCD.getODCD0 : TBits_1; inline;
begin
  getODCD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTD_ODCD.setODCD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTD_ODCD.clearODCD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTD_ODCD.setODCD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTD_ODCD.getODCD1 : TBits_1; inline;
begin
  getODCD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTD_ODCD.setODCD2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTD_ODCD.clearODCD2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTD_ODCD.setODCD2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTD_ODCD.getODCD2 : TBits_1; inline;
begin
  getODCD2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTD_ODCD.setODCD3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTD_ODCD.clearODCD3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTD_ODCD.setODCD3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTD_ODCD.getODCD3 : TBits_1; inline;
begin
  getODCD3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTD_ODCD.setODCD4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTD_ODCD.clearODCD4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTD_ODCD.setODCD4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTD_ODCD.getODCD4 : TBits_1; inline;
begin
  getODCD4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTD_ODCD.setODCD5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTD_ODCD.clearODCD5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTD_ODCD.setODCD5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTD_ODCD.getODCD5 : TBits_1; inline;
begin
  getODCD5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTD_ODCD.setODCD6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTD_ODCD.clearODCD6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTD_ODCD.setODCD6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTD_ODCD.getODCD6 : TBits_1; inline;
begin
  getODCD6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTD_ODCD.setODCD7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTD_ODCD.clearODCD7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTD_ODCD.setODCD7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTD_ODCD.getODCD7 : TBits_1; inline;
begin
  getODCD7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTD_ODCD.setODCD8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTD_ODCD.clearODCD8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTD_ODCD.setODCD8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTD_ODCD.getODCD8 : TBits_1; inline;
begin
  getODCD8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTD_ODCD.setODCD9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTD_ODCD.clearODCD9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTD_ODCD.setODCD9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTD_ODCD.getODCD9 : TBits_1; inline;
begin
  getODCD9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTD_ODCD.setODCD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTD_ODCD.clearODCD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTD_ODCD.setODCD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTD_ODCD.getODCD10 : TBits_1; inline;
begin
  getODCD10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTD_ODCD.setODCD11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTD_ODCD.clearODCD11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTD_ODCD.setODCD11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTD_ODCD.getODCD11 : TBits_1; inline;
begin
  getODCD11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTD_ODCD.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTD_ODCD.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_TRISE.setTRISE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTE_TRISE.clearTRISE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTE_TRISE.setTRISE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTE_TRISE.getTRISE0 : TBits_1; inline;
begin
  getTRISE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTE_TRISE.setTRISE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTE_TRISE.clearTRISE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTE_TRISE.setTRISE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTE_TRISE.getTRISE1 : TBits_1; inline;
begin
  getTRISE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTE_TRISE.setTRISE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTE_TRISE.clearTRISE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTE_TRISE.setTRISE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTE_TRISE.getTRISE2 : TBits_1; inline;
begin
  getTRISE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTE_TRISE.setTRISE3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTE_TRISE.clearTRISE3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTE_TRISE.setTRISE3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTE_TRISE.getTRISE3 : TBits_1; inline;
begin
  getTRISE3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTE_TRISE.setTRISE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTE_TRISE.clearTRISE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTE_TRISE.setTRISE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTE_TRISE.getTRISE4 : TBits_1; inline;
begin
  getTRISE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTE_TRISE.setTRISE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTE_TRISE.clearTRISE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTE_TRISE.setTRISE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTE_TRISE.getTRISE5 : TBits_1; inline;
begin
  getTRISE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTE_TRISE.setTRISE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTE_TRISE.clearTRISE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTE_TRISE.setTRISE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTE_TRISE.getTRISE6 : TBits_1; inline;
begin
  getTRISE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTE_TRISE.setTRISE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTE_TRISE.clearTRISE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTE_TRISE.setTRISE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTE_TRISE.getTRISE7 : TBits_1; inline;
begin
  getTRISE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTE_TRISE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_TRISE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_PORTE.setRE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTE_PORTE.clearRE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTE_PORTE.setRE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTE_PORTE.getRE0 : TBits_1; inline;
begin
  getRE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTE_PORTE.setRE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTE_PORTE.clearRE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTE_PORTE.setRE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTE_PORTE.getRE1 : TBits_1; inline;
begin
  getRE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTE_PORTE.setRE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTE_PORTE.clearRE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTE_PORTE.setRE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTE_PORTE.getRE2 : TBits_1; inline;
begin
  getRE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTE_PORTE.setRE3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTE_PORTE.clearRE3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTE_PORTE.setRE3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTE_PORTE.getRE3 : TBits_1; inline;
begin
  getRE3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTE_PORTE.setRE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTE_PORTE.clearRE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTE_PORTE.setRE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTE_PORTE.getRE4 : TBits_1; inline;
begin
  getRE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTE_PORTE.setRE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTE_PORTE.clearRE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTE_PORTE.setRE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTE_PORTE.getRE5 : TBits_1; inline;
begin
  getRE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTE_PORTE.setRE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTE_PORTE.clearRE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTE_PORTE.setRE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTE_PORTE.getRE6 : TBits_1; inline;
begin
  getRE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTE_PORTE.setRE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTE_PORTE.clearRE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTE_PORTE.setRE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTE_PORTE.getRE7 : TBits_1; inline;
begin
  getRE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTE_PORTE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_PORTE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_LATE.setLATE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTE_LATE.clearLATE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTE_LATE.setLATE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTE_LATE.getLATE0 : TBits_1; inline;
begin
  getLATE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTE_LATE.setLATE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTE_LATE.clearLATE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTE_LATE.setLATE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTE_LATE.getLATE1 : TBits_1; inline;
begin
  getLATE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTE_LATE.setLATE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTE_LATE.clearLATE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTE_LATE.setLATE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTE_LATE.getLATE2 : TBits_1; inline;
begin
  getLATE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTE_LATE.setLATE3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTE_LATE.clearLATE3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTE_LATE.setLATE3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTE_LATE.getLATE3 : TBits_1; inline;
begin
  getLATE3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTE_LATE.setLATE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTE_LATE.clearLATE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTE_LATE.setLATE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTE_LATE.getLATE4 : TBits_1; inline;
begin
  getLATE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTE_LATE.setLATE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTE_LATE.clearLATE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTE_LATE.setLATE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTE_LATE.getLATE5 : TBits_1; inline;
begin
  getLATE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTE_LATE.setLATE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTE_LATE.clearLATE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTE_LATE.setLATE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTE_LATE.getLATE6 : TBits_1; inline;
begin
  getLATE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTE_LATE.setLATE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTE_LATE.clearLATE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTE_LATE.setLATE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTE_LATE.getLATE7 : TBits_1; inline;
begin
  getLATE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTE_LATE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_LATE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTE_ODCE.setODCE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTE_ODCE.clearODCE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTE_ODCE.setODCE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTE_ODCE.getODCE0 : TBits_1; inline;
begin
  getODCE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTE_ODCE.setODCE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTE_ODCE.clearODCE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTE_ODCE.setODCE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTE_ODCE.getODCE1 : TBits_1; inline;
begin
  getODCE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTE_ODCE.setODCE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTE_ODCE.clearODCE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTE_ODCE.setODCE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTE_ODCE.getODCE2 : TBits_1; inline;
begin
  getODCE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTE_ODCE.setODCE3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTE_ODCE.clearODCE3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTE_ODCE.setODCE3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTE_ODCE.getODCE3 : TBits_1; inline;
begin
  getODCE3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTE_ODCE.setODCE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTE_ODCE.clearODCE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTE_ODCE.setODCE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTE_ODCE.getODCE4 : TBits_1; inline;
begin
  getODCE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTE_ODCE.setODCE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTE_ODCE.clearODCE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTE_ODCE.setODCE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTE_ODCE.getODCE5 : TBits_1; inline;
begin
  getODCE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTE_ODCE.setODCE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTE_ODCE.clearODCE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTE_ODCE.setODCE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTE_ODCE.getODCE6 : TBits_1; inline;
begin
  getODCE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTE_ODCE.setODCE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTE_ODCE.clearODCE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTE_ODCE.setODCE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTE_ODCE.getODCE7 : TBits_1; inline;
begin
  getODCE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTE_ODCE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTE_ODCE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_TRISF.setTRISF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTF_TRISF.clearTRISF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTF_TRISF.setTRISF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTF_TRISF.getTRISF0 : TBits_1; inline;
begin
  getTRISF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTF_TRISF.setTRISF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTF_TRISF.clearTRISF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTF_TRISF.setTRISF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTF_TRISF.getTRISF1 : TBits_1; inline;
begin
  getTRISF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTF_TRISF.setTRISF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTF_TRISF.clearTRISF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTF_TRISF.setTRISF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTF_TRISF.getTRISF2 : TBits_1; inline;
begin
  getTRISF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTF_TRISF.setTRISF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTF_TRISF.clearTRISF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTF_TRISF.setTRISF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTF_TRISF.getTRISF3 : TBits_1; inline;
begin
  getTRISF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTF_TRISF.setTRISF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTF_TRISF.clearTRISF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTF_TRISF.setTRISF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTF_TRISF.getTRISF4 : TBits_1; inline;
begin
  getTRISF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTF_TRISF.setTRISF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTF_TRISF.clearTRISF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTF_TRISF.setTRISF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTF_TRISF.getTRISF5 : TBits_1; inline;
begin
  getTRISF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTF_TRISF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_TRISF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_PORTF.setRF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTF_PORTF.clearRF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTF_PORTF.setRF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTF_PORTF.getRF0 : TBits_1; inline;
begin
  getRF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTF_PORTF.setRF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTF_PORTF.clearRF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTF_PORTF.setRF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTF_PORTF.getRF1 : TBits_1; inline;
begin
  getRF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTF_PORTF.setRF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTF_PORTF.clearRF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTF_PORTF.setRF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTF_PORTF.getRF2 : TBits_1; inline;
begin
  getRF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTF_PORTF.setRF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTF_PORTF.clearRF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTF_PORTF.setRF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTF_PORTF.getRF3 : TBits_1; inline;
begin
  getRF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTF_PORTF.setRF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTF_PORTF.clearRF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTF_PORTF.setRF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTF_PORTF.getRF4 : TBits_1; inline;
begin
  getRF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTF_PORTF.setRF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTF_PORTF.clearRF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTF_PORTF.setRF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTF_PORTF.getRF5 : TBits_1; inline;
begin
  getRF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTF_PORTF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_PORTF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_LATF.setLATF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTF_LATF.clearLATF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTF_LATF.setLATF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTF_LATF.getLATF0 : TBits_1; inline;
begin
  getLATF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTF_LATF.setLATF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTF_LATF.clearLATF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTF_LATF.setLATF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTF_LATF.getLATF1 : TBits_1; inline;
begin
  getLATF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTF_LATF.setLATF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTF_LATF.clearLATF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTF_LATF.setLATF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTF_LATF.getLATF2 : TBits_1; inline;
begin
  getLATF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTF_LATF.setLATF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTF_LATF.clearLATF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTF_LATF.setLATF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTF_LATF.getLATF3 : TBits_1; inline;
begin
  getLATF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTF_LATF.setLATF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTF_LATF.clearLATF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTF_LATF.setLATF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTF_LATF.getLATF4 : TBits_1; inline;
begin
  getLATF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTF_LATF.setLATF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTF_LATF.clearLATF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTF_LATF.setLATF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTF_LATF.getLATF5 : TBits_1; inline;
begin
  getLATF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTF_LATF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_LATF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTF_ODCF.setODCF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTF_ODCF.clearODCF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTF_ODCF.setODCF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTF_ODCF.getODCF0 : TBits_1; inline;
begin
  getODCF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTF_ODCF.setODCF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTF_ODCF.clearODCF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTF_ODCF.setODCF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTF_ODCF.getODCF1 : TBits_1; inline;
begin
  getODCF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTF_ODCF.setODCF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTF_ODCF.clearODCF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTF_ODCF.setODCF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTF_ODCF.getODCF2 : TBits_1; inline;
begin
  getODCF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTF_ODCF.setODCF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTF_ODCF.clearODCF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTF_ODCF.setODCF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTF_ODCF.getODCF3 : TBits_1; inline;
begin
  getODCF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTF_ODCF.setODCF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTF_ODCF.clearODCF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTF_ODCF.setODCF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTF_ODCF.getODCF4 : TBits_1; inline;
begin
  getODCF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTF_ODCF.setODCF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTF_ODCF.clearODCF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTF_ODCF.setODCF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTF_ODCF.getODCF5 : TBits_1; inline;
begin
  getODCF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTF_ODCF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTF_ODCF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_TRISG.setTRISG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTG_TRISG.clearTRISG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTG_TRISG.setTRISG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTG_TRISG.getTRISG2 : TBits_1; inline;
begin
  getTRISG2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTG_TRISG.setTRISG3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTG_TRISG.clearTRISG3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTG_TRISG.setTRISG3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTG_TRISG.getTRISG3 : TBits_1; inline;
begin
  getTRISG3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTG_TRISG.setTRISG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTG_TRISG.clearTRISG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTG_TRISG.setTRISG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTG_TRISG.getTRISG6 : TBits_1; inline;
begin
  getTRISG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTG_TRISG.setTRISG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTG_TRISG.clearTRISG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTG_TRISG.setTRISG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTG_TRISG.getTRISG7 : TBits_1; inline;
begin
  getTRISG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTG_TRISG.setTRISG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTG_TRISG.clearTRISG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTG_TRISG.setTRISG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTG_TRISG.getTRISG8 : TBits_1; inline;
begin
  getTRISG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTG_TRISG.setTRISG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTG_TRISG.clearTRISG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTG_TRISG.setTRISG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTG_TRISG.getTRISG9 : TBits_1; inline;
begin
  getTRISG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTG_TRISG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_TRISG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_PORTG.setRG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTG_PORTG.clearRG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTG_PORTG.setRG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTG_PORTG.getRG2 : TBits_1; inline;
begin
  getRG2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTG_PORTG.setRG3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTG_PORTG.clearRG3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTG_PORTG.setRG3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTG_PORTG.getRG3 : TBits_1; inline;
begin
  getRG3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTG_PORTG.setRG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTG_PORTG.clearRG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTG_PORTG.setRG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTG_PORTG.getRG6 : TBits_1; inline;
begin
  getRG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTG_PORTG.setRG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTG_PORTG.clearRG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTG_PORTG.setRG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTG_PORTG.getRG7 : TBits_1; inline;
begin
  getRG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTG_PORTG.setRG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTG_PORTG.clearRG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTG_PORTG.setRG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTG_PORTG.getRG8 : TBits_1; inline;
begin
  getRG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTG_PORTG.setRG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTG_PORTG.clearRG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTG_PORTG.setRG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTG_PORTG.getRG9 : TBits_1; inline;
begin
  getRG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTG_PORTG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_PORTG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_LATG.setLATG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTG_LATG.clearLATG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTG_LATG.setLATG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTG_LATG.getLATG2 : TBits_1; inline;
begin
  getLATG2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTG_LATG.setLATG3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTG_LATG.clearLATG3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTG_LATG.setLATG3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTG_LATG.getLATG3 : TBits_1; inline;
begin
  getLATG3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTG_LATG.setLATG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTG_LATG.clearLATG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTG_LATG.setLATG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTG_LATG.getLATG6 : TBits_1; inline;
begin
  getLATG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTG_LATG.setLATG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTG_LATG.clearLATG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTG_LATG.setLATG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTG_LATG.getLATG7 : TBits_1; inline;
begin
  getLATG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTG_LATG.setLATG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTG_LATG.clearLATG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTG_LATG.setLATG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTG_LATG.getLATG8 : TBits_1; inline;
begin
  getLATG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTG_LATG.setLATG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTG_LATG.clearLATG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTG_LATG.setLATG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTG_LATG.getLATG9 : TBits_1; inline;
begin
  getLATG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTG_LATG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_LATG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_ODCG.setODCG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTG_ODCG.clearODCG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTG_ODCG.setODCG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTG_ODCG.getODCG2 : TBits_1; inline;
begin
  getODCG2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTG_ODCG.setODCG3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTG_ODCG.clearODCG3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTG_ODCG.setODCG3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTG_ODCG.getODCG3 : TBits_1; inline;
begin
  getODCG3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTG_ODCG.setODCG6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTG_ODCG.clearODCG6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTG_ODCG.setODCG6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTG_ODCG.getODCG6 : TBits_1; inline;
begin
  getODCG6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTG_ODCG.setODCG7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTG_ODCG.clearODCG7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTG_ODCG.setODCG7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTG_ODCG.getODCG7 : TBits_1; inline;
begin
  getODCG7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTG_ODCG.setODCG8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTG_ODCG.clearODCG8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTG_ODCG.setODCG8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTG_ODCG.getODCG8 : TBits_1; inline;
begin
  getODCG8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTG_ODCG.setODCG9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTG_ODCG.clearODCG9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTG_ODCG.setODCG9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTG_ODCG.getODCG9 : TBits_1; inline;
begin
  getODCG9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTG_ODCG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_ODCG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_CNCON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTG_CNCON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTG_CNCON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTG_CNCON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTG_CNCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTG_CNCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTG_CNCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTG_CNCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTG_CNCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_CNCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_CNEN.setCNEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTG_CNEN.clearCNEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTG_CNEN.setCNEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTG_CNEN.getCNEN0 : TBits_1; inline;
begin
  getCNEN0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTG_CNEN.setCNEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTG_CNEN.clearCNEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTG_CNEN.setCNEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTG_CNEN.getCNEN1 : TBits_1; inline;
begin
  getCNEN1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTG_CNEN.setCNEN2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTG_CNEN.clearCNEN2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTG_CNEN.setCNEN2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTG_CNEN.getCNEN2 : TBits_1; inline;
begin
  getCNEN2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTG_CNEN.setCNEN3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTG_CNEN.clearCNEN3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTG_CNEN.setCNEN3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTG_CNEN.getCNEN3 : TBits_1; inline;
begin
  getCNEN3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTG_CNEN.setCNEN4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTG_CNEN.clearCNEN4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTG_CNEN.setCNEN4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTG_CNEN.getCNEN4 : TBits_1; inline;
begin
  getCNEN4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTG_CNEN.setCNEN5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTG_CNEN.clearCNEN5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTG_CNEN.setCNEN5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTG_CNEN.getCNEN5 : TBits_1; inline;
begin
  getCNEN5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTG_CNEN.setCNEN6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTG_CNEN.clearCNEN6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTG_CNEN.setCNEN6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTG_CNEN.getCNEN6 : TBits_1; inline;
begin
  getCNEN6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTG_CNEN.setCNEN7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTG_CNEN.clearCNEN7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTG_CNEN.setCNEN7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTG_CNEN.getCNEN7 : TBits_1; inline;
begin
  getCNEN7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTG_CNEN.setCNEN8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTG_CNEN.clearCNEN8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTG_CNEN.setCNEN8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTG_CNEN.getCNEN8 : TBits_1; inline;
begin
  getCNEN8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTG_CNEN.setCNEN9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTG_CNEN.clearCNEN9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTG_CNEN.setCNEN9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTG_CNEN.getCNEN9 : TBits_1; inline;
begin
  getCNEN9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTG_CNEN.setCNEN10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTG_CNEN.clearCNEN10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTG_CNEN.setCNEN10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTG_CNEN.getCNEN10 : TBits_1; inline;
begin
  getCNEN10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTG_CNEN.setCNEN11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTG_CNEN.clearCNEN11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTG_CNEN.setCNEN11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTG_CNEN.getCNEN11 : TBits_1; inline;
begin
  getCNEN11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTG_CNEN.setCNEN12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTG_CNEN.clearCNEN12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTG_CNEN.setCNEN12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTG_CNEN.getCNEN12 : TBits_1; inline;
begin
  getCNEN12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTG_CNEN.setCNEN13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTG_CNEN.clearCNEN13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTG_CNEN.setCNEN13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTG_CNEN.getCNEN13 : TBits_1; inline;
begin
  getCNEN13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTG_CNEN.setCNEN14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTG_CNEN.clearCNEN14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTG_CNEN.setCNEN14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTG_CNEN.getCNEN14 : TBits_1; inline;
begin
  getCNEN14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTG_CNEN.setCNEN15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTG_CNEN.clearCNEN15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTG_CNEN.setCNEN15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTG_CNEN.getCNEN15 : TBits_1; inline;
begin
  getCNEN15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTG_CNEN.setCNEN16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TPORTG_CNEN.clearCNEN16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TPORTG_CNEN.setCNEN16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TPORTG_CNEN.getCNEN16 : TBits_1; inline;
begin
  getCNEN16 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TPORTG_CNEN.setCNEN17; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TPORTG_CNEN.clearCNEN17; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TPORTG_CNEN.setCNEN17(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TPORTG_CNEN.getCNEN17 : TBits_1; inline;
begin
  getCNEN17 := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TPORTG_CNEN.setCNEN18; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TPORTG_CNEN.clearCNEN18; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TPORTG_CNEN.setCNEN18(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TPORTG_CNEN.getCNEN18 : TBits_1; inline;
begin
  getCNEN18 := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TPORTG_CNEN.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_CNEN.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTG_CNPUE.setCNPUE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTG_CNPUE.clearCNPUE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTG_CNPUE.setCNPUE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTG_CNPUE.getCNPUE0 : TBits_1; inline;
begin
  getCNPUE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTG_CNPUE.setCNPUE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTG_CNPUE.clearCNPUE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTG_CNPUE.setCNPUE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTG_CNPUE.getCNPUE1 : TBits_1; inline;
begin
  getCNPUE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTG_CNPUE.setCNPUE2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTG_CNPUE.clearCNPUE2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTG_CNPUE.setCNPUE2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTG_CNPUE.getCNPUE2 : TBits_1; inline;
begin
  getCNPUE2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTG_CNPUE.setCNPUE3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTG_CNPUE.clearCNPUE3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTG_CNPUE.setCNPUE3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTG_CNPUE.getCNPUE3 : TBits_1; inline;
begin
  getCNPUE3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTG_CNPUE.setCNPUE4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTG_CNPUE.clearCNPUE4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTG_CNPUE.setCNPUE4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTG_CNPUE.getCNPUE4 : TBits_1; inline;
begin
  getCNPUE4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTG_CNPUE.setCNPUE5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTG_CNPUE.clearCNPUE5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTG_CNPUE.setCNPUE5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTG_CNPUE.getCNPUE5 : TBits_1; inline;
begin
  getCNPUE5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTG_CNPUE.setCNPUE6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPORTG_CNPUE.clearCNPUE6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPORTG_CNPUE.setCNPUE6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPORTG_CNPUE.getCNPUE6 : TBits_1; inline;
begin
  getCNPUE6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPORTG_CNPUE.setCNPUE7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTG_CNPUE.clearCNPUE7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTG_CNPUE.setCNPUE7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTG_CNPUE.getCNPUE7 : TBits_1; inline;
begin
  getCNPUE7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTG_CNPUE.setCNPUE8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTG_CNPUE.clearCNPUE8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTG_CNPUE.setCNPUE8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTG_CNPUE.getCNPUE8 : TBits_1; inline;
begin
  getCNPUE8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTG_CNPUE.setCNPUE9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTG_CNPUE.clearCNPUE9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTG_CNPUE.setCNPUE9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTG_CNPUE.getCNPUE9 : TBits_1; inline;
begin
  getCNPUE9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTG_CNPUE.setCNPUE10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTG_CNPUE.clearCNPUE10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTG_CNPUE.setCNPUE10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTG_CNPUE.getCNPUE10 : TBits_1; inline;
begin
  getCNPUE10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTG_CNPUE.setCNPUE11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTG_CNPUE.clearCNPUE11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTG_CNPUE.setCNPUE11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTG_CNPUE.getCNPUE11 : TBits_1; inline;
begin
  getCNPUE11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTG_CNPUE.setCNPUE12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPORTG_CNPUE.clearCNPUE12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPORTG_CNPUE.setCNPUE12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPORTG_CNPUE.getCNPUE12 : TBits_1; inline;
begin
  getCNPUE12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPORTG_CNPUE.setCNPUE13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTG_CNPUE.clearCNPUE13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTG_CNPUE.setCNPUE13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTG_CNPUE.getCNPUE13 : TBits_1; inline;
begin
  getCNPUE13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTG_CNPUE.setCNPUE14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTG_CNPUE.clearCNPUE14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTG_CNPUE.setCNPUE14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTG_CNPUE.getCNPUE14 : TBits_1; inline;
begin
  getCNPUE14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTG_CNPUE.setCNPUE15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTG_CNPUE.clearCNPUE15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTG_CNPUE.setCNPUE15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTG_CNPUE.getCNPUE15 : TBits_1; inline;
begin
  getCNPUE15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTG_CNPUE.setCNPUE16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TPORTG_CNPUE.clearCNPUE16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TPORTG_CNPUE.setCNPUE16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TPORTG_CNPUE.getCNPUE16 : TBits_1; inline;
begin
  getCNPUE16 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TPORTG_CNPUE.setCNPUE17; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TPORTG_CNPUE.clearCNPUE17; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TPORTG_CNPUE.setCNPUE17(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TPORTG_CNPUE.getCNPUE17 : TBits_1; inline;
begin
  getCNPUE17 := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TPORTG_CNPUE.setCNPUE18; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TPORTG_CNPUE.clearCNPUE18; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TPORTG_CNPUE.setCNPUE18(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TPORTG_CNPUE.getCNPUE18 : TBits_1; inline;
begin
  getCNPUE18 := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TPORTG_CNPUE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTG_CNPUE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1CON.setDNCNT(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1CON.getDNCNT : TBits_5; inline;
begin
  getDNCNT := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1CON.setCANBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TCAN1_C1CON.clearCANBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TCAN1_C1CON.setCANBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TCAN1_C1CON.getCANBUSY : TBits_1; inline;
begin
  getCANBUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TCAN1_C1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCAN1_C1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCAN1_C1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCAN1_C1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCAN1_C1CON.setCANCAP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TCAN1_C1CON.clearCANCAP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TCAN1_C1CON.setCANCAP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TCAN1_C1CON.getCANCAP : TBits_1; inline;
begin
  getCANCAP := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TCAN1_C1CON.setOPMOD(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF1FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1CON.getOPMOD : TBits_3; inline;
begin
  getOPMOD := (pTDefRegMap(@Self)^.val and $00E00000) shr 21;
end;
procedure TCAN1_C1CON.setREQOP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TCAN1_C1CON.getREQOP : TBits_3; inline;
begin
  getREQOP := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TCAN1_C1CON.setABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TCAN1_C1CON.clearABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TCAN1_C1CON.setABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TCAN1_C1CON.getABAT : TBits_1; inline;
begin
  getABAT := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TCAN1_C1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1CFG.setBRP(thebits : TBits_6); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFC0 or ( thebits shl 0 );
end;
function  TCAN1_C1CFG.getBRP : TBits_6; inline;
begin
  getBRP := (pTDefRegMap(@Self)^.val and $0000003F) shr 0;
end;
procedure TCAN1_C1CFG.setSJW(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TCAN1_C1CFG.getSJW : TBits_2; inline;
begin
  getSJW := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TCAN1_C1CFG.setPRSEG(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF8FF or ( thebits shl 8 );
end;
function  TCAN1_C1CFG.getPRSEG : TBits_3; inline;
begin
  getPRSEG := (pTDefRegMap(@Self)^.val and $00000700) shr 8;
end;
procedure TCAN1_C1CFG.setSEG1PH(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFC7FF or ( thebits shl 11 );
end;
function  TCAN1_C1CFG.getSEG1PH : TBits_3; inline;
begin
  getSEG1PH := (pTDefRegMap(@Self)^.val and $00003800) shr 11;
end;
procedure TCAN1_C1CFG.setSAM; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1CFG.clearSAM; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1CFG.setSAM(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1CFG.getSAM : TBits_1; inline;
begin
  getSAM := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1CFG.setSEG2PHTS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCAN1_C1CFG.clearSEG2PHTS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCAN1_C1CFG.setSEG2PHTS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCAN1_C1CFG.getSEG2PHTS : TBits_1; inline;
begin
  getSEG2PHTS := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCAN1_C1CFG.setSEG2PH(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF8FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1CFG.getSEG2PH : TBits_3; inline;
begin
  getSEG2PH := (pTDefRegMap(@Self)^.val and $00070000) shr 16;
end;
procedure TCAN1_C1CFG.setWAKFIL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TCAN1_C1CFG.clearWAKFIL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TCAN1_C1CFG.setWAKFIL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TCAN1_C1CFG.getWAKFIL : TBits_1; inline;
begin
  getWAKFIL := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TCAN1_C1CFG.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1CFG.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1INT.setTBIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1INT.clearTBIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1INT.setTBIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1INT.getTBIF : TBits_1; inline;
begin
  getTBIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1INT.setRBIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1INT.clearRBIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1INT.setRBIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1INT.getRBIF : TBits_1; inline;
begin
  getRBIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1INT.setCTMRIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1INT.clearCTMRIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1INT.setCTMRIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1INT.getCTMRIF : TBits_1; inline;
begin
  getCTMRIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1INT.setMODIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1INT.clearMODIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1INT.setMODIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1INT.getMODIF : TBits_1; inline;
begin
  getMODIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1INT.setRBOVIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TCAN1_C1INT.clearRBOVIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TCAN1_C1INT.setRBOVIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TCAN1_C1INT.getRBOVIF : TBits_1; inline;
begin
  getRBOVIF := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TCAN1_C1INT.setSERRIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1INT.clearSERRIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1INT.setSERRIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1INT.getSERRIF : TBits_1; inline;
begin
  getSERRIF := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1INT.setCERRIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1INT.clearCERRIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1INT.setCERRIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1INT.getCERRIF : TBits_1; inline;
begin
  getCERRIF := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1INT.setWAKIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1INT.clearWAKIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1INT.setWAKIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1INT.getWAKIF : TBits_1; inline;
begin
  getWAKIF := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1INT.setIVRIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCAN1_C1INT.clearIVRIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCAN1_C1INT.setIVRIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCAN1_C1INT.getIVRIF : TBits_1; inline;
begin
  getIVRIF := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCAN1_C1INT.setTBIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1INT.clearTBIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1INT.setTBIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1INT.getTBIE : TBits_1; inline;
begin
  getTBIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1INT.setRBIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1INT.clearRBIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1INT.setRBIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1INT.getRBIE : TBits_1; inline;
begin
  getRBIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1INT.setCTMRIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1INT.clearCTMRIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1INT.setCTMRIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1INT.getCTMRIE : TBits_1; inline;
begin
  getCTMRIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1INT.setMODIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1INT.clearMODIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1INT.setMODIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1INT.getMODIE : TBits_1; inline;
begin
  getMODIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1INT.setRBOVIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TCAN1_C1INT.clearRBOVIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TCAN1_C1INT.setRBOVIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TCAN1_C1INT.getRBOVIE : TBits_1; inline;
begin
  getRBOVIE := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TCAN1_C1INT.setSERRIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TCAN1_C1INT.clearSERRIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TCAN1_C1INT.setSERRIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TCAN1_C1INT.getSERRIE : TBits_1; inline;
begin
  getSERRIE := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TCAN1_C1INT.setCERRIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TCAN1_C1INT.clearCERRIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TCAN1_C1INT.setCERRIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TCAN1_C1INT.getCERRIE : TBits_1; inline;
begin
  getCERRIE := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TCAN1_C1INT.setWAKIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TCAN1_C1INT.clearWAKIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TCAN1_C1INT.setWAKIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TCAN1_C1INT.getWAKIE : TBits_1; inline;
begin
  getWAKIE := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TCAN1_C1INT.setIVRIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TCAN1_C1INT.clearIVRIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TCAN1_C1INT.setIVRIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TCAN1_C1INT.getIVRIE : TBits_1; inline;
begin
  getIVRIE := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TCAN1_C1INT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1INT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1VEC.setICODE(thebits : TBits_7); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF80 or ( thebits shl 0 );
end;
function  TCAN1_C1VEC.getICODE : TBits_7; inline;
begin
  getICODE := (pTDefRegMap(@Self)^.val and $0000007F) shr 0;
end;
procedure TCAN1_C1VEC.setFILHIT(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TCAN1_C1VEC.getFILHIT : TBits_5; inline;
begin
  getFILHIT := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TCAN1_C1VEC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1VEC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1TREC.setRERRCNT(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF00 or ( thebits shl 0 );
end;
function  TCAN1_C1TREC.getRERRCNT : TBits_8; inline;
begin
  getRERRCNT := (pTDefRegMap(@Self)^.val and $000000FF) shr 0;
end;
procedure TCAN1_C1TREC.setTERRCNT(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF00FF or ( thebits shl 8 );
end;
function  TCAN1_C1TREC.getTERRCNT : TBits_8; inline;
begin
  getTERRCNT := (pTDefRegMap(@Self)^.val and $0000FF00) shr 8;
end;
procedure TCAN1_C1TREC.setEWARN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1TREC.clearEWARN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1TREC.setEWARN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1TREC.getEWARN : TBits_1; inline;
begin
  getEWARN := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1TREC.setRXWARN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1TREC.clearRXWARN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1TREC.setRXWARN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1TREC.getRXWARN : TBits_1; inline;
begin
  getRXWARN := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1TREC.setTXWARN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1TREC.clearTXWARN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1TREC.setTXWARN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1TREC.getTXWARN : TBits_1; inline;
begin
  getTXWARN := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1TREC.setRXBP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1TREC.clearRXBP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1TREC.setRXBP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1TREC.getRXBP : TBits_1; inline;
begin
  getRXBP := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1TREC.setTXBP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TCAN1_C1TREC.clearTXBP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TCAN1_C1TREC.setTXBP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TCAN1_C1TREC.getTXBP : TBits_1; inline;
begin
  getTXBP := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TCAN1_C1TREC.setTXBO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TCAN1_C1TREC.clearTXBO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TCAN1_C1TREC.setTXBO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TCAN1_C1TREC.getTXBO : TBits_1; inline;
begin
  getTXBO := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TCAN1_C1TREC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1TREC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FSTAT.setFIFOIP(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FSTAT.getFIFOIP : TBits_32; inline;
begin
  getFIFOIP := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FSTAT.setFIFOIP0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FSTAT.setFIFOIP0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FSTAT.getFIFOIP0 : TBits_1; inline;
begin
  getFIFOIP0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FSTAT.setFIFOIP1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FSTAT.setFIFOIP1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FSTAT.getFIFOIP1 : TBits_1; inline;
begin
  getFIFOIP1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FSTAT.setFIFOIP2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FSTAT.setFIFOIP2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FSTAT.getFIFOIP2 : TBits_1; inline;
begin
  getFIFOIP2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FSTAT.setFIFOIP3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FSTAT.setFIFOIP3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FSTAT.getFIFOIP3 : TBits_1; inline;
begin
  getFIFOIP3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FSTAT.setFIFOIP4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FSTAT.setFIFOIP4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FSTAT.getFIFOIP4 : TBits_1; inline;
begin
  getFIFOIP4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FSTAT.setFIFOIP5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FSTAT.setFIFOIP5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FSTAT.getFIFOIP5 : TBits_1; inline;
begin
  getFIFOIP5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FSTAT.setFIFOIP6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FSTAT.setFIFOIP6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FSTAT.getFIFOIP6 : TBits_1; inline;
begin
  getFIFOIP6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FSTAT.setFIFOIP7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FSTAT.setFIFOIP7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FSTAT.getFIFOIP7 : TBits_1; inline;
begin
  getFIFOIP7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FSTAT.setFIFOIP8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FSTAT.setFIFOIP8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FSTAT.getFIFOIP8 : TBits_1; inline;
begin
  getFIFOIP8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FSTAT.setFIFOIP9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FSTAT.setFIFOIP9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FSTAT.getFIFOIP9 : TBits_1; inline;
begin
  getFIFOIP9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FSTAT.setFIFOIP10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FSTAT.setFIFOIP10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FSTAT.getFIFOIP10 : TBits_1; inline;
begin
  getFIFOIP10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FSTAT.setFIFOIP11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TCAN1_C1FSTAT.setFIFOIP11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TCAN1_C1FSTAT.getFIFOIP11 : TBits_1; inline;
begin
  getFIFOIP11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TCAN1_C1FSTAT.setFIFOIP12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FSTAT.getFIFOIP12 : TBits_1; inline;
begin
  getFIFOIP12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FSTAT.setFIFOIP13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FSTAT.getFIFOIP13 : TBits_1; inline;
begin
  getFIFOIP13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FSTAT.setFIFOIP14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FSTAT.getFIFOIP14 : TBits_1; inline;
begin
  getFIFOIP14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FSTAT.setFIFOIP15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCAN1_C1FSTAT.getFIFOIP15 : TBits_1; inline;
begin
  getFIFOIP15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCAN1_C1FSTAT.setFIFOIP16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FSTAT.getFIFOIP16 : TBits_1; inline;
begin
  getFIFOIP16 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FSTAT.setFIFOIP17; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP17; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP17(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FSTAT.getFIFOIP17 : TBits_1; inline;
begin
  getFIFOIP17 := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FSTAT.setFIFOIP18; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP18; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP18(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FSTAT.getFIFOIP18 : TBits_1; inline;
begin
  getFIFOIP18 := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FSTAT.setFIFOIP19; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP19; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP19(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FSTAT.getFIFOIP19 : TBits_1; inline;
begin
  getFIFOIP19 := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FSTAT.setFIFOIP20; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP20; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP20(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TCAN1_C1FSTAT.getFIFOIP20 : TBits_1; inline;
begin
  getFIFOIP20 := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TCAN1_C1FSTAT.setFIFOIP21; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP21; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP21(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TCAN1_C1FSTAT.getFIFOIP21 : TBits_1; inline;
begin
  getFIFOIP21 := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TCAN1_C1FSTAT.setFIFOIP22; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP22; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP22(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TCAN1_C1FSTAT.getFIFOIP22 : TBits_1; inline;
begin
  getFIFOIP22 := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TCAN1_C1FSTAT.setFIFOIP23; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP23; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP23(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TCAN1_C1FSTAT.getFIFOIP23 : TBits_1; inline;
begin
  getFIFOIP23 := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TCAN1_C1FSTAT.setFIFOIP24; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP24; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP24(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FSTAT.getFIFOIP24 : TBits_1; inline;
begin
  getFIFOIP24 := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FSTAT.setFIFOIP25; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP25; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP25(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FSTAT.getFIFOIP25 : TBits_1; inline;
begin
  getFIFOIP25 := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FSTAT.setFIFOIP26; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP26; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP26(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FSTAT.getFIFOIP26 : TBits_1; inline;
begin
  getFIFOIP26 := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FSTAT.setFIFOIP27; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP27; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP27(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TCAN1_C1FSTAT.getFIFOIP27 : TBits_1; inline;
begin
  getFIFOIP27 := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TCAN1_C1FSTAT.setFIFOIP28; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP28; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP28(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TCAN1_C1FSTAT.getFIFOIP28 : TBits_1; inline;
begin
  getFIFOIP28 := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TCAN1_C1FSTAT.setFIFOIP29; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP29; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP29(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TCAN1_C1FSTAT.getFIFOIP29 : TBits_1; inline;
begin
  getFIFOIP29 := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TCAN1_C1FSTAT.setFIFOIP30; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP30; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP30(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TCAN1_C1FSTAT.getFIFOIP30 : TBits_1; inline;
begin
  getFIFOIP30 := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TCAN1_C1FSTAT.setFIFOIP31; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TCAN1_C1FSTAT.clearFIFOIP31; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TCAN1_C1FSTAT.setFIFOIP31(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TCAN1_C1FSTAT.getFIFOIP31 : TBits_1; inline;
begin
  getFIFOIP31 := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TCAN1_C1FSTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FSTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXOVF.setRXOVF(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXOVF.getRXOVF : TBits_32; inline;
begin
  getRXOVF := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXOVF.setRXOVF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1RXOVF.clearRXOVF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1RXOVF.setRXOVF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1RXOVF.getRXOVF0 : TBits_1; inline;
begin
  getRXOVF0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1RXOVF.setRXOVF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1RXOVF.clearRXOVF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1RXOVF.setRXOVF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1RXOVF.getRXOVF1 : TBits_1; inline;
begin
  getRXOVF1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1RXOVF.setRXOVF2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1RXOVF.clearRXOVF2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1RXOVF.setRXOVF2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1RXOVF.getRXOVF2 : TBits_1; inline;
begin
  getRXOVF2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1RXOVF.setRXOVF3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1RXOVF.clearRXOVF3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1RXOVF.setRXOVF3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1RXOVF.getRXOVF3 : TBits_1; inline;
begin
  getRXOVF3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1RXOVF.setRXOVF4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1RXOVF.clearRXOVF4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1RXOVF.setRXOVF4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1RXOVF.getRXOVF4 : TBits_1; inline;
begin
  getRXOVF4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1RXOVF.setRXOVF5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1RXOVF.clearRXOVF5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1RXOVF.setRXOVF5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1RXOVF.getRXOVF5 : TBits_1; inline;
begin
  getRXOVF5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1RXOVF.setRXOVF6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1RXOVF.clearRXOVF6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1RXOVF.setRXOVF6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1RXOVF.getRXOVF6 : TBits_1; inline;
begin
  getRXOVF6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1RXOVF.setRXOVF7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1RXOVF.clearRXOVF7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1RXOVF.setRXOVF7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1RXOVF.getRXOVF7 : TBits_1; inline;
begin
  getRXOVF7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1RXOVF.setRXOVF8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1RXOVF.clearRXOVF8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1RXOVF.setRXOVF8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1RXOVF.getRXOVF8 : TBits_1; inline;
begin
  getRXOVF8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1RXOVF.setRXOVF9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1RXOVF.clearRXOVF9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1RXOVF.setRXOVF9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1RXOVF.getRXOVF9 : TBits_1; inline;
begin
  getRXOVF9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1RXOVF.setRXOVF10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1RXOVF.clearRXOVF10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1RXOVF.setRXOVF10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1RXOVF.getRXOVF10 : TBits_1; inline;
begin
  getRXOVF10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1RXOVF.setRXOVF11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TCAN1_C1RXOVF.clearRXOVF11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TCAN1_C1RXOVF.setRXOVF11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TCAN1_C1RXOVF.getRXOVF11 : TBits_1; inline;
begin
  getRXOVF11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TCAN1_C1RXOVF.setRXOVF12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1RXOVF.setRXOVF12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1RXOVF.getRXOVF12 : TBits_1; inline;
begin
  getRXOVF12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1RXOVF.setRXOVF13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1RXOVF.setRXOVF13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1RXOVF.getRXOVF13 : TBits_1; inline;
begin
  getRXOVF13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1RXOVF.setRXOVF14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1RXOVF.setRXOVF14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1RXOVF.getRXOVF14 : TBits_1; inline;
begin
  getRXOVF14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1RXOVF.setRXOVF15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCAN1_C1RXOVF.setRXOVF15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCAN1_C1RXOVF.getRXOVF15 : TBits_1; inline;
begin
  getRXOVF15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCAN1_C1RXOVF.setRXOVF16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1RXOVF.setRXOVF16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1RXOVF.getRXOVF16 : TBits_1; inline;
begin
  getRXOVF16 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1RXOVF.setRXOVF17; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF17; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1RXOVF.setRXOVF17(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1RXOVF.getRXOVF17 : TBits_1; inline;
begin
  getRXOVF17 := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1RXOVF.setRXOVF18; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF18; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1RXOVF.setRXOVF18(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1RXOVF.getRXOVF18 : TBits_1; inline;
begin
  getRXOVF18 := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1RXOVF.setRXOVF19; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF19; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXOVF.setRXOVF19(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXOVF.getRXOVF19 : TBits_1; inline;
begin
  getRXOVF19 := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXOVF.setRXOVF20; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF20; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TCAN1_C1RXOVF.setRXOVF20(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TCAN1_C1RXOVF.getRXOVF20 : TBits_1; inline;
begin
  getRXOVF20 := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TCAN1_C1RXOVF.setRXOVF21; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF21; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TCAN1_C1RXOVF.setRXOVF21(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TCAN1_C1RXOVF.getRXOVF21 : TBits_1; inline;
begin
  getRXOVF21 := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TCAN1_C1RXOVF.setRXOVF22; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF22; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TCAN1_C1RXOVF.setRXOVF22(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TCAN1_C1RXOVF.getRXOVF22 : TBits_1; inline;
begin
  getRXOVF22 := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TCAN1_C1RXOVF.setRXOVF23; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF23; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TCAN1_C1RXOVF.setRXOVF23(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TCAN1_C1RXOVF.getRXOVF23 : TBits_1; inline;
begin
  getRXOVF23 := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TCAN1_C1RXOVF.setRXOVF24; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF24; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1RXOVF.setRXOVF24(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1RXOVF.getRXOVF24 : TBits_1; inline;
begin
  getRXOVF24 := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1RXOVF.setRXOVF25; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF25; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1RXOVF.setRXOVF25(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1RXOVF.getRXOVF25 : TBits_1; inline;
begin
  getRXOVF25 := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1RXOVF.setRXOVF26; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF26; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1RXOVF.setRXOVF26(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1RXOVF.getRXOVF26 : TBits_1; inline;
begin
  getRXOVF26 := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1RXOVF.setRXOVF27; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF27; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TCAN1_C1RXOVF.setRXOVF27(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TCAN1_C1RXOVF.getRXOVF27 : TBits_1; inline;
begin
  getRXOVF27 := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TCAN1_C1RXOVF.setRXOVF28; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF28; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TCAN1_C1RXOVF.setRXOVF28(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TCAN1_C1RXOVF.getRXOVF28 : TBits_1; inline;
begin
  getRXOVF28 := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TCAN1_C1RXOVF.setRXOVF29; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF29; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TCAN1_C1RXOVF.setRXOVF29(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TCAN1_C1RXOVF.getRXOVF29 : TBits_1; inline;
begin
  getRXOVF29 := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TCAN1_C1RXOVF.setRXOVF30; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF30; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TCAN1_C1RXOVF.setRXOVF30(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TCAN1_C1RXOVF.getRXOVF30 : TBits_1; inline;
begin
  getRXOVF30 := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TCAN1_C1RXOVF.setRXOVF31; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TCAN1_C1RXOVF.clearRXOVF31; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TCAN1_C1RXOVF.setRXOVF31(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TCAN1_C1RXOVF.getRXOVF31 : TBits_1; inline;
begin
  getRXOVF31 := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TCAN1_C1RXOVF.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXOVF.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1TMR.setCANTSPRE(thebits : TBits_16); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0000 or ( thebits shl 0 );
end;
function  TCAN1_C1TMR.getCANTSPRE : TBits_16; inline;
begin
  getCANTSPRE := (pTDefRegMap(@Self)^.val and $0000FFFF) shr 0;
end;
procedure TCAN1_C1TMR.setCANTS(thebits : TBits_16); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $0000FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1TMR.getCANTS : TBits_16; inline;
begin
  getCANTS := (pTDefRegMap(@Self)^.val and $FFFF0000) shr 16;
end;
procedure TCAN1_C1TMR.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1TMR.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXM0.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXM0.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXM0.setMIDE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXM0.clearMIDE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXM0.setMIDE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXM0.getMIDE : TBits_1; inline;
begin
  getMIDE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXM0.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXM0.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXM0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXM0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXM1.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXM1.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXM1.setMIDE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXM1.clearMIDE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXM1.setMIDE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXM1.getMIDE : TBits_1; inline;
begin
  getMIDE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXM1.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXM1.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXM1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXM1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXM2.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXM2.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXM2.setMIDE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXM2.clearMIDE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXM2.setMIDE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXM2.getMIDE : TBits_1; inline;
begin
  getMIDE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXM2.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXM2.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXM2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXM2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXM3.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXM3.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXM3.setMIDE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXM3.clearMIDE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXM3.setMIDE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXM3.getMIDE : TBits_1; inline;
begin
  getMIDE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXM3.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXM3.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXM3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXM3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FLTCON0.setFSEL0(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FLTCON0.getFSEL0 : TBits_5; inline;
begin
  getFSEL0 := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FLTCON0.setMSEL0(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TCAN1_C1FLTCON0.getMSEL0 : TBits_2; inline;
begin
  getMSEL0 := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TCAN1_C1FLTCON0.setFLTEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FLTCON0.clearFLTEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FLTCON0.setFLTEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FLTCON0.getFLTEN0 : TBits_1; inline;
begin
  getFLTEN0 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FLTCON0.setFSEL1(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TCAN1_C1FLTCON0.getFSEL1 : TBits_5; inline;
begin
  getFSEL1 := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TCAN1_C1FLTCON0.setMSEL1(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF9FFF or ( thebits shl 13 );
end;
function  TCAN1_C1FLTCON0.getMSEL1 : TBits_2; inline;
begin
  getMSEL1 := (pTDefRegMap(@Self)^.val and $00006000) shr 13;
end;
procedure TCAN1_C1FLTCON0.setFLTEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCAN1_C1FLTCON0.clearFLTEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCAN1_C1FLTCON0.setFLTEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCAN1_C1FLTCON0.getFLTEN1 : TBits_1; inline;
begin
  getFLTEN1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCAN1_C1FLTCON0.setFSEL2(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FLTCON0.getFSEL2 : TBits_5; inline;
begin
  getFSEL2 := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FLTCON0.setMSEL2(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF9FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1FLTCON0.getMSEL2 : TBits_2; inline;
begin
  getMSEL2 := (pTDefRegMap(@Self)^.val and $00600000) shr 21;
end;
procedure TCAN1_C1FLTCON0.setFLTEN2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TCAN1_C1FLTCON0.clearFLTEN2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TCAN1_C1FLTCON0.setFLTEN2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TCAN1_C1FLTCON0.getFLTEN2 : TBits_1; inline;
begin
  getFLTEN2 := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TCAN1_C1FLTCON0.setFSEL3(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TCAN1_C1FLTCON0.getFSEL3 : TBits_5; inline;
begin
  getFSEL3 := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TCAN1_C1FLTCON0.setMSEL3(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $9FFFFFFF or ( thebits shl 29 );
end;
function  TCAN1_C1FLTCON0.getMSEL3 : TBits_2; inline;
begin
  getMSEL3 := (pTDefRegMap(@Self)^.val and $60000000) shr 29;
end;
procedure TCAN1_C1FLTCON0.setFLTEN3; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TCAN1_C1FLTCON0.clearFLTEN3; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TCAN1_C1FLTCON0.setFLTEN3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TCAN1_C1FLTCON0.getFLTEN3 : TBits_1; inline;
begin
  getFLTEN3 := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TCAN1_C1FLTCON0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FLTCON0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FLTCON1.setFSEL4(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FLTCON1.getFSEL4 : TBits_5; inline;
begin
  getFSEL4 := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FLTCON1.setMSEL4(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TCAN1_C1FLTCON1.getMSEL4 : TBits_2; inline;
begin
  getMSEL4 := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TCAN1_C1FLTCON1.setFLTEN4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FLTCON1.clearFLTEN4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FLTCON1.setFLTEN4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FLTCON1.getFLTEN4 : TBits_1; inline;
begin
  getFLTEN4 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FLTCON1.setFSEL5(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TCAN1_C1FLTCON1.getFSEL5 : TBits_5; inline;
begin
  getFSEL5 := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TCAN1_C1FLTCON1.setMSEL5(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF9FFF or ( thebits shl 13 );
end;
function  TCAN1_C1FLTCON1.getMSEL5 : TBits_2; inline;
begin
  getMSEL5 := (pTDefRegMap(@Self)^.val and $00006000) shr 13;
end;
procedure TCAN1_C1FLTCON1.setFLTEN5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCAN1_C1FLTCON1.clearFLTEN5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCAN1_C1FLTCON1.setFLTEN5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCAN1_C1FLTCON1.getFLTEN5 : TBits_1; inline;
begin
  getFLTEN5 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCAN1_C1FLTCON1.setFSEL6(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FLTCON1.getFSEL6 : TBits_5; inline;
begin
  getFSEL6 := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FLTCON1.setMSEL6(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF9FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1FLTCON1.getMSEL6 : TBits_2; inline;
begin
  getMSEL6 := (pTDefRegMap(@Self)^.val and $00600000) shr 21;
end;
procedure TCAN1_C1FLTCON1.setFLTEN6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TCAN1_C1FLTCON1.clearFLTEN6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TCAN1_C1FLTCON1.setFLTEN6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TCAN1_C1FLTCON1.getFLTEN6 : TBits_1; inline;
begin
  getFLTEN6 := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TCAN1_C1FLTCON1.setFSEL7(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TCAN1_C1FLTCON1.getFSEL7 : TBits_5; inline;
begin
  getFSEL7 := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TCAN1_C1FLTCON1.setMSEL7(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $9FFFFFFF or ( thebits shl 29 );
end;
function  TCAN1_C1FLTCON1.getMSEL7 : TBits_2; inline;
begin
  getMSEL7 := (pTDefRegMap(@Self)^.val and $60000000) shr 29;
end;
procedure TCAN1_C1FLTCON1.setFLTEN7; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TCAN1_C1FLTCON1.clearFLTEN7; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TCAN1_C1FLTCON1.setFLTEN7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TCAN1_C1FLTCON1.getFLTEN7 : TBits_1; inline;
begin
  getFLTEN7 := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TCAN1_C1FLTCON1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FLTCON1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FLTCON2.setFSEL8(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FLTCON2.getFSEL8 : TBits_5; inline;
begin
  getFSEL8 := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FLTCON2.setMSEL8(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TCAN1_C1FLTCON2.getMSEL8 : TBits_2; inline;
begin
  getMSEL8 := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TCAN1_C1FLTCON2.setFLTEN8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FLTCON2.clearFLTEN8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FLTCON2.setFLTEN8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FLTCON2.getFLTEN8 : TBits_1; inline;
begin
  getFLTEN8 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FLTCON2.setFSEL9(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TCAN1_C1FLTCON2.getFSEL9 : TBits_5; inline;
begin
  getFSEL9 := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TCAN1_C1FLTCON2.setMSEL9(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF9FFF or ( thebits shl 13 );
end;
function  TCAN1_C1FLTCON2.getMSEL9 : TBits_2; inline;
begin
  getMSEL9 := (pTDefRegMap(@Self)^.val and $00006000) shr 13;
end;
procedure TCAN1_C1FLTCON2.setFLTEN9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCAN1_C1FLTCON2.clearFLTEN9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCAN1_C1FLTCON2.setFLTEN9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCAN1_C1FLTCON2.getFLTEN9 : TBits_1; inline;
begin
  getFLTEN9 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCAN1_C1FLTCON2.setFSEL10(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FLTCON2.getFSEL10 : TBits_5; inline;
begin
  getFSEL10 := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FLTCON2.setMSEL10(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF9FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1FLTCON2.getMSEL10 : TBits_2; inline;
begin
  getMSEL10 := (pTDefRegMap(@Self)^.val and $00600000) shr 21;
end;
procedure TCAN1_C1FLTCON2.setFLTEN10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TCAN1_C1FLTCON2.clearFLTEN10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TCAN1_C1FLTCON2.setFLTEN10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TCAN1_C1FLTCON2.getFLTEN10 : TBits_1; inline;
begin
  getFLTEN10 := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TCAN1_C1FLTCON2.setFSEL11(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TCAN1_C1FLTCON2.getFSEL11 : TBits_5; inline;
begin
  getFSEL11 := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TCAN1_C1FLTCON2.setMSEL11(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $9FFFFFFF or ( thebits shl 29 );
end;
function  TCAN1_C1FLTCON2.getMSEL11 : TBits_2; inline;
begin
  getMSEL11 := (pTDefRegMap(@Self)^.val and $60000000) shr 29;
end;
procedure TCAN1_C1FLTCON2.setFLTEN11; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TCAN1_C1FLTCON2.clearFLTEN11; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TCAN1_C1FLTCON2.setFLTEN11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TCAN1_C1FLTCON2.getFLTEN11 : TBits_1; inline;
begin
  getFLTEN11 := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TCAN1_C1FLTCON2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FLTCON2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FLTCON3.setFSEL12(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FLTCON3.getFSEL12 : TBits_5; inline;
begin
  getFSEL12 := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FLTCON3.setMSEL12(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TCAN1_C1FLTCON3.getMSEL12 : TBits_2; inline;
begin
  getMSEL12 := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TCAN1_C1FLTCON3.setFLTEN12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FLTCON3.clearFLTEN12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FLTCON3.setFLTEN12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FLTCON3.getFLTEN12 : TBits_1; inline;
begin
  getFLTEN12 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FLTCON3.setFSEL13(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TCAN1_C1FLTCON3.getFSEL13 : TBits_5; inline;
begin
  getFSEL13 := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TCAN1_C1FLTCON3.setMSEL13(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF9FFF or ( thebits shl 13 );
end;
function  TCAN1_C1FLTCON3.getMSEL13 : TBits_2; inline;
begin
  getMSEL13 := (pTDefRegMap(@Self)^.val and $00006000) shr 13;
end;
procedure TCAN1_C1FLTCON3.setFLTEN13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCAN1_C1FLTCON3.clearFLTEN13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCAN1_C1FLTCON3.setFLTEN13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCAN1_C1FLTCON3.getFLTEN13 : TBits_1; inline;
begin
  getFLTEN13 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCAN1_C1FLTCON3.setFSEL14(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FLTCON3.getFSEL14 : TBits_5; inline;
begin
  getFSEL14 := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FLTCON3.setMSEL14(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF9FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1FLTCON3.getMSEL14 : TBits_2; inline;
begin
  getMSEL14 := (pTDefRegMap(@Self)^.val and $00600000) shr 21;
end;
procedure TCAN1_C1FLTCON3.setFLTEN14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TCAN1_C1FLTCON3.clearFLTEN14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TCAN1_C1FLTCON3.setFLTEN14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TCAN1_C1FLTCON3.getFLTEN14 : TBits_1; inline;
begin
  getFLTEN14 := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TCAN1_C1FLTCON3.setFSEL15(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TCAN1_C1FLTCON3.getFSEL15 : TBits_5; inline;
begin
  getFSEL15 := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TCAN1_C1FLTCON3.setMSEL15(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $9FFFFFFF or ( thebits shl 29 );
end;
function  TCAN1_C1FLTCON3.getMSEL15 : TBits_2; inline;
begin
  getMSEL15 := (pTDefRegMap(@Self)^.val and $60000000) shr 29;
end;
procedure TCAN1_C1FLTCON3.setFLTEN15; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TCAN1_C1FLTCON3.clearFLTEN15; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TCAN1_C1FLTCON3.setFLTEN15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TCAN1_C1FLTCON3.getFLTEN15 : TBits_1; inline;
begin
  getFLTEN15 := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TCAN1_C1FLTCON3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FLTCON3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FLTCON4.setFSEL16(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FLTCON4.getFSEL16 : TBits_5; inline;
begin
  getFSEL16 := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FLTCON4.setMSEL16(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TCAN1_C1FLTCON4.getMSEL16 : TBits_2; inline;
begin
  getMSEL16 := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TCAN1_C1FLTCON4.setFLTEN16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FLTCON4.clearFLTEN16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FLTCON4.setFLTEN16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FLTCON4.getFLTEN16 : TBits_1; inline;
begin
  getFLTEN16 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FLTCON4.setFSEL17(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TCAN1_C1FLTCON4.getFSEL17 : TBits_5; inline;
begin
  getFSEL17 := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TCAN1_C1FLTCON4.setMSEL17(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF9FFF or ( thebits shl 13 );
end;
function  TCAN1_C1FLTCON4.getMSEL17 : TBits_2; inline;
begin
  getMSEL17 := (pTDefRegMap(@Self)^.val and $00006000) shr 13;
end;
procedure TCAN1_C1FLTCON4.setFLTEN17; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCAN1_C1FLTCON4.clearFLTEN17; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCAN1_C1FLTCON4.setFLTEN17(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCAN1_C1FLTCON4.getFLTEN17 : TBits_1; inline;
begin
  getFLTEN17 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCAN1_C1FLTCON4.setFSEL18(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FLTCON4.getFSEL18 : TBits_5; inline;
begin
  getFSEL18 := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FLTCON4.setMSEL18(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF9FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1FLTCON4.getMSEL18 : TBits_2; inline;
begin
  getMSEL18 := (pTDefRegMap(@Self)^.val and $00600000) shr 21;
end;
procedure TCAN1_C1FLTCON4.setFLTEN18; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TCAN1_C1FLTCON4.clearFLTEN18; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TCAN1_C1FLTCON4.setFLTEN18(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TCAN1_C1FLTCON4.getFLTEN18 : TBits_1; inline;
begin
  getFLTEN18 := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TCAN1_C1FLTCON4.setFSEL19(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TCAN1_C1FLTCON4.getFSEL19 : TBits_5; inline;
begin
  getFSEL19 := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TCAN1_C1FLTCON4.setMSEL19(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $9FFFFFFF or ( thebits shl 29 );
end;
function  TCAN1_C1FLTCON4.getMSEL19 : TBits_2; inline;
begin
  getMSEL19 := (pTDefRegMap(@Self)^.val and $60000000) shr 29;
end;
procedure TCAN1_C1FLTCON4.setFLTEN19; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TCAN1_C1FLTCON4.clearFLTEN19; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TCAN1_C1FLTCON4.setFLTEN19(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TCAN1_C1FLTCON4.getFLTEN19 : TBits_1; inline;
begin
  getFLTEN19 := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TCAN1_C1FLTCON4.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FLTCON4.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FLTCON5.setFSEL20(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FLTCON5.getFSEL20 : TBits_5; inline;
begin
  getFSEL20 := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FLTCON5.setMSEL20(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TCAN1_C1FLTCON5.getMSEL20 : TBits_2; inline;
begin
  getMSEL20 := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TCAN1_C1FLTCON5.setFLTEN20; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FLTCON5.clearFLTEN20; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FLTCON5.setFLTEN20(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FLTCON5.getFLTEN20 : TBits_1; inline;
begin
  getFLTEN20 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FLTCON5.setFSEL21(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TCAN1_C1FLTCON5.getFSEL21 : TBits_5; inline;
begin
  getFSEL21 := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TCAN1_C1FLTCON5.setMSEL21(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF9FFF or ( thebits shl 13 );
end;
function  TCAN1_C1FLTCON5.getMSEL21 : TBits_2; inline;
begin
  getMSEL21 := (pTDefRegMap(@Self)^.val and $00006000) shr 13;
end;
procedure TCAN1_C1FLTCON5.setFLTEN21; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCAN1_C1FLTCON5.clearFLTEN21; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCAN1_C1FLTCON5.setFLTEN21(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCAN1_C1FLTCON5.getFLTEN21 : TBits_1; inline;
begin
  getFLTEN21 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCAN1_C1FLTCON5.setFSEL22(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FLTCON5.getFSEL22 : TBits_5; inline;
begin
  getFSEL22 := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FLTCON5.setMSEL22(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF9FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1FLTCON5.getMSEL22 : TBits_2; inline;
begin
  getMSEL22 := (pTDefRegMap(@Self)^.val and $00600000) shr 21;
end;
procedure TCAN1_C1FLTCON5.setFLTEN22; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TCAN1_C1FLTCON5.clearFLTEN22; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TCAN1_C1FLTCON5.setFLTEN22(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TCAN1_C1FLTCON5.getFLTEN22 : TBits_1; inline;
begin
  getFLTEN22 := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TCAN1_C1FLTCON5.setFSEL23(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TCAN1_C1FLTCON5.getFSEL23 : TBits_5; inline;
begin
  getFSEL23 := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TCAN1_C1FLTCON5.setMSEL23(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $9FFFFFFF or ( thebits shl 29 );
end;
function  TCAN1_C1FLTCON5.getMSEL23 : TBits_2; inline;
begin
  getMSEL23 := (pTDefRegMap(@Self)^.val and $60000000) shr 29;
end;
procedure TCAN1_C1FLTCON5.setFLTEN23; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TCAN1_C1FLTCON5.clearFLTEN23; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TCAN1_C1FLTCON5.setFLTEN23(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TCAN1_C1FLTCON5.getFLTEN23 : TBits_1; inline;
begin
  getFLTEN23 := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TCAN1_C1FLTCON5.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FLTCON5.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FLTCON6.setFSEL24(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FLTCON6.getFSEL24 : TBits_5; inline;
begin
  getFSEL24 := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FLTCON6.setMSEL24(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TCAN1_C1FLTCON6.getMSEL24 : TBits_2; inline;
begin
  getMSEL24 := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TCAN1_C1FLTCON6.setFLTEN24; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FLTCON6.clearFLTEN24; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FLTCON6.setFLTEN24(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FLTCON6.getFLTEN24 : TBits_1; inline;
begin
  getFLTEN24 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FLTCON6.setFSEL25(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TCAN1_C1FLTCON6.getFSEL25 : TBits_5; inline;
begin
  getFSEL25 := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TCAN1_C1FLTCON6.setMSEL25(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF9FFF or ( thebits shl 13 );
end;
function  TCAN1_C1FLTCON6.getMSEL25 : TBits_2; inline;
begin
  getMSEL25 := (pTDefRegMap(@Self)^.val and $00006000) shr 13;
end;
procedure TCAN1_C1FLTCON6.setFLTEN25; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCAN1_C1FLTCON6.clearFLTEN25; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCAN1_C1FLTCON6.setFLTEN25(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCAN1_C1FLTCON6.getFLTEN25 : TBits_1; inline;
begin
  getFLTEN25 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCAN1_C1FLTCON6.setFSEL26(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FLTCON6.getFSEL26 : TBits_5; inline;
begin
  getFSEL26 := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FLTCON6.setMSEL26(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF9FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1FLTCON6.getMSEL26 : TBits_2; inline;
begin
  getMSEL26 := (pTDefRegMap(@Self)^.val and $00600000) shr 21;
end;
procedure TCAN1_C1FLTCON6.setFLTEN26; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TCAN1_C1FLTCON6.clearFLTEN26; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TCAN1_C1FLTCON6.setFLTEN26(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TCAN1_C1FLTCON6.getFLTEN26 : TBits_1; inline;
begin
  getFLTEN26 := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TCAN1_C1FLTCON6.setFSEL27(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TCAN1_C1FLTCON6.getFSEL27 : TBits_5; inline;
begin
  getFSEL27 := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TCAN1_C1FLTCON6.setMSEL27(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $9FFFFFFF or ( thebits shl 29 );
end;
function  TCAN1_C1FLTCON6.getMSEL27 : TBits_2; inline;
begin
  getMSEL27 := (pTDefRegMap(@Self)^.val and $60000000) shr 29;
end;
procedure TCAN1_C1FLTCON6.setFLTEN27; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TCAN1_C1FLTCON6.clearFLTEN27; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TCAN1_C1FLTCON6.setFLTEN27(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TCAN1_C1FLTCON6.getFLTEN27 : TBits_1; inline;
begin
  getFLTEN27 := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TCAN1_C1FLTCON6.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FLTCON6.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FLTCON7.setFSEL28(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FLTCON7.getFSEL28 : TBits_5; inline;
begin
  getFSEL28 := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FLTCON7.setMSEL28(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TCAN1_C1FLTCON7.getMSEL28 : TBits_2; inline;
begin
  getMSEL28 := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TCAN1_C1FLTCON7.setFLTEN28; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FLTCON7.clearFLTEN28; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FLTCON7.setFLTEN28(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FLTCON7.getFLTEN28 : TBits_1; inline;
begin
  getFLTEN28 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FLTCON7.setFSEL29(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TCAN1_C1FLTCON7.getFSEL29 : TBits_5; inline;
begin
  getFSEL29 := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TCAN1_C1FLTCON7.setMSEL29(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF9FFF or ( thebits shl 13 );
end;
function  TCAN1_C1FLTCON7.getMSEL29 : TBits_2; inline;
begin
  getMSEL29 := (pTDefRegMap(@Self)^.val and $00006000) shr 13;
end;
procedure TCAN1_C1FLTCON7.setFLTEN29; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCAN1_C1FLTCON7.clearFLTEN29; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCAN1_C1FLTCON7.setFLTEN29(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCAN1_C1FLTCON7.getFLTEN29 : TBits_1; inline;
begin
  getFLTEN29 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCAN1_C1FLTCON7.setFSEL30(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FLTCON7.getFSEL30 : TBits_5; inline;
begin
  getFSEL30 := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FLTCON7.setMSEL30(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF9FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1FLTCON7.getMSEL30 : TBits_2; inline;
begin
  getMSEL30 := (pTDefRegMap(@Self)^.val and $00600000) shr 21;
end;
procedure TCAN1_C1FLTCON7.setFLTEN30; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TCAN1_C1FLTCON7.clearFLTEN30; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TCAN1_C1FLTCON7.setFLTEN30(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TCAN1_C1FLTCON7.getFLTEN30 : TBits_1; inline;
begin
  getFLTEN30 := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TCAN1_C1FLTCON7.setFSEL31(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TCAN1_C1FLTCON7.getFSEL31 : TBits_5; inline;
begin
  getFSEL31 := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TCAN1_C1FLTCON7.setMSEL31(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $9FFFFFFF or ( thebits shl 29 );
end;
function  TCAN1_C1FLTCON7.getMSEL31 : TBits_2; inline;
begin
  getMSEL31 := (pTDefRegMap(@Self)^.val and $60000000) shr 29;
end;
procedure TCAN1_C1FLTCON7.setFLTEN31; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TCAN1_C1FLTCON7.clearFLTEN31; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TCAN1_C1FLTCON7.setFLTEN31(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TCAN1_C1FLTCON7.getFLTEN31 : TBits_1; inline;
begin
  getFLTEN31 := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TCAN1_C1FLTCON7.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FLTCON7.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF0.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF0.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF0.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF0.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF0.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF0.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF0.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF0.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF1.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF1.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF1.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF1.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF1.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF1.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF1.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF1.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF2.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF2.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF2.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF2.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF2.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF2.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF2.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF2.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF3.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF3.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF3.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF3.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF3.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF3.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF3.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF3.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF4.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF4.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF4.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF4.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF4.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF4.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF4.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF4.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF4.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF4.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF5.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF5.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF5.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF5.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF5.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF5.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF5.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF5.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF5.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF5.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF6.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF6.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF6.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF6.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF6.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF6.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF6.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF6.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF6.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF6.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF7.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF7.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF7.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF7.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF7.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF7.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF7.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF7.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF7.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF7.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF8.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF8.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF8.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF8.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF8.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF8.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF8.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF8.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF8.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF8.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF9.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF9.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF9.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF9.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF9.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF9.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF9.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF9.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF9.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF9.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF10.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF10.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF10.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF10.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF10.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF10.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF10.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF10.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF10.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF10.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF11.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF11.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF11.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF11.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF11.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF11.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF11.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF11.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF11.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF11.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF12.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF12.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF12.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF12.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF12.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF12.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF12.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF12.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF12.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF12.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF13.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF13.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF13.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF13.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF13.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF13.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF13.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF13.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF13.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF13.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF14.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF14.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF14.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF14.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF14.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF14.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF14.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF14.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF14.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF14.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF15.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF15.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF15.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF15.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF15.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF15.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF15.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF15.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF15.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF15.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF16.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF16.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF16.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF16.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF16.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF16.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF16.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF16.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF16.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF16.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF17.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF17.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF17.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF17.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF17.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF17.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF17.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF17.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF17.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF17.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF18.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF18.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF18.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF18.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF18.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF18.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF18.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF18.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF18.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF18.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF19.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF19.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF19.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF19.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF19.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF19.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF19.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF19.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF19.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF19.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF20.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF20.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF20.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF20.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF20.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF20.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF20.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF20.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF20.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF20.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF21.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF21.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF21.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF21.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF21.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF21.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF21.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF21.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF21.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF21.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF22.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF22.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF22.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF22.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF22.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF22.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF22.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF22.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF22.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF22.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF23.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF23.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF23.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF23.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF23.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF23.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF23.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF23.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF23.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF23.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF24.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF24.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF24.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF24.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF24.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF24.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF24.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF24.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF24.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF24.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF25.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF25.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF25.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF25.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF25.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF25.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF25.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF25.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF25.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF25.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF26.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF26.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF26.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF26.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF26.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF26.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF26.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF26.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF26.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF26.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF27.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF27.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF27.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF27.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF27.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF27.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF27.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF27.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF27.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF27.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF28.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF28.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF28.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF28.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF28.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF28.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF28.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF28.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF28.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF28.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF29.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF29.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF29.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF29.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF29.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF29.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF29.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF29.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF29.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF29.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF30.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF30.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF30.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF30.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF30.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF30.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF30.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF30.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF30.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF30.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1RXF31.setEID(thebits : TBits_18); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFC0000 or ( thebits shl 0 );
end;
function  TCAN1_C1RXF31.getEID : TBits_18; inline;
begin
  getEID := (pTDefRegMap(@Self)^.val and $0003FFFF) shr 0;
end;
procedure TCAN1_C1RXF31.setEXID; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1RXF31.clearEXID; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1RXF31.setEXID(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1RXF31.getEXID : TBits_1; inline;
begin
  getEXID := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1RXF31.setSID(thebits : TBits_11); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $001FFFFF or ( thebits shl 21 );
end;
function  TCAN1_C1RXF31.getSID : TBits_11; inline;
begin
  getSID := (pTDefRegMap(@Self)^.val and $FFE00000) shr 21;
end;
procedure TCAN1_C1RXF31.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1RXF31.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON0.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON0.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON0.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON0.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON0.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON0.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON0.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON0.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON0.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON0.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON0.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON0.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON0.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON0.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON0.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON0.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON0.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON0.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON0.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON0.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON0.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON0.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON0.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON0.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON0.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON0.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON0.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON0.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON0.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON0.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON0.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON0.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON0.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON0.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON0.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON0.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON0.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON0.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON0.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON0.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT0.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT0.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT0.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT0.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT0.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT0.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT0.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT0.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT0.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT0.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT0.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT0.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT0.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT0.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT0.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT0.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT0.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT0.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT0.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT0.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT0.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT0.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT0.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT0.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT0.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT0.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT0.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT0.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT0.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT0.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT0.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT0.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT0.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT0.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT0.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT0.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT0.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT0.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT0.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT0.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT0.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT0.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT0.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT0.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT0.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT0.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT0.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT0.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT0.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT0.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT0.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT0.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT0.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT0.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT0.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT0.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI0.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI0.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON1.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON1.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON1.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON1.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON1.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON1.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON1.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON1.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON1.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON1.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON1.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON1.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON1.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON1.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON1.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON1.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON1.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON1.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON1.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON1.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON1.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON1.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON1.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON1.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON1.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON1.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON1.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON1.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON1.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON1.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON1.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON1.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON1.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON1.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON1.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON1.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON1.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON1.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON1.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON1.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT1.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT1.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT1.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT1.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT1.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT1.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT1.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT1.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT1.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT1.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT1.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT1.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT1.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT1.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT1.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT1.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT1.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT1.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT1.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT1.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT1.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT1.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT1.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT1.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT1.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT1.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT1.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT1.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT1.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT1.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT1.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT1.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT1.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT1.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT1.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT1.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT1.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT1.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT1.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT1.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT1.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT1.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT1.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT1.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT1.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT1.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT1.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT1.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT1.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT1.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT1.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT1.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT1.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT1.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT1.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT1.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI1.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI1.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON2.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON2.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON2.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON2.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON2.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON2.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON2.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON2.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON2.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON2.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON2.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON2.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON2.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON2.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON2.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON2.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON2.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON2.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON2.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON2.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON2.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON2.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON2.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON2.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON2.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON2.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON2.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON2.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON2.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON2.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON2.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON2.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON2.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON2.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON2.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON2.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON2.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON2.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON2.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON2.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT2.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT2.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT2.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT2.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT2.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT2.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT2.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT2.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT2.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT2.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT2.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT2.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT2.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT2.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT2.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT2.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT2.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT2.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT2.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT2.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT2.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT2.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT2.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT2.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT2.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT2.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT2.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT2.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT2.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT2.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT2.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT2.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT2.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT2.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT2.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT2.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT2.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT2.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT2.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT2.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT2.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT2.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT2.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT2.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT2.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT2.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT2.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT2.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT2.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT2.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT2.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT2.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT2.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT2.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT2.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT2.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI2.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI2.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON3.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON3.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON3.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON3.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON3.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON3.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON3.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON3.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON3.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON3.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON3.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON3.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON3.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON3.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON3.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON3.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON3.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON3.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON3.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON3.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON3.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON3.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON3.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON3.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON3.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON3.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON3.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON3.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON3.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON3.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON3.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON3.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON3.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON3.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON3.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON3.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON3.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON3.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON3.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON3.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT3.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT3.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT3.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT3.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT3.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT3.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT3.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT3.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT3.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT3.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT3.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT3.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT3.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT3.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT3.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT3.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT3.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT3.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT3.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT3.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT3.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT3.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT3.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT3.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT3.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT3.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT3.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT3.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT3.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT3.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT3.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT3.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT3.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT3.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT3.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT3.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT3.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT3.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT3.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT3.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT3.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT3.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT3.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT3.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT3.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT3.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT3.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT3.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT3.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT3.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT3.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT3.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT3.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT3.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT3.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT3.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI3.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI3.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON4.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON4.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON4.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON4.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON4.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON4.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON4.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON4.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON4.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON4.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON4.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON4.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON4.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON4.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON4.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON4.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON4.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON4.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON4.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON4.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON4.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON4.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON4.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON4.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON4.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON4.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON4.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON4.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON4.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON4.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON4.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON4.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON4.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON4.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON4.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON4.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON4.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON4.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON4.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON4.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON4.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON4.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT4.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT4.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT4.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT4.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT4.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT4.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT4.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT4.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT4.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT4.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT4.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT4.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT4.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT4.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT4.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT4.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT4.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT4.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT4.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT4.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT4.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT4.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT4.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT4.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT4.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT4.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT4.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT4.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT4.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT4.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT4.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT4.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT4.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT4.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT4.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT4.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT4.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT4.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT4.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT4.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT4.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT4.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT4.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT4.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT4.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT4.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT4.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT4.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT4.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT4.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT4.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT4.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT4.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT4.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT4.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT4.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT4.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT4.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI4.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI4.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI4.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI4.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON5.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON5.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON5.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON5.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON5.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON5.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON5.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON5.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON5.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON5.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON5.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON5.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON5.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON5.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON5.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON5.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON5.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON5.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON5.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON5.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON5.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON5.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON5.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON5.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON5.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON5.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON5.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON5.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON5.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON5.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON5.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON5.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON5.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON5.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON5.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON5.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON5.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON5.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON5.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON5.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON5.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON5.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT5.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT5.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT5.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT5.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT5.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT5.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT5.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT5.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT5.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT5.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT5.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT5.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT5.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT5.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT5.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT5.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT5.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT5.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT5.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT5.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT5.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT5.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT5.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT5.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT5.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT5.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT5.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT5.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT5.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT5.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT5.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT5.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT5.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT5.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT5.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT5.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT5.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT5.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT5.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT5.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT5.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT5.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT5.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT5.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT5.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT5.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT5.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT5.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT5.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT5.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT5.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT5.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT5.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT5.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT5.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT5.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT5.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT5.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI5.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI5.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI5.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI5.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON6.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON6.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON6.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON6.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON6.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON6.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON6.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON6.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON6.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON6.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON6.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON6.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON6.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON6.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON6.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON6.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON6.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON6.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON6.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON6.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON6.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON6.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON6.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON6.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON6.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON6.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON6.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON6.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON6.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON6.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON6.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON6.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON6.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON6.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON6.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON6.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON6.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON6.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON6.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON6.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON6.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON6.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT6.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT6.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT6.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT6.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT6.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT6.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT6.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT6.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT6.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT6.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT6.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT6.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT6.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT6.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT6.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT6.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT6.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT6.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT6.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT6.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT6.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT6.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT6.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT6.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT6.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT6.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT6.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT6.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT6.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT6.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT6.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT6.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT6.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT6.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT6.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT6.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT6.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT6.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT6.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT6.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT6.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT6.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT6.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT6.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT6.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT6.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT6.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT6.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT6.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT6.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT6.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT6.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT6.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT6.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT6.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT6.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT6.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT6.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI6.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI6.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI6.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI6.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON7.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON7.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON7.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON7.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON7.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON7.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON7.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON7.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON7.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON7.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON7.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON7.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON7.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON7.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON7.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON7.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON7.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON7.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON7.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON7.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON7.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON7.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON7.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON7.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON7.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON7.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON7.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON7.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON7.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON7.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON7.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON7.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON7.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON7.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON7.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON7.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON7.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON7.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON7.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON7.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON7.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON7.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT7.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT7.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT7.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT7.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT7.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT7.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT7.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT7.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT7.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT7.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT7.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT7.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT7.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT7.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT7.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT7.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT7.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT7.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT7.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT7.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT7.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT7.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT7.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT7.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT7.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT7.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT7.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT7.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT7.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT7.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT7.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT7.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT7.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT7.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT7.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT7.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT7.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT7.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT7.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT7.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT7.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT7.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT7.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT7.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT7.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT7.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT7.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT7.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT7.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT7.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT7.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT7.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT7.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT7.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT7.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT7.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT7.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT7.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI7.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI7.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI7.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI7.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON8.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON8.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON8.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON8.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON8.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON8.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON8.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON8.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON8.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON8.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON8.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON8.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON8.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON8.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON8.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON8.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON8.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON8.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON8.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON8.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON8.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON8.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON8.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON8.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON8.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON8.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON8.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON8.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON8.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON8.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON8.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON8.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON8.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON8.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON8.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON8.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON8.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON8.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON8.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON8.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON8.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON8.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT8.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT8.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT8.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT8.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT8.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT8.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT8.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT8.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT8.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT8.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT8.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT8.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT8.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT8.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT8.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT8.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT8.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT8.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT8.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT8.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT8.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT8.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT8.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT8.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT8.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT8.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT8.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT8.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT8.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT8.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT8.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT8.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT8.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT8.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT8.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT8.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT8.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT8.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT8.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT8.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT8.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT8.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT8.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT8.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT8.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT8.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT8.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT8.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT8.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT8.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT8.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT8.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT8.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT8.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT8.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT8.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT8.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT8.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI8.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI8.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI8.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI8.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON9.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON9.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON9.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON9.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON9.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON9.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON9.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON9.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON9.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON9.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON9.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON9.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON9.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON9.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON9.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON9.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON9.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON9.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON9.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON9.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON9.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON9.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON9.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON9.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON9.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON9.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON9.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON9.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON9.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON9.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON9.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON9.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON9.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON9.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON9.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON9.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON9.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON9.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON9.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON9.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON9.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON9.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT9.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT9.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT9.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT9.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT9.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT9.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT9.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT9.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT9.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT9.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT9.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT9.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT9.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT9.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT9.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT9.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT9.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT9.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT9.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT9.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT9.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT9.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT9.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT9.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT9.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT9.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT9.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT9.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT9.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT9.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT9.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT9.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT9.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT9.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT9.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT9.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT9.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT9.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT9.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT9.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT9.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT9.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT9.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT9.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT9.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT9.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT9.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT9.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT9.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT9.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT9.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT9.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT9.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT9.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT9.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT9.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT9.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT9.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI9.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI9.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI9.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI9.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON10.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON10.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON10.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON10.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON10.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON10.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON10.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON10.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON10.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON10.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON10.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON10.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON10.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON10.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON10.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON10.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON10.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON10.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON10.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON10.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON10.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON10.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON10.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON10.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON10.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON10.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON10.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON10.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON10.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON10.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON10.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON10.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON10.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON10.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON10.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON10.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON10.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON10.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON10.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON10.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON10.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON10.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT10.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT10.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT10.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT10.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT10.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT10.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT10.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT10.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT10.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT10.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT10.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT10.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT10.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT10.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT10.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT10.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT10.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT10.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT10.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT10.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT10.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT10.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT10.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT10.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT10.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT10.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT10.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT10.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT10.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT10.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT10.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT10.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT10.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT10.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT10.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT10.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT10.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT10.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT10.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT10.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT10.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT10.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT10.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT10.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT10.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT10.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT10.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT10.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT10.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT10.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT10.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT10.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT10.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT10.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT10.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT10.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT10.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT10.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI10.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI10.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI10.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI10.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON11.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON11.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON11.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON11.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON11.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON11.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON11.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON11.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON11.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON11.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON11.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON11.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON11.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON11.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON11.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON11.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON11.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON11.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON11.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON11.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON11.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON11.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON11.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON11.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON11.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON11.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON11.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON11.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON11.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON11.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON11.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON11.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON11.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON11.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON11.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON11.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON11.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON11.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON11.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON11.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON11.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON11.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT11.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT11.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT11.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT11.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT11.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT11.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT11.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT11.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT11.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT11.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT11.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT11.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT11.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT11.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT11.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT11.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT11.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT11.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT11.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT11.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT11.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT11.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT11.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT11.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT11.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT11.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT11.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT11.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT11.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT11.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT11.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT11.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT11.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT11.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT11.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT11.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT11.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT11.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT11.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT11.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT11.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT11.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT11.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT11.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT11.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT11.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT11.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT11.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT11.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT11.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT11.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT11.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT11.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT11.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT11.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT11.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT11.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT11.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI11.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI11.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI11.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI11.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON12.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON12.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON12.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON12.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON12.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON12.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON12.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON12.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON12.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON12.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON12.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON12.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON12.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON12.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON12.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON12.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON12.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON12.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON12.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON12.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON12.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON12.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON12.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON12.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON12.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON12.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON12.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON12.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON12.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON12.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON12.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON12.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON12.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON12.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON12.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON12.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON12.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON12.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON12.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON12.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON12.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON12.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT12.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT12.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT12.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT12.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT12.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT12.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT12.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT12.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT12.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT12.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT12.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT12.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT12.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT12.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT12.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT12.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT12.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT12.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT12.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT12.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT12.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT12.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT12.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT12.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT12.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT12.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT12.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT12.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT12.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT12.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT12.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT12.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT12.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT12.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT12.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT12.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT12.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT12.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT12.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT12.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT12.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT12.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT12.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT12.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT12.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT12.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT12.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT12.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT12.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT12.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT12.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT12.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT12.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT12.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT12.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT12.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT12.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT12.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI12.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI12.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI12.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI12.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON13.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON13.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON13.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON13.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON13.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON13.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON13.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON13.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON13.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON13.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON13.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON13.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON13.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON13.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON13.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON13.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON13.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON13.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON13.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON13.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON13.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON13.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON13.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON13.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON13.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON13.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON13.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON13.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON13.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON13.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON13.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON13.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON13.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON13.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON13.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON13.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON13.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON13.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON13.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON13.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON13.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON13.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT13.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT13.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT13.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT13.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT13.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT13.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT13.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT13.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT13.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT13.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT13.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT13.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT13.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT13.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT13.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT13.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT13.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT13.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT13.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT13.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT13.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT13.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT13.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT13.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT13.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT13.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT13.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT13.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT13.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT13.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT13.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT13.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT13.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT13.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT13.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT13.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT13.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT13.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT13.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT13.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT13.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT13.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT13.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT13.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT13.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT13.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT13.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT13.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT13.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT13.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT13.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT13.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT13.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT13.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT13.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT13.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT13.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT13.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI13.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI13.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI13.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI13.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON14.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON14.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON14.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON14.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON14.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON14.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON14.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON14.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON14.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON14.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON14.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON14.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON14.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON14.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON14.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON14.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON14.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON14.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON14.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON14.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON14.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON14.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON14.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON14.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON14.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON14.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON14.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON14.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON14.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON14.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON14.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON14.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON14.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON14.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON14.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON14.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON14.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON14.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON14.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON14.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON14.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON14.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT14.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT14.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT14.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT14.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT14.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT14.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT14.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT14.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT14.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT14.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT14.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT14.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT14.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT14.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT14.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT14.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT14.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT14.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT14.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT14.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT14.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT14.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT14.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT14.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT14.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT14.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT14.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT14.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT14.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT14.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT14.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT14.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT14.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT14.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT14.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT14.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT14.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT14.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT14.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT14.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT14.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT14.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT14.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT14.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT14.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT14.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT14.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT14.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT14.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT14.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT14.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT14.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT14.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT14.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT14.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT14.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT14.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT14.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI14.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI14.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI14.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI14.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON15.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON15.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON15.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON15.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON15.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON15.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON15.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON15.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON15.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON15.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON15.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON15.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON15.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON15.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON15.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON15.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON15.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON15.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON15.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON15.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON15.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON15.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON15.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON15.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON15.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON15.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON15.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON15.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON15.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON15.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON15.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON15.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON15.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON15.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON15.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON15.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON15.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON15.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON15.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON15.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON15.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON15.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT15.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT15.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT15.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT15.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT15.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT15.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT15.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT15.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT15.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT15.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT15.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT15.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT15.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT15.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT15.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT15.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT15.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT15.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT15.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT15.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT15.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT15.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT15.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT15.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT15.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT15.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT15.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT15.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT15.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT15.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT15.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT15.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT15.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT15.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT15.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT15.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT15.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT15.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT15.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT15.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT15.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT15.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT15.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT15.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT15.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT15.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT15.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT15.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT15.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT15.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT15.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT15.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT15.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT15.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT15.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT15.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT15.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT15.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI15.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI15.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI15.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI15.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON16.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON16.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON16.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON16.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON16.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON16.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON16.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON16.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON16.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON16.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON16.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON16.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON16.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON16.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON16.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON16.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON16.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON16.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON16.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON16.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON16.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON16.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON16.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON16.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON16.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON16.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON16.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON16.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON16.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON16.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON16.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON16.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON16.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON16.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON16.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON16.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON16.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON16.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON16.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON16.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON16.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON16.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT16.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT16.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT16.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT16.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT16.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT16.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT16.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT16.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT16.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT16.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT16.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT16.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT16.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT16.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT16.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT16.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT16.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT16.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT16.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT16.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT16.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT16.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT16.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT16.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT16.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT16.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT16.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT16.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT16.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT16.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT16.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT16.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT16.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT16.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT16.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT16.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT16.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT16.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT16.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT16.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT16.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT16.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT16.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT16.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT16.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT16.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT16.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT16.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT16.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT16.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT16.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT16.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT16.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT16.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT16.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT16.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT16.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT16.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI16.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI16.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI16.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI16.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON17.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON17.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON17.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON17.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON17.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON17.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON17.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON17.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON17.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON17.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON17.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON17.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON17.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON17.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON17.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON17.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON17.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON17.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON17.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON17.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON17.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON17.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON17.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON17.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON17.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON17.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON17.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON17.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON17.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON17.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON17.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON17.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON17.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON17.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON17.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON17.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON17.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON17.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON17.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON17.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON17.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON17.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT17.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT17.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT17.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT17.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT17.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT17.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT17.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT17.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT17.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT17.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT17.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT17.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT17.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT17.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT17.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT17.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT17.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT17.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT17.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT17.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT17.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT17.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT17.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT17.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT17.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT17.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT17.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT17.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT17.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT17.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT17.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT17.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT17.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT17.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT17.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT17.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT17.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT17.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT17.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT17.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT17.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT17.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT17.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT17.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT17.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT17.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT17.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT17.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT17.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT17.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT17.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT17.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT17.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT17.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT17.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT17.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT17.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT17.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI17.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI17.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI17.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI17.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON18.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON18.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON18.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON18.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON18.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON18.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON18.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON18.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON18.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON18.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON18.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON18.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON18.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON18.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON18.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON18.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON18.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON18.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON18.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON18.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON18.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON18.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON18.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON18.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON18.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON18.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON18.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON18.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON18.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON18.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON18.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON18.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON18.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON18.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON18.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON18.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON18.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON18.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON18.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON18.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON18.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON18.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT18.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT18.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT18.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT18.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT18.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT18.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT18.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT18.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT18.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT18.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT18.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT18.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT18.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT18.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT18.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT18.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT18.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT18.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT18.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT18.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT18.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT18.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT18.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT18.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT18.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT18.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT18.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT18.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT18.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT18.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT18.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT18.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT18.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT18.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT18.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT18.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT18.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT18.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT18.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT18.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT18.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT18.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT18.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT18.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT18.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT18.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT18.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT18.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT18.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT18.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT18.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT18.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT18.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT18.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT18.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT18.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT18.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT18.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI18.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI18.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI18.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI18.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON19.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON19.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON19.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON19.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON19.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON19.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON19.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON19.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON19.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON19.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON19.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON19.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON19.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON19.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON19.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON19.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON19.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON19.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON19.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON19.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON19.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON19.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON19.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON19.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON19.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON19.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON19.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON19.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON19.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON19.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON19.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON19.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON19.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON19.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON19.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON19.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON19.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON19.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON19.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON19.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON19.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON19.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT19.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT19.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT19.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT19.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT19.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT19.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT19.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT19.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT19.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT19.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT19.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT19.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT19.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT19.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT19.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT19.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT19.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT19.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT19.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT19.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT19.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT19.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT19.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT19.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT19.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT19.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT19.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT19.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT19.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT19.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT19.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT19.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT19.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT19.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT19.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT19.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT19.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT19.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT19.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT19.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT19.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT19.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT19.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT19.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT19.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT19.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT19.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT19.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT19.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT19.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT19.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT19.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT19.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT19.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT19.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT19.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT19.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT19.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI19.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI19.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI19.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI19.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON20.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON20.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON20.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON20.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON20.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON20.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON20.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON20.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON20.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON20.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON20.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON20.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON20.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON20.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON20.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON20.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON20.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON20.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON20.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON20.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON20.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON20.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON20.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON20.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON20.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON20.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON20.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON20.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON20.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON20.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON20.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON20.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON20.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON20.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON20.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON20.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON20.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON20.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON20.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON20.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON20.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON20.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT20.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT20.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT20.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT20.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT20.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT20.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT20.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT20.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT20.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT20.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT20.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT20.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT20.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT20.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT20.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT20.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT20.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT20.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT20.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT20.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT20.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT20.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT20.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT20.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT20.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT20.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT20.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT20.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT20.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT20.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT20.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT20.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT20.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT20.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT20.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT20.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT20.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT20.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT20.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT20.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT20.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT20.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT20.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT20.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT20.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT20.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT20.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT20.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT20.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT20.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT20.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT20.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT20.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT20.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT20.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT20.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT20.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT20.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI20.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI20.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI20.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI20.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON21.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON21.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON21.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON21.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON21.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON21.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON21.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON21.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON21.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON21.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON21.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON21.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON21.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON21.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON21.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON21.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON21.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON21.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON21.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON21.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON21.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON21.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON21.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON21.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON21.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON21.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON21.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON21.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON21.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON21.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON21.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON21.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON21.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON21.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON21.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON21.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON21.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON21.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON21.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON21.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON21.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON21.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT21.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT21.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT21.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT21.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT21.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT21.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT21.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT21.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT21.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT21.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT21.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT21.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT21.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT21.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT21.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT21.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT21.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT21.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT21.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT21.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT21.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT21.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT21.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT21.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT21.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT21.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT21.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT21.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT21.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT21.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT21.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT21.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT21.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT21.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT21.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT21.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT21.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT21.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT21.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT21.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT21.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT21.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT21.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT21.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT21.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT21.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT21.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT21.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT21.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT21.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT21.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT21.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT21.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT21.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT21.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT21.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT21.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT21.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI21.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI21.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI21.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI21.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON22.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON22.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON22.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON22.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON22.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON22.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON22.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON22.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON22.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON22.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON22.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON22.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON22.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON22.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON22.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON22.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON22.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON22.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON22.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON22.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON22.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON22.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON22.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON22.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON22.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON22.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON22.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON22.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON22.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON22.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON22.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON22.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON22.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON22.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON22.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON22.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON22.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON22.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON22.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON22.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON22.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON22.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT22.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT22.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT22.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT22.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT22.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT22.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT22.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT22.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT22.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT22.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT22.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT22.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT22.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT22.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT22.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT22.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT22.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT22.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT22.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT22.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT22.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT22.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT22.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT22.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT22.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT22.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT22.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT22.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT22.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT22.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT22.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT22.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT22.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT22.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT22.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT22.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT22.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT22.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT22.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT22.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT22.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT22.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT22.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT22.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT22.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT22.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT22.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT22.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT22.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT22.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT22.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT22.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT22.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT22.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT22.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT22.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT22.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT22.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI22.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI22.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI22.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI22.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON23.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON23.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON23.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON23.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON23.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON23.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON23.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON23.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON23.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON23.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON23.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON23.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON23.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON23.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON23.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON23.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON23.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON23.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON23.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON23.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON23.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON23.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON23.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON23.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON23.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON23.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON23.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON23.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON23.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON23.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON23.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON23.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON23.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON23.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON23.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON23.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON23.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON23.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON23.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON23.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON23.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON23.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT23.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT23.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT23.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT23.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT23.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT23.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT23.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT23.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT23.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT23.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT23.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT23.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT23.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT23.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT23.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT23.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT23.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT23.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT23.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT23.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT23.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT23.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT23.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT23.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT23.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT23.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT23.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT23.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT23.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT23.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT23.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT23.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT23.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT23.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT23.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT23.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT23.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT23.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT23.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT23.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT23.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT23.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT23.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT23.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT23.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT23.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT23.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT23.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT23.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT23.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT23.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT23.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT23.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT23.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT23.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT23.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT23.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT23.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI23.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI23.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI23.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI23.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON24.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON24.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON24.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON24.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON24.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON24.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON24.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON24.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON24.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON24.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON24.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON24.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON24.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON24.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON24.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON24.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON24.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON24.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON24.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON24.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON24.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON24.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON24.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON24.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON24.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON24.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON24.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON24.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON24.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON24.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON24.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON24.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON24.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON24.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON24.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON24.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON24.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON24.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON24.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON24.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON24.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON24.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT24.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT24.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT24.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT24.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT24.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT24.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT24.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT24.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT24.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT24.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT24.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT24.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT24.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT24.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT24.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT24.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT24.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT24.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT24.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT24.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT24.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT24.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT24.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT24.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT24.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT24.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT24.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT24.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT24.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT24.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT24.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT24.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT24.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT24.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT24.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT24.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT24.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT24.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT24.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT24.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT24.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT24.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT24.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT24.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT24.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT24.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT24.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT24.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT24.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT24.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT24.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT24.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT24.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT24.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT24.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT24.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT24.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT24.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI24.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI24.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI24.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI24.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON25.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON25.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON25.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON25.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON25.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON25.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON25.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON25.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON25.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON25.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON25.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON25.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON25.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON25.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON25.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON25.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON25.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON25.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON25.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON25.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON25.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON25.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON25.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON25.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON25.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON25.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON25.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON25.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON25.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON25.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON25.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON25.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON25.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON25.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON25.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON25.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON25.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON25.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON25.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON25.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON25.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON25.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT25.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT25.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT25.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT25.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT25.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT25.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT25.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT25.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT25.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT25.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT25.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT25.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT25.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT25.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT25.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT25.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT25.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT25.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT25.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT25.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT25.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT25.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT25.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT25.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT25.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT25.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT25.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT25.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT25.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT25.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT25.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT25.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT25.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT25.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT25.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT25.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT25.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT25.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT25.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT25.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT25.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT25.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT25.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT25.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT25.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT25.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT25.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT25.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT25.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT25.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT25.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT25.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT25.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT25.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT25.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT25.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT25.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT25.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI25.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI25.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI25.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI25.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON26.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON26.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON26.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON26.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON26.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON26.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON26.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON26.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON26.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON26.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON26.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON26.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON26.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON26.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON26.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON26.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON26.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON26.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON26.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON26.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON26.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON26.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON26.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON26.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON26.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON26.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON26.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON26.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON26.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON26.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON26.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON26.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON26.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON26.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON26.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON26.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON26.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON26.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON26.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON26.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON26.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON26.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT26.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT26.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT26.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT26.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT26.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT26.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT26.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT26.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT26.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT26.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT26.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT26.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT26.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT26.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT26.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT26.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT26.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT26.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT26.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT26.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT26.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT26.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT26.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT26.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT26.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT26.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT26.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT26.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT26.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT26.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT26.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT26.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT26.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT26.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT26.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT26.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT26.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT26.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT26.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT26.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT26.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT26.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT26.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT26.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT26.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT26.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT26.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT26.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT26.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT26.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT26.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT26.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT26.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT26.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT26.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT26.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT26.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT26.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI26.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI26.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI26.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI26.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON27.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON27.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON27.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON27.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON27.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON27.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON27.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON27.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON27.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON27.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON27.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON27.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON27.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON27.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON27.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON27.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON27.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON27.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON27.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON27.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON27.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON27.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON27.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON27.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON27.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON27.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON27.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON27.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON27.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON27.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON27.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON27.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON27.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON27.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON27.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON27.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON27.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON27.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON27.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON27.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON27.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON27.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT27.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT27.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT27.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT27.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT27.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT27.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT27.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT27.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT27.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT27.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT27.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT27.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT27.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT27.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT27.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT27.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT27.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT27.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT27.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT27.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT27.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT27.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT27.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT27.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT27.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT27.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT27.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT27.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT27.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT27.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT27.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT27.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT27.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT27.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT27.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT27.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT27.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT27.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT27.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT27.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT27.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT27.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT27.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT27.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT27.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT27.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT27.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT27.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT27.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT27.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT27.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT27.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT27.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT27.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT27.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT27.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT27.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT27.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI27.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI27.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI27.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI27.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON28.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON28.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON28.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON28.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON28.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON28.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON28.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON28.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON28.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON28.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON28.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON28.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON28.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON28.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON28.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON28.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON28.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON28.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON28.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON28.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON28.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON28.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON28.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON28.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON28.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON28.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON28.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON28.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON28.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON28.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON28.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON28.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON28.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON28.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON28.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON28.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON28.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON28.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON28.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON28.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON28.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON28.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT28.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT28.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT28.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT28.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT28.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT28.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT28.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT28.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT28.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT28.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT28.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT28.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT28.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT28.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT28.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT28.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT28.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT28.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT28.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT28.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT28.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT28.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT28.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT28.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT28.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT28.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT28.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT28.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT28.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT28.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT28.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT28.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT28.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT28.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT28.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT28.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT28.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT28.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT28.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT28.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT28.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT28.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT28.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT28.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT28.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT28.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT28.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT28.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT28.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT28.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT28.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT28.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT28.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT28.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT28.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT28.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT28.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT28.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI28.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI28.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI28.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI28.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON29.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON29.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON29.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON29.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON29.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON29.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON29.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON29.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON29.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON29.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON29.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON29.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON29.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON29.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON29.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON29.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON29.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON29.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON29.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON29.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON29.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON29.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON29.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON29.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON29.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON29.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON29.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON29.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON29.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON29.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON29.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON29.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON29.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON29.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON29.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON29.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON29.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON29.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON29.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON29.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON29.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON29.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT29.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT29.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT29.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT29.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT29.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT29.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT29.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT29.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT29.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT29.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT29.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT29.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT29.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT29.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT29.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT29.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT29.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT29.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT29.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT29.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT29.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT29.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT29.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT29.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT29.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT29.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT29.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT29.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT29.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT29.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT29.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT29.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT29.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT29.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT29.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT29.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT29.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT29.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT29.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT29.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT29.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT29.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT29.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT29.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT29.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT29.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT29.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT29.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT29.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT29.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT29.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT29.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT29.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT29.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT29.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT29.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT29.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT29.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI29.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI29.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI29.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI29.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON30.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON30.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON30.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON30.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON30.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON30.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON30.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON30.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON30.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON30.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON30.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON30.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON30.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON30.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON30.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON30.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON30.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON30.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON30.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON30.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON30.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON30.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON30.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON30.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON30.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON30.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON30.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON30.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON30.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON30.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON30.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON30.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON30.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON30.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON30.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON30.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON30.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON30.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON30.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON30.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON30.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON30.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT30.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT30.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT30.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT30.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT30.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT30.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT30.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT30.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT30.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT30.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT30.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT30.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT30.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT30.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT30.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT30.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT30.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT30.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT30.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT30.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT30.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT30.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT30.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT30.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT30.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT30.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT30.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT30.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT30.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT30.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT30.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT30.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT30.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT30.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT30.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT30.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT30.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT30.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT30.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT30.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT30.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT30.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT30.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT30.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT30.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT30.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT30.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT30.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT30.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT30.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT30.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT30.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT30.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT30.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT30.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT30.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT30.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT30.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI30.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI30.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI30.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI30.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCON31.setTXPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCON31.getTXPRI : TBits_2; inline;
begin
  getTXPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCAN1_C1FIFOCON31.setRTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOCON31.clearRTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOCON31.setRTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOCON31.getRTREN : TBits_1; inline;
begin
  getRTREN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOCON31.setTXREQ; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOCON31.clearTXREQ; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOCON31.setTXREQ(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOCON31.getTXREQ : TBits_1; inline;
begin
  getTXREQ := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOCON31.setTXERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCAN1_C1FIFOCON31.clearTXERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCAN1_C1FIFOCON31.setTXERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCAN1_C1FIFOCON31.getTXERR : TBits_1; inline;
begin
  getTXERR := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCAN1_C1FIFOCON31.setTXLARB; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCAN1_C1FIFOCON31.clearTXLARB; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCAN1_C1FIFOCON31.setTXLARB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCAN1_C1FIFOCON31.getTXLARB : TBits_1; inline;
begin
  getTXLARB := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCAN1_C1FIFOCON31.setTXABAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCAN1_C1FIFOCON31.clearTXABAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCAN1_C1FIFOCON31.setTXABAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCAN1_C1FIFOCON31.getTXABAT : TBits_1; inline;
begin
  getTXABAT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCAN1_C1FIFOCON31.setTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCAN1_C1FIFOCON31.clearTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCAN1_C1FIFOCON31.setTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCAN1_C1FIFOCON31.getTXEN : TBits_1; inline;
begin
  getTXEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCAN1_C1FIFOCON31.setDONLY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCAN1_C1FIFOCON31.clearDONLY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCAN1_C1FIFOCON31.setDONLY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCAN1_C1FIFOCON31.getDONLY : TBits_1; inline;
begin
  getDONLY := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCAN1_C1FIFOCON31.setUINC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCAN1_C1FIFOCON31.clearUINC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCAN1_C1FIFOCON31.setUINC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCAN1_C1FIFOCON31.getUINC : TBits_1; inline;
begin
  getUINC := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCAN1_C1FIFOCON31.setFRESET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCAN1_C1FIFOCON31.clearFRESET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCAN1_C1FIFOCON31.setFRESET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCAN1_C1FIFOCON31.getFRESET : TBits_1; inline;
begin
  getFRESET := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCAN1_C1FIFOCON31.setFSIZE(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TCAN1_C1FIFOCON31.getFSIZE : TBits_5; inline;
begin
  getFSIZE := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TCAN1_C1FIFOCON31.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCON31.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOINT31.setRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCAN1_C1FIFOINT31.clearRXNEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCAN1_C1FIFOINT31.setRXNEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCAN1_C1FIFOINT31.getRXNEMPTYIF : TBits_1; inline;
begin
  getRXNEMPTYIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCAN1_C1FIFOINT31.setRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCAN1_C1FIFOINT31.clearRXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCAN1_C1FIFOINT31.setRXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCAN1_C1FIFOINT31.getRXHALFIF : TBits_1; inline;
begin
  getRXHALFIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCAN1_C1FIFOINT31.setRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCAN1_C1FIFOINT31.clearRXFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCAN1_C1FIFOINT31.setRXFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCAN1_C1FIFOINT31.getRXFULLIF : TBits_1; inline;
begin
  getRXFULLIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCAN1_C1FIFOINT31.setRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCAN1_C1FIFOINT31.clearRXOVFLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCAN1_C1FIFOINT31.setRXOVFLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCAN1_C1FIFOINT31.getRXOVFLIF : TBits_1; inline;
begin
  getRXOVFLIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCAN1_C1FIFOINT31.setTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCAN1_C1FIFOINT31.clearTXEMPTYIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCAN1_C1FIFOINT31.setTXEMPTYIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCAN1_C1FIFOINT31.getTXEMPTYIF : TBits_1; inline;
begin
  getTXEMPTYIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCAN1_C1FIFOINT31.setTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCAN1_C1FIFOINT31.clearTXHALFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCAN1_C1FIFOINT31.setTXHALFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCAN1_C1FIFOINT31.getTXHALFIF : TBits_1; inline;
begin
  getTXHALFIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCAN1_C1FIFOINT31.setTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCAN1_C1FIFOINT31.clearTXNFULLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCAN1_C1FIFOINT31.setTXNFULLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCAN1_C1FIFOINT31.getTXNFULLIF : TBits_1; inline;
begin
  getTXNFULLIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCAN1_C1FIFOINT31.setRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCAN1_C1FIFOINT31.clearRXNEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCAN1_C1FIFOINT31.setRXNEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCAN1_C1FIFOINT31.getRXNEMPTYIE : TBits_1; inline;
begin
  getRXNEMPTYIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCAN1_C1FIFOINT31.setRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCAN1_C1FIFOINT31.clearRXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCAN1_C1FIFOINT31.setRXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCAN1_C1FIFOINT31.getRXHALFIE : TBits_1; inline;
begin
  getRXHALFIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCAN1_C1FIFOINT31.setRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TCAN1_C1FIFOINT31.clearRXFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TCAN1_C1FIFOINT31.setRXFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TCAN1_C1FIFOINT31.getRXFULLIE : TBits_1; inline;
begin
  getRXFULLIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TCAN1_C1FIFOINT31.setRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TCAN1_C1FIFOINT31.clearRXOVFLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TCAN1_C1FIFOINT31.setRXOVFLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TCAN1_C1FIFOINT31.getRXOVFLIE : TBits_1; inline;
begin
  getRXOVFLIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TCAN1_C1FIFOINT31.setTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCAN1_C1FIFOINT31.clearTXEMPTYIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCAN1_C1FIFOINT31.setTXEMPTYIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCAN1_C1FIFOINT31.getTXEMPTYIE : TBits_1; inline;
begin
  getTXEMPTYIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCAN1_C1FIFOINT31.setTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCAN1_C1FIFOINT31.clearTXHALFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCAN1_C1FIFOINT31.setTXHALFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCAN1_C1FIFOINT31.getTXHALFIE : TBits_1; inline;
begin
  getTXHALFIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCAN1_C1FIFOINT31.setTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TCAN1_C1FIFOINT31.clearTXNFULLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TCAN1_C1FIFOINT31.setTXNFULLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TCAN1_C1FIFOINT31.getTXNFULLIE : TBits_1; inline;
begin
  getTXNFULLIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TCAN1_C1FIFOINT31.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOINT31.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCAN1_C1FIFOCI31.setCFIFOCI(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE0 or ( thebits shl 0 );
end;
function  TCAN1_C1FIFOCI31.getCFIFOCI : TBits_5; inline;
begin
  getCFIFOCI := (pTDefRegMap(@Self)^.val and $0000001F) shr 0;
end;
procedure TCAN1_C1FIFOCI31.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCAN1_C1FIFOCI31.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG3.setUSERID(thebits : TBits_16); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0000 or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG3.getUSERID : TBits_16; inline;
begin
  getUSERID := (pTDefRegMap(@Self)^.val and $0000FFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG3.setFSRSSEL(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF8FFFF or ( thebits shl 16 );
end;
function  TDEVCFG_DEVCFG3.getFSRSSEL : TBits_3; inline;
begin
  getFSRSSEL := (pTDefRegMap(@Self)^.val and $00070000) shr 16;
end;
procedure TDEVCFG_DEVCFG3.setFCANIO; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TDEVCFG_DEVCFG3.clearFCANIO; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TDEVCFG_DEVCFG3.setFCANIO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TDEVCFG_DEVCFG3.getFCANIO : TBits_1; inline;
begin
  getFCANIO := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TDEVCFG_DEVCFG3.setFUSBIDIO; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TDEVCFG_DEVCFG3.clearFUSBIDIO; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TDEVCFG_DEVCFG3.setFUSBIDIO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TDEVCFG_DEVCFG3.getFUSBIDIO : TBits_1; inline;
begin
  getFUSBIDIO := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TDEVCFG_DEVCFG3.setFVBUSONIO; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TDEVCFG_DEVCFG3.clearFVBUSONIO; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TDEVCFG_DEVCFG3.setFVBUSONIO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TDEVCFG_DEVCFG3.getFVBUSONIO : TBits_1; inline;
begin
  getFVBUSONIO := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TDEVCFG_DEVCFG3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDEVCFG_DEVCFG3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG2.setFPLLIDIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG2.getFPLLIDIV : TBits_3; inline;
begin
  getFPLLIDIV := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TDEVCFG_DEVCFG2.setFPLLMUL(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TDEVCFG_DEVCFG2.getFPLLMUL : TBits_3; inline;
begin
  getFPLLMUL := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TDEVCFG_DEVCFG2.setUPLLIDIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF8FF or ( thebits shl 8 );
end;
function  TDEVCFG_DEVCFG2.getUPLLIDIV : TBits_3; inline;
begin
  getUPLLIDIV := (pTDefRegMap(@Self)^.val and $00000700) shr 8;
end;
procedure TDEVCFG_DEVCFG2.setUPLLEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDEVCFG_DEVCFG2.clearUPLLEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDEVCFG_DEVCFG2.setUPLLEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDEVCFG_DEVCFG2.getUPLLEN : TBits_1; inline;
begin
  getUPLLEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDEVCFG_DEVCFG2.setFPLLODIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF8FFFF or ( thebits shl 16 );
end;
function  TDEVCFG_DEVCFG2.getFPLLODIV : TBits_3; inline;
begin
  getFPLLODIV := (pTDefRegMap(@Self)^.val and $00070000) shr 16;
end;
procedure TDEVCFG_DEVCFG2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDEVCFG_DEVCFG2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG1.setFNOSC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG1.getFNOSC : TBits_3; inline;
begin
  getFNOSC := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TDEVCFG_DEVCFG1.setFSOSCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDEVCFG_DEVCFG1.clearFSOSCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDEVCFG_DEVCFG1.setFSOSCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDEVCFG_DEVCFG1.getFSOSCEN : TBits_1; inline;
begin
  getFSOSCEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDEVCFG_DEVCFG1.setIESO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDEVCFG_DEVCFG1.clearIESO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDEVCFG_DEVCFG1.setIESO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDEVCFG_DEVCFG1.getIESO : TBits_1; inline;
begin
  getIESO := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDEVCFG_DEVCFG1.setPOSCMOD(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TDEVCFG_DEVCFG1.getPOSCMOD : TBits_2; inline;
begin
  getPOSCMOD := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TDEVCFG_DEVCFG1.setOSCIOFNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TDEVCFG_DEVCFG1.clearOSCIOFNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TDEVCFG_DEVCFG1.setOSCIOFNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TDEVCFG_DEVCFG1.getOSCIOFNC : TBits_1; inline;
begin
  getOSCIOFNC := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TDEVCFG_DEVCFG1.setFPBDIV(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFCFFF or ( thebits shl 12 );
end;
function  TDEVCFG_DEVCFG1.getFPBDIV : TBits_2; inline;
begin
  getFPBDIV := (pTDefRegMap(@Self)^.val and $00003000) shr 12;
end;
procedure TDEVCFG_DEVCFG1.setFCKSM(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TDEVCFG_DEVCFG1.getFCKSM : TBits_2; inline;
begin
  getFCKSM := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TDEVCFG_DEVCFG1.setWDTPS(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TDEVCFG_DEVCFG1.getWDTPS : TBits_5; inline;
begin
  getWDTPS := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TDEVCFG_DEVCFG1.setFWDTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDEVCFG_DEVCFG1.clearFWDTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDEVCFG_DEVCFG1.setFWDTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDEVCFG_DEVCFG1.getFWDTEN : TBits_1; inline;
begin
  getFWDTEN := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDEVCFG_DEVCFG1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDEVCFG_DEVCFG1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG0.setDEBUG(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG0.getDEBUG : TBits_2; inline;
begin
  getDEBUG := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDEVCFG_DEVCFG0.setICESEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDEVCFG_DEVCFG0.clearICESEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDEVCFG_DEVCFG0.setICESEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDEVCFG_DEVCFG0.getICESEL : TBits_1; inline;
begin
  getICESEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDEVCFG_DEVCFG0.setPWP(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF00FFF or ( thebits shl 12 );
end;
function  TDEVCFG_DEVCFG0.getPWP : TBits_8; inline;
begin
  getPWP := (pTDefRegMap(@Self)^.val and $000FF000) shr 12;
end;
procedure TDEVCFG_DEVCFG0.setBWP; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TDEVCFG_DEVCFG0.clearBWP; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TDEVCFG_DEVCFG0.setBWP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TDEVCFG_DEVCFG0.getBWP : TBits_1; inline;
begin
  getBWP := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TDEVCFG_DEVCFG0.setCP; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TDEVCFG_DEVCFG0.clearCP; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TDEVCFG_DEVCFG0.setCP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TDEVCFG_DEVCFG0.getCP : TBits_1; inline;
begin
  getCP := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TDEVCFG_DEVCFG0.setFDEBUG(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG0.getFDEBUG : TBits_2; inline;
begin
  getFDEBUG := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDEVCFG_DEVCFG0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDEVCFG_DEVCFG0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
  procedure _CORE_TIMER_VECTOR_interrupt; external name '_CORE_TIMER_VECTOR_interrupt';
  procedure _CORE_SOFTWARE_0_VECTOR_interrupt; external name '_CORE_SOFTWARE_0_VECTOR_interrupt';
  procedure _CORE_SOFTWARE_1_VECTOR_interrupt; external name '_CORE_SOFTWARE_1_VECTOR_interrupt';
  procedure _EXTERNAL_0_VECTOR_interrupt; external name '_EXTERNAL_0_VECTOR_interrupt';
  procedure _TIMER_1_VECTOR_interrupt; external name '_TIMER_1_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_1_VECTOR_interrupt; external name '_INPUT_CAPTURE_1_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_1_VECTOR_interrupt; external name '_OUTPUT_COMPARE_1_VECTOR_interrupt';
  procedure _EXTERNAL_1_VECTOR_interrupt; external name '_EXTERNAL_1_VECTOR_interrupt';
  procedure _TIMER_2_VECTOR_interrupt; external name '_TIMER_2_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_2_VECTOR_interrupt; external name '_INPUT_CAPTURE_2_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_2_VECTOR_interrupt; external name '_OUTPUT_COMPARE_2_VECTOR_interrupt';
  procedure _EXTERNAL_2_VECTOR_interrupt; external name '_EXTERNAL_2_VECTOR_interrupt';
  procedure _TIMER_3_VECTOR_interrupt; external name '_TIMER_3_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_3_VECTOR_interrupt; external name '_INPUT_CAPTURE_3_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_3_VECTOR_interrupt; external name '_OUTPUT_COMPARE_3_VECTOR_interrupt';
  procedure _EXTERNAL_3_VECTOR_interrupt; external name '_EXTERNAL_3_VECTOR_interrupt';
  procedure _TIMER_4_VECTOR_interrupt; external name '_TIMER_4_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_4_VECTOR_interrupt; external name '_INPUT_CAPTURE_4_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_4_VECTOR_interrupt; external name '_OUTPUT_COMPARE_4_VECTOR_interrupt';
  procedure _EXTERNAL_4_VECTOR_interrupt; external name '_EXTERNAL_4_VECTOR_interrupt';
  procedure _TIMER_5_VECTOR_interrupt; external name '_TIMER_5_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_5_VECTOR_interrupt; external name '_INPUT_CAPTURE_5_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_5_VECTOR_interrupt; external name '_OUTPUT_COMPARE_5_VECTOR_interrupt';
  procedure _SPI_1A_VECTOR_interrupt; external name '_SPI_1A_VECTOR_interrupt';
  procedure _UART_1_VECTOR_interrupt; external name '_UART_1_VECTOR_interrupt';
  procedure _UART_1A_VECTOR_interrupt; external name '_UART_1A_VECTOR_interrupt';
  procedure _I2C_3_VECTOR_interrupt; external name '_I2C_3_VECTOR_interrupt';
  procedure _I2C_1A_VECTOR_interrupt; external name '_I2C_1A_VECTOR_interrupt';
  procedure _SPI_3_VECTOR_interrupt; external name '_SPI_3_VECTOR_interrupt';
  procedure _I2C_1_VECTOR_interrupt; external name '_I2C_1_VECTOR_interrupt';
  procedure _CHANGE_NOTICE_VECTOR_interrupt; external name '_CHANGE_NOTICE_VECTOR_interrupt';
  procedure _ADC_VECTOR_interrupt; external name '_ADC_VECTOR_interrupt';
  procedure _PMP_VECTOR_interrupt; external name '_PMP_VECTOR_interrupt';
  procedure _COMPARATOR_1_VECTOR_interrupt; external name '_COMPARATOR_1_VECTOR_interrupt';
  procedure _COMPARATOR_2_VECTOR_interrupt; external name '_COMPARATOR_2_VECTOR_interrupt';
  procedure _SPI_2A_VECTOR_interrupt; external name '_SPI_2A_VECTOR_interrupt';
  procedure _UART_3_VECTOR_interrupt; external name '_UART_3_VECTOR_interrupt';
  procedure _UART_2A_VECTOR_interrupt; external name '_UART_2A_VECTOR_interrupt';
  procedure _I2C_4_VECTOR_interrupt; external name '_I2C_4_VECTOR_interrupt';
  procedure _I2C_2A_VECTOR_interrupt; external name '_I2C_2A_VECTOR_interrupt';
  procedure _SPI_2_VECTOR_interrupt; external name '_SPI_2_VECTOR_interrupt';
  procedure _SPI_3A_VECTOR_interrupt; external name '_SPI_3A_VECTOR_interrupt';
  procedure _UART_2_VECTOR_interrupt; external name '_UART_2_VECTOR_interrupt';
  procedure _UART_3A_VECTOR_interrupt; external name '_UART_3A_VECTOR_interrupt';
  procedure _I2C_5_VECTOR_interrupt; external name '_I2C_5_VECTOR_interrupt';
  procedure _I2C_3A_VECTOR_interrupt; external name '_I2C_3A_VECTOR_interrupt';
  procedure _SPI_4_VECTOR_interrupt; external name '_SPI_4_VECTOR_interrupt';
  procedure _I2C_2_VECTOR_interrupt; external name '_I2C_2_VECTOR_interrupt';
  procedure _FAIL_SAFE_MONITOR_VECTOR_interrupt; external name '_FAIL_SAFE_MONITOR_VECTOR_interrupt';
  procedure _RTCC_VECTOR_interrupt; external name '_RTCC_VECTOR_interrupt';
  procedure _DMA_0_VECTOR_interrupt; external name '_DMA_0_VECTOR_interrupt';
  procedure _DMA_1_VECTOR_interrupt; external name '_DMA_1_VECTOR_interrupt';
  procedure _DMA_2_VECTOR_interrupt; external name '_DMA_2_VECTOR_interrupt';
  procedure _DMA_3_VECTOR_interrupt; external name '_DMA_3_VECTOR_interrupt';
  procedure _FCE_VECTOR_interrupt; external name '_FCE_VECTOR_interrupt';
  procedure _USB_1_VECTOR_interrupt; external name '_USB_1_VECTOR_interrupt';
  procedure _CAN_1_VECTOR_interrupt; external name '_CAN_1_VECTOR_interrupt';
  procedure _CAN_2_VECTOR_interrupt; external name '_CAN_2_VECTOR_interrupt';
  procedure _UART_1B_VECTOR_interrupt; external name '_UART_1B_VECTOR_interrupt';
  procedure _UART_2B_VECTOR_interrupt; external name '_UART_2B_VECTOR_interrupt';
  procedure _UART_6_VECTOR_interrupt; external name '_UART_6_VECTOR_interrupt';
  procedure _UART_3B_VECTOR_interrupt; external name '_UART_3B_VECTOR_interrupt';
  procedure _UART_5_VECTOR_interrupt; external name '_UART_5_VECTOR_interrupt';

  procedure Vectors; assembler; nostackframe;
  label interrupt_vectors;
  asm
    .section ".init.interrupt_vectors,\"ax\",@progbits"
  interrupt_vectors:

    j _CORE_TIMER_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _CORE_SOFTWARE_0_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _CORE_SOFTWARE_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_0_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_4_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_4_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_4_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_4_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_5_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_5_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_5_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _SPI_1A_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _I2C_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _CHANGE_NOTICE_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _ADC_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _PMP_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _COMPARATOR_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _COMPARATOR_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _SPI_2A_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _SPI_3A_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _I2C_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _FAIL_SAFE_MONITOR_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _RTCC_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _DMA_0_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _DMA_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _DMA_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _DMA_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _FCE_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _USB_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _CAN_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _CAN_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _UART_1B_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _UART_2B_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _UART_3B_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    .weak _CORE_TIMER_VECTOR_interrupt
    .weak _CORE_SOFTWARE_0_VECTOR_interrupt
    .weak _CORE_SOFTWARE_1_VECTOR_interrupt
    .weak _EXTERNAL_0_VECTOR_interrupt
    .weak _TIMER_1_VECTOR_interrupt
    .weak _INPUT_CAPTURE_1_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_1_VECTOR_interrupt
    .weak _EXTERNAL_1_VECTOR_interrupt
    .weak _TIMER_2_VECTOR_interrupt
    .weak _INPUT_CAPTURE_2_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_2_VECTOR_interrupt
    .weak _EXTERNAL_2_VECTOR_interrupt
    .weak _TIMER_3_VECTOR_interrupt
    .weak _INPUT_CAPTURE_3_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_3_VECTOR_interrupt
    .weak _EXTERNAL_3_VECTOR_interrupt
    .weak _TIMER_4_VECTOR_interrupt
    .weak _INPUT_CAPTURE_4_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_4_VECTOR_interrupt
    .weak _EXTERNAL_4_VECTOR_interrupt
    .weak _TIMER_5_VECTOR_interrupt
    .weak _INPUT_CAPTURE_5_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_5_VECTOR_interrupt
    .weak _SPI_1A_VECTOR_interrupt
    .weak _UART_1_VECTOR_interrupt
    .weak _UART_1A_VECTOR_interrupt
    .weak _I2C_3_VECTOR_interrupt
    .weak _I2C_1A_VECTOR_interrupt
    .weak _SPI_3_VECTOR_interrupt
    .weak _I2C_1_VECTOR_interrupt
    .weak _CHANGE_NOTICE_VECTOR_interrupt
    .weak _ADC_VECTOR_interrupt
    .weak _PMP_VECTOR_interrupt
    .weak _COMPARATOR_1_VECTOR_interrupt
    .weak _COMPARATOR_2_VECTOR_interrupt
    .weak _SPI_2A_VECTOR_interrupt
    .weak _UART_3_VECTOR_interrupt
    .weak _UART_2A_VECTOR_interrupt
    .weak _I2C_4_VECTOR_interrupt
    .weak _I2C_2A_VECTOR_interrupt
    .weak _SPI_2_VECTOR_interrupt
    .weak _SPI_3A_VECTOR_interrupt
    .weak _UART_2_VECTOR_interrupt
    .weak _UART_3A_VECTOR_interrupt
    .weak _I2C_5_VECTOR_interrupt
    .weak _I2C_3A_VECTOR_interrupt
    .weak _SPI_4_VECTOR_interrupt
    .weak _I2C_2_VECTOR_interrupt
    .weak _FAIL_SAFE_MONITOR_VECTOR_interrupt
    .weak _RTCC_VECTOR_interrupt
    .weak _DMA_0_VECTOR_interrupt
    .weak _DMA_1_VECTOR_interrupt
    .weak _DMA_2_VECTOR_interrupt
    .weak _DMA_3_VECTOR_interrupt
    .weak _FCE_VECTOR_interrupt
    .weak _USB_1_VECTOR_interrupt
    .weak _CAN_1_VECTOR_interrupt
    .weak _CAN_2_VECTOR_interrupt
    .weak _UART_1B_VECTOR_interrupt
    .weak _UART_2B_VECTOR_interrupt
    .weak _UART_6_VECTOR_interrupt
    .weak _UART_3B_VECTOR_interrupt
    .weak _UART_5_VECTOR_interrupt

    .text
  end;
end.
