unit pic32mx250f128c;
interface
{$goto on}
{$modeswitch advancedrecords}
{$INLINE ON}
{$OPTIMIZATION STACKFRAME}
{$L startup.o}
{$PACKRECORDS 2}
type
  TBits_1 = 0..1;
  TBits_2 = 0..3;
  TBits_3 = 0..7;
  TBits_4 = 0..15;
  TBits_5 = 0..31;
  TBits_6 = 0..63;
  TBits_7 = 0..127;
  TBits_8 = 0..255;
  TBits_9 = 0..511;
  TBits_10 = 0..1023;
  TBits_11 = 0..2047;
  TBits_12 = 0..4095;
  TBits_13 = 0..8191;
  TBits_14 = 0..16383;
  TBits_15 = 0..32767;
  TBits_16 = 0..65535;
  TBits_17 = 0..131071;
  TBits_18 = 0..262143;
  TBits_19 = 0..524287;
  TBits_20 = 0..1048575;
  TBits_21 = 0..2097151;
  TBits_22 = 0..4194303;
  TBits_23 = 0..8388607;
  TBits_24 = 0..16777215;
  TBits_25 = 0..33554431;
  TBits_26 = 0..67108863;
  TBits_27 = 0..134217727;
  TBits_28 = 0..268435455;
  TBits_29 = 0..536870911;
  TBits_30 = 0..1073741823;
  TBits_31 = 0..2147483647;
  TBits_32 = 0..4294967295;
  TWDT_WDTCON = record
  private
    function  getON : TBits_1; inline;
    function  getSWDTPS : TBits_5; inline;
    function  getSWDTPS0 : TBits_1; inline;
    function  getSWDTPS1 : TBits_1; inline;
    function  getSWDTPS2 : TBits_1; inline;
    function  getSWDTPS3 : TBits_1; inline;
    function  getSWDTPS4 : TBits_1; inline;
    function  getWDTCLR : TBits_1; inline;
    function  getWDTPS : TBits_5; inline;
    function  getWDTPSTA : TBits_5; inline;
    function  getWDTWINEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSWDTPS(thebits : TBits_5); inline;
    procedure setSWDTPS0(thebits : TBits_1); inline;
    procedure setSWDTPS1(thebits : TBits_1); inline;
    procedure setSWDTPS2(thebits : TBits_1); inline;
    procedure setSWDTPS3(thebits : TBits_1); inline;
    procedure setSWDTPS4(thebits : TBits_1); inline;
    procedure setWDTCLR(thebits : TBits_1); inline;
    procedure setWDTPS(thebits : TBits_5); inline;
    procedure setWDTPSTA(thebits : TBits_5); inline;
    procedure setWDTWINEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSWDTPS0; inline;
    procedure clearSWDTPS1; inline;
    procedure clearSWDTPS2; inline;
    procedure clearSWDTPS3; inline;
    procedure clearSWDTPS4; inline;
    procedure clearWDTCLR; inline;
    procedure clearWDTWINEN; inline;
    procedure setON; inline;
    procedure setSWDTPS0; inline;
    procedure setSWDTPS1; inline;
    procedure setSWDTPS2; inline;
    procedure setSWDTPS3; inline;
    procedure setSWDTPS4; inline;
    procedure setWDTCLR; inline;
    procedure setWDTWINEN; inline;
    property ON : TBits_1 read getON write setON;
    property SWDTPS : TBits_5 read getSWDTPS write setSWDTPS;
    property SWDTPS0 : TBits_1 read getSWDTPS0 write setSWDTPS0;
    property SWDTPS1 : TBits_1 read getSWDTPS1 write setSWDTPS1;
    property SWDTPS2 : TBits_1 read getSWDTPS2 write setSWDTPS2;
    property SWDTPS3 : TBits_1 read getSWDTPS3 write setSWDTPS3;
    property SWDTPS4 : TBits_1 read getSWDTPS4 write setSWDTPS4;
    property WDTCLR : TBits_1 read getWDTCLR write setWDTCLR;
    property WDTPS : TBits_5 read getWDTPS write setWDTPS;
    property WDTPSTA : TBits_5 read getWDTPSTA write setWDTPSTA;
    property WDTWINEN : TBits_1 read getWDTWINEN write setWDTWINEN;
    property w : TBits_32 read getw write setw;
  end;
type
  TWDTRegisters = record
    WDTCONbits : TWDT_WDTCON;
    WDTCON : longWord;
    WDTCONCLR : longWord;
    WDTCONSET : longWord;
    WDTCONINV : longWord;
  end;
  TRTCC_RTCCON = record
  private
    function  getCAL : TBits_10; inline;
    function  getHALFSEC : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getRTCCLKON : TBits_1; inline;
    function  getRTCOE : TBits_1; inline;
    function  getRTCSYNC : TBits_1; inline;
    function  getRTCWREN : TBits_1; inline;
    function  getRTSECSEL : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCAL(thebits : TBits_10); inline;
    procedure setHALFSEC(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setRTCCLKON(thebits : TBits_1); inline;
    procedure setRTCOE(thebits : TBits_1); inline;
    procedure setRTCSYNC(thebits : TBits_1); inline;
    procedure setRTCWREN(thebits : TBits_1); inline;
    procedure setRTSECSEL(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearHALFSEC; inline;
    procedure clearON; inline;
    procedure clearRTCCLKON; inline;
    procedure clearRTCOE; inline;
    procedure clearRTCSYNC; inline;
    procedure clearRTCWREN; inline;
    procedure clearRTSECSEL; inline;
    procedure clearSIDL; inline;
    procedure setHALFSEC; inline;
    procedure setON; inline;
    procedure setRTCCLKON; inline;
    procedure setRTCOE; inline;
    procedure setRTCSYNC; inline;
    procedure setRTCWREN; inline;
    procedure setRTSECSEL; inline;
    procedure setSIDL; inline;
    property CAL : TBits_10 read getCAL write setCAL;
    property HALFSEC : TBits_1 read getHALFSEC write setHALFSEC;
    property ON : TBits_1 read getON write setON;
    property RTCCLKON : TBits_1 read getRTCCLKON write setRTCCLKON;
    property RTCOE : TBits_1 read getRTCOE write setRTCOE;
    property RTCSYNC : TBits_1 read getRTCSYNC write setRTCSYNC;
    property RTCWREN : TBits_1 read getRTCWREN write setRTCWREN;
    property RTSECSEL : TBits_1 read getRTSECSEL write setRTSECSEL;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_RTCALRM = record
  private
    function  getALRMEN : TBits_1; inline;
    function  getALRMSYNC : TBits_1; inline;
    function  getAMASK : TBits_4; inline;
    function  getARPT : TBits_8; inline;
    function  getCHIME : TBits_1; inline;
    function  getPIV : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setALRMEN(thebits : TBits_1); inline;
    procedure setALRMSYNC(thebits : TBits_1); inline;
    procedure setAMASK(thebits : TBits_4); inline;
    procedure setARPT(thebits : TBits_8); inline;
    procedure setCHIME(thebits : TBits_1); inline;
    procedure setPIV(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearALRMEN; inline;
    procedure clearALRMSYNC; inline;
    procedure clearCHIME; inline;
    procedure clearPIV; inline;
    procedure setALRMEN; inline;
    procedure setALRMSYNC; inline;
    procedure setCHIME; inline;
    procedure setPIV; inline;
    property ALRMEN : TBits_1 read getALRMEN write setALRMEN;
    property ALRMSYNC : TBits_1 read getALRMSYNC write setALRMSYNC;
    property AMASK : TBits_4 read getAMASK write setAMASK;
    property ARPT : TBits_8 read getARPT write setARPT;
    property CHIME : TBits_1 read getCHIME write setCHIME;
    property PIV : TBits_1 read getPIV write setPIV;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_RTCTIME = record
  private
    function  getHR01 : TBits_4; inline;
    function  getHR10 : TBits_4; inline;
    function  getMIN01 : TBits_4; inline;
    function  getMIN10 : TBits_4; inline;
    function  getSEC01 : TBits_4; inline;
    function  getSEC10 : TBits_4; inline;
    function  getw : TBits_32; inline;
    procedure setHR01(thebits : TBits_4); inline;
    procedure setHR10(thebits : TBits_4); inline;
    procedure setMIN01(thebits : TBits_4); inline;
    procedure setMIN10(thebits : TBits_4); inline;
    procedure setSEC01(thebits : TBits_4); inline;
    procedure setSEC10(thebits : TBits_4); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property HR01 : TBits_4 read getHR01 write setHR01;
    property HR10 : TBits_4 read getHR10 write setHR10;
    property MIN01 : TBits_4 read getMIN01 write setMIN01;
    property MIN10 : TBits_4 read getMIN10 write setMIN10;
    property SEC01 : TBits_4 read getSEC01 write setSEC01;
    property SEC10 : TBits_4 read getSEC10 write setSEC10;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_RTCDATE = record
  private
    function  getDAY01 : TBits_4; inline;
    function  getDAY10 : TBits_4; inline;
    function  getMONTH01 : TBits_4; inline;
    function  getMONTH10 : TBits_4; inline;
    function  getWDAY01 : TBits_4; inline;
    function  getYEAR01 : TBits_4; inline;
    function  getYEAR10 : TBits_4; inline;
    function  getw : TBits_32; inline;
    procedure setDAY01(thebits : TBits_4); inline;
    procedure setDAY10(thebits : TBits_4); inline;
    procedure setMONTH01(thebits : TBits_4); inline;
    procedure setMONTH10(thebits : TBits_4); inline;
    procedure setWDAY01(thebits : TBits_4); inline;
    procedure setYEAR01(thebits : TBits_4); inline;
    procedure setYEAR10(thebits : TBits_4); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DAY01 : TBits_4 read getDAY01 write setDAY01;
    property DAY10 : TBits_4 read getDAY10 write setDAY10;
    property MONTH01 : TBits_4 read getMONTH01 write setMONTH01;
    property MONTH10 : TBits_4 read getMONTH10 write setMONTH10;
    property WDAY01 : TBits_4 read getWDAY01 write setWDAY01;
    property YEAR01 : TBits_4 read getYEAR01 write setYEAR01;
    property YEAR10 : TBits_4 read getYEAR10 write setYEAR10;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_ALRMTIME = record
  private
    function  getHR01 : TBits_4; inline;
    function  getHR10 : TBits_4; inline;
    function  getMIN01 : TBits_4; inline;
    function  getMIN10 : TBits_4; inline;
    function  getSEC01 : TBits_4; inline;
    function  getSEC10 : TBits_4; inline;
    function  getw : TBits_32; inline;
    procedure setHR01(thebits : TBits_4); inline;
    procedure setHR10(thebits : TBits_4); inline;
    procedure setMIN01(thebits : TBits_4); inline;
    procedure setMIN10(thebits : TBits_4); inline;
    procedure setSEC01(thebits : TBits_4); inline;
    procedure setSEC10(thebits : TBits_4); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property HR01 : TBits_4 read getHR01 write setHR01;
    property HR10 : TBits_4 read getHR10 write setHR10;
    property MIN01 : TBits_4 read getMIN01 write setMIN01;
    property MIN10 : TBits_4 read getMIN10 write setMIN10;
    property SEC01 : TBits_4 read getSEC01 write setSEC01;
    property SEC10 : TBits_4 read getSEC10 write setSEC10;
    property w : TBits_32 read getw write setw;
  end;
  TRTCC_ALRMDATE = record
  private
    function  getDAY01 : TBits_4; inline;
    function  getDAY10 : TBits_4; inline;
    function  getMONTH01 : TBits_4; inline;
    function  getMONTH10 : TBits_4; inline;
    function  getWDAY01 : TBits_4; inline;
    function  getw : TBits_32; inline;
    procedure setDAY01(thebits : TBits_4); inline;
    procedure setDAY10(thebits : TBits_4); inline;
    procedure setMONTH01(thebits : TBits_4); inline;
    procedure setMONTH10(thebits : TBits_4); inline;
    procedure setWDAY01(thebits : TBits_4); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DAY01 : TBits_4 read getDAY01 write setDAY01;
    property DAY10 : TBits_4 read getDAY10 write setDAY10;
    property MONTH01 : TBits_4 read getMONTH01 write setMONTH01;
    property MONTH10 : TBits_4 read getMONTH10 write setMONTH10;
    property WDAY01 : TBits_4 read getWDAY01 write setWDAY01;
    property w : TBits_32 read getw write setw;
  end;
type
  TRTCCRegisters = record
    RTCCONbits : TRTCC_RTCCON;
    RTCCON : longWord;
    RTCCONCLR : longWord;
    RTCCONSET : longWord;
    RTCCONINV : longWord;
    RTCALRMbits : TRTCC_RTCALRM;
    RTCALRM : longWord;
    RTCALRMCLR : longWord;
    RTCALRMSET : longWord;
    RTCALRMINV : longWord;
    RTCTIMEbits : TRTCC_RTCTIME;
    RTCTIME : longWord;
    RTCTIMECLR : longWord;
    RTCTIMESET : longWord;
    RTCTIMEINV : longWord;
    RTCDATEbits : TRTCC_RTCDATE;
    RTCDATE : longWord;
    RTCDATECLR : longWord;
    RTCDATESET : longWord;
    RTCDATEINV : longWord;
    ALRMTIMEbits : TRTCC_ALRMTIME;
    ALRMTIME : longWord;
    ALRMTIMECLR : longWord;
    ALRMTIMESET : longWord;
    ALRMTIMEINV : longWord;
    ALRMDATEbits : TRTCC_ALRMDATE;
    ALRMDATE : longWord;
    ALRMDATECLR : longWord;
    ALRMDATESET : longWord;
    ALRMDATEINV : longWord;
  end;
  TTMR1_T1CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getTCKPS : TBits_2; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCS : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getTSYNC : TBits_1; inline;
    function  getTWDIS : TBits_1; inline;
    function  getTWIP : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_2); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCS(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setTSYNC(thebits : TBits_1); inline;
    procedure setTWDIS(thebits : TBits_1); inline;
    procedure setTWIP(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCS; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure clearTSYNC; inline;
    procedure clearTWDIS; inline;
    procedure clearTWIP; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCS; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    procedure setTSYNC; inline;
    procedure setTWDIS; inline;
    procedure setTWIP; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property TCKPS : TBits_2 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCS : TBits_1 read getTCS write setTCS;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property TSYNC : TBits_1 read getTSYNC write setTSYNC;
    property TWDIS : TBits_1 read getTWDIS write setTWDIS;
    property TWIP : TBits_1 read getTWIP write setTWIP;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR1Registers = record
    T1CONbits : TTMR1_T1CON;
    T1CON : longWord;
    T1CONCLR : longWord;
    T1CONSET : longWord;
    T1CONINV : longWord;
    TMR1 : longWord;
    TMR1CLR : longWord;
    TMR1SET : longWord;
    TMR1INV : longWord;
    PR1 : longWord;
    PR1CLR : longWord;
    PR1SET : longWord;
    PR1INV : longWord;
  end;
  TTMR2_T2CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getT32 : TBits_1; inline;
    function  getTCKPS : TBits_3; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCKPS2 : TBits_1; inline;
    function  getTCS : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setT32(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_3); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCKPS2(thebits : TBits_1); inline;
    procedure setTCS(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearT32; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCKPS2; inline;
    procedure clearTCS; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setT32; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCKPS2; inline;
    procedure setTCS; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property T32 : TBits_1 read getT32 write setT32;
    property TCKPS : TBits_3 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCKPS2 : TBits_1 read getTCKPS2 write setTCKPS2;
    property TCS : TBits_1 read getTCS write setTCS;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR2Registers = record
    T2CONbits : TTMR2_T2CON;
    T2CON : longWord;
    T2CONCLR : longWord;
    T2CONSET : longWord;
    T2CONINV : longWord;
    TMR2 : longWord;
    TMR2CLR : longWord;
    TMR2SET : longWord;
    TMR2INV : longWord;
    PR2 : longWord;
    PR2CLR : longWord;
    PR2SET : longWord;
    PR2INV : longWord;
  end;
  TTMR3_T3CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getTCKPS : TBits_3; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCKPS2 : TBits_1; inline;
    function  getTCS : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_3); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCKPS2(thebits : TBits_1); inline;
    procedure setTCS(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCKPS2; inline;
    procedure clearTCS; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCKPS2; inline;
    procedure setTCS; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property TCKPS : TBits_3 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCKPS2 : TBits_1 read getTCKPS2 write setTCKPS2;
    property TCS : TBits_1 read getTCS write setTCS;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR3Registers = record
    T3CONbits : TTMR3_T3CON;
    T3CON : longWord;
    T3CONCLR : longWord;
    T3CONSET : longWord;
    T3CONINV : longWord;
    TMR3 : longWord;
    TMR3CLR : longWord;
    TMR3SET : longWord;
    TMR3INV : longWord;
    PR3 : longWord;
    PR3CLR : longWord;
    PR3SET : longWord;
    PR3INV : longWord;
  end;
  TTMR4_T4CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getT32 : TBits_1; inline;
    function  getTCKPS : TBits_3; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCKPS2 : TBits_1; inline;
    function  getTCS : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setT32(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_3); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCKPS2(thebits : TBits_1); inline;
    procedure setTCS(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearT32; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCKPS2; inline;
    procedure clearTCS; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setT32; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCKPS2; inline;
    procedure setTCS; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property T32 : TBits_1 read getT32 write setT32;
    property TCKPS : TBits_3 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCKPS2 : TBits_1 read getTCKPS2 write setTCKPS2;
    property TCS : TBits_1 read getTCS write setTCS;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR4Registers = record
    T4CONbits : TTMR4_T4CON;
    T4CON : longWord;
    T4CONCLR : longWord;
    T4CONSET : longWord;
    T4CONINV : longWord;
    TMR4 : longWord;
    TMR4CLR : longWord;
    TMR4SET : longWord;
    TMR4INV : longWord;
    PR4 : longWord;
    PR4CLR : longWord;
    PR4SET : longWord;
    PR4INV : longWord;
  end;
  TTMR5_T5CON = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getTCKPS : TBits_3; inline;
    function  getTCKPS0 : TBits_1; inline;
    function  getTCKPS1 : TBits_1; inline;
    function  getTCKPS2 : TBits_1; inline;
    function  getTCS : TBits_1; inline;
    function  getTGATE : TBits_1; inline;
    function  getTON : TBits_1; inline;
    function  getTSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setTCKPS(thebits : TBits_3); inline;
    procedure setTCKPS0(thebits : TBits_1); inline;
    procedure setTCKPS1(thebits : TBits_1); inline;
    procedure setTCKPS2(thebits : TBits_1); inline;
    procedure setTCS(thebits : TBits_1); inline;
    procedure setTGATE(thebits : TBits_1); inline;
    procedure setTON(thebits : TBits_1); inline;
    procedure setTSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearTCKPS0; inline;
    procedure clearTCKPS1; inline;
    procedure clearTCKPS2; inline;
    procedure clearTCS; inline;
    procedure clearTGATE; inline;
    procedure clearTON; inline;
    procedure clearTSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setTCKPS0; inline;
    procedure setTCKPS1; inline;
    procedure setTCKPS2; inline;
    procedure setTCS; inline;
    procedure setTGATE; inline;
    procedure setTON; inline;
    procedure setTSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property TCKPS : TBits_3 read getTCKPS write setTCKPS;
    property TCKPS0 : TBits_1 read getTCKPS0 write setTCKPS0;
    property TCKPS1 : TBits_1 read getTCKPS1 write setTCKPS1;
    property TCKPS2 : TBits_1 read getTCKPS2 write setTCKPS2;
    property TCS : TBits_1 read getTCS write setTCS;
    property TGATE : TBits_1 read getTGATE write setTGATE;
    property TON : TBits_1 read getTON write setTON;
    property TSIDL : TBits_1 read getTSIDL write setTSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TTMR5Registers = record
    T5CONbits : TTMR5_T5CON;
    T5CON : longWord;
    T5CONCLR : longWord;
    T5CONSET : longWord;
    T5CONINV : longWord;
    TMR5 : longWord;
    TMR5CLR : longWord;
    TMR5SET : longWord;
    TMR5INV : longWord;
    PR5 : longWord;
    PR5CLR : longWord;
    PR5SET : longWord;
    PR5INV : longWord;
  end;
  TICAP1_IC1CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP1Registers = record
    IC1CONbits : TICAP1_IC1CON;
    IC1CON : longWord;
    IC1CONCLR : longWord;
    IC1CONSET : longWord;
    IC1CONINV : longWord;
    IC1BUF : longWord;
  end;
  TICAP2_IC2CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP2Registers = record
    IC2CONbits : TICAP2_IC2CON;
    IC2CON : longWord;
    IC2CONCLR : longWord;
    IC2CONSET : longWord;
    IC2CONINV : longWord;
    IC2BUF : longWord;
  end;
  TICAP3_IC3CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP3Registers = record
    IC3CONbits : TICAP3_IC3CON;
    IC3CON : longWord;
    IC3CONCLR : longWord;
    IC3CONSET : longWord;
    IC3CONINV : longWord;
    IC3BUF : longWord;
  end;
  TICAP4_IC4CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP4Registers = record
    IC4CONbits : TICAP4_IC4CON;
    IC4CON : longWord;
    IC4CONCLR : longWord;
    IC4CONSET : longWord;
    IC4CONINV : longWord;
    IC4BUF : longWord;
  end;
  TICAP5_IC5CON = record
  private
    function  getC32 : TBits_1; inline;
    function  getFEDGE : TBits_1; inline;
    function  getICBNE : TBits_1; inline;
    function  getICI : TBits_2; inline;
    function  getICI0 : TBits_1; inline;
    function  getICI1 : TBits_1; inline;
    function  getICM : TBits_3; inline;
    function  getICM0 : TBits_1; inline;
    function  getICM1 : TBits_1; inline;
    function  getICM2 : TBits_1; inline;
    function  getICOV : TBits_1; inline;
    function  getICSIDL : TBits_1; inline;
    function  getICTMR : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC32(thebits : TBits_1); inline;
    procedure setFEDGE(thebits : TBits_1); inline;
    procedure setICBNE(thebits : TBits_1); inline;
    procedure setICI(thebits : TBits_2); inline;
    procedure setICI0(thebits : TBits_1); inline;
    procedure setICI1(thebits : TBits_1); inline;
    procedure setICM(thebits : TBits_3); inline;
    procedure setICM0(thebits : TBits_1); inline;
    procedure setICM1(thebits : TBits_1); inline;
    procedure setICM2(thebits : TBits_1); inline;
    procedure setICOV(thebits : TBits_1); inline;
    procedure setICSIDL(thebits : TBits_1); inline;
    procedure setICTMR(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC32; inline;
    procedure clearFEDGE; inline;
    procedure clearICBNE; inline;
    procedure clearICI0; inline;
    procedure clearICI1; inline;
    procedure clearICM0; inline;
    procedure clearICM1; inline;
    procedure clearICM2; inline;
    procedure clearICOV; inline;
    procedure clearICSIDL; inline;
    procedure clearICTMR; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setC32; inline;
    procedure setFEDGE; inline;
    procedure setICBNE; inline;
    procedure setICI0; inline;
    procedure setICI1; inline;
    procedure setICM0; inline;
    procedure setICM1; inline;
    procedure setICM2; inline;
    procedure setICOV; inline;
    procedure setICSIDL; inline;
    procedure setICTMR; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property C32 : TBits_1 read getC32 write setC32;
    property FEDGE : TBits_1 read getFEDGE write setFEDGE;
    property ICBNE : TBits_1 read getICBNE write setICBNE;
    property ICI : TBits_2 read getICI write setICI;
    property ICI0 : TBits_1 read getICI0 write setICI0;
    property ICI1 : TBits_1 read getICI1 write setICI1;
    property ICM : TBits_3 read getICM write setICM;
    property ICM0 : TBits_1 read getICM0 write setICM0;
    property ICM1 : TBits_1 read getICM1 write setICM1;
    property ICM2 : TBits_1 read getICM2 write setICM2;
    property ICOV : TBits_1 read getICOV write setICOV;
    property ICSIDL : TBits_1 read getICSIDL write setICSIDL;
    property ICTMR : TBits_1 read getICTMR write setICTMR;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TICAP5Registers = record
    IC5CONbits : TICAP5_IC5CON;
    IC5CON : longWord;
    IC5CONCLR : longWord;
    IC5CONSET : longWord;
    IC5CONINV : longWord;
    IC5BUF : longWord;
  end;
  TOCMP1_OC1CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP1Registers = record
    OC1CONbits : TOCMP1_OC1CON;
    OC1CON : longWord;
    OC1CONCLR : longWord;
    OC1CONSET : longWord;
    OC1CONINV : longWord;
    OC1R : longWord;
    OC1RCLR : longWord;
    OC1RSET : longWord;
    OC1RINV : longWord;
    OC1RS : longWord;
    OC1RSCLR : longWord;
    OC1RSSET : longWord;
    OC1RSINV : longWord;
  end;
  TOCMP2_OC2CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP2Registers = record
    OC2CONbits : TOCMP2_OC2CON;
    OC2CON : longWord;
    OC2CONCLR : longWord;
    OC2CONSET : longWord;
    OC2CONINV : longWord;
    OC2R : longWord;
    OC2RCLR : longWord;
    OC2RSET : longWord;
    OC2RINV : longWord;
    OC2RS : longWord;
    OC2RSCLR : longWord;
    OC2RSSET : longWord;
    OC2RSINV : longWord;
  end;
  TOCMP3_OC3CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP3Registers = record
    OC3CONbits : TOCMP3_OC3CON;
    OC3CON : longWord;
    OC3CONCLR : longWord;
    OC3CONSET : longWord;
    OC3CONINV : longWord;
    OC3R : longWord;
    OC3RCLR : longWord;
    OC3RSET : longWord;
    OC3RINV : longWord;
    OC3RS : longWord;
    OC3RSCLR : longWord;
    OC3RSSET : longWord;
    OC3RSINV : longWord;
  end;
  TOCMP4_OC4CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP4Registers = record
    OC4CONbits : TOCMP4_OC4CON;
    OC4CON : longWord;
    OC4CONCLR : longWord;
    OC4CONSET : longWord;
    OC4CONINV : longWord;
    OC4R : longWord;
    OC4RCLR : longWord;
    OC4RSET : longWord;
    OC4RINV : longWord;
    OC4RS : longWord;
    OC4RSCLR : longWord;
    OC4RSSET : longWord;
    OC4RSINV : longWord;
  end;
  TOCMP5_OC5CON = record
  private
    function  getOC32 : TBits_1; inline;
    function  getOCFLT : TBits_1; inline;
    function  getOCM : TBits_3; inline;
    function  getOCM0 : TBits_1; inline;
    function  getOCM1 : TBits_1; inline;
    function  getOCM2 : TBits_1; inline;
    function  getOCSIDL : TBits_1; inline;
    function  getOCTSEL : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setOC32(thebits : TBits_1); inline;
    procedure setOCFLT(thebits : TBits_1); inline;
    procedure setOCM(thebits : TBits_3); inline;
    procedure setOCM0(thebits : TBits_1); inline;
    procedure setOCM1(thebits : TBits_1); inline;
    procedure setOCM2(thebits : TBits_1); inline;
    procedure setOCSIDL(thebits : TBits_1); inline;
    procedure setOCTSEL(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearOC32; inline;
    procedure clearOCFLT; inline;
    procedure clearOCM0; inline;
    procedure clearOCM1; inline;
    procedure clearOCM2; inline;
    procedure clearOCSIDL; inline;
    procedure clearOCTSEL; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setOC32; inline;
    procedure setOCFLT; inline;
    procedure setOCM0; inline;
    procedure setOCM1; inline;
    procedure setOCM2; inline;
    procedure setOCSIDL; inline;
    procedure setOCTSEL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property OC32 : TBits_1 read getOC32 write setOC32;
    property OCFLT : TBits_1 read getOCFLT write setOCFLT;
    property OCM : TBits_3 read getOCM write setOCM;
    property OCM0 : TBits_1 read getOCM0 write setOCM0;
    property OCM1 : TBits_1 read getOCM1 write setOCM1;
    property OCM2 : TBits_1 read getOCM2 write setOCM2;
    property OCSIDL : TBits_1 read getOCSIDL write setOCSIDL;
    property OCTSEL : TBits_1 read getOCTSEL write setOCTSEL;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
type
  TOCMP5Registers = record
    OC5CONbits : TOCMP5_OC5CON;
    OC5CON : longWord;
    OC5CONCLR : longWord;
    OC5CONSET : longWord;
    OC5CONINV : longWord;
    OC5R : longWord;
    OC5RCLR : longWord;
    OC5RSET : longWord;
    OC5RINV : longWord;
    OC5RS : longWord;
    OC5RSCLR : longWord;
    OC5RSSET : longWord;
    OC5RSINV : longWord;
  end;
  TI2C1_I2C1ACON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C1_I2C1CON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C1_I2C1ASTAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C1_I2C1STAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
type
  TI2C1Registers = record
    I2C1ACONbits : TI2C1_I2C1ACON;
    I2C1ACON : longWord;
    I2C1CONbits : TI2C1_I2C1CON;
    I2C1CON : longWord;
    I2C1ACONCLR : longWord;
    I2C1CONCLR : longWord;
    I2C1ACONSET : longWord;
    I2C1CONSET : longWord;
    I2C1ACONINV : longWord;
    I2C1CONINV : longWord;
    I2C1ASTATbits : TI2C1_I2C1ASTAT;
    I2C1ASTAT : longWord;
    I2C1STATbits : TI2C1_I2C1STAT;
    I2C1STAT : longWord;
    I2C1ASTATCLR : longWord;
    I2C1STATCLR : longWord;
    I2C1ASTATSET : longWord;
    I2C1STATSET : longWord;
    I2C1ASTATINV : longWord;
    I2C1STATINV : longWord;
    I2C1AADD : longWord;
    I2C1ADD : longWord;
    I2C1AADDCLR : longWord;
    I2C1ADDCLR : longWord;
    I2C1AADDSET : longWord;
    I2C1ADDSET : longWord;
    I2C1AADDINV : longWord;
    I2C1ADDINV : longWord;
    I2C1AMSK : longWord;
    I2C1MSK : longWord;
    I2C1AMSKCLR : longWord;
    I2C1MSKCLR : longWord;
    I2C1AMSKSET : longWord;
    I2C1MSKSET : longWord;
    I2C1AMSKINV : longWord;
    I2C1MSKINV : longWord;
    I2C1ABRG : longWord;
    I2C1BRG : longWord;
    I2C1ABRGCLR : longWord;
    I2C1BRGCLR : longWord;
    I2C1ABRGSET : longWord;
    I2C1BRGSET : longWord;
    I2C1ABRGINV : longWord;
    I2C1BRGINV : longWord;
    I2C1ATRN : longWord;
    I2C1TRN : longWord;
    I2C1ATRNCLR : longWord;
    I2C1TRNCLR : longWord;
    I2C1ATRNSET : longWord;
    I2C1TRNSET : longWord;
    I2C1ATRNINV : longWord;
    I2C1TRNINV : longWord;
    I2C1ARCV : longWord;
    I2C1RCV : longWord;
  end;
  TI2C2_I2C2ACON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C2_I2C2CON = record
  private
    function  getA10M : TBits_1; inline;
    function  getACKDT : TBits_1; inline;
    function  getACKEN : TBits_1; inline;
    function  getDISSLW : TBits_1; inline;
    function  getGCEN : TBits_1; inline;
    function  getI2CEN : TBits_1; inline;
    function  getI2CSIDL : TBits_1; inline;
    function  getIPMIEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPEN : TBits_1; inline;
    function  getRCEN : TBits_1; inline;
    function  getRSEN : TBits_1; inline;
    function  getSCLREL : TBits_1; inline;
    function  getSEN : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMEN : TBits_1; inline;
    function  getSTREN : TBits_1; inline;
    function  getSTRICT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setA10M(thebits : TBits_1); inline;
    procedure setACKDT(thebits : TBits_1); inline;
    procedure setACKEN(thebits : TBits_1); inline;
    procedure setDISSLW(thebits : TBits_1); inline;
    procedure setGCEN(thebits : TBits_1); inline;
    procedure setI2CEN(thebits : TBits_1); inline;
    procedure setI2CSIDL(thebits : TBits_1); inline;
    procedure setIPMIEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPEN(thebits : TBits_1); inline;
    procedure setRCEN(thebits : TBits_1); inline;
    procedure setRSEN(thebits : TBits_1); inline;
    procedure setSCLREL(thebits : TBits_1); inline;
    procedure setSEN(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMEN(thebits : TBits_1); inline;
    procedure setSTREN(thebits : TBits_1); inline;
    procedure setSTRICT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearA10M; inline;
    procedure clearACKDT; inline;
    procedure clearACKEN; inline;
    procedure clearDISSLW; inline;
    procedure clearGCEN; inline;
    procedure clearI2CEN; inline;
    procedure clearI2CSIDL; inline;
    procedure clearIPMIEN; inline;
    procedure clearON; inline;
    procedure clearPEN; inline;
    procedure clearRCEN; inline;
    procedure clearRSEN; inline;
    procedure clearSCLREL; inline;
    procedure clearSEN; inline;
    procedure clearSIDL; inline;
    procedure clearSMEN; inline;
    procedure clearSTREN; inline;
    procedure clearSTRICT; inline;
    procedure setA10M; inline;
    procedure setACKDT; inline;
    procedure setACKEN; inline;
    procedure setDISSLW; inline;
    procedure setGCEN; inline;
    procedure setI2CEN; inline;
    procedure setI2CSIDL; inline;
    procedure setIPMIEN; inline;
    procedure setON; inline;
    procedure setPEN; inline;
    procedure setRCEN; inline;
    procedure setRSEN; inline;
    procedure setSCLREL; inline;
    procedure setSEN; inline;
    procedure setSIDL; inline;
    procedure setSMEN; inline;
    procedure setSTREN; inline;
    procedure setSTRICT; inline;
    property A10M : TBits_1 read getA10M write setA10M;
    property ACKDT : TBits_1 read getACKDT write setACKDT;
    property ACKEN : TBits_1 read getACKEN write setACKEN;
    property DISSLW : TBits_1 read getDISSLW write setDISSLW;
    property GCEN : TBits_1 read getGCEN write setGCEN;
    property I2CEN : TBits_1 read getI2CEN write setI2CEN;
    property I2CSIDL : TBits_1 read getI2CSIDL write setI2CSIDL;
    property IPMIEN : TBits_1 read getIPMIEN write setIPMIEN;
    property ON : TBits_1 read getON write setON;
    property PEN : TBits_1 read getPEN write setPEN;
    property RCEN : TBits_1 read getRCEN write setRCEN;
    property RSEN : TBits_1 read getRSEN write setRSEN;
    property SCLREL : TBits_1 read getSCLREL write setSCLREL;
    property SEN : TBits_1 read getSEN write setSEN;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMEN : TBits_1 read getSMEN write setSMEN;
    property STREN : TBits_1 read getSTREN write setSTREN;
    property STRICT : TBits_1 read getSTRICT write setSTRICT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C2_I2C2ASTAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
  TI2C2_I2C2STAT = record
  private
    function  getACKSTAT : TBits_1; inline;
    function  getADD10 : TBits_1; inline;
    function  getBCL : TBits_1; inline;
    function  getD_A : TBits_1; inline;
    function  getGCSTAT : TBits_1; inline;
    function  getI2COV : TBits_1; inline;
    function  getI2CPOV : TBits_1; inline;
    function  getIWCOL : TBits_1; inline;
    function  getP : TBits_1; inline;
    function  getRBF : TBits_1; inline;
    function  getR_W : TBits_1; inline;
    function  getS : TBits_1; inline;
    function  getTBF : TBits_1; inline;
    function  getTRSTAT : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACKSTAT(thebits : TBits_1); inline;
    procedure setADD10(thebits : TBits_1); inline;
    procedure setBCL(thebits : TBits_1); inline;
    procedure setD_A(thebits : TBits_1); inline;
    procedure setGCSTAT(thebits : TBits_1); inline;
    procedure setI2COV(thebits : TBits_1); inline;
    procedure setI2CPOV(thebits : TBits_1); inline;
    procedure setIWCOL(thebits : TBits_1); inline;
    procedure setP(thebits : TBits_1); inline;
    procedure setRBF(thebits : TBits_1); inline;
    procedure setR_W(thebits : TBits_1); inline;
    procedure setS(thebits : TBits_1); inline;
    procedure setTBF(thebits : TBits_1); inline;
    procedure setTRSTAT(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACKSTAT; inline;
    procedure clearADD10; inline;
    procedure clearBCL; inline;
    procedure clearD_A; inline;
    procedure clearGCSTAT; inline;
    procedure clearI2COV; inline;
    procedure clearI2CPOV; inline;
    procedure clearIWCOL; inline;
    procedure clearP; inline;
    procedure clearRBF; inline;
    procedure clearR_W; inline;
    procedure clearS; inline;
    procedure clearTBF; inline;
    procedure clearTRSTAT; inline;
    procedure setACKSTAT; inline;
    procedure setADD10; inline;
    procedure setBCL; inline;
    procedure setD_A; inline;
    procedure setGCSTAT; inline;
    procedure setI2COV; inline;
    procedure setI2CPOV; inline;
    procedure setIWCOL; inline;
    procedure setP; inline;
    procedure setRBF; inline;
    procedure setR_W; inline;
    procedure setS; inline;
    procedure setTBF; inline;
    procedure setTRSTAT; inline;
    property ACKSTAT : TBits_1 read getACKSTAT write setACKSTAT;
    property ADD10 : TBits_1 read getADD10 write setADD10;
    property BCL : TBits_1 read getBCL write setBCL;
    property D_A : TBits_1 read getD_A write setD_A;
    property GCSTAT : TBits_1 read getGCSTAT write setGCSTAT;
    property I2COV : TBits_1 read getI2COV write setI2COV;
    property I2CPOV : TBits_1 read getI2CPOV write setI2CPOV;
    property IWCOL : TBits_1 read getIWCOL write setIWCOL;
    property P : TBits_1 read getP write setP;
    property RBF : TBits_1 read getRBF write setRBF;
    property R_W : TBits_1 read getR_W write setR_W;
    property S : TBits_1 read getS write setS;
    property TBF : TBits_1 read getTBF write setTBF;
    property TRSTAT : TBits_1 read getTRSTAT write setTRSTAT;
    property w : TBits_32 read getw write setw;
  end;
type
  TI2C2Registers = record
    I2C2ACONbits : TI2C2_I2C2ACON;
    I2C2ACON : longWord;
    I2C2CONbits : TI2C2_I2C2CON;
    I2C2CON : longWord;
    I2C2ACONCLR : longWord;
    I2C2CONCLR : longWord;
    I2C2ACONSET : longWord;
    I2C2CONSET : longWord;
    I2C2ACONINV : longWord;
    I2C2CONINV : longWord;
    I2C2ASTATbits : TI2C2_I2C2ASTAT;
    I2C2ASTAT : longWord;
    I2C2STATbits : TI2C2_I2C2STAT;
    I2C2STAT : longWord;
    I2C2ASTATCLR : longWord;
    I2C2STATCLR : longWord;
    I2C2ASTATSET : longWord;
    I2C2STATSET : longWord;
    I2C2ASTATINV : longWord;
    I2C2STATINV : longWord;
    I2C2AADD : longWord;
    I2C2ADD : longWord;
    I2C2AADDCLR : longWord;
    I2C2ADDCLR : longWord;
    I2C2AADDSET : longWord;
    I2C2ADDSET : longWord;
    I2C2AADDINV : longWord;
    I2C2ADDINV : longWord;
    I2C2AMSK : longWord;
    I2C2MSK : longWord;
    I2C2AMSKCLR : longWord;
    I2C2MSKCLR : longWord;
    I2C2AMSKSET : longWord;
    I2C2MSKSET : longWord;
    I2C2AMSKINV : longWord;
    I2C2MSKINV : longWord;
    I2C2ABRG : longWord;
    I2C2BRG : longWord;
    I2C2ABRGCLR : longWord;
    I2C2BRGCLR : longWord;
    I2C2ABRGSET : longWord;
    I2C2BRGSET : longWord;
    I2C2ABRGINV : longWord;
    I2C2BRGINV : longWord;
    I2C2ATRN : longWord;
    I2C2TRN : longWord;
    I2C2ATRNCLR : longWord;
    I2C2TRNCLR : longWord;
    I2C2ATRNSET : longWord;
    I2C2TRNSET : longWord;
    I2C2ATRNINV : longWord;
    I2C2TRNINV : longWord;
    I2C2ARCV : longWord;
    I2C2RCV : longWord;
  end;
  TSPI1_SPI1CON = record
  private
    function  getCKE : TBits_1; inline;
    function  getCKP : TBits_1; inline;
    function  getDISSDI : TBits_1; inline;
    function  getDISSDO : TBits_1; inline;
    function  getENHBUF : TBits_1; inline;
    function  getFRMCNT : TBits_3; inline;
    function  getFRMEN : TBits_1; inline;
    function  getFRMPOL : TBits_1; inline;
    function  getFRMSYNC : TBits_1; inline;
    function  getFRMSYPW : TBits_1; inline;
    function  getMCLKSEL : TBits_1; inline;
    function  getMODE16 : TBits_1; inline;
    function  getMODE32 : TBits_1; inline;
    function  getMSSEN : TBits_1; inline;
    function  getMSTEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMP : TBits_1; inline;
    function  getSPIFE : TBits_1; inline;
    function  getSRXISEL : TBits_2; inline;
    function  getSSEN : TBits_1; inline;
    function  getSTXISEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCKE(thebits : TBits_1); inline;
    procedure setCKP(thebits : TBits_1); inline;
    procedure setDISSDI(thebits : TBits_1); inline;
    procedure setDISSDO(thebits : TBits_1); inline;
    procedure setENHBUF(thebits : TBits_1); inline;
    procedure setFRMCNT(thebits : TBits_3); inline;
    procedure setFRMEN(thebits : TBits_1); inline;
    procedure setFRMPOL(thebits : TBits_1); inline;
    procedure setFRMSYNC(thebits : TBits_1); inline;
    procedure setFRMSYPW(thebits : TBits_1); inline;
    procedure setMCLKSEL(thebits : TBits_1); inline;
    procedure setMODE16(thebits : TBits_1); inline;
    procedure setMODE32(thebits : TBits_1); inline;
    procedure setMSSEN(thebits : TBits_1); inline;
    procedure setMSTEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMP(thebits : TBits_1); inline;
    procedure setSPIFE(thebits : TBits_1); inline;
    procedure setSRXISEL(thebits : TBits_2); inline;
    procedure setSSEN(thebits : TBits_1); inline;
    procedure setSTXISEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCKE; inline;
    procedure clearCKP; inline;
    procedure clearDISSDI; inline;
    procedure clearDISSDO; inline;
    procedure clearENHBUF; inline;
    procedure clearFRMEN; inline;
    procedure clearFRMPOL; inline;
    procedure clearFRMSYNC; inline;
    procedure clearFRMSYPW; inline;
    procedure clearMCLKSEL; inline;
    procedure clearMODE16; inline;
    procedure clearMODE32; inline;
    procedure clearMSSEN; inline;
    procedure clearMSTEN; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearSMP; inline;
    procedure clearSPIFE; inline;
    procedure clearSSEN; inline;
    procedure setCKE; inline;
    procedure setCKP; inline;
    procedure setDISSDI; inline;
    procedure setDISSDO; inline;
    procedure setENHBUF; inline;
    procedure setFRMEN; inline;
    procedure setFRMPOL; inline;
    procedure setFRMSYNC; inline;
    procedure setFRMSYPW; inline;
    procedure setMCLKSEL; inline;
    procedure setMODE16; inline;
    procedure setMODE32; inline;
    procedure setMSSEN; inline;
    procedure setMSTEN; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setSMP; inline;
    procedure setSPIFE; inline;
    procedure setSSEN; inline;
    property CKE : TBits_1 read getCKE write setCKE;
    property CKP : TBits_1 read getCKP write setCKP;
    property DISSDI : TBits_1 read getDISSDI write setDISSDI;
    property DISSDO : TBits_1 read getDISSDO write setDISSDO;
    property ENHBUF : TBits_1 read getENHBUF write setENHBUF;
    property FRMCNT : TBits_3 read getFRMCNT write setFRMCNT;
    property FRMEN : TBits_1 read getFRMEN write setFRMEN;
    property FRMPOL : TBits_1 read getFRMPOL write setFRMPOL;
    property FRMSYNC : TBits_1 read getFRMSYNC write setFRMSYNC;
    property FRMSYPW : TBits_1 read getFRMSYPW write setFRMSYPW;
    property MCLKSEL : TBits_1 read getMCLKSEL write setMCLKSEL;
    property MODE16 : TBits_1 read getMODE16 write setMODE16;
    property MODE32 : TBits_1 read getMODE32 write setMODE32;
    property MSSEN : TBits_1 read getMSSEN write setMSSEN;
    property MSTEN : TBits_1 read getMSTEN write setMSTEN;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMP : TBits_1 read getSMP write setSMP;
    property SPIFE : TBits_1 read getSPIFE write setSPIFE;
    property SRXISEL : TBits_2 read getSRXISEL write setSRXISEL;
    property SSEN : TBits_1 read getSSEN write setSSEN;
    property STXISEL : TBits_2 read getSTXISEL write setSTXISEL;
    property w : TBits_32 read getw write setw;
  end;
  TSPI1_SPI1STAT = record
  private
    function  getFRMERR : TBits_1; inline;
    function  getRXBUFELM : TBits_5; inline;
    function  getSPIBUSY : TBits_1; inline;
    function  getSPIRBE : TBits_1; inline;
    function  getSPIRBF : TBits_1; inline;
    function  getSPIROV : TBits_1; inline;
    function  getSPITBE : TBits_1; inline;
    function  getSPITBF : TBits_1; inline;
    function  getSPITUR : TBits_1; inline;
    function  getSRMT : TBits_1; inline;
    function  getTXBUFELM : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setFRMERR(thebits : TBits_1); inline;
    procedure setRXBUFELM(thebits : TBits_5); inline;
    procedure setSPIBUSY(thebits : TBits_1); inline;
    procedure setSPIRBE(thebits : TBits_1); inline;
    procedure setSPIRBF(thebits : TBits_1); inline;
    procedure setSPIROV(thebits : TBits_1); inline;
    procedure setSPITBE(thebits : TBits_1); inline;
    procedure setSPITBF(thebits : TBits_1); inline;
    procedure setSPITUR(thebits : TBits_1); inline;
    procedure setSRMT(thebits : TBits_1); inline;
    procedure setTXBUFELM(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFRMERR; inline;
    procedure clearSPIBUSY; inline;
    procedure clearSPIRBE; inline;
    procedure clearSPIRBF; inline;
    procedure clearSPIROV; inline;
    procedure clearSPITBE; inline;
    procedure clearSPITBF; inline;
    procedure clearSPITUR; inline;
    procedure clearSRMT; inline;
    procedure setFRMERR; inline;
    procedure setSPIBUSY; inline;
    procedure setSPIRBE; inline;
    procedure setSPIRBF; inline;
    procedure setSPIROV; inline;
    procedure setSPITBE; inline;
    procedure setSPITBF; inline;
    procedure setSPITUR; inline;
    procedure setSRMT; inline;
    property FRMERR : TBits_1 read getFRMERR write setFRMERR;
    property RXBUFELM : TBits_5 read getRXBUFELM write setRXBUFELM;
    property SPIBUSY : TBits_1 read getSPIBUSY write setSPIBUSY;
    property SPIRBE : TBits_1 read getSPIRBE write setSPIRBE;
    property SPIRBF : TBits_1 read getSPIRBF write setSPIRBF;
    property SPIROV : TBits_1 read getSPIROV write setSPIROV;
    property SPITBE : TBits_1 read getSPITBE write setSPITBE;
    property SPITBF : TBits_1 read getSPITBF write setSPITBF;
    property SPITUR : TBits_1 read getSPITUR write setSPITUR;
    property SRMT : TBits_1 read getSRMT write setSRMT;
    property TXBUFELM : TBits_5 read getTXBUFELM write setTXBUFELM;
    property w : TBits_32 read getw write setw;
  end;
  TSPI1_SPI1CON2 = record
  private
    function  getAUDEN : TBits_1; inline;
    function  getAUDMOD : TBits_2; inline;
    function  getAUDMOD0 : TBits_1; inline;
    function  getAUDMOD1 : TBits_1; inline;
    function  getAUDMONO : TBits_1; inline;
    function  getFRMERREN : TBits_1; inline;
    function  getIGNROV : TBits_1; inline;
    function  getIGNTUR : TBits_1; inline;
    function  getSPIROVEN : TBits_1; inline;
    function  getSPISGNEXT : TBits_1; inline;
    function  getSPITUREN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAUDEN(thebits : TBits_1); inline;
    procedure setAUDMOD(thebits : TBits_2); inline;
    procedure setAUDMOD0(thebits : TBits_1); inline;
    procedure setAUDMOD1(thebits : TBits_1); inline;
    procedure setAUDMONO(thebits : TBits_1); inline;
    procedure setFRMERREN(thebits : TBits_1); inline;
    procedure setIGNROV(thebits : TBits_1); inline;
    procedure setIGNTUR(thebits : TBits_1); inline;
    procedure setSPIROVEN(thebits : TBits_1); inline;
    procedure setSPISGNEXT(thebits : TBits_1); inline;
    procedure setSPITUREN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAUDEN; inline;
    procedure clearAUDMOD0; inline;
    procedure clearAUDMOD1; inline;
    procedure clearAUDMONO; inline;
    procedure clearFRMERREN; inline;
    procedure clearIGNROV; inline;
    procedure clearIGNTUR; inline;
    procedure clearSPIROVEN; inline;
    procedure clearSPISGNEXT; inline;
    procedure clearSPITUREN; inline;
    procedure setAUDEN; inline;
    procedure setAUDMOD0; inline;
    procedure setAUDMOD1; inline;
    procedure setAUDMONO; inline;
    procedure setFRMERREN; inline;
    procedure setIGNROV; inline;
    procedure setIGNTUR; inline;
    procedure setSPIROVEN; inline;
    procedure setSPISGNEXT; inline;
    procedure setSPITUREN; inline;
    property AUDEN : TBits_1 read getAUDEN write setAUDEN;
    property AUDMOD : TBits_2 read getAUDMOD write setAUDMOD;
    property AUDMOD0 : TBits_1 read getAUDMOD0 write setAUDMOD0;
    property AUDMOD1 : TBits_1 read getAUDMOD1 write setAUDMOD1;
    property AUDMONO : TBits_1 read getAUDMONO write setAUDMONO;
    property FRMERREN : TBits_1 read getFRMERREN write setFRMERREN;
    property IGNROV : TBits_1 read getIGNROV write setIGNROV;
    property IGNTUR : TBits_1 read getIGNTUR write setIGNTUR;
    property SPIROVEN : TBits_1 read getSPIROVEN write setSPIROVEN;
    property SPISGNEXT : TBits_1 read getSPISGNEXT write setSPISGNEXT;
    property SPITUREN : TBits_1 read getSPITUREN write setSPITUREN;
    property w : TBits_32 read getw write setw;
  end;
type
  TSPI1Registers = record
    SPI1CONbits : TSPI1_SPI1CON;
    SPI1CON : longWord;
    SPI1CONCLR : longWord;
    SPI1CONSET : longWord;
    SPI1CONINV : longWord;
    SPI1STATbits : TSPI1_SPI1STAT;
    SPI1STAT : longWord;
    SPI1STATCLR : longWord;
    SPI1STATSET : longWord;
    SPI1STATINV : longWord;
    SPI1BUF : longWord;
    SPI1BRG : longWord;
    SPI1BRGCLR : longWord;
    SPI1BRGSET : longWord;
    SPI1BRGINV : longWord;
    SPI1CON2bits : TSPI1_SPI1CON2;
    SPI1CON2 : longWord;
    SPI1CON2CLR : longWord;
    SPI1CON2SET : longWord;
    SPI1CON2INV : longWord;
  end;
  TSPI2_SPI2CON = record
  private
    function  getCKE : TBits_1; inline;
    function  getCKP : TBits_1; inline;
    function  getDISSDI : TBits_1; inline;
    function  getDISSDO : TBits_1; inline;
    function  getENHBUF : TBits_1; inline;
    function  getFRMCNT : TBits_3; inline;
    function  getFRMEN : TBits_1; inline;
    function  getFRMPOL : TBits_1; inline;
    function  getFRMSYNC : TBits_1; inline;
    function  getFRMSYPW : TBits_1; inline;
    function  getMCLKSEL : TBits_1; inline;
    function  getMODE16 : TBits_1; inline;
    function  getMODE32 : TBits_1; inline;
    function  getMSSEN : TBits_1; inline;
    function  getMSTEN : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSMP : TBits_1; inline;
    function  getSPIFE : TBits_1; inline;
    function  getSRXISEL : TBits_2; inline;
    function  getSSEN : TBits_1; inline;
    function  getSTXISEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCKE(thebits : TBits_1); inline;
    procedure setCKP(thebits : TBits_1); inline;
    procedure setDISSDI(thebits : TBits_1); inline;
    procedure setDISSDO(thebits : TBits_1); inline;
    procedure setENHBUF(thebits : TBits_1); inline;
    procedure setFRMCNT(thebits : TBits_3); inline;
    procedure setFRMEN(thebits : TBits_1); inline;
    procedure setFRMPOL(thebits : TBits_1); inline;
    procedure setFRMSYNC(thebits : TBits_1); inline;
    procedure setFRMSYPW(thebits : TBits_1); inline;
    procedure setMCLKSEL(thebits : TBits_1); inline;
    procedure setMODE16(thebits : TBits_1); inline;
    procedure setMODE32(thebits : TBits_1); inline;
    procedure setMSSEN(thebits : TBits_1); inline;
    procedure setMSTEN(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSMP(thebits : TBits_1); inline;
    procedure setSPIFE(thebits : TBits_1); inline;
    procedure setSRXISEL(thebits : TBits_2); inline;
    procedure setSSEN(thebits : TBits_1); inline;
    procedure setSTXISEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCKE; inline;
    procedure clearCKP; inline;
    procedure clearDISSDI; inline;
    procedure clearDISSDO; inline;
    procedure clearENHBUF; inline;
    procedure clearFRMEN; inline;
    procedure clearFRMPOL; inline;
    procedure clearFRMSYNC; inline;
    procedure clearFRMSYPW; inline;
    procedure clearMCLKSEL; inline;
    procedure clearMODE16; inline;
    procedure clearMODE32; inline;
    procedure clearMSSEN; inline;
    procedure clearMSTEN; inline;
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure clearSMP; inline;
    procedure clearSPIFE; inline;
    procedure clearSSEN; inline;
    procedure setCKE; inline;
    procedure setCKP; inline;
    procedure setDISSDI; inline;
    procedure setDISSDO; inline;
    procedure setENHBUF; inline;
    procedure setFRMEN; inline;
    procedure setFRMPOL; inline;
    procedure setFRMSYNC; inline;
    procedure setFRMSYPW; inline;
    procedure setMCLKSEL; inline;
    procedure setMODE16; inline;
    procedure setMODE32; inline;
    procedure setMSSEN; inline;
    procedure setMSTEN; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    procedure setSMP; inline;
    procedure setSPIFE; inline;
    procedure setSSEN; inline;
    property CKE : TBits_1 read getCKE write setCKE;
    property CKP : TBits_1 read getCKP write setCKP;
    property DISSDI : TBits_1 read getDISSDI write setDISSDI;
    property DISSDO : TBits_1 read getDISSDO write setDISSDO;
    property ENHBUF : TBits_1 read getENHBUF write setENHBUF;
    property FRMCNT : TBits_3 read getFRMCNT write setFRMCNT;
    property FRMEN : TBits_1 read getFRMEN write setFRMEN;
    property FRMPOL : TBits_1 read getFRMPOL write setFRMPOL;
    property FRMSYNC : TBits_1 read getFRMSYNC write setFRMSYNC;
    property FRMSYPW : TBits_1 read getFRMSYPW write setFRMSYPW;
    property MCLKSEL : TBits_1 read getMCLKSEL write setMCLKSEL;
    property MODE16 : TBits_1 read getMODE16 write setMODE16;
    property MODE32 : TBits_1 read getMODE32 write setMODE32;
    property MSSEN : TBits_1 read getMSSEN write setMSSEN;
    property MSTEN : TBits_1 read getMSTEN write setMSTEN;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SMP : TBits_1 read getSMP write setSMP;
    property SPIFE : TBits_1 read getSPIFE write setSPIFE;
    property SRXISEL : TBits_2 read getSRXISEL write setSRXISEL;
    property SSEN : TBits_1 read getSSEN write setSSEN;
    property STXISEL : TBits_2 read getSTXISEL write setSTXISEL;
    property w : TBits_32 read getw write setw;
  end;
  TSPI2_SPI2STAT = record
  private
    function  getFRMERR : TBits_1; inline;
    function  getRXBUFELM : TBits_5; inline;
    function  getSPIBUSY : TBits_1; inline;
    function  getSPIRBE : TBits_1; inline;
    function  getSPIRBF : TBits_1; inline;
    function  getSPIROV : TBits_1; inline;
    function  getSPITBE : TBits_1; inline;
    function  getSPITBF : TBits_1; inline;
    function  getSPITUR : TBits_1; inline;
    function  getSRMT : TBits_1; inline;
    function  getTXBUFELM : TBits_5; inline;
    function  getw : TBits_32; inline;
    procedure setFRMERR(thebits : TBits_1); inline;
    procedure setRXBUFELM(thebits : TBits_5); inline;
    procedure setSPIBUSY(thebits : TBits_1); inline;
    procedure setSPIRBE(thebits : TBits_1); inline;
    procedure setSPIRBF(thebits : TBits_1); inline;
    procedure setSPIROV(thebits : TBits_1); inline;
    procedure setSPITBE(thebits : TBits_1); inline;
    procedure setSPITBF(thebits : TBits_1); inline;
    procedure setSPITUR(thebits : TBits_1); inline;
    procedure setSRMT(thebits : TBits_1); inline;
    procedure setTXBUFELM(thebits : TBits_5); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFRMERR; inline;
    procedure clearSPIBUSY; inline;
    procedure clearSPIRBE; inline;
    procedure clearSPIRBF; inline;
    procedure clearSPIROV; inline;
    procedure clearSPITBE; inline;
    procedure clearSPITBF; inline;
    procedure clearSPITUR; inline;
    procedure clearSRMT; inline;
    procedure setFRMERR; inline;
    procedure setSPIBUSY; inline;
    procedure setSPIRBE; inline;
    procedure setSPIRBF; inline;
    procedure setSPIROV; inline;
    procedure setSPITBE; inline;
    procedure setSPITBF; inline;
    procedure setSPITUR; inline;
    procedure setSRMT; inline;
    property FRMERR : TBits_1 read getFRMERR write setFRMERR;
    property RXBUFELM : TBits_5 read getRXBUFELM write setRXBUFELM;
    property SPIBUSY : TBits_1 read getSPIBUSY write setSPIBUSY;
    property SPIRBE : TBits_1 read getSPIRBE write setSPIRBE;
    property SPIRBF : TBits_1 read getSPIRBF write setSPIRBF;
    property SPIROV : TBits_1 read getSPIROV write setSPIROV;
    property SPITBE : TBits_1 read getSPITBE write setSPITBE;
    property SPITBF : TBits_1 read getSPITBF write setSPITBF;
    property SPITUR : TBits_1 read getSPITUR write setSPITUR;
    property SRMT : TBits_1 read getSRMT write setSRMT;
    property TXBUFELM : TBits_5 read getTXBUFELM write setTXBUFELM;
    property w : TBits_32 read getw write setw;
  end;
  TSPI2_SPI2CON2 = record
  private
    function  getAUDEN : TBits_1; inline;
    function  getAUDMOD : TBits_2; inline;
    function  getAUDMOD0 : TBits_1; inline;
    function  getAUDMOD1 : TBits_1; inline;
    function  getAUDMONO : TBits_1; inline;
    function  getFRMERREN : TBits_1; inline;
    function  getIGNROV : TBits_1; inline;
    function  getIGNTUR : TBits_1; inline;
    function  getSPIROVEN : TBits_1; inline;
    function  getSPISGNEXT : TBits_1; inline;
    function  getSPITUREN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAUDEN(thebits : TBits_1); inline;
    procedure setAUDMOD(thebits : TBits_2); inline;
    procedure setAUDMOD0(thebits : TBits_1); inline;
    procedure setAUDMOD1(thebits : TBits_1); inline;
    procedure setAUDMONO(thebits : TBits_1); inline;
    procedure setFRMERREN(thebits : TBits_1); inline;
    procedure setIGNROV(thebits : TBits_1); inline;
    procedure setIGNTUR(thebits : TBits_1); inline;
    procedure setSPIROVEN(thebits : TBits_1); inline;
    procedure setSPISGNEXT(thebits : TBits_1); inline;
    procedure setSPITUREN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAUDEN; inline;
    procedure clearAUDMOD0; inline;
    procedure clearAUDMOD1; inline;
    procedure clearAUDMONO; inline;
    procedure clearFRMERREN; inline;
    procedure clearIGNROV; inline;
    procedure clearIGNTUR; inline;
    procedure clearSPIROVEN; inline;
    procedure clearSPISGNEXT; inline;
    procedure clearSPITUREN; inline;
    procedure setAUDEN; inline;
    procedure setAUDMOD0; inline;
    procedure setAUDMOD1; inline;
    procedure setAUDMONO; inline;
    procedure setFRMERREN; inline;
    procedure setIGNROV; inline;
    procedure setIGNTUR; inline;
    procedure setSPIROVEN; inline;
    procedure setSPISGNEXT; inline;
    procedure setSPITUREN; inline;
    property AUDEN : TBits_1 read getAUDEN write setAUDEN;
    property AUDMOD : TBits_2 read getAUDMOD write setAUDMOD;
    property AUDMOD0 : TBits_1 read getAUDMOD0 write setAUDMOD0;
    property AUDMOD1 : TBits_1 read getAUDMOD1 write setAUDMOD1;
    property AUDMONO : TBits_1 read getAUDMONO write setAUDMONO;
    property FRMERREN : TBits_1 read getFRMERREN write setFRMERREN;
    property IGNROV : TBits_1 read getIGNROV write setIGNROV;
    property IGNTUR : TBits_1 read getIGNTUR write setIGNTUR;
    property SPIROVEN : TBits_1 read getSPIROVEN write setSPIROVEN;
    property SPISGNEXT : TBits_1 read getSPISGNEXT write setSPISGNEXT;
    property SPITUREN : TBits_1 read getSPITUREN write setSPITUREN;
    property w : TBits_32 read getw write setw;
  end;
type
  TSPI2Registers = record
    SPI2CONbits : TSPI2_SPI2CON;
    SPI2CON : longWord;
    SPI2CONCLR : longWord;
    SPI2CONSET : longWord;
    SPI2CONINV : longWord;
    SPI2STATbits : TSPI2_SPI2STAT;
    SPI2STAT : longWord;
    SPI2STATCLR : longWord;
    SPI2STATSET : longWord;
    SPI2STATINV : longWord;
    SPI2BUF : longWord;
    SPI2BRG : longWord;
    SPI2BRGCLR : longWord;
    SPI2BRGSET : longWord;
    SPI2BRGINV : longWord;
    SPI2CON2bits : TSPI2_SPI2CON2;
    SPI2CON2 : longWord;
    SPI2CON2CLR : longWord;
    SPI2CON2SET : longWord;
    SPI2CON2INV : longWord;
  end;
  TUART1_U1AMODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART1_U1MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART1_U1ASTA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
  TUART1_U1STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
type
  TUART1Registers = record
    U1AMODEbits : TUART1_U1AMODE;
    U1AMODE : longWord;
    U1MODEbits : TUART1_U1MODE;
    U1MODE : longWord;
    U1AMODECLR : longWord;
    U1MODECLR : longWord;
    U1AMODESET : longWord;
    U1MODESET : longWord;
    U1AMODEINV : longWord;
    U1MODEINV : longWord;
    U1ASTAbits : TUART1_U1ASTA;
    U1ASTA : longWord;
    U1STAbits : TUART1_U1STA;
    U1STA : longWord;
    U1ASTACLR : longWord;
    U1STACLR : longWord;
    U1ASTASET : longWord;
    U1STASET : longWord;
    U1ASTAINV : longWord;
    U1STAINV : longWord;
    U1ATXREG : longWord;
    U1TXREG : longWord;
    U1ARXREG : longWord;
    U1RXREG : longWord;
    U1ABRG : longWord;
    U1BRG : longWord;
    U1ABRGCLR : longWord;
    U1BRGCLR : longWord;
    U1ABRGSET : longWord;
    U1BRGSET : longWord;
    U1ABRGINV : longWord;
    U1BRGINV : longWord;
  end;
  TUART2_U2MODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART2_U3AMODE = record
  private
    function  getABAUD : TBits_1; inline;
    function  getBRGH : TBits_1; inline;
    function  getIREN : TBits_1; inline;
    function  getLPBACK : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPDSEL : TBits_2; inline;
    function  getPDSEL0 : TBits_1; inline;
    function  getPDSEL1 : TBits_1; inline;
    function  getRTSMD : TBits_1; inline;
    function  getRXINV : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSTSEL : TBits_1; inline;
    function  getUARTEN : TBits_1; inline;
    function  getUEN : TBits_2; inline;
    function  getUEN0 : TBits_1; inline;
    function  getUEN1 : TBits_1; inline;
    function  getUSIDL : TBits_1; inline;
    function  getWAKE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setABAUD(thebits : TBits_1); inline;
    procedure setBRGH(thebits : TBits_1); inline;
    procedure setIREN(thebits : TBits_1); inline;
    procedure setLPBACK(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPDSEL(thebits : TBits_2); inline;
    procedure setPDSEL0(thebits : TBits_1); inline;
    procedure setPDSEL1(thebits : TBits_1); inline;
    procedure setRTSMD(thebits : TBits_1); inline;
    procedure setRXINV(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSTSEL(thebits : TBits_1); inline;
    procedure setUARTEN(thebits : TBits_1); inline;
    procedure setUEN(thebits : TBits_2); inline;
    procedure setUEN0(thebits : TBits_1); inline;
    procedure setUEN1(thebits : TBits_1); inline;
    procedure setUSIDL(thebits : TBits_1); inline;
    procedure setWAKE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearABAUD; inline;
    procedure clearBRGH; inline;
    procedure clearIREN; inline;
    procedure clearLPBACK; inline;
    procedure clearON; inline;
    procedure clearPDSEL0; inline;
    procedure clearPDSEL1; inline;
    procedure clearRTSMD; inline;
    procedure clearRXINV; inline;
    procedure clearSIDL; inline;
    procedure clearSTSEL; inline;
    procedure clearUARTEN; inline;
    procedure clearUEN0; inline;
    procedure clearUEN1; inline;
    procedure clearUSIDL; inline;
    procedure clearWAKE; inline;
    procedure setABAUD; inline;
    procedure setBRGH; inline;
    procedure setIREN; inline;
    procedure setLPBACK; inline;
    procedure setON; inline;
    procedure setPDSEL0; inline;
    procedure setPDSEL1; inline;
    procedure setRTSMD; inline;
    procedure setRXINV; inline;
    procedure setSIDL; inline;
    procedure setSTSEL; inline;
    procedure setUARTEN; inline;
    procedure setUEN0; inline;
    procedure setUEN1; inline;
    procedure setUSIDL; inline;
    procedure setWAKE; inline;
    property ABAUD : TBits_1 read getABAUD write setABAUD;
    property BRGH : TBits_1 read getBRGH write setBRGH;
    property IREN : TBits_1 read getIREN write setIREN;
    property LPBACK : TBits_1 read getLPBACK write setLPBACK;
    property ON : TBits_1 read getON write setON;
    property PDSEL : TBits_2 read getPDSEL write setPDSEL;
    property PDSEL0 : TBits_1 read getPDSEL0 write setPDSEL0;
    property PDSEL1 : TBits_1 read getPDSEL1 write setPDSEL1;
    property RTSMD : TBits_1 read getRTSMD write setRTSMD;
    property RXINV : TBits_1 read getRXINV write setRXINV;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property STSEL : TBits_1 read getSTSEL write setSTSEL;
    property UARTEN : TBits_1 read getUARTEN write setUARTEN;
    property UEN : TBits_2 read getUEN write setUEN;
    property UEN0 : TBits_1 read getUEN0 write setUEN0;
    property UEN1 : TBits_1 read getUEN1 write setUEN1;
    property USIDL : TBits_1 read getUSIDL write setUSIDL;
    property WAKE : TBits_1 read getWAKE write setWAKE;
    property w : TBits_32 read getw write setw;
  end;
  TUART2_U2STA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
  TUART2_U3ASTA = record
  private
    function  getADDEN : TBits_1; inline;
    function  getADDR : TBits_8; inline;
    function  getADM_EN : TBits_1; inline;
    function  getFERR : TBits_1; inline;
    function  getOERR : TBits_1; inline;
    function  getPERR : TBits_1; inline;
    function  getRIDLE : TBits_1; inline;
    function  getTRMT : TBits_1; inline;
    function  getURXDA : TBits_1; inline;
    function  getURXEN : TBits_1; inline;
    function  getURXISEL : TBits_2; inline;
    function  getURXISEL0 : TBits_1; inline;
    function  getURXISEL1 : TBits_1; inline;
    function  getUTXBF : TBits_1; inline;
    function  getUTXBRK : TBits_1; inline;
    function  getUTXEN : TBits_1; inline;
    function  getUTXINV : TBits_1; inline;
    function  getUTXISEL : TBits_2; inline;
    function  getUTXISEL0 : TBits_1; inline;
    function  getUTXISEL1 : TBits_1; inline;
    function  getUTXSEL : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setADDEN(thebits : TBits_1); inline;
    procedure setADDR(thebits : TBits_8); inline;
    procedure setADM_EN(thebits : TBits_1); inline;
    procedure setFERR(thebits : TBits_1); inline;
    procedure setOERR(thebits : TBits_1); inline;
    procedure setPERR(thebits : TBits_1); inline;
    procedure setRIDLE(thebits : TBits_1); inline;
    procedure setTRMT(thebits : TBits_1); inline;
    procedure setURXDA(thebits : TBits_1); inline;
    procedure setURXEN(thebits : TBits_1); inline;
    procedure setURXISEL(thebits : TBits_2); inline;
    procedure setURXISEL0(thebits : TBits_1); inline;
    procedure setURXISEL1(thebits : TBits_1); inline;
    procedure setUTXBF(thebits : TBits_1); inline;
    procedure setUTXBRK(thebits : TBits_1); inline;
    procedure setUTXEN(thebits : TBits_1); inline;
    procedure setUTXINV(thebits : TBits_1); inline;
    procedure setUTXISEL(thebits : TBits_2); inline;
    procedure setUTXISEL0(thebits : TBits_1); inline;
    procedure setUTXISEL1(thebits : TBits_1); inline;
    procedure setUTXSEL(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADDEN; inline;
    procedure clearADM_EN; inline;
    procedure clearFERR; inline;
    procedure clearOERR; inline;
    procedure clearPERR; inline;
    procedure clearRIDLE; inline;
    procedure clearTRMT; inline;
    procedure clearURXDA; inline;
    procedure clearURXEN; inline;
    procedure clearURXISEL0; inline;
    procedure clearURXISEL1; inline;
    procedure clearUTXBF; inline;
    procedure clearUTXBRK; inline;
    procedure clearUTXEN; inline;
    procedure clearUTXINV; inline;
    procedure clearUTXISEL0; inline;
    procedure clearUTXISEL1; inline;
    procedure setADDEN; inline;
    procedure setADM_EN; inline;
    procedure setFERR; inline;
    procedure setOERR; inline;
    procedure setPERR; inline;
    procedure setRIDLE; inline;
    procedure setTRMT; inline;
    procedure setURXDA; inline;
    procedure setURXEN; inline;
    procedure setURXISEL0; inline;
    procedure setURXISEL1; inline;
    procedure setUTXBF; inline;
    procedure setUTXBRK; inline;
    procedure setUTXEN; inline;
    procedure setUTXINV; inline;
    procedure setUTXISEL0; inline;
    procedure setUTXISEL1; inline;
    property ADDEN : TBits_1 read getADDEN write setADDEN;
    property ADDR : TBits_8 read getADDR write setADDR;
    property ADM_EN : TBits_1 read getADM_EN write setADM_EN;
    property FERR : TBits_1 read getFERR write setFERR;
    property OERR : TBits_1 read getOERR write setOERR;
    property PERR : TBits_1 read getPERR write setPERR;
    property RIDLE : TBits_1 read getRIDLE write setRIDLE;
    property TRMT : TBits_1 read getTRMT write setTRMT;
    property URXDA : TBits_1 read getURXDA write setURXDA;
    property URXEN : TBits_1 read getURXEN write setURXEN;
    property URXISEL : TBits_2 read getURXISEL write setURXISEL;
    property URXISEL0 : TBits_1 read getURXISEL0 write setURXISEL0;
    property URXISEL1 : TBits_1 read getURXISEL1 write setURXISEL1;
    property UTXBF : TBits_1 read getUTXBF write setUTXBF;
    property UTXBRK : TBits_1 read getUTXBRK write setUTXBRK;
    property UTXEN : TBits_1 read getUTXEN write setUTXEN;
    property UTXINV : TBits_1 read getUTXINV write setUTXINV;
    property UTXISEL : TBits_2 read getUTXISEL write setUTXISEL;
    property UTXISEL0 : TBits_1 read getUTXISEL0 write setUTXISEL0;
    property UTXISEL1 : TBits_1 read getUTXISEL1 write setUTXISEL1;
    property UTXSEL : TBits_2 read getUTXSEL write setUTXSEL;
    property w : TBits_32 read getw write setw;
  end;
type
  TUART2Registers = record
    U2MODEbits : TUART2_U2MODE;
    U2MODE : longWord;
    U3AMODEbits : TUART2_U3AMODE;
    U3AMODE : longWord;
    U2MODECLR : longWord;
    U3AMODECLR : longWord;
    U2MODESET : longWord;
    U3AMODESET : longWord;
    U2MODEINV : longWord;
    U3AMODEINV : longWord;
    U2STAbits : TUART2_U2STA;
    U2STA : longWord;
    U3ASTAbits : TUART2_U3ASTA;
    U3ASTA : longWord;
    U2STACLR : longWord;
    U3ASTACLR : longWord;
    U2STASET : longWord;
    U3ASTASET : longWord;
    U2STAINV : longWord;
    U3ASTAINV : longWord;
    U2TXREG : longWord;
    U3ATXREG : longWord;
    U2RXREG : longWord;
    U3ARXREG : longWord;
    U2BRG : longWord;
    U3ABRG : longWord;
    U2BRGCLR : longWord;
    U3ABRGCLR : longWord;
    U2BRGSET : longWord;
    U3ABRGSET : longWord;
    U2BRGINV : longWord;
    U3ABRGINV : longWord;
  end;
  TPMP_PMCON = record
  private
    function  getADRMUX : TBits_2; inline;
    function  getADRMUX0 : TBits_1; inline;
    function  getADRMUX1 : TBits_1; inline;
    function  getALP : TBits_1; inline;
    function  getCS1P : TBits_1; inline;
    function  getCSF : TBits_2; inline;
    function  getCSF0 : TBits_1; inline;
    function  getCSF1 : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getPMPEN : TBits_1; inline;
    function  getPMPTTL : TBits_1; inline;
    function  getPSIDL : TBits_1; inline;
    function  getPTRDEN : TBits_1; inline;
    function  getPTWREN : TBits_1; inline;
    function  getRDSP : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getWRSP : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setADRMUX(thebits : TBits_2); inline;
    procedure setADRMUX0(thebits : TBits_1); inline;
    procedure setADRMUX1(thebits : TBits_1); inline;
    procedure setALP(thebits : TBits_1); inline;
    procedure setCS1P(thebits : TBits_1); inline;
    procedure setCSF(thebits : TBits_2); inline;
    procedure setCSF0(thebits : TBits_1); inline;
    procedure setCSF1(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setPMPEN(thebits : TBits_1); inline;
    procedure setPMPTTL(thebits : TBits_1); inline;
    procedure setPSIDL(thebits : TBits_1); inline;
    procedure setPTRDEN(thebits : TBits_1); inline;
    procedure setPTWREN(thebits : TBits_1); inline;
    procedure setRDSP(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setWRSP(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADRMUX0; inline;
    procedure clearADRMUX1; inline;
    procedure clearALP; inline;
    procedure clearCS1P; inline;
    procedure clearCSF0; inline;
    procedure clearCSF1; inline;
    procedure clearON; inline;
    procedure clearPMPEN; inline;
    procedure clearPMPTTL; inline;
    procedure clearPSIDL; inline;
    procedure clearPTRDEN; inline;
    procedure clearPTWREN; inline;
    procedure clearRDSP; inline;
    procedure clearSIDL; inline;
    procedure clearWRSP; inline;
    procedure setADRMUX0; inline;
    procedure setADRMUX1; inline;
    procedure setALP; inline;
    procedure setCS1P; inline;
    procedure setCSF0; inline;
    procedure setCSF1; inline;
    procedure setON; inline;
    procedure setPMPEN; inline;
    procedure setPMPTTL; inline;
    procedure setPSIDL; inline;
    procedure setPTRDEN; inline;
    procedure setPTWREN; inline;
    procedure setRDSP; inline;
    procedure setSIDL; inline;
    procedure setWRSP; inline;
    property ADRMUX : TBits_2 read getADRMUX write setADRMUX;
    property ADRMUX0 : TBits_1 read getADRMUX0 write setADRMUX0;
    property ADRMUX1 : TBits_1 read getADRMUX1 write setADRMUX1;
    property ALP : TBits_1 read getALP write setALP;
    property CS1P : TBits_1 read getCS1P write setCS1P;
    property CSF : TBits_2 read getCSF write setCSF;
    property CSF0 : TBits_1 read getCSF0 write setCSF0;
    property CSF1 : TBits_1 read getCSF1 write setCSF1;
    property ON : TBits_1 read getON write setON;
    property PMPEN : TBits_1 read getPMPEN write setPMPEN;
    property PMPTTL : TBits_1 read getPMPTTL write setPMPTTL;
    property PSIDL : TBits_1 read getPSIDL write setPSIDL;
    property PTRDEN : TBits_1 read getPTRDEN write setPTRDEN;
    property PTWREN : TBits_1 read getPTWREN write setPTWREN;
    property RDSP : TBits_1 read getRDSP write setRDSP;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property WRSP : TBits_1 read getWRSP write setWRSP;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMMODE = record
  private
    function  getBUSY : TBits_1; inline;
    function  getINCM : TBits_2; inline;
    function  getINCM0 : TBits_1; inline;
    function  getINCM1 : TBits_1; inline;
    function  getIRQM : TBits_2; inline;
    function  getIRQM0 : TBits_1; inline;
    function  getIRQM1 : TBits_1; inline;
    function  getMODE : TBits_2; inline;
    function  getMODE0 : TBits_1; inline;
    function  getMODE1 : TBits_1; inline;
    function  getWAITB : TBits_2; inline;
    function  getWAITB0 : TBits_1; inline;
    function  getWAITB1 : TBits_1; inline;
    function  getWAITE : TBits_2; inline;
    function  getWAITE0 : TBits_1; inline;
    function  getWAITE1 : TBits_1; inline;
    function  getWAITM : TBits_4; inline;
    function  getWAITM0 : TBits_1; inline;
    function  getWAITM1 : TBits_1; inline;
    function  getWAITM2 : TBits_1; inline;
    function  getWAITM3 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBUSY(thebits : TBits_1); inline;
    procedure setINCM(thebits : TBits_2); inline;
    procedure setINCM0(thebits : TBits_1); inline;
    procedure setINCM1(thebits : TBits_1); inline;
    procedure setIRQM(thebits : TBits_2); inline;
    procedure setIRQM0(thebits : TBits_1); inline;
    procedure setIRQM1(thebits : TBits_1); inline;
    procedure setMODE(thebits : TBits_2); inline;
    procedure setMODE0(thebits : TBits_1); inline;
    procedure setMODE1(thebits : TBits_1); inline;
    procedure setWAITB(thebits : TBits_2); inline;
    procedure setWAITB0(thebits : TBits_1); inline;
    procedure setWAITB1(thebits : TBits_1); inline;
    procedure setWAITE(thebits : TBits_2); inline;
    procedure setWAITE0(thebits : TBits_1); inline;
    procedure setWAITE1(thebits : TBits_1); inline;
    procedure setWAITM(thebits : TBits_4); inline;
    procedure setWAITM0(thebits : TBits_1); inline;
    procedure setWAITM1(thebits : TBits_1); inline;
    procedure setWAITM2(thebits : TBits_1); inline;
    procedure setWAITM3(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBUSY; inline;
    procedure clearINCM0; inline;
    procedure clearINCM1; inline;
    procedure clearIRQM0; inline;
    procedure clearIRQM1; inline;
    procedure clearMODE0; inline;
    procedure clearMODE1; inline;
    procedure clearWAITB0; inline;
    procedure clearWAITB1; inline;
    procedure clearWAITE0; inline;
    procedure clearWAITE1; inline;
    procedure clearWAITM0; inline;
    procedure clearWAITM1; inline;
    procedure clearWAITM2; inline;
    procedure clearWAITM3; inline;
    procedure setBUSY; inline;
    procedure setINCM0; inline;
    procedure setINCM1; inline;
    procedure setIRQM0; inline;
    procedure setIRQM1; inline;
    procedure setMODE0; inline;
    procedure setMODE1; inline;
    procedure setWAITB0; inline;
    procedure setWAITB1; inline;
    procedure setWAITE0; inline;
    procedure setWAITE1; inline;
    procedure setWAITM0; inline;
    procedure setWAITM1; inline;
    procedure setWAITM2; inline;
    procedure setWAITM3; inline;
    property BUSY : TBits_1 read getBUSY write setBUSY;
    property INCM : TBits_2 read getINCM write setINCM;
    property INCM0 : TBits_1 read getINCM0 write setINCM0;
    property INCM1 : TBits_1 read getINCM1 write setINCM1;
    property IRQM : TBits_2 read getIRQM write setIRQM;
    property IRQM0 : TBits_1 read getIRQM0 write setIRQM0;
    property IRQM1 : TBits_1 read getIRQM1 write setIRQM1;
    property MODE : TBits_2 read getMODE write setMODE;
    property MODE0 : TBits_1 read getMODE0 write setMODE0;
    property MODE1 : TBits_1 read getMODE1 write setMODE1;
    property WAITB : TBits_2 read getWAITB write setWAITB;
    property WAITB0 : TBits_1 read getWAITB0 write setWAITB0;
    property WAITB1 : TBits_1 read getWAITB1 write setWAITB1;
    property WAITE : TBits_2 read getWAITE write setWAITE;
    property WAITE0 : TBits_1 read getWAITE0 write setWAITE0;
    property WAITE1 : TBits_1 read getWAITE1 write setWAITE1;
    property WAITM : TBits_4 read getWAITM write setWAITM;
    property WAITM0 : TBits_1 read getWAITM0 write setWAITM0;
    property WAITM1 : TBits_1 read getWAITM1 write setWAITM1;
    property WAITM2 : TBits_1 read getWAITM2 write setWAITM2;
    property WAITM3 : TBits_1 read getWAITM3 write setWAITM3;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMADDR = record
  private
    function  getADDR : TBits_14; inline;
    function  getCS : TBits_2; inline;
    function  getCS1 : TBits_1; inline;
    function  getPADDR : TBits_14; inline;
    function  getw : TBits_32; inline;
    procedure setADDR(thebits : TBits_14); inline;
    procedure setCS(thebits : TBits_2); inline;
    procedure setCS1(thebits : TBits_1); inline;
    procedure setPADDR(thebits : TBits_14); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCS1; inline;
    procedure setCS1; inline;
    property ADDR : TBits_14 read getADDR write setADDR;
    property CS : TBits_2 read getCS write setCS;
    property CS1 : TBits_1 read getCS1 write setCS1;
    property PADDR : TBits_14 read getPADDR write setPADDR;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMDOUT = record
  private
    function  getDATAOUT : TBits_32; inline;
    function  getw : TBits_32; inline;
    procedure setDATAOUT(thebits : TBits_32); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DATAOUT : TBits_32 read getDATAOUT write setDATAOUT;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMDIN = record
  private
    function  getDATAIN : TBits_32; inline;
    function  getw : TBits_32; inline;
    procedure setDATAIN(thebits : TBits_32); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DATAIN : TBits_32 read getDATAIN write setDATAIN;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMAEN = record
  private
    function  getPTEN : TBits_16; inline;
    function  getPTEN0 : TBits_1; inline;
    function  getPTEN1 : TBits_1; inline;
    function  getPTEN10 : TBits_1; inline;
    function  getPTEN11 : TBits_1; inline;
    function  getPTEN12 : TBits_1; inline;
    function  getPTEN13 : TBits_1; inline;
    function  getPTEN14 : TBits_1; inline;
    function  getPTEN15 : TBits_1; inline;
    function  getPTEN2 : TBits_1; inline;
    function  getPTEN3 : TBits_1; inline;
    function  getPTEN4 : TBits_1; inline;
    function  getPTEN5 : TBits_1; inline;
    function  getPTEN6 : TBits_1; inline;
    function  getPTEN7 : TBits_1; inline;
    function  getPTEN8 : TBits_1; inline;
    function  getPTEN9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setPTEN(thebits : TBits_16); inline;
    procedure setPTEN0(thebits : TBits_1); inline;
    procedure setPTEN1(thebits : TBits_1); inline;
    procedure setPTEN10(thebits : TBits_1); inline;
    procedure setPTEN11(thebits : TBits_1); inline;
    procedure setPTEN12(thebits : TBits_1); inline;
    procedure setPTEN13(thebits : TBits_1); inline;
    procedure setPTEN14(thebits : TBits_1); inline;
    procedure setPTEN15(thebits : TBits_1); inline;
    procedure setPTEN2(thebits : TBits_1); inline;
    procedure setPTEN3(thebits : TBits_1); inline;
    procedure setPTEN4(thebits : TBits_1); inline;
    procedure setPTEN5(thebits : TBits_1); inline;
    procedure setPTEN6(thebits : TBits_1); inline;
    procedure setPTEN7(thebits : TBits_1); inline;
    procedure setPTEN8(thebits : TBits_1); inline;
    procedure setPTEN9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearPTEN0; inline;
    procedure clearPTEN10; inline;
    procedure clearPTEN11; inline;
    procedure clearPTEN12; inline;
    procedure clearPTEN13; inline;
    procedure clearPTEN14; inline;
    procedure clearPTEN15; inline;
    procedure clearPTEN1; inline;
    procedure clearPTEN2; inline;
    procedure clearPTEN3; inline;
    procedure clearPTEN4; inline;
    procedure clearPTEN5; inline;
    procedure clearPTEN6; inline;
    procedure clearPTEN7; inline;
    procedure clearPTEN8; inline;
    procedure clearPTEN9; inline;
    procedure setPTEN0; inline;
    procedure setPTEN10; inline;
    procedure setPTEN11; inline;
    procedure setPTEN12; inline;
    procedure setPTEN13; inline;
    procedure setPTEN14; inline;
    procedure setPTEN15; inline;
    procedure setPTEN1; inline;
    procedure setPTEN2; inline;
    procedure setPTEN3; inline;
    procedure setPTEN4; inline;
    procedure setPTEN5; inline;
    procedure setPTEN6; inline;
    procedure setPTEN7; inline;
    procedure setPTEN8; inline;
    procedure setPTEN9; inline;
    property PTEN : TBits_16 read getPTEN write setPTEN;
    property PTEN0 : TBits_1 read getPTEN0 write setPTEN0;
    property PTEN1 : TBits_1 read getPTEN1 write setPTEN1;
    property PTEN10 : TBits_1 read getPTEN10 write setPTEN10;
    property PTEN11 : TBits_1 read getPTEN11 write setPTEN11;
    property PTEN12 : TBits_1 read getPTEN12 write setPTEN12;
    property PTEN13 : TBits_1 read getPTEN13 write setPTEN13;
    property PTEN14 : TBits_1 read getPTEN14 write setPTEN14;
    property PTEN15 : TBits_1 read getPTEN15 write setPTEN15;
    property PTEN2 : TBits_1 read getPTEN2 write setPTEN2;
    property PTEN3 : TBits_1 read getPTEN3 write setPTEN3;
    property PTEN4 : TBits_1 read getPTEN4 write setPTEN4;
    property PTEN5 : TBits_1 read getPTEN5 write setPTEN5;
    property PTEN6 : TBits_1 read getPTEN6 write setPTEN6;
    property PTEN7 : TBits_1 read getPTEN7 write setPTEN7;
    property PTEN8 : TBits_1 read getPTEN8 write setPTEN8;
    property PTEN9 : TBits_1 read getPTEN9 write setPTEN9;
    property w : TBits_32 read getw write setw;
  end;
  TPMP_PMSTAT = record
  private
    function  getIB0F : TBits_1; inline;
    function  getIB1F : TBits_1; inline;
    function  getIB2F : TBits_1; inline;
    function  getIB3F : TBits_1; inline;
    function  getIBF : TBits_1; inline;
    function  getIBOV : TBits_1; inline;
    function  getOB0E : TBits_1; inline;
    function  getOB1E : TBits_1; inline;
    function  getOB2E : TBits_1; inline;
    function  getOB3E : TBits_1; inline;
    function  getOBE : TBits_1; inline;
    function  getOBUF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setIB0F(thebits : TBits_1); inline;
    procedure setIB1F(thebits : TBits_1); inline;
    procedure setIB2F(thebits : TBits_1); inline;
    procedure setIB3F(thebits : TBits_1); inline;
    procedure setIBF(thebits : TBits_1); inline;
    procedure setIBOV(thebits : TBits_1); inline;
    procedure setOB0E(thebits : TBits_1); inline;
    procedure setOB1E(thebits : TBits_1); inline;
    procedure setOB2E(thebits : TBits_1); inline;
    procedure setOB3E(thebits : TBits_1); inline;
    procedure setOBE(thebits : TBits_1); inline;
    procedure setOBUF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearIB0F; inline;
    procedure clearIB1F; inline;
    procedure clearIB2F; inline;
    procedure clearIB3F; inline;
    procedure clearIBF; inline;
    procedure clearIBOV; inline;
    procedure clearOB0E; inline;
    procedure clearOB1E; inline;
    procedure clearOB2E; inline;
    procedure clearOB3E; inline;
    procedure clearOBE; inline;
    procedure clearOBUF; inline;
    procedure setIB0F; inline;
    procedure setIB1F; inline;
    procedure setIB2F; inline;
    procedure setIB3F; inline;
    procedure setIBF; inline;
    procedure setIBOV; inline;
    procedure setOB0E; inline;
    procedure setOB1E; inline;
    procedure setOB2E; inline;
    procedure setOB3E; inline;
    procedure setOBE; inline;
    procedure setOBUF; inline;
    property IB0F : TBits_1 read getIB0F write setIB0F;
    property IB1F : TBits_1 read getIB1F write setIB1F;
    property IB2F : TBits_1 read getIB2F write setIB2F;
    property IB3F : TBits_1 read getIB3F write setIB3F;
    property IBF : TBits_1 read getIBF write setIBF;
    property IBOV : TBits_1 read getIBOV write setIBOV;
    property OB0E : TBits_1 read getOB0E write setOB0E;
    property OB1E : TBits_1 read getOB1E write setOB1E;
    property OB2E : TBits_1 read getOB2E write setOB2E;
    property OB3E : TBits_1 read getOB3E write setOB3E;
    property OBE : TBits_1 read getOBE write setOBE;
    property OBUF : TBits_1 read getOBUF write setOBUF;
    property w : TBits_32 read getw write setw;
  end;
type
  TPMPRegisters = record
    PMCONbits : TPMP_PMCON;
    PMCON : longWord;
    PMCONCLR : longWord;
    PMCONSET : longWord;
    PMCONINV : longWord;
    PMMODEbits : TPMP_PMMODE;
    PMMODE : longWord;
    PMMODECLR : longWord;
    PMMODESET : longWord;
    PMMODEINV : longWord;
    PMADDRbits : TPMP_PMADDR;
    PMADDR : longWord;
    PMADDRCLR : longWord;
    PMADDRSET : longWord;
    PMADDRINV : longWord;
    PMDOUTbits : TPMP_PMDOUT;
    PMDOUT : longWord;
    PMDOUTCLR : longWord;
    PMDOUTSET : longWord;
    PMDOUTINV : longWord;
    PMDINbits : TPMP_PMDIN;
    PMDIN : longWord;
    PMDINCLR : longWord;
    PMDINSET : longWord;
    PMDININV : longWord;
    PMAENbits : TPMP_PMAEN;
    PMAEN : longWord;
    PMAENCLR : longWord;
    PMAENSET : longWord;
    PMAENINV : longWord;
    PMSTATbits : TPMP_PMSTAT;
    PMSTAT : longWord;
    PMSTATCLR : longWord;
    PMSTATSET : longWord;
    PMSTATINV : longWord;
  end;
  TADC10_AD1CON1 = record
  private
    function  getADON : TBits_1; inline;
    function  getADSIDL : TBits_1; inline;
    function  getASAM : TBits_1; inline;
    function  getCLRASAM : TBits_1; inline;
    function  getDONE : TBits_1; inline;
    function  getFORM : TBits_3; inline;
    function  getFORM0 : TBits_1; inline;
    function  getFORM1 : TBits_1; inline;
    function  getFORM2 : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSAMP : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getSSRC : TBits_3; inline;
    function  getSSRC0 : TBits_1; inline;
    function  getSSRC1 : TBits_1; inline;
    function  getSSRC2 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setADON(thebits : TBits_1); inline;
    procedure setADSIDL(thebits : TBits_1); inline;
    procedure setASAM(thebits : TBits_1); inline;
    procedure setCLRASAM(thebits : TBits_1); inline;
    procedure setDONE(thebits : TBits_1); inline;
    procedure setFORM(thebits : TBits_3); inline;
    procedure setFORM0(thebits : TBits_1); inline;
    procedure setFORM1(thebits : TBits_1); inline;
    procedure setFORM2(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSAMP(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setSSRC(thebits : TBits_3); inline;
    procedure setSSRC0(thebits : TBits_1); inline;
    procedure setSSRC1(thebits : TBits_1); inline;
    procedure setSSRC2(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADON; inline;
    procedure clearADSIDL; inline;
    procedure clearASAM; inline;
    procedure clearCLRASAM; inline;
    procedure clearDONE; inline;
    procedure clearFORM0; inline;
    procedure clearFORM1; inline;
    procedure clearFORM2; inline;
    procedure clearON; inline;
    procedure clearSAMP; inline;
    procedure clearSIDL; inline;
    procedure clearSSRC0; inline;
    procedure clearSSRC1; inline;
    procedure clearSSRC2; inline;
    procedure setADON; inline;
    procedure setADSIDL; inline;
    procedure setASAM; inline;
    procedure setCLRASAM; inline;
    procedure setDONE; inline;
    procedure setFORM0; inline;
    procedure setFORM1; inline;
    procedure setFORM2; inline;
    procedure setON; inline;
    procedure setSAMP; inline;
    procedure setSIDL; inline;
    procedure setSSRC0; inline;
    procedure setSSRC1; inline;
    procedure setSSRC2; inline;
    property ADON : TBits_1 read getADON write setADON;
    property ADSIDL : TBits_1 read getADSIDL write setADSIDL;
    property ASAM : TBits_1 read getASAM write setASAM;
    property CLRASAM : TBits_1 read getCLRASAM write setCLRASAM;
    property DONE : TBits_1 read getDONE write setDONE;
    property FORM : TBits_3 read getFORM write setFORM;
    property FORM0 : TBits_1 read getFORM0 write setFORM0;
    property FORM1 : TBits_1 read getFORM1 write setFORM1;
    property FORM2 : TBits_1 read getFORM2 write setFORM2;
    property ON : TBits_1 read getON write setON;
    property SAMP : TBits_1 read getSAMP write setSAMP;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property SSRC : TBits_3 read getSSRC write setSSRC;
    property SSRC0 : TBits_1 read getSSRC0 write setSSRC0;
    property SSRC1 : TBits_1 read getSSRC1 write setSSRC1;
    property SSRC2 : TBits_1 read getSSRC2 write setSSRC2;
    property w : TBits_32 read getw write setw;
  end;
  TADC10_AD1CON2 = record
  private
    function  getALTS : TBits_1; inline;
    function  getBUFM : TBits_1; inline;
    function  getBUFS : TBits_1; inline;
    function  getCSCNA : TBits_1; inline;
    function  getOFFCAL : TBits_1; inline;
    function  getSMPI : TBits_4; inline;
    function  getSMPI0 : TBits_1; inline;
    function  getSMPI1 : TBits_1; inline;
    function  getSMPI2 : TBits_1; inline;
    function  getSMPI3 : TBits_1; inline;
    function  getVCFG : TBits_3; inline;
    function  getVCFG0 : TBits_1; inline;
    function  getVCFG1 : TBits_1; inline;
    function  getVCFG2 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setALTS(thebits : TBits_1); inline;
    procedure setBUFM(thebits : TBits_1); inline;
    procedure setBUFS(thebits : TBits_1); inline;
    procedure setCSCNA(thebits : TBits_1); inline;
    procedure setOFFCAL(thebits : TBits_1); inline;
    procedure setSMPI(thebits : TBits_4); inline;
    procedure setSMPI0(thebits : TBits_1); inline;
    procedure setSMPI1(thebits : TBits_1); inline;
    procedure setSMPI2(thebits : TBits_1); inline;
    procedure setSMPI3(thebits : TBits_1); inline;
    procedure setVCFG(thebits : TBits_3); inline;
    procedure setVCFG0(thebits : TBits_1); inline;
    procedure setVCFG1(thebits : TBits_1); inline;
    procedure setVCFG2(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearALTS; inline;
    procedure clearBUFM; inline;
    procedure clearBUFS; inline;
    procedure clearCSCNA; inline;
    procedure clearOFFCAL; inline;
    procedure clearSMPI0; inline;
    procedure clearSMPI1; inline;
    procedure clearSMPI2; inline;
    procedure clearSMPI3; inline;
    procedure clearVCFG0; inline;
    procedure clearVCFG1; inline;
    procedure clearVCFG2; inline;
    procedure setALTS; inline;
    procedure setBUFM; inline;
    procedure setBUFS; inline;
    procedure setCSCNA; inline;
    procedure setOFFCAL; inline;
    procedure setSMPI0; inline;
    procedure setSMPI1; inline;
    procedure setSMPI2; inline;
    procedure setSMPI3; inline;
    procedure setVCFG0; inline;
    procedure setVCFG1; inline;
    procedure setVCFG2; inline;
    property ALTS : TBits_1 read getALTS write setALTS;
    property BUFM : TBits_1 read getBUFM write setBUFM;
    property BUFS : TBits_1 read getBUFS write setBUFS;
    property CSCNA : TBits_1 read getCSCNA write setCSCNA;
    property OFFCAL : TBits_1 read getOFFCAL write setOFFCAL;
    property SMPI : TBits_4 read getSMPI write setSMPI;
    property SMPI0 : TBits_1 read getSMPI0 write setSMPI0;
    property SMPI1 : TBits_1 read getSMPI1 write setSMPI1;
    property SMPI2 : TBits_1 read getSMPI2 write setSMPI2;
    property SMPI3 : TBits_1 read getSMPI3 write setSMPI3;
    property VCFG : TBits_3 read getVCFG write setVCFG;
    property VCFG0 : TBits_1 read getVCFG0 write setVCFG0;
    property VCFG1 : TBits_1 read getVCFG1 write setVCFG1;
    property VCFG2 : TBits_1 read getVCFG2 write setVCFG2;
    property w : TBits_32 read getw write setw;
  end;
  TADC10_AD1CON3 = record
  private
    function  getADCS : TBits_8; inline;
    function  getADCS0 : TBits_1; inline;
    function  getADCS1 : TBits_1; inline;
    function  getADCS2 : TBits_1; inline;
    function  getADCS3 : TBits_1; inline;
    function  getADCS4 : TBits_1; inline;
    function  getADCS5 : TBits_1; inline;
    function  getADCS6 : TBits_1; inline;
    function  getADCS7 : TBits_1; inline;
    function  getADRC : TBits_1; inline;
    function  getSAMC : TBits_5; inline;
    function  getSAMC0 : TBits_1; inline;
    function  getSAMC1 : TBits_1; inline;
    function  getSAMC2 : TBits_1; inline;
    function  getSAMC3 : TBits_1; inline;
    function  getSAMC4 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setADCS(thebits : TBits_8); inline;
    procedure setADCS0(thebits : TBits_1); inline;
    procedure setADCS1(thebits : TBits_1); inline;
    procedure setADCS2(thebits : TBits_1); inline;
    procedure setADCS3(thebits : TBits_1); inline;
    procedure setADCS4(thebits : TBits_1); inline;
    procedure setADCS5(thebits : TBits_1); inline;
    procedure setADCS6(thebits : TBits_1); inline;
    procedure setADCS7(thebits : TBits_1); inline;
    procedure setADRC(thebits : TBits_1); inline;
    procedure setSAMC(thebits : TBits_5); inline;
    procedure setSAMC0(thebits : TBits_1); inline;
    procedure setSAMC1(thebits : TBits_1); inline;
    procedure setSAMC2(thebits : TBits_1); inline;
    procedure setSAMC3(thebits : TBits_1); inline;
    procedure setSAMC4(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearADCS0; inline;
    procedure clearADCS1; inline;
    procedure clearADCS2; inline;
    procedure clearADCS3; inline;
    procedure clearADCS4; inline;
    procedure clearADCS5; inline;
    procedure clearADCS6; inline;
    procedure clearADCS7; inline;
    procedure clearADRC; inline;
    procedure clearSAMC0; inline;
    procedure clearSAMC1; inline;
    procedure clearSAMC2; inline;
    procedure clearSAMC3; inline;
    procedure clearSAMC4; inline;
    procedure setADCS0; inline;
    procedure setADCS1; inline;
    procedure setADCS2; inline;
    procedure setADCS3; inline;
    procedure setADCS4; inline;
    procedure setADCS5; inline;
    procedure setADCS6; inline;
    procedure setADCS7; inline;
    procedure setADRC; inline;
    procedure setSAMC0; inline;
    procedure setSAMC1; inline;
    procedure setSAMC2; inline;
    procedure setSAMC3; inline;
    procedure setSAMC4; inline;
    property ADCS : TBits_8 read getADCS write setADCS;
    property ADCS0 : TBits_1 read getADCS0 write setADCS0;
    property ADCS1 : TBits_1 read getADCS1 write setADCS1;
    property ADCS2 : TBits_1 read getADCS2 write setADCS2;
    property ADCS3 : TBits_1 read getADCS3 write setADCS3;
    property ADCS4 : TBits_1 read getADCS4 write setADCS4;
    property ADCS5 : TBits_1 read getADCS5 write setADCS5;
    property ADCS6 : TBits_1 read getADCS6 write setADCS6;
    property ADCS7 : TBits_1 read getADCS7 write setADCS7;
    property ADRC : TBits_1 read getADRC write setADRC;
    property SAMC : TBits_5 read getSAMC write setSAMC;
    property SAMC0 : TBits_1 read getSAMC0 write setSAMC0;
    property SAMC1 : TBits_1 read getSAMC1 write setSAMC1;
    property SAMC2 : TBits_1 read getSAMC2 write setSAMC2;
    property SAMC3 : TBits_1 read getSAMC3 write setSAMC3;
    property SAMC4 : TBits_1 read getSAMC4 write setSAMC4;
    property w : TBits_32 read getw write setw;
  end;
  TADC10_AD1CHS = record
  private
    function  getCH0NA : TBits_1; inline;
    function  getCH0NB : TBits_1; inline;
    function  getCH0SA : TBits_4; inline;
    function  getCH0SA0 : TBits_1; inline;
    function  getCH0SA1 : TBits_1; inline;
    function  getCH0SA2 : TBits_1; inline;
    function  getCH0SA3 : TBits_1; inline;
    function  getCH0SB : TBits_4; inline;
    function  getCH0SB0 : TBits_1; inline;
    function  getCH0SB1 : TBits_1; inline;
    function  getCH0SB2 : TBits_1; inline;
    function  getCH0SB3 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCH0NA(thebits : TBits_1); inline;
    procedure setCH0NB(thebits : TBits_1); inline;
    procedure setCH0SA(thebits : TBits_4); inline;
    procedure setCH0SA0(thebits : TBits_1); inline;
    procedure setCH0SA1(thebits : TBits_1); inline;
    procedure setCH0SA2(thebits : TBits_1); inline;
    procedure setCH0SA3(thebits : TBits_1); inline;
    procedure setCH0SB(thebits : TBits_4); inline;
    procedure setCH0SB0(thebits : TBits_1); inline;
    procedure setCH0SB1(thebits : TBits_1); inline;
    procedure setCH0SB2(thebits : TBits_1); inline;
    procedure setCH0SB3(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCH0NA; inline;
    procedure clearCH0NB; inline;
    procedure clearCH0SA0; inline;
    procedure clearCH0SA1; inline;
    procedure clearCH0SA2; inline;
    procedure clearCH0SA3; inline;
    procedure clearCH0SB0; inline;
    procedure clearCH0SB1; inline;
    procedure clearCH0SB2; inline;
    procedure clearCH0SB3; inline;
    procedure setCH0NA; inline;
    procedure setCH0NB; inline;
    procedure setCH0SA0; inline;
    procedure setCH0SA1; inline;
    procedure setCH0SA2; inline;
    procedure setCH0SA3; inline;
    procedure setCH0SB0; inline;
    procedure setCH0SB1; inline;
    procedure setCH0SB2; inline;
    procedure setCH0SB3; inline;
    property CH0NA : TBits_1 read getCH0NA write setCH0NA;
    property CH0NB : TBits_1 read getCH0NB write setCH0NB;
    property CH0SA : TBits_4 read getCH0SA write setCH0SA;
    property CH0SA0 : TBits_1 read getCH0SA0 write setCH0SA0;
    property CH0SA1 : TBits_1 read getCH0SA1 write setCH0SA1;
    property CH0SA2 : TBits_1 read getCH0SA2 write setCH0SA2;
    property CH0SA3 : TBits_1 read getCH0SA3 write setCH0SA3;
    property CH0SB : TBits_4 read getCH0SB write setCH0SB;
    property CH0SB0 : TBits_1 read getCH0SB0 write setCH0SB0;
    property CH0SB1 : TBits_1 read getCH0SB1 write setCH0SB1;
    property CH0SB2 : TBits_1 read getCH0SB2 write setCH0SB2;
    property CH0SB3 : TBits_1 read getCH0SB3 write setCH0SB3;
    property w : TBits_32 read getw write setw;
  end;
  TADC10_AD1CSSL = record
  private
    function  getCSSL : TBits_16; inline;
    function  getCSSL0 : TBits_1; inline;
    function  getCSSL1 : TBits_1; inline;
    function  getCSSL10 : TBits_1; inline;
    function  getCSSL11 : TBits_1; inline;
    function  getCSSL12 : TBits_1; inline;
    function  getCSSL13 : TBits_1; inline;
    function  getCSSL14 : TBits_1; inline;
    function  getCSSL15 : TBits_1; inline;
    function  getCSSL2 : TBits_1; inline;
    function  getCSSL3 : TBits_1; inline;
    function  getCSSL4 : TBits_1; inline;
    function  getCSSL5 : TBits_1; inline;
    function  getCSSL6 : TBits_1; inline;
    function  getCSSL7 : TBits_1; inline;
    function  getCSSL8 : TBits_1; inline;
    function  getCSSL9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCSSL(thebits : TBits_16); inline;
    procedure setCSSL0(thebits : TBits_1); inline;
    procedure setCSSL1(thebits : TBits_1); inline;
    procedure setCSSL10(thebits : TBits_1); inline;
    procedure setCSSL11(thebits : TBits_1); inline;
    procedure setCSSL12(thebits : TBits_1); inline;
    procedure setCSSL13(thebits : TBits_1); inline;
    procedure setCSSL14(thebits : TBits_1); inline;
    procedure setCSSL15(thebits : TBits_1); inline;
    procedure setCSSL2(thebits : TBits_1); inline;
    procedure setCSSL3(thebits : TBits_1); inline;
    procedure setCSSL4(thebits : TBits_1); inline;
    procedure setCSSL5(thebits : TBits_1); inline;
    procedure setCSSL6(thebits : TBits_1); inline;
    procedure setCSSL7(thebits : TBits_1); inline;
    procedure setCSSL8(thebits : TBits_1); inline;
    procedure setCSSL9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCSSL0; inline;
    procedure clearCSSL10; inline;
    procedure clearCSSL11; inline;
    procedure clearCSSL12; inline;
    procedure clearCSSL13; inline;
    procedure clearCSSL14; inline;
    procedure clearCSSL15; inline;
    procedure clearCSSL1; inline;
    procedure clearCSSL2; inline;
    procedure clearCSSL3; inline;
    procedure clearCSSL4; inline;
    procedure clearCSSL5; inline;
    procedure clearCSSL6; inline;
    procedure clearCSSL7; inline;
    procedure clearCSSL8; inline;
    procedure clearCSSL9; inline;
    procedure setCSSL0; inline;
    procedure setCSSL10; inline;
    procedure setCSSL11; inline;
    procedure setCSSL12; inline;
    procedure setCSSL13; inline;
    procedure setCSSL14; inline;
    procedure setCSSL15; inline;
    procedure setCSSL1; inline;
    procedure setCSSL2; inline;
    procedure setCSSL3; inline;
    procedure setCSSL4; inline;
    procedure setCSSL5; inline;
    procedure setCSSL6; inline;
    procedure setCSSL7; inline;
    procedure setCSSL8; inline;
    procedure setCSSL9; inline;
    property CSSL : TBits_16 read getCSSL write setCSSL;
    property CSSL0 : TBits_1 read getCSSL0 write setCSSL0;
    property CSSL1 : TBits_1 read getCSSL1 write setCSSL1;
    property CSSL10 : TBits_1 read getCSSL10 write setCSSL10;
    property CSSL11 : TBits_1 read getCSSL11 write setCSSL11;
    property CSSL12 : TBits_1 read getCSSL12 write setCSSL12;
    property CSSL13 : TBits_1 read getCSSL13 write setCSSL13;
    property CSSL14 : TBits_1 read getCSSL14 write setCSSL14;
    property CSSL15 : TBits_1 read getCSSL15 write setCSSL15;
    property CSSL2 : TBits_1 read getCSSL2 write setCSSL2;
    property CSSL3 : TBits_1 read getCSSL3 write setCSSL3;
    property CSSL4 : TBits_1 read getCSSL4 write setCSSL4;
    property CSSL5 : TBits_1 read getCSSL5 write setCSSL5;
    property CSSL6 : TBits_1 read getCSSL6 write setCSSL6;
    property CSSL7 : TBits_1 read getCSSL7 write setCSSL7;
    property CSSL8 : TBits_1 read getCSSL8 write setCSSL8;
    property CSSL9 : TBits_1 read getCSSL9 write setCSSL9;
    property w : TBits_32 read getw write setw;
  end;
type
  TADC10Registers = record
    AD1CON1bits : TADC10_AD1CON1;
    AD1CON1 : longWord;
    AD1CON1CLR : longWord;
    AD1CON1SET : longWord;
    AD1CON1INV : longWord;
    AD1CON2bits : TADC10_AD1CON2;
    AD1CON2 : longWord;
    AD1CON2CLR : longWord;
    AD1CON2SET : longWord;
    AD1CON2INV : longWord;
    AD1CON3bits : TADC10_AD1CON3;
    AD1CON3 : longWord;
    AD1CON3CLR : longWord;
    AD1CON3SET : longWord;
    AD1CON3INV : longWord;
    AD1CHSbits : TADC10_AD1CHS;
    AD1CHS : longWord;
    AD1CHSCLR : longWord;
    AD1CHSSET : longWord;
    AD1CHSINV : longWord;
    AD1CSSLbits : TADC10_AD1CSSL;
    AD1CSSL : longWord;
    AD1CSSLCLR : longWord;
    AD1CSSLSET : longWord;
    AD1CSSLINV : longWord;
    ADC1BUF0 : longWord;
    ADC1BUF1 : longWord;
    ADC1BUF2 : longWord;
    ADC1BUF3 : longWord;
    ADC1BUF4 : longWord;
    ADC1BUF5 : longWord;
    ADC1BUF6 : longWord;
    ADC1BUF7 : longWord;
    ADC1BUF8 : longWord;
    ADC1BUF9 : longWord;
    ADC1BUFA : longWord;
    ADC1BUFB : longWord;
    ADC1BUFC : longWord;
    ADC1BUFD : longWord;
    ADC1BUFE : longWord;
    ADC1BUFF : longWord;
  end;
  TCVR_CVRCON = record
  private
    function  getCVR : TBits_4; inline;
    function  getCVR0 : TBits_1; inline;
    function  getCVR1 : TBits_1; inline;
    function  getCVR2 : TBits_1; inline;
    function  getCVR3 : TBits_1; inline;
    function  getCVROE : TBits_1; inline;
    function  getCVRR : TBits_1; inline;
    function  getCVRSS : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCVR(thebits : TBits_4); inline;
    procedure setCVR0(thebits : TBits_1); inline;
    procedure setCVR1(thebits : TBits_1); inline;
    procedure setCVR2(thebits : TBits_1); inline;
    procedure setCVR3(thebits : TBits_1); inline;
    procedure setCVROE(thebits : TBits_1); inline;
    procedure setCVRR(thebits : TBits_1); inline;
    procedure setCVRSS(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCVR0; inline;
    procedure clearCVR1; inline;
    procedure clearCVR2; inline;
    procedure clearCVR3; inline;
    procedure clearCVROE; inline;
    procedure clearCVRR; inline;
    procedure clearCVRSS; inline;
    procedure clearON; inline;
    procedure setCVR0; inline;
    procedure setCVR1; inline;
    procedure setCVR2; inline;
    procedure setCVR3; inline;
    procedure setCVROE; inline;
    procedure setCVRR; inline;
    procedure setCVRSS; inline;
    procedure setON; inline;
    property CVR : TBits_4 read getCVR write setCVR;
    property CVR0 : TBits_1 read getCVR0 write setCVR0;
    property CVR1 : TBits_1 read getCVR1 write setCVR1;
    property CVR2 : TBits_1 read getCVR2 write setCVR2;
    property CVR3 : TBits_1 read getCVR3 write setCVR3;
    property CVROE : TBits_1 read getCVROE write setCVROE;
    property CVRR : TBits_1 read getCVRR write setCVRR;
    property CVRSS : TBits_1 read getCVRSS write setCVRSS;
    property ON : TBits_1 read getON write setON;
    property w : TBits_32 read getw write setw;
  end;
type
  TCVRRegisters = record
    CVRCONbits : TCVR_CVRCON;
    CVRCON : longWord;
    CVRCONCLR : longWord;
    CVRCONSET : longWord;
    CVRCONINV : longWord;
  end;
  TCMP_CM1CON = record
  private
    function  getCCH : TBits_2; inline;
    function  getCCH0 : TBits_1; inline;
    function  getCCH1 : TBits_1; inline;
    function  getCOE : TBits_1; inline;
    function  getCOUT : TBits_1; inline;
    function  getCPOL : TBits_1; inline;
    function  getCREF : TBits_1; inline;
    function  getEVPOL : TBits_2; inline;
    function  getEVPOL0 : TBits_1; inline;
    function  getEVPOL1 : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCCH(thebits : TBits_2); inline;
    procedure setCCH0(thebits : TBits_1); inline;
    procedure setCCH1(thebits : TBits_1); inline;
    procedure setCOE(thebits : TBits_1); inline;
    procedure setCOUT(thebits : TBits_1); inline;
    procedure setCPOL(thebits : TBits_1); inline;
    procedure setCREF(thebits : TBits_1); inline;
    procedure setEVPOL(thebits : TBits_2); inline;
    procedure setEVPOL0(thebits : TBits_1); inline;
    procedure setEVPOL1(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCCH0; inline;
    procedure clearCCH1; inline;
    procedure clearCOE; inline;
    procedure clearCOUT; inline;
    procedure clearCPOL; inline;
    procedure clearCREF; inline;
    procedure clearEVPOL0; inline;
    procedure clearEVPOL1; inline;
    procedure clearON; inline;
    procedure setCCH0; inline;
    procedure setCCH1; inline;
    procedure setCOE; inline;
    procedure setCOUT; inline;
    procedure setCPOL; inline;
    procedure setCREF; inline;
    procedure setEVPOL0; inline;
    procedure setEVPOL1; inline;
    procedure setON; inline;
    property CCH : TBits_2 read getCCH write setCCH;
    property CCH0 : TBits_1 read getCCH0 write setCCH0;
    property CCH1 : TBits_1 read getCCH1 write setCCH1;
    property COE : TBits_1 read getCOE write setCOE;
    property COUT : TBits_1 read getCOUT write setCOUT;
    property CPOL : TBits_1 read getCPOL write setCPOL;
    property CREF : TBits_1 read getCREF write setCREF;
    property EVPOL : TBits_2 read getEVPOL write setEVPOL;
    property EVPOL0 : TBits_1 read getEVPOL0 write setEVPOL0;
    property EVPOL1 : TBits_1 read getEVPOL1 write setEVPOL1;
    property ON : TBits_1 read getON write setON;
    property w : TBits_32 read getw write setw;
  end;
  TCMP_CM2CON = record
  private
    function  getCCH : TBits_2; inline;
    function  getCCH0 : TBits_1; inline;
    function  getCCH1 : TBits_1; inline;
    function  getCOE : TBits_1; inline;
    function  getCOUT : TBits_1; inline;
    function  getCPOL : TBits_1; inline;
    function  getCREF : TBits_1; inline;
    function  getEVPOL : TBits_2; inline;
    function  getEVPOL0 : TBits_1; inline;
    function  getEVPOL1 : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCCH(thebits : TBits_2); inline;
    procedure setCCH0(thebits : TBits_1); inline;
    procedure setCCH1(thebits : TBits_1); inline;
    procedure setCOE(thebits : TBits_1); inline;
    procedure setCOUT(thebits : TBits_1); inline;
    procedure setCPOL(thebits : TBits_1); inline;
    procedure setCREF(thebits : TBits_1); inline;
    procedure setEVPOL(thebits : TBits_2); inline;
    procedure setEVPOL0(thebits : TBits_1); inline;
    procedure setEVPOL1(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCCH0; inline;
    procedure clearCCH1; inline;
    procedure clearCOE; inline;
    procedure clearCOUT; inline;
    procedure clearCPOL; inline;
    procedure clearCREF; inline;
    procedure clearEVPOL0; inline;
    procedure clearEVPOL1; inline;
    procedure clearON; inline;
    procedure setCCH0; inline;
    procedure setCCH1; inline;
    procedure setCOE; inline;
    procedure setCOUT; inline;
    procedure setCPOL; inline;
    procedure setCREF; inline;
    procedure setEVPOL0; inline;
    procedure setEVPOL1; inline;
    procedure setON; inline;
    property CCH : TBits_2 read getCCH write setCCH;
    property CCH0 : TBits_1 read getCCH0 write setCCH0;
    property CCH1 : TBits_1 read getCCH1 write setCCH1;
    property COE : TBits_1 read getCOE write setCOE;
    property COUT : TBits_1 read getCOUT write setCOUT;
    property CPOL : TBits_1 read getCPOL write setCPOL;
    property CREF : TBits_1 read getCREF write setCREF;
    property EVPOL : TBits_2 read getEVPOL write setEVPOL;
    property EVPOL0 : TBits_1 read getEVPOL0 write setEVPOL0;
    property EVPOL1 : TBits_1 read getEVPOL1 write setEVPOL1;
    property ON : TBits_1 read getON write setON;
    property w : TBits_32 read getw write setw;
  end;
  TCMP_CM3CON = record
  private
    function  getCCH : TBits_2; inline;
    function  getCCH0 : TBits_1; inline;
    function  getCCH1 : TBits_1; inline;
    function  getCOE : TBits_1; inline;
    function  getCOUT : TBits_1; inline;
    function  getCPOL : TBits_1; inline;
    function  getCREF : TBits_1; inline;
    function  getEVPOL : TBits_2; inline;
    function  getEVPOL0 : TBits_1; inline;
    function  getEVPOL1 : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCCH(thebits : TBits_2); inline;
    procedure setCCH0(thebits : TBits_1); inline;
    procedure setCCH1(thebits : TBits_1); inline;
    procedure setCOE(thebits : TBits_1); inline;
    procedure setCOUT(thebits : TBits_1); inline;
    procedure setCPOL(thebits : TBits_1); inline;
    procedure setCREF(thebits : TBits_1); inline;
    procedure setEVPOL(thebits : TBits_2); inline;
    procedure setEVPOL0(thebits : TBits_1); inline;
    procedure setEVPOL1(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCCH0; inline;
    procedure clearCCH1; inline;
    procedure clearCOE; inline;
    procedure clearCOUT; inline;
    procedure clearCPOL; inline;
    procedure clearCREF; inline;
    procedure clearEVPOL0; inline;
    procedure clearEVPOL1; inline;
    procedure clearON; inline;
    procedure setCCH0; inline;
    procedure setCCH1; inline;
    procedure setCOE; inline;
    procedure setCOUT; inline;
    procedure setCPOL; inline;
    procedure setCREF; inline;
    procedure setEVPOL0; inline;
    procedure setEVPOL1; inline;
    procedure setON; inline;
    property CCH : TBits_2 read getCCH write setCCH;
    property CCH0 : TBits_1 read getCCH0 write setCCH0;
    property CCH1 : TBits_1 read getCCH1 write setCCH1;
    property COE : TBits_1 read getCOE write setCOE;
    property COUT : TBits_1 read getCOUT write setCOUT;
    property CPOL : TBits_1 read getCPOL write setCPOL;
    property CREF : TBits_1 read getCREF write setCREF;
    property EVPOL : TBits_2 read getEVPOL write setEVPOL;
    property EVPOL0 : TBits_1 read getEVPOL0 write setEVPOL0;
    property EVPOL1 : TBits_1 read getEVPOL1 write setEVPOL1;
    property ON : TBits_1 read getON write setON;
    property w : TBits_32 read getw write setw;
  end;
  TCMP_CMSTAT = record
  private
    function  getC1OUT : TBits_1; inline;
    function  getC2OUT : TBits_1; inline;
    function  getC3OUT : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setC1OUT(thebits : TBits_1); inline;
    procedure setC2OUT(thebits : TBits_1); inline;
    procedure setC3OUT(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearC1OUT; inline;
    procedure clearC2OUT; inline;
    procedure clearC3OUT; inline;
    procedure clearSIDL; inline;
    procedure setC1OUT; inline;
    procedure setC2OUT; inline;
    procedure setC3OUT; inline;
    procedure setSIDL; inline;
    property C1OUT : TBits_1 read getC1OUT write setC1OUT;
    property C2OUT : TBits_1 read getC2OUT write setC2OUT;
    property C3OUT : TBits_1 read getC3OUT write setC3OUT;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TCMP_CTMUCON = record
  private
    function  getCTMUSIDL : TBits_1; inline;
    function  getCTTRIG : TBits_1; inline;
    function  getEDG1MOD : TBits_1; inline;
    function  getEDG1POL : TBits_1; inline;
    function  getEDG1SEL : TBits_4; inline;
    function  getEDG1STAT : TBits_1; inline;
    function  getEDG2MOD : TBits_1; inline;
    function  getEDG2POL : TBits_1; inline;
    function  getEDG2SEL : TBits_4; inline;
    function  getEDG2STAT : TBits_1; inline;
    function  getEDGEN : TBits_1; inline;
    function  getEDGSEQEN : TBits_1; inline;
    function  getIDISSEN : TBits_1; inline;
    function  getIRNG : TBits_2; inline;
    function  getITRIM : TBits_6; inline;
    function  getON : TBits_1; inline;
    function  getTGEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCTMUSIDL(thebits : TBits_1); inline;
    procedure setCTTRIG(thebits : TBits_1); inline;
    procedure setEDG1MOD(thebits : TBits_1); inline;
    procedure setEDG1POL(thebits : TBits_1); inline;
    procedure setEDG1SEL(thebits : TBits_4); inline;
    procedure setEDG1STAT(thebits : TBits_1); inline;
    procedure setEDG2MOD(thebits : TBits_1); inline;
    procedure setEDG2POL(thebits : TBits_1); inline;
    procedure setEDG2SEL(thebits : TBits_4); inline;
    procedure setEDG2STAT(thebits : TBits_1); inline;
    procedure setEDGEN(thebits : TBits_1); inline;
    procedure setEDGSEQEN(thebits : TBits_1); inline;
    procedure setIDISSEN(thebits : TBits_1); inline;
    procedure setIRNG(thebits : TBits_2); inline;
    procedure setITRIM(thebits : TBits_6); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setTGEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCTMUSIDL; inline;
    procedure clearCTTRIG; inline;
    procedure clearEDG1MOD; inline;
    procedure clearEDG1POL; inline;
    procedure clearEDG1STAT; inline;
    procedure clearEDG2MOD; inline;
    procedure clearEDG2POL; inline;
    procedure clearEDG2STAT; inline;
    procedure clearEDGEN; inline;
    procedure clearEDGSEQEN; inline;
    procedure clearIDISSEN; inline;
    procedure clearON; inline;
    procedure clearTGEN; inline;
    procedure setCTMUSIDL; inline;
    procedure setCTTRIG; inline;
    procedure setEDG1MOD; inline;
    procedure setEDG1POL; inline;
    procedure setEDG1STAT; inline;
    procedure setEDG2MOD; inline;
    procedure setEDG2POL; inline;
    procedure setEDG2STAT; inline;
    procedure setEDGEN; inline;
    procedure setEDGSEQEN; inline;
    procedure setIDISSEN; inline;
    procedure setON; inline;
    procedure setTGEN; inline;
    property CTMUSIDL : TBits_1 read getCTMUSIDL write setCTMUSIDL;
    property CTTRIG : TBits_1 read getCTTRIG write setCTTRIG;
    property EDG1MOD : TBits_1 read getEDG1MOD write setEDG1MOD;
    property EDG1POL : TBits_1 read getEDG1POL write setEDG1POL;
    property EDG1SEL : TBits_4 read getEDG1SEL write setEDG1SEL;
    property EDG1STAT : TBits_1 read getEDG1STAT write setEDG1STAT;
    property EDG2MOD : TBits_1 read getEDG2MOD write setEDG2MOD;
    property EDG2POL : TBits_1 read getEDG2POL write setEDG2POL;
    property EDG2SEL : TBits_4 read getEDG2SEL write setEDG2SEL;
    property EDG2STAT : TBits_1 read getEDG2STAT write setEDG2STAT;
    property EDGEN : TBits_1 read getEDGEN write setEDGEN;
    property EDGSEQEN : TBits_1 read getEDGSEQEN write setEDGSEQEN;
    property IDISSEN : TBits_1 read getIDISSEN write setIDISSEN;
    property IRNG : TBits_2 read getIRNG write setIRNG;
    property ITRIM : TBits_6 read getITRIM write setITRIM;
    property ON : TBits_1 read getON write setON;
    property TGEN : TBits_1 read getTGEN write setTGEN;
    property w : TBits_32 read getw write setw;
  end;
type
  TCMPRegisters = record
    CM1CONbits : TCMP_CM1CON;
    CM1CON : longWord;
    CM1CONCLR : longWord;
    CM1CONSET : longWord;
    CM1CONINV : longWord;
    CM2CONbits : TCMP_CM2CON;
    CM2CON : longWord;
    CM2CONCLR : longWord;
    CM2CONSET : longWord;
    CM2CONINV : longWord;
    CM3CONbits : TCMP_CM3CON;
    CM3CON : longWord;
    CM3CONCLR : longWord;
    CM3CONSET : longWord;
    CM3CONINV : longWord;
    CMSTATbits : TCMP_CMSTAT;
    CMSTAT : longWord;
    CMSTATCLR : longWord;
    CMSTATSET : longWord;
    CMSTATINV : longWord;
    CTMUCONbits : TCMP_CTMUCON;
    CTMUCON : longWord;
    CTMUCONCLR : longWord;
    CTMUCONSET : longWord;
    CTMUCONINV : longWord;
  end;
  TOSC_OSCCON = record
  private
    function  getCF : TBits_1; inline;
    function  getCLKLOCK : TBits_1; inline;
    function  getCOSC : TBits_3; inline;
    function  getCOSC0 : TBits_1; inline;
    function  getCOSC1 : TBits_1; inline;
    function  getCOSC2 : TBits_1; inline;
    function  getFRCDIV : TBits_3; inline;
    function  getFRCDIV0 : TBits_1; inline;
    function  getFRCDIV1 : TBits_1; inline;
    function  getFRCDIV2 : TBits_1; inline;
    function  getNOSC : TBits_3; inline;
    function  getNOSC0 : TBits_1; inline;
    function  getNOSC1 : TBits_1; inline;
    function  getNOSC2 : TBits_1; inline;
    function  getOSWEN : TBits_1; inline;
    function  getPBDIV : TBits_2; inline;
    function  getPBDIV0 : TBits_1; inline;
    function  getPBDIV1 : TBits_1; inline;
    function  getPBDIVRDY : TBits_1; inline;
    function  getPLLMULT : TBits_3; inline;
    function  getPLLMULT0 : TBits_1; inline;
    function  getPLLMULT1 : TBits_1; inline;
    function  getPLLMULT2 : TBits_1; inline;
    function  getPLLODIV : TBits_3; inline;
    function  getPLLODIV0 : TBits_1; inline;
    function  getPLLODIV1 : TBits_1; inline;
    function  getPLLODIV2 : TBits_1; inline;
    function  getSLOCK : TBits_1; inline;
    function  getSLPEN : TBits_1; inline;
    function  getSOSCEN : TBits_1; inline;
    function  getSOSCRDY : TBits_1; inline;
    function  getUFRCEN : TBits_1; inline;
    function  getULOCK : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCF(thebits : TBits_1); inline;
    procedure setCLKLOCK(thebits : TBits_1); inline;
    procedure setCOSC(thebits : TBits_3); inline;
    procedure setCOSC0(thebits : TBits_1); inline;
    procedure setCOSC1(thebits : TBits_1); inline;
    procedure setCOSC2(thebits : TBits_1); inline;
    procedure setFRCDIV(thebits : TBits_3); inline;
    procedure setFRCDIV0(thebits : TBits_1); inline;
    procedure setFRCDIV1(thebits : TBits_1); inline;
    procedure setFRCDIV2(thebits : TBits_1); inline;
    procedure setNOSC(thebits : TBits_3); inline;
    procedure setNOSC0(thebits : TBits_1); inline;
    procedure setNOSC1(thebits : TBits_1); inline;
    procedure setNOSC2(thebits : TBits_1); inline;
    procedure setOSWEN(thebits : TBits_1); inline;
    procedure setPBDIV(thebits : TBits_2); inline;
    procedure setPBDIV0(thebits : TBits_1); inline;
    procedure setPBDIV1(thebits : TBits_1); inline;
    procedure setPBDIVRDY(thebits : TBits_1); inline;
    procedure setPLLMULT(thebits : TBits_3); inline;
    procedure setPLLMULT0(thebits : TBits_1); inline;
    procedure setPLLMULT1(thebits : TBits_1); inline;
    procedure setPLLMULT2(thebits : TBits_1); inline;
    procedure setPLLODIV(thebits : TBits_3); inline;
    procedure setPLLODIV0(thebits : TBits_1); inline;
    procedure setPLLODIV1(thebits : TBits_1); inline;
    procedure setPLLODIV2(thebits : TBits_1); inline;
    procedure setSLOCK(thebits : TBits_1); inline;
    procedure setSLPEN(thebits : TBits_1); inline;
    procedure setSOSCEN(thebits : TBits_1); inline;
    procedure setSOSCRDY(thebits : TBits_1); inline;
    procedure setUFRCEN(thebits : TBits_1); inline;
    procedure setULOCK(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCF; inline;
    procedure clearCLKLOCK; inline;
    procedure clearCOSC0; inline;
    procedure clearCOSC1; inline;
    procedure clearCOSC2; inline;
    procedure clearFRCDIV0; inline;
    procedure clearFRCDIV1; inline;
    procedure clearFRCDIV2; inline;
    procedure clearNOSC0; inline;
    procedure clearNOSC1; inline;
    procedure clearNOSC2; inline;
    procedure clearOSWEN; inline;
    procedure clearPBDIV0; inline;
    procedure clearPBDIV1; inline;
    procedure clearPBDIVRDY; inline;
    procedure clearPLLMULT0; inline;
    procedure clearPLLMULT1; inline;
    procedure clearPLLMULT2; inline;
    procedure clearPLLODIV0; inline;
    procedure clearPLLODIV1; inline;
    procedure clearPLLODIV2; inline;
    procedure clearSLOCK; inline;
    procedure clearSLPEN; inline;
    procedure clearSOSCEN; inline;
    procedure clearSOSCRDY; inline;
    procedure clearUFRCEN; inline;
    procedure clearULOCK; inline;
    procedure setCF; inline;
    procedure setCLKLOCK; inline;
    procedure setCOSC0; inline;
    procedure setCOSC1; inline;
    procedure setCOSC2; inline;
    procedure setFRCDIV0; inline;
    procedure setFRCDIV1; inline;
    procedure setFRCDIV2; inline;
    procedure setNOSC0; inline;
    procedure setNOSC1; inline;
    procedure setNOSC2; inline;
    procedure setOSWEN; inline;
    procedure setPBDIV0; inline;
    procedure setPBDIV1; inline;
    procedure setPBDIVRDY; inline;
    procedure setPLLMULT0; inline;
    procedure setPLLMULT1; inline;
    procedure setPLLMULT2; inline;
    procedure setPLLODIV0; inline;
    procedure setPLLODIV1; inline;
    procedure setPLLODIV2; inline;
    procedure setSLOCK; inline;
    procedure setSLPEN; inline;
    procedure setSOSCEN; inline;
    procedure setSOSCRDY; inline;
    procedure setUFRCEN; inline;
    procedure setULOCK; inline;
    property CF : TBits_1 read getCF write setCF;
    property CLKLOCK : TBits_1 read getCLKLOCK write setCLKLOCK;
    property COSC : TBits_3 read getCOSC write setCOSC;
    property COSC0 : TBits_1 read getCOSC0 write setCOSC0;
    property COSC1 : TBits_1 read getCOSC1 write setCOSC1;
    property COSC2 : TBits_1 read getCOSC2 write setCOSC2;
    property FRCDIV : TBits_3 read getFRCDIV write setFRCDIV;
    property FRCDIV0 : TBits_1 read getFRCDIV0 write setFRCDIV0;
    property FRCDIV1 : TBits_1 read getFRCDIV1 write setFRCDIV1;
    property FRCDIV2 : TBits_1 read getFRCDIV2 write setFRCDIV2;
    property NOSC : TBits_3 read getNOSC write setNOSC;
    property NOSC0 : TBits_1 read getNOSC0 write setNOSC0;
    property NOSC1 : TBits_1 read getNOSC1 write setNOSC1;
    property NOSC2 : TBits_1 read getNOSC2 write setNOSC2;
    property OSWEN : TBits_1 read getOSWEN write setOSWEN;
    property PBDIV : TBits_2 read getPBDIV write setPBDIV;
    property PBDIV0 : TBits_1 read getPBDIV0 write setPBDIV0;
    property PBDIV1 : TBits_1 read getPBDIV1 write setPBDIV1;
    property PBDIVRDY : TBits_1 read getPBDIVRDY write setPBDIVRDY;
    property PLLMULT : TBits_3 read getPLLMULT write setPLLMULT;
    property PLLMULT0 : TBits_1 read getPLLMULT0 write setPLLMULT0;
    property PLLMULT1 : TBits_1 read getPLLMULT1 write setPLLMULT1;
    property PLLMULT2 : TBits_1 read getPLLMULT2 write setPLLMULT2;
    property PLLODIV : TBits_3 read getPLLODIV write setPLLODIV;
    property PLLODIV0 : TBits_1 read getPLLODIV0 write setPLLODIV0;
    property PLLODIV1 : TBits_1 read getPLLODIV1 write setPLLODIV1;
    property PLLODIV2 : TBits_1 read getPLLODIV2 write setPLLODIV2;
    property SLOCK : TBits_1 read getSLOCK write setSLOCK;
    property SLPEN : TBits_1 read getSLPEN write setSLPEN;
    property SOSCEN : TBits_1 read getSOSCEN write setSOSCEN;
    property SOSCRDY : TBits_1 read getSOSCRDY write setSOSCRDY;
    property UFRCEN : TBits_1 read getUFRCEN write setUFRCEN;
    property ULOCK : TBits_1 read getULOCK write setULOCK;
    property w : TBits_32 read getw write setw;
  end;
  TOSC_OSCTUN = record
  private
    function  getTUN : TBits_6; inline;
    function  getTUN0 : TBits_1; inline;
    function  getTUN1 : TBits_1; inline;
    function  getTUN2 : TBits_1; inline;
    function  getTUN3 : TBits_1; inline;
    function  getTUN4 : TBits_1; inline;
    function  getTUN5 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTUN(thebits : TBits_6); inline;
    procedure setTUN0(thebits : TBits_1); inline;
    procedure setTUN1(thebits : TBits_1); inline;
    procedure setTUN2(thebits : TBits_1); inline;
    procedure setTUN3(thebits : TBits_1); inline;
    procedure setTUN4(thebits : TBits_1); inline;
    procedure setTUN5(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTUN0; inline;
    procedure clearTUN1; inline;
    procedure clearTUN2; inline;
    procedure clearTUN3; inline;
    procedure clearTUN4; inline;
    procedure clearTUN5; inline;
    procedure setTUN0; inline;
    procedure setTUN1; inline;
    procedure setTUN2; inline;
    procedure setTUN3; inline;
    procedure setTUN4; inline;
    procedure setTUN5; inline;
    property TUN : TBits_6 read getTUN write setTUN;
    property TUN0 : TBits_1 read getTUN0 write setTUN0;
    property TUN1 : TBits_1 read getTUN1 write setTUN1;
    property TUN2 : TBits_1 read getTUN2 write setTUN2;
    property TUN3 : TBits_1 read getTUN3 write setTUN3;
    property TUN4 : TBits_1 read getTUN4 write setTUN4;
    property TUN5 : TBits_1 read getTUN5 write setTUN5;
    property w : TBits_32 read getw write setw;
  end;
  TOSC_REFOCON = record
  private
    function  getACTIVE : TBits_1; inline;
    function  getDIVSWEN : TBits_1; inline;
    function  getOE : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getRODIV : TBits_15; inline;
    function  getROSEL : TBits_4; inline;
    function  getRSLP : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setACTIVE(thebits : TBits_1); inline;
    procedure setDIVSWEN(thebits : TBits_1); inline;
    procedure setOE(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setRODIV(thebits : TBits_15); inline;
    procedure setROSEL(thebits : TBits_4); inline;
    procedure setRSLP(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearACTIVE; inline;
    procedure clearDIVSWEN; inline;
    procedure clearOE; inline;
    procedure clearON; inline;
    procedure clearRSLP; inline;
    procedure clearSIDL; inline;
    procedure setACTIVE; inline;
    procedure setDIVSWEN; inline;
    procedure setOE; inline;
    procedure setON; inline;
    procedure setRSLP; inline;
    procedure setSIDL; inline;
    property ACTIVE : TBits_1 read getACTIVE write setACTIVE;
    property DIVSWEN : TBits_1 read getDIVSWEN write setDIVSWEN;
    property OE : TBits_1 read getOE write setOE;
    property ON : TBits_1 read getON write setON;
    property RODIV : TBits_15 read getRODIV write setRODIV;
    property ROSEL : TBits_4 read getROSEL write setROSEL;
    property RSLP : TBits_1 read getRSLP write setRSLP;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TOSC_REFOTRIM = record
  private
    function  getROTRIM : TBits_9; inline;
    function  getw : TBits_32; inline;
    procedure setROTRIM(thebits : TBits_9); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property ROTRIM : TBits_9 read getROTRIM write setROTRIM;
    property w : TBits_32 read getw write setw;
  end;
type
  TOSCRegisters = record
    OSCCONbits : TOSC_OSCCON;
    OSCCON : longWord;
    OSCCONCLR : longWord;
    OSCCONSET : longWord;
    OSCCONINV : longWord;
    OSCTUNbits : TOSC_OSCTUN;
    OSCTUN : longWord;
    OSCTUNCLR : longWord;
    OSCTUNSET : longWord;
    OSCTUNINV : longWord;
    REFOCONbits : TOSC_REFOCON;
    REFOCON : longWord;
    REFOCONCLR : longWord;
    REFOCONSET : longWord;
    REFOCONINV : longWord;
    REFOTRIMbits : TOSC_REFOTRIM;
    REFOTRIM : longWord;
    REFOTRIMCLR : longWord;
    REFOTRIMSET : longWord;
    REFOTRIMINV : longWord;
  end;
  TCFG_PMD5 = record
  private
    function  getI2C1MD : TBits_1; inline;
    function  getI2C2MD : TBits_1; inline;
    function  getSPI1MD : TBits_1; inline;
    function  getSPI2MD : TBits_1; inline;
    function  getU1MD : TBits_1; inline;
    function  getU2MD : TBits_1; inline;
    function  getUSB1MD : TBits_1; inline;
    function  getUSBMD : TBits_1; inline;
    procedure setI2C1MD(thebits : TBits_1); inline;
    procedure setI2C2MD(thebits : TBits_1); inline;
    procedure setSPI1MD(thebits : TBits_1); inline;
    procedure setSPI2MD(thebits : TBits_1); inline;
    procedure setU1MD(thebits : TBits_1); inline;
    procedure setU2MD(thebits : TBits_1); inline;
    procedure setUSB1MD(thebits : TBits_1); inline;
    procedure setUSBMD(thebits : TBits_1); inline;
  public
    procedure clearI2C1MD; inline;
    procedure clearI2C2MD; inline;
    procedure clearSPI1MD; inline;
    procedure clearSPI2MD; inline;
    procedure clearU1MD; inline;
    procedure clearU2MD; inline;
    procedure clearUSB1MD; inline;
    procedure clearUSBMD; inline;
    procedure setI2C1MD; inline;
    procedure setI2C2MD; inline;
    procedure setSPI1MD; inline;
    procedure setSPI2MD; inline;
    procedure setU1MD; inline;
    procedure setU2MD; inline;
    procedure setUSB1MD; inline;
    procedure setUSBMD; inline;
    property I2C1MD : TBits_1 read getI2C1MD write setI2C1MD;
    property I2C2MD : TBits_1 read getI2C2MD write setI2C2MD;
    property SPI1MD : TBits_1 read getSPI1MD write setSPI1MD;
    property SPI2MD : TBits_1 read getSPI2MD write setSPI2MD;
    property U1MD : TBits_1 read getU1MD write setU1MD;
    property U2MD : TBits_1 read getU2MD write setU2MD;
    property USB1MD : TBits_1 read getUSB1MD write setUSB1MD;
    property USBMD : TBits_1 read getUSBMD write setUSBMD;
  end;
type
  TCFGRegisters = record
    CFGCON : longWord;
    DDPCON : longWord;
    DEVID : longWord;
    SYSKEY : longWord;
    SYSKEYCLR : longWord;
    SYSKEYSET : longWord;
    SYSKEYINV : longWord;
    PMD1 : longWord;
    PMD1CLR : longWord;
    PMD1SET : longWord;
    PMD1INV : longWord;
    PMD2 : longWord;
    PMD2CLR : longWord;
    PMD2SET : longWord;
    PMD2INV : longWord;
    PMD3 : longWord;
    PMD3CLR : longWord;
    PMD3SET : longWord;
    PMD3INV : longWord;
    PMD4 : longWord;
    PMD4CLR : longWord;
    PMD4SET : longWord;
    PMD4INV : longWord;
    PMD5bits : TCFG_PMD5;
    PMD5 : longWord;
    PMD5CLR : longWord;
    PMD5SET : longWord;
    PMD5INV : longWord;
    PMD6 : longWord;
    PMD6CLR : longWord;
    PMD6SET : longWord;
    PMD6INV : longWord;
  end;
  TNVM_NVMCON = record
  private
    function  getLVDERR : TBits_1; inline;
    function  getLVDSTAT : TBits_1; inline;
    function  getNVMOP : TBits_4; inline;
    function  getNVMOP0 : TBits_1; inline;
    function  getNVMOP1 : TBits_1; inline;
    function  getNVMOP2 : TBits_1; inline;
    function  getNVMOP3 : TBits_1; inline;
    function  getPROGOP : TBits_4; inline;
    function  getPROGOP0 : TBits_1; inline;
    function  getPROGOP1 : TBits_1; inline;
    function  getPROGOP2 : TBits_1; inline;
    function  getPROGOP3 : TBits_1; inline;
    function  getWR : TBits_1; inline;
    function  getWREN : TBits_1; inline;
    function  getWRERR : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLVDERR(thebits : TBits_1); inline;
    procedure setLVDSTAT(thebits : TBits_1); inline;
    procedure setNVMOP(thebits : TBits_4); inline;
    procedure setNVMOP0(thebits : TBits_1); inline;
    procedure setNVMOP1(thebits : TBits_1); inline;
    procedure setNVMOP2(thebits : TBits_1); inline;
    procedure setNVMOP3(thebits : TBits_1); inline;
    procedure setPROGOP(thebits : TBits_4); inline;
    procedure setPROGOP0(thebits : TBits_1); inline;
    procedure setPROGOP1(thebits : TBits_1); inline;
    procedure setPROGOP2(thebits : TBits_1); inline;
    procedure setPROGOP3(thebits : TBits_1); inline;
    procedure setWR(thebits : TBits_1); inline;
    procedure setWREN(thebits : TBits_1); inline;
    procedure setWRERR(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLVDERR; inline;
    procedure clearLVDSTAT; inline;
    procedure clearNVMOP0; inline;
    procedure clearNVMOP1; inline;
    procedure clearNVMOP2; inline;
    procedure clearNVMOP3; inline;
    procedure clearPROGOP0; inline;
    procedure clearPROGOP1; inline;
    procedure clearPROGOP2; inline;
    procedure clearPROGOP3; inline;
    procedure clearWR; inline;
    procedure clearWREN; inline;
    procedure clearWRERR; inline;
    procedure setLVDERR; inline;
    procedure setLVDSTAT; inline;
    procedure setNVMOP0; inline;
    procedure setNVMOP1; inline;
    procedure setNVMOP2; inline;
    procedure setNVMOP3; inline;
    procedure setPROGOP0; inline;
    procedure setPROGOP1; inline;
    procedure setPROGOP2; inline;
    procedure setPROGOP3; inline;
    procedure setWR; inline;
    procedure setWREN; inline;
    procedure setWRERR; inline;
    property LVDERR : TBits_1 read getLVDERR write setLVDERR;
    property LVDSTAT : TBits_1 read getLVDSTAT write setLVDSTAT;
    property NVMOP : TBits_4 read getNVMOP write setNVMOP;
    property NVMOP0 : TBits_1 read getNVMOP0 write setNVMOP0;
    property NVMOP1 : TBits_1 read getNVMOP1 write setNVMOP1;
    property NVMOP2 : TBits_1 read getNVMOP2 write setNVMOP2;
    property NVMOP3 : TBits_1 read getNVMOP3 write setNVMOP3;
    property PROGOP : TBits_4 read getPROGOP write setPROGOP;
    property PROGOP0 : TBits_1 read getPROGOP0 write setPROGOP0;
    property PROGOP1 : TBits_1 read getPROGOP1 write setPROGOP1;
    property PROGOP2 : TBits_1 read getPROGOP2 write setPROGOP2;
    property PROGOP3 : TBits_1 read getPROGOP3 write setPROGOP3;
    property WR : TBits_1 read getWR write setWR;
    property WREN : TBits_1 read getWREN write setWREN;
    property WRERR : TBits_1 read getWRERR write setWRERR;
    property w : TBits_32 read getw write setw;
  end;
type
  TNVMRegisters = record
    NVMCONbits : TNVM_NVMCON;
    NVMCON : longWord;
    NVMCONCLR : longWord;
    NVMCONSET : longWord;
    NVMCONINV : longWord;
    NVMKEY : longWord;
    NVMADDR : longWord;
    NVMADDRCLR : longWord;
    NVMADDRSET : longWord;
    NVMADDRINV : longWord;
    NVMDATA : longWord;
    NVMSRCADDR : longWord;
  end;
  TRCON_RCON = record
  private
    function  getBOR : TBits_1; inline;
    function  getCMR : TBits_1; inline;
    function  getEXTR : TBits_1; inline;
    function  getIDLE : TBits_1; inline;
    function  getPOR : TBits_1; inline;
    function  getSLEEP : TBits_1; inline;
    function  getSWR : TBits_1; inline;
    function  getVREGS : TBits_1; inline;
    function  getWDTO : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBOR(thebits : TBits_1); inline;
    procedure setCMR(thebits : TBits_1); inline;
    procedure setEXTR(thebits : TBits_1); inline;
    procedure setIDLE(thebits : TBits_1); inline;
    procedure setPOR(thebits : TBits_1); inline;
    procedure setSLEEP(thebits : TBits_1); inline;
    procedure setSWR(thebits : TBits_1); inline;
    procedure setVREGS(thebits : TBits_1); inline;
    procedure setWDTO(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBOR; inline;
    procedure clearCMR; inline;
    procedure clearEXTR; inline;
    procedure clearIDLE; inline;
    procedure clearPOR; inline;
    procedure clearSLEEP; inline;
    procedure clearSWR; inline;
    procedure clearVREGS; inline;
    procedure clearWDTO; inline;
    procedure setBOR; inline;
    procedure setCMR; inline;
    procedure setEXTR; inline;
    procedure setIDLE; inline;
    procedure setPOR; inline;
    procedure setSLEEP; inline;
    procedure setSWR; inline;
    procedure setVREGS; inline;
    procedure setWDTO; inline;
    property BOR : TBits_1 read getBOR write setBOR;
    property CMR : TBits_1 read getCMR write setCMR;
    property EXTR : TBits_1 read getEXTR write setEXTR;
    property IDLE : TBits_1 read getIDLE write setIDLE;
    property POR : TBits_1 read getPOR write setPOR;
    property SLEEP : TBits_1 read getSLEEP write setSLEEP;
    property SWR : TBits_1 read getSWR write setSWR;
    property VREGS : TBits_1 read getVREGS write setVREGS;
    property WDTO : TBits_1 read getWDTO write setWDTO;
    property w : TBits_32 read getw write setw;
  end;
  TRCON_RSWRST = record
  private
    function  getSWRST : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setSWRST(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearSWRST; inline;
    procedure setSWRST; inline;
    property SWRST : TBits_1 read getSWRST write setSWRST;
    property w : TBits_32 read getw write setw;
  end;
type
  TRCONRegisters = record
    RCONbits : TRCON_RCON;
    RCON : longWord;
    RCONCLR : longWord;
    RCONSET : longWord;
    RCONINV : longWord;
    RSWRSTbits : TRCON_RSWRST;
    RSWRST : longWord;
    RSWRSTCLR : longWord;
    RSWRSTSET : longWord;
    RSWRSTINV : longWord;
    INT1R : longWord;
    INT2R : longWord;
    INT3R : longWord;
    INT4R : longWord;
    T2CKR : longWord;
    T3CKR : longWord;
    T4CKR : longWord;
    T5CKR : longWord;
    IC1R : longWord;
    IC2R : longWord;
    IC3R : longWord;
    IC4R : longWord;
    IC5R : longWord;
    OCFAR : longWord;
    OCFBR : longWord;
    U1RXR : longWord;
    U1CTSR : longWord;
    U2RXR : longWord;
    U2CTSR : longWord;
    SDI1R : longWord;
    SS1R : longWord;
    SDI2R : longWord;
    SS2R : longWord;
    REFCLKIR : longWord;
    RPA0R : longWord;
    RPA1R : longWord;
    RPA2R : longWord;
    RPA3R : longWord;
    RPA4R : longWord;
    RPA8R : longWord;
    RPA9R : longWord;
    RPB0R : longWord;
    RPB1R : longWord;
    RPB2R : longWord;
    RPB3R : longWord;
    RPB4R : longWord;
    RPB5R : longWord;
    RPB7R : longWord;
    RPB8R : longWord;
    RPB9R : longWord;
    RPB10R : longWord;
    RPB11R : longWord;
    RPB13R : longWord;
    RPB14R : longWord;
    RPB15R : longWord;
    RPC0R : longWord;
    RPC1R : longWord;
    RPC2R : longWord;
    RPC3R : longWord;
    RPC4R : longWord;
    RPC5R : longWord;
    RPC6R : longWord;
    RPC7R : longWord;
    RPC8R : longWord;
    RPC9R : longWord;
  end;
  TINT_INTCON = record
  private
    function  getINT0EP : TBits_1; inline;
    function  getINT1EP : TBits_1; inline;
    function  getINT2EP : TBits_1; inline;
    function  getINT3EP : TBits_1; inline;
    function  getINT4EP : TBits_1; inline;
    function  getMVEC : TBits_1; inline;
    function  getSS0 : TBits_1; inline;
    function  getTPC : TBits_3; inline;
    function  getw : TBits_32; inline;
    procedure setINT0EP(thebits : TBits_1); inline;
    procedure setINT1EP(thebits : TBits_1); inline;
    procedure setINT2EP(thebits : TBits_1); inline;
    procedure setINT3EP(thebits : TBits_1); inline;
    procedure setINT4EP(thebits : TBits_1); inline;
    procedure setMVEC(thebits : TBits_1); inline;
    procedure setSS0(thebits : TBits_1); inline;
    procedure setTPC(thebits : TBits_3); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearINT0EP; inline;
    procedure clearINT1EP; inline;
    procedure clearINT2EP; inline;
    procedure clearINT3EP; inline;
    procedure clearINT4EP; inline;
    procedure clearMVEC; inline;
    procedure clearSS0; inline;
    procedure setINT0EP; inline;
    procedure setINT1EP; inline;
    procedure setINT2EP; inline;
    procedure setINT3EP; inline;
    procedure setINT4EP; inline;
    procedure setMVEC; inline;
    procedure setSS0; inline;
    property INT0EP : TBits_1 read getINT0EP write setINT0EP;
    property INT1EP : TBits_1 read getINT1EP write setINT1EP;
    property INT2EP : TBits_1 read getINT2EP write setINT2EP;
    property INT3EP : TBits_1 read getINT3EP write setINT3EP;
    property INT4EP : TBits_1 read getINT4EP write setINT4EP;
    property MVEC : TBits_1 read getMVEC write setMVEC;
    property SS0 : TBits_1 read getSS0 write setSS0;
    property TPC : TBits_3 read getTPC write setTPC;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IFS0 = record
  private
    function  getAD1IF : TBits_1; inline;
    function  getCS0IF : TBits_1; inline;
    function  getCS1IF : TBits_1; inline;
    function  getCTIF : TBits_1; inline;
    function  getFCEIF : TBits_1; inline;
    function  getFSCMIF : TBits_1; inline;
    function  getIC1EIF : TBits_1; inline;
    function  getIC1IF : TBits_1; inline;
    function  getIC2EIF : TBits_1; inline;
    function  getIC2IF : TBits_1; inline;
    function  getIC3EIF : TBits_1; inline;
    function  getIC3IF : TBits_1; inline;
    function  getIC4EIF : TBits_1; inline;
    function  getIC4IF : TBits_1; inline;
    function  getIC5EIF : TBits_1; inline;
    function  getIC5IF : TBits_1; inline;
    function  getINT0IF : TBits_1; inline;
    function  getINT1IF : TBits_1; inline;
    function  getINT2IF : TBits_1; inline;
    function  getINT3IF : TBits_1; inline;
    function  getINT4IF : TBits_1; inline;
    function  getOC1IF : TBits_1; inline;
    function  getOC2IF : TBits_1; inline;
    function  getOC3IF : TBits_1; inline;
    function  getOC4IF : TBits_1; inline;
    function  getOC5IF : TBits_1; inline;
    function  getRTCCIF : TBits_1; inline;
    function  getT1IF : TBits_1; inline;
    function  getT2IF : TBits_1; inline;
    function  getT3IF : TBits_1; inline;
    function  getT4IF : TBits_1; inline;
    function  getT5IF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAD1IF(thebits : TBits_1); inline;
    procedure setCS0IF(thebits : TBits_1); inline;
    procedure setCS1IF(thebits : TBits_1); inline;
    procedure setCTIF(thebits : TBits_1); inline;
    procedure setFCEIF(thebits : TBits_1); inline;
    procedure setFSCMIF(thebits : TBits_1); inline;
    procedure setIC1EIF(thebits : TBits_1); inline;
    procedure setIC1IF(thebits : TBits_1); inline;
    procedure setIC2EIF(thebits : TBits_1); inline;
    procedure setIC2IF(thebits : TBits_1); inline;
    procedure setIC3EIF(thebits : TBits_1); inline;
    procedure setIC3IF(thebits : TBits_1); inline;
    procedure setIC4EIF(thebits : TBits_1); inline;
    procedure setIC4IF(thebits : TBits_1); inline;
    procedure setIC5EIF(thebits : TBits_1); inline;
    procedure setIC5IF(thebits : TBits_1); inline;
    procedure setINT0IF(thebits : TBits_1); inline;
    procedure setINT1IF(thebits : TBits_1); inline;
    procedure setINT2IF(thebits : TBits_1); inline;
    procedure setINT3IF(thebits : TBits_1); inline;
    procedure setINT4IF(thebits : TBits_1); inline;
    procedure setOC1IF(thebits : TBits_1); inline;
    procedure setOC2IF(thebits : TBits_1); inline;
    procedure setOC3IF(thebits : TBits_1); inline;
    procedure setOC4IF(thebits : TBits_1); inline;
    procedure setOC5IF(thebits : TBits_1); inline;
    procedure setRTCCIF(thebits : TBits_1); inline;
    procedure setT1IF(thebits : TBits_1); inline;
    procedure setT2IF(thebits : TBits_1); inline;
    procedure setT3IF(thebits : TBits_1); inline;
    procedure setT4IF(thebits : TBits_1); inline;
    procedure setT5IF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAD1IF; inline;
    procedure clearCS0IF; inline;
    procedure clearCS1IF; inline;
    procedure clearCTIF; inline;
    procedure clearFCEIF; inline;
    procedure clearFSCMIF; inline;
    procedure clearIC1EIF; inline;
    procedure clearIC1IF; inline;
    procedure clearIC2EIF; inline;
    procedure clearIC2IF; inline;
    procedure clearIC3EIF; inline;
    procedure clearIC3IF; inline;
    procedure clearIC4EIF; inline;
    procedure clearIC4IF; inline;
    procedure clearIC5EIF; inline;
    procedure clearIC5IF; inline;
    procedure clearINT0IF; inline;
    procedure clearINT1IF; inline;
    procedure clearINT2IF; inline;
    procedure clearINT3IF; inline;
    procedure clearINT4IF; inline;
    procedure clearOC1IF; inline;
    procedure clearOC2IF; inline;
    procedure clearOC3IF; inline;
    procedure clearOC4IF; inline;
    procedure clearOC5IF; inline;
    procedure clearRTCCIF; inline;
    procedure clearT1IF; inline;
    procedure clearT2IF; inline;
    procedure clearT3IF; inline;
    procedure clearT4IF; inline;
    procedure clearT5IF; inline;
    procedure setAD1IF; inline;
    procedure setCS0IF; inline;
    procedure setCS1IF; inline;
    procedure setCTIF; inline;
    procedure setFCEIF; inline;
    procedure setFSCMIF; inline;
    procedure setIC1EIF; inline;
    procedure setIC1IF; inline;
    procedure setIC2EIF; inline;
    procedure setIC2IF; inline;
    procedure setIC3EIF; inline;
    procedure setIC3IF; inline;
    procedure setIC4EIF; inline;
    procedure setIC4IF; inline;
    procedure setIC5EIF; inline;
    procedure setIC5IF; inline;
    procedure setINT0IF; inline;
    procedure setINT1IF; inline;
    procedure setINT2IF; inline;
    procedure setINT3IF; inline;
    procedure setINT4IF; inline;
    procedure setOC1IF; inline;
    procedure setOC2IF; inline;
    procedure setOC3IF; inline;
    procedure setOC4IF; inline;
    procedure setOC5IF; inline;
    procedure setRTCCIF; inline;
    procedure setT1IF; inline;
    procedure setT2IF; inline;
    procedure setT3IF; inline;
    procedure setT4IF; inline;
    procedure setT5IF; inline;
    property AD1IF : TBits_1 read getAD1IF write setAD1IF;
    property CS0IF : TBits_1 read getCS0IF write setCS0IF;
    property CS1IF : TBits_1 read getCS1IF write setCS1IF;
    property CTIF : TBits_1 read getCTIF write setCTIF;
    property FCEIF : TBits_1 read getFCEIF write setFCEIF;
    property FSCMIF : TBits_1 read getFSCMIF write setFSCMIF;
    property IC1EIF : TBits_1 read getIC1EIF write setIC1EIF;
    property IC1IF : TBits_1 read getIC1IF write setIC1IF;
    property IC2EIF : TBits_1 read getIC2EIF write setIC2EIF;
    property IC2IF : TBits_1 read getIC2IF write setIC2IF;
    property IC3EIF : TBits_1 read getIC3EIF write setIC3EIF;
    property IC3IF : TBits_1 read getIC3IF write setIC3IF;
    property IC4EIF : TBits_1 read getIC4EIF write setIC4EIF;
    property IC4IF : TBits_1 read getIC4IF write setIC4IF;
    property IC5EIF : TBits_1 read getIC5EIF write setIC5EIF;
    property IC5IF : TBits_1 read getIC5IF write setIC5IF;
    property INT0IF : TBits_1 read getINT0IF write setINT0IF;
    property INT1IF : TBits_1 read getINT1IF write setINT1IF;
    property INT2IF : TBits_1 read getINT2IF write setINT2IF;
    property INT3IF : TBits_1 read getINT3IF write setINT3IF;
    property INT4IF : TBits_1 read getINT4IF write setINT4IF;
    property OC1IF : TBits_1 read getOC1IF write setOC1IF;
    property OC2IF : TBits_1 read getOC2IF write setOC2IF;
    property OC3IF : TBits_1 read getOC3IF write setOC3IF;
    property OC4IF : TBits_1 read getOC4IF write setOC4IF;
    property OC5IF : TBits_1 read getOC5IF write setOC5IF;
    property RTCCIF : TBits_1 read getRTCCIF write setRTCCIF;
    property T1IF : TBits_1 read getT1IF write setT1IF;
    property T2IF : TBits_1 read getT2IF write setT2IF;
    property T3IF : TBits_1 read getT3IF write setT3IF;
    property T4IF : TBits_1 read getT4IF write setT4IF;
    property T5IF : TBits_1 read getT5IF write setT5IF;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IFS1 = record
  private
    function  getCMP1IF : TBits_1; inline;
    function  getCMP2IF : TBits_1; inline;
    function  getCMP3IF : TBits_1; inline;
    function  getCNAIF : TBits_1; inline;
    function  getCNBIF : TBits_1; inline;
    function  getCNCIF : TBits_1; inline;
    function  getCTMUIF : TBits_1; inline;
    function  getDMA0IF : TBits_1; inline;
    function  getDMA1IF : TBits_1; inline;
    function  getDMA2IF : TBits_1; inline;
    function  getDMA3IF : TBits_1; inline;
    function  getI2C1BIF : TBits_1; inline;
    function  getI2C1MIF : TBits_1; inline;
    function  getI2C1SIF : TBits_1; inline;
    function  getI2C2BIF : TBits_1; inline;
    function  getI2C2MIF : TBits_1; inline;
    function  getI2C2SIF : TBits_1; inline;
    function  getPMPEIF : TBits_1; inline;
    function  getPMPIF : TBits_1; inline;
    function  getSPI1EIF : TBits_1; inline;
    function  getSPI1RXIF : TBits_1; inline;
    function  getSPI1TXIF : TBits_1; inline;
    function  getSPI2EIF : TBits_1; inline;
    function  getSPI2RXIF : TBits_1; inline;
    function  getSPI2TXIF : TBits_1; inline;
    function  getU1EIF : TBits_1; inline;
    function  getU1RXIF : TBits_1; inline;
    function  getU1TXIF : TBits_1; inline;
    function  getU2EIF : TBits_1; inline;
    function  getU2RXIF : TBits_1; inline;
    function  getU2TXIF : TBits_1; inline;
    function  getUSBIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCMP1IF(thebits : TBits_1); inline;
    procedure setCMP2IF(thebits : TBits_1); inline;
    procedure setCMP3IF(thebits : TBits_1); inline;
    procedure setCNAIF(thebits : TBits_1); inline;
    procedure setCNBIF(thebits : TBits_1); inline;
    procedure setCNCIF(thebits : TBits_1); inline;
    procedure setCTMUIF(thebits : TBits_1); inline;
    procedure setDMA0IF(thebits : TBits_1); inline;
    procedure setDMA1IF(thebits : TBits_1); inline;
    procedure setDMA2IF(thebits : TBits_1); inline;
    procedure setDMA3IF(thebits : TBits_1); inline;
    procedure setI2C1BIF(thebits : TBits_1); inline;
    procedure setI2C1MIF(thebits : TBits_1); inline;
    procedure setI2C1SIF(thebits : TBits_1); inline;
    procedure setI2C2BIF(thebits : TBits_1); inline;
    procedure setI2C2MIF(thebits : TBits_1); inline;
    procedure setI2C2SIF(thebits : TBits_1); inline;
    procedure setPMPEIF(thebits : TBits_1); inline;
    procedure setPMPIF(thebits : TBits_1); inline;
    procedure setSPI1EIF(thebits : TBits_1); inline;
    procedure setSPI1RXIF(thebits : TBits_1); inline;
    procedure setSPI1TXIF(thebits : TBits_1); inline;
    procedure setSPI2EIF(thebits : TBits_1); inline;
    procedure setSPI2RXIF(thebits : TBits_1); inline;
    procedure setSPI2TXIF(thebits : TBits_1); inline;
    procedure setU1EIF(thebits : TBits_1); inline;
    procedure setU1RXIF(thebits : TBits_1); inline;
    procedure setU1TXIF(thebits : TBits_1); inline;
    procedure setU2EIF(thebits : TBits_1); inline;
    procedure setU2RXIF(thebits : TBits_1); inline;
    procedure setU2TXIF(thebits : TBits_1); inline;
    procedure setUSBIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCMP1IF; inline;
    procedure clearCMP2IF; inline;
    procedure clearCMP3IF; inline;
    procedure clearCNAIF; inline;
    procedure clearCNBIF; inline;
    procedure clearCNCIF; inline;
    procedure clearCTMUIF; inline;
    procedure clearDMA0IF; inline;
    procedure clearDMA1IF; inline;
    procedure clearDMA2IF; inline;
    procedure clearDMA3IF; inline;
    procedure clearI2C1BIF; inline;
    procedure clearI2C1MIF; inline;
    procedure clearI2C1SIF; inline;
    procedure clearI2C2BIF; inline;
    procedure clearI2C2MIF; inline;
    procedure clearI2C2SIF; inline;
    procedure clearPMPEIF; inline;
    procedure clearPMPIF; inline;
    procedure clearSPI1EIF; inline;
    procedure clearSPI1RXIF; inline;
    procedure clearSPI1TXIF; inline;
    procedure clearSPI2EIF; inline;
    procedure clearSPI2RXIF; inline;
    procedure clearSPI2TXIF; inline;
    procedure clearU1EIF; inline;
    procedure clearU1RXIF; inline;
    procedure clearU1TXIF; inline;
    procedure clearU2EIF; inline;
    procedure clearU2RXIF; inline;
    procedure clearU2TXIF; inline;
    procedure clearUSBIF; inline;
    procedure setCMP1IF; inline;
    procedure setCMP2IF; inline;
    procedure setCMP3IF; inline;
    procedure setCNAIF; inline;
    procedure setCNBIF; inline;
    procedure setCNCIF; inline;
    procedure setCTMUIF; inline;
    procedure setDMA0IF; inline;
    procedure setDMA1IF; inline;
    procedure setDMA2IF; inline;
    procedure setDMA3IF; inline;
    procedure setI2C1BIF; inline;
    procedure setI2C1MIF; inline;
    procedure setI2C1SIF; inline;
    procedure setI2C2BIF; inline;
    procedure setI2C2MIF; inline;
    procedure setI2C2SIF; inline;
    procedure setPMPEIF; inline;
    procedure setPMPIF; inline;
    procedure setSPI1EIF; inline;
    procedure setSPI1RXIF; inline;
    procedure setSPI1TXIF; inline;
    procedure setSPI2EIF; inline;
    procedure setSPI2RXIF; inline;
    procedure setSPI2TXIF; inline;
    procedure setU1EIF; inline;
    procedure setU1RXIF; inline;
    procedure setU1TXIF; inline;
    procedure setU2EIF; inline;
    procedure setU2RXIF; inline;
    procedure setU2TXIF; inline;
    procedure setUSBIF; inline;
    property CMP1IF : TBits_1 read getCMP1IF write setCMP1IF;
    property CMP2IF : TBits_1 read getCMP2IF write setCMP2IF;
    property CMP3IF : TBits_1 read getCMP3IF write setCMP3IF;
    property CNAIF : TBits_1 read getCNAIF write setCNAIF;
    property CNBIF : TBits_1 read getCNBIF write setCNBIF;
    property CNCIF : TBits_1 read getCNCIF write setCNCIF;
    property CTMUIF : TBits_1 read getCTMUIF write setCTMUIF;
    property DMA0IF : TBits_1 read getDMA0IF write setDMA0IF;
    property DMA1IF : TBits_1 read getDMA1IF write setDMA1IF;
    property DMA2IF : TBits_1 read getDMA2IF write setDMA2IF;
    property DMA3IF : TBits_1 read getDMA3IF write setDMA3IF;
    property I2C1BIF : TBits_1 read getI2C1BIF write setI2C1BIF;
    property I2C1MIF : TBits_1 read getI2C1MIF write setI2C1MIF;
    property I2C1SIF : TBits_1 read getI2C1SIF write setI2C1SIF;
    property I2C2BIF : TBits_1 read getI2C2BIF write setI2C2BIF;
    property I2C2MIF : TBits_1 read getI2C2MIF write setI2C2MIF;
    property I2C2SIF : TBits_1 read getI2C2SIF write setI2C2SIF;
    property PMPEIF : TBits_1 read getPMPEIF write setPMPEIF;
    property PMPIF : TBits_1 read getPMPIF write setPMPIF;
    property SPI1EIF : TBits_1 read getSPI1EIF write setSPI1EIF;
    property SPI1RXIF : TBits_1 read getSPI1RXIF write setSPI1RXIF;
    property SPI1TXIF : TBits_1 read getSPI1TXIF write setSPI1TXIF;
    property SPI2EIF : TBits_1 read getSPI2EIF write setSPI2EIF;
    property SPI2RXIF : TBits_1 read getSPI2RXIF write setSPI2RXIF;
    property SPI2TXIF : TBits_1 read getSPI2TXIF write setSPI2TXIF;
    property U1EIF : TBits_1 read getU1EIF write setU1EIF;
    property U1RXIF : TBits_1 read getU1RXIF write setU1RXIF;
    property U1TXIF : TBits_1 read getU1TXIF write setU1TXIF;
    property U2EIF : TBits_1 read getU2EIF write setU2EIF;
    property U2RXIF : TBits_1 read getU2RXIF write setU2RXIF;
    property U2TXIF : TBits_1 read getU2TXIF write setU2TXIF;
    property USBIF : TBits_1 read getUSBIF write setUSBIF;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IEC0 = record
  private
    function  getAD1IE : TBits_1; inline;
    function  getCS0IE : TBits_1; inline;
    function  getCS1IE : TBits_1; inline;
    function  getCTIE : TBits_1; inline;
    function  getFCEIE : TBits_1; inline;
    function  getFSCMIE : TBits_1; inline;
    function  getIC1EIE : TBits_1; inline;
    function  getIC1IE : TBits_1; inline;
    function  getIC2EIE : TBits_1; inline;
    function  getIC2IE : TBits_1; inline;
    function  getIC3EIE : TBits_1; inline;
    function  getIC3IE : TBits_1; inline;
    function  getIC4EIE : TBits_1; inline;
    function  getIC4IE : TBits_1; inline;
    function  getIC5EIE : TBits_1; inline;
    function  getIC5IE : TBits_1; inline;
    function  getINT0IE : TBits_1; inline;
    function  getINT1IE : TBits_1; inline;
    function  getINT2IE : TBits_1; inline;
    function  getINT3IE : TBits_1; inline;
    function  getINT4IE : TBits_1; inline;
    function  getOC1IE : TBits_1; inline;
    function  getOC2IE : TBits_1; inline;
    function  getOC3IE : TBits_1; inline;
    function  getOC4IE : TBits_1; inline;
    function  getOC5IE : TBits_1; inline;
    function  getRTCCIE : TBits_1; inline;
    function  getT1IE : TBits_1; inline;
    function  getT2IE : TBits_1; inline;
    function  getT3IE : TBits_1; inline;
    function  getT4IE : TBits_1; inline;
    function  getT5IE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAD1IE(thebits : TBits_1); inline;
    procedure setCS0IE(thebits : TBits_1); inline;
    procedure setCS1IE(thebits : TBits_1); inline;
    procedure setCTIE(thebits : TBits_1); inline;
    procedure setFCEIE(thebits : TBits_1); inline;
    procedure setFSCMIE(thebits : TBits_1); inline;
    procedure setIC1EIE(thebits : TBits_1); inline;
    procedure setIC1IE(thebits : TBits_1); inline;
    procedure setIC2EIE(thebits : TBits_1); inline;
    procedure setIC2IE(thebits : TBits_1); inline;
    procedure setIC3EIE(thebits : TBits_1); inline;
    procedure setIC3IE(thebits : TBits_1); inline;
    procedure setIC4EIE(thebits : TBits_1); inline;
    procedure setIC4IE(thebits : TBits_1); inline;
    procedure setIC5EIE(thebits : TBits_1); inline;
    procedure setIC5IE(thebits : TBits_1); inline;
    procedure setINT0IE(thebits : TBits_1); inline;
    procedure setINT1IE(thebits : TBits_1); inline;
    procedure setINT2IE(thebits : TBits_1); inline;
    procedure setINT3IE(thebits : TBits_1); inline;
    procedure setINT4IE(thebits : TBits_1); inline;
    procedure setOC1IE(thebits : TBits_1); inline;
    procedure setOC2IE(thebits : TBits_1); inline;
    procedure setOC3IE(thebits : TBits_1); inline;
    procedure setOC4IE(thebits : TBits_1); inline;
    procedure setOC5IE(thebits : TBits_1); inline;
    procedure setRTCCIE(thebits : TBits_1); inline;
    procedure setT1IE(thebits : TBits_1); inline;
    procedure setT2IE(thebits : TBits_1); inline;
    procedure setT3IE(thebits : TBits_1); inline;
    procedure setT4IE(thebits : TBits_1); inline;
    procedure setT5IE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAD1IE; inline;
    procedure clearCS0IE; inline;
    procedure clearCS1IE; inline;
    procedure clearCTIE; inline;
    procedure clearFCEIE; inline;
    procedure clearFSCMIE; inline;
    procedure clearIC1EIE; inline;
    procedure clearIC1IE; inline;
    procedure clearIC2EIE; inline;
    procedure clearIC2IE; inline;
    procedure clearIC3EIE; inline;
    procedure clearIC3IE; inline;
    procedure clearIC4EIE; inline;
    procedure clearIC4IE; inline;
    procedure clearIC5EIE; inline;
    procedure clearIC5IE; inline;
    procedure clearINT0IE; inline;
    procedure clearINT1IE; inline;
    procedure clearINT2IE; inline;
    procedure clearINT3IE; inline;
    procedure clearINT4IE; inline;
    procedure clearOC1IE; inline;
    procedure clearOC2IE; inline;
    procedure clearOC3IE; inline;
    procedure clearOC4IE; inline;
    procedure clearOC5IE; inline;
    procedure clearRTCCIE; inline;
    procedure clearT1IE; inline;
    procedure clearT2IE; inline;
    procedure clearT3IE; inline;
    procedure clearT4IE; inline;
    procedure clearT5IE; inline;
    procedure setAD1IE; inline;
    procedure setCS0IE; inline;
    procedure setCS1IE; inline;
    procedure setCTIE; inline;
    procedure setFCEIE; inline;
    procedure setFSCMIE; inline;
    procedure setIC1EIE; inline;
    procedure setIC1IE; inline;
    procedure setIC2EIE; inline;
    procedure setIC2IE; inline;
    procedure setIC3EIE; inline;
    procedure setIC3IE; inline;
    procedure setIC4EIE; inline;
    procedure setIC4IE; inline;
    procedure setIC5EIE; inline;
    procedure setIC5IE; inline;
    procedure setINT0IE; inline;
    procedure setINT1IE; inline;
    procedure setINT2IE; inline;
    procedure setINT3IE; inline;
    procedure setINT4IE; inline;
    procedure setOC1IE; inline;
    procedure setOC2IE; inline;
    procedure setOC3IE; inline;
    procedure setOC4IE; inline;
    procedure setOC5IE; inline;
    procedure setRTCCIE; inline;
    procedure setT1IE; inline;
    procedure setT2IE; inline;
    procedure setT3IE; inline;
    procedure setT4IE; inline;
    procedure setT5IE; inline;
    property AD1IE : TBits_1 read getAD1IE write setAD1IE;
    property CS0IE : TBits_1 read getCS0IE write setCS0IE;
    property CS1IE : TBits_1 read getCS1IE write setCS1IE;
    property CTIE : TBits_1 read getCTIE write setCTIE;
    property FCEIE : TBits_1 read getFCEIE write setFCEIE;
    property FSCMIE : TBits_1 read getFSCMIE write setFSCMIE;
    property IC1EIE : TBits_1 read getIC1EIE write setIC1EIE;
    property IC1IE : TBits_1 read getIC1IE write setIC1IE;
    property IC2EIE : TBits_1 read getIC2EIE write setIC2EIE;
    property IC2IE : TBits_1 read getIC2IE write setIC2IE;
    property IC3EIE : TBits_1 read getIC3EIE write setIC3EIE;
    property IC3IE : TBits_1 read getIC3IE write setIC3IE;
    property IC4EIE : TBits_1 read getIC4EIE write setIC4EIE;
    property IC4IE : TBits_1 read getIC4IE write setIC4IE;
    property IC5EIE : TBits_1 read getIC5EIE write setIC5EIE;
    property IC5IE : TBits_1 read getIC5IE write setIC5IE;
    property INT0IE : TBits_1 read getINT0IE write setINT0IE;
    property INT1IE : TBits_1 read getINT1IE write setINT1IE;
    property INT2IE : TBits_1 read getINT2IE write setINT2IE;
    property INT3IE : TBits_1 read getINT3IE write setINT3IE;
    property INT4IE : TBits_1 read getINT4IE write setINT4IE;
    property OC1IE : TBits_1 read getOC1IE write setOC1IE;
    property OC2IE : TBits_1 read getOC2IE write setOC2IE;
    property OC3IE : TBits_1 read getOC3IE write setOC3IE;
    property OC4IE : TBits_1 read getOC4IE write setOC4IE;
    property OC5IE : TBits_1 read getOC5IE write setOC5IE;
    property RTCCIE : TBits_1 read getRTCCIE write setRTCCIE;
    property T1IE : TBits_1 read getT1IE write setT1IE;
    property T2IE : TBits_1 read getT2IE write setT2IE;
    property T3IE : TBits_1 read getT3IE write setT3IE;
    property T4IE : TBits_1 read getT4IE write setT4IE;
    property T5IE : TBits_1 read getT5IE write setT5IE;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IEC1 = record
  private
    function  getCMP1IE : TBits_1; inline;
    function  getCMP2IE : TBits_1; inline;
    function  getCMP3IE : TBits_1; inline;
    function  getCNAIE : TBits_1; inline;
    function  getCNBIE : TBits_1; inline;
    function  getCNCIE : TBits_1; inline;
    function  getCTMUIE : TBits_1; inline;
    function  getDMA0IE : TBits_1; inline;
    function  getDMA1IE : TBits_1; inline;
    function  getDMA2IE : TBits_1; inline;
    function  getDMA3IE : TBits_1; inline;
    function  getI2C1BIE : TBits_1; inline;
    function  getI2C1MIE : TBits_1; inline;
    function  getI2C1SIE : TBits_1; inline;
    function  getI2C2BIE : TBits_1; inline;
    function  getI2C2MIE : TBits_1; inline;
    function  getI2C2SIE : TBits_1; inline;
    function  getPMPEIE : TBits_1; inline;
    function  getPMPIE : TBits_1; inline;
    function  getSPI1EIE : TBits_1; inline;
    function  getSPI1RXIE : TBits_1; inline;
    function  getSPI1TXIE : TBits_1; inline;
    function  getSPI2EIE : TBits_1; inline;
    function  getSPI2RXIE : TBits_1; inline;
    function  getSPI2TXIE : TBits_1; inline;
    function  getU1EIE : TBits_1; inline;
    function  getU1RXIE : TBits_1; inline;
    function  getU1TXIE : TBits_1; inline;
    function  getU2EIE : TBits_1; inline;
    function  getU2RXIE : TBits_1; inline;
    function  getU2TXIE : TBits_1; inline;
    function  getUSBIE : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCMP1IE(thebits : TBits_1); inline;
    procedure setCMP2IE(thebits : TBits_1); inline;
    procedure setCMP3IE(thebits : TBits_1); inline;
    procedure setCNAIE(thebits : TBits_1); inline;
    procedure setCNBIE(thebits : TBits_1); inline;
    procedure setCNCIE(thebits : TBits_1); inline;
    procedure setCTMUIE(thebits : TBits_1); inline;
    procedure setDMA0IE(thebits : TBits_1); inline;
    procedure setDMA1IE(thebits : TBits_1); inline;
    procedure setDMA2IE(thebits : TBits_1); inline;
    procedure setDMA3IE(thebits : TBits_1); inline;
    procedure setI2C1BIE(thebits : TBits_1); inline;
    procedure setI2C1MIE(thebits : TBits_1); inline;
    procedure setI2C1SIE(thebits : TBits_1); inline;
    procedure setI2C2BIE(thebits : TBits_1); inline;
    procedure setI2C2MIE(thebits : TBits_1); inline;
    procedure setI2C2SIE(thebits : TBits_1); inline;
    procedure setPMPEIE(thebits : TBits_1); inline;
    procedure setPMPIE(thebits : TBits_1); inline;
    procedure setSPI1EIE(thebits : TBits_1); inline;
    procedure setSPI1RXIE(thebits : TBits_1); inline;
    procedure setSPI1TXIE(thebits : TBits_1); inline;
    procedure setSPI2EIE(thebits : TBits_1); inline;
    procedure setSPI2RXIE(thebits : TBits_1); inline;
    procedure setSPI2TXIE(thebits : TBits_1); inline;
    procedure setU1EIE(thebits : TBits_1); inline;
    procedure setU1RXIE(thebits : TBits_1); inline;
    procedure setU1TXIE(thebits : TBits_1); inline;
    procedure setU2EIE(thebits : TBits_1); inline;
    procedure setU2RXIE(thebits : TBits_1); inline;
    procedure setU2TXIE(thebits : TBits_1); inline;
    procedure setUSBIE(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCMP1IE; inline;
    procedure clearCMP2IE; inline;
    procedure clearCMP3IE; inline;
    procedure clearCNAIE; inline;
    procedure clearCNBIE; inline;
    procedure clearCNCIE; inline;
    procedure clearCTMUIE; inline;
    procedure clearDMA0IE; inline;
    procedure clearDMA1IE; inline;
    procedure clearDMA2IE; inline;
    procedure clearDMA3IE; inline;
    procedure clearI2C1BIE; inline;
    procedure clearI2C1MIE; inline;
    procedure clearI2C1SIE; inline;
    procedure clearI2C2BIE; inline;
    procedure clearI2C2MIE; inline;
    procedure clearI2C2SIE; inline;
    procedure clearPMPEIE; inline;
    procedure clearPMPIE; inline;
    procedure clearSPI1EIE; inline;
    procedure clearSPI1RXIE; inline;
    procedure clearSPI1TXIE; inline;
    procedure clearSPI2EIE; inline;
    procedure clearSPI2RXIE; inline;
    procedure clearSPI2TXIE; inline;
    procedure clearU1EIE; inline;
    procedure clearU1RXIE; inline;
    procedure clearU1TXIE; inline;
    procedure clearU2EIE; inline;
    procedure clearU2RXIE; inline;
    procedure clearU2TXIE; inline;
    procedure clearUSBIE; inline;
    procedure setCMP1IE; inline;
    procedure setCMP2IE; inline;
    procedure setCMP3IE; inline;
    procedure setCNAIE; inline;
    procedure setCNBIE; inline;
    procedure setCNCIE; inline;
    procedure setCTMUIE; inline;
    procedure setDMA0IE; inline;
    procedure setDMA1IE; inline;
    procedure setDMA2IE; inline;
    procedure setDMA3IE; inline;
    procedure setI2C1BIE; inline;
    procedure setI2C1MIE; inline;
    procedure setI2C1SIE; inline;
    procedure setI2C2BIE; inline;
    procedure setI2C2MIE; inline;
    procedure setI2C2SIE; inline;
    procedure setPMPEIE; inline;
    procedure setPMPIE; inline;
    procedure setSPI1EIE; inline;
    procedure setSPI1RXIE; inline;
    procedure setSPI1TXIE; inline;
    procedure setSPI2EIE; inline;
    procedure setSPI2RXIE; inline;
    procedure setSPI2TXIE; inline;
    procedure setU1EIE; inline;
    procedure setU1RXIE; inline;
    procedure setU1TXIE; inline;
    procedure setU2EIE; inline;
    procedure setU2RXIE; inline;
    procedure setU2TXIE; inline;
    procedure setUSBIE; inline;
    property CMP1IE : TBits_1 read getCMP1IE write setCMP1IE;
    property CMP2IE : TBits_1 read getCMP2IE write setCMP2IE;
    property CMP3IE : TBits_1 read getCMP3IE write setCMP3IE;
    property CNAIE : TBits_1 read getCNAIE write setCNAIE;
    property CNBIE : TBits_1 read getCNBIE write setCNBIE;
    property CNCIE : TBits_1 read getCNCIE write setCNCIE;
    property CTMUIE : TBits_1 read getCTMUIE write setCTMUIE;
    property DMA0IE : TBits_1 read getDMA0IE write setDMA0IE;
    property DMA1IE : TBits_1 read getDMA1IE write setDMA1IE;
    property DMA2IE : TBits_1 read getDMA2IE write setDMA2IE;
    property DMA3IE : TBits_1 read getDMA3IE write setDMA3IE;
    property I2C1BIE : TBits_1 read getI2C1BIE write setI2C1BIE;
    property I2C1MIE : TBits_1 read getI2C1MIE write setI2C1MIE;
    property I2C1SIE : TBits_1 read getI2C1SIE write setI2C1SIE;
    property I2C2BIE : TBits_1 read getI2C2BIE write setI2C2BIE;
    property I2C2MIE : TBits_1 read getI2C2MIE write setI2C2MIE;
    property I2C2SIE : TBits_1 read getI2C2SIE write setI2C2SIE;
    property PMPEIE : TBits_1 read getPMPEIE write setPMPEIE;
    property PMPIE : TBits_1 read getPMPIE write setPMPIE;
    property SPI1EIE : TBits_1 read getSPI1EIE write setSPI1EIE;
    property SPI1RXIE : TBits_1 read getSPI1RXIE write setSPI1RXIE;
    property SPI1TXIE : TBits_1 read getSPI1TXIE write setSPI1TXIE;
    property SPI2EIE : TBits_1 read getSPI2EIE write setSPI2EIE;
    property SPI2RXIE : TBits_1 read getSPI2RXIE write setSPI2RXIE;
    property SPI2TXIE : TBits_1 read getSPI2TXIE write setSPI2TXIE;
    property U1EIE : TBits_1 read getU1EIE write setU1EIE;
    property U1RXIE : TBits_1 read getU1RXIE write setU1RXIE;
    property U1TXIE : TBits_1 read getU1TXIE write setU1TXIE;
    property U2EIE : TBits_1 read getU2EIE write setU2EIE;
    property U2RXIE : TBits_1 read getU2RXIE write setU2RXIE;
    property U2TXIE : TBits_1 read getU2TXIE write setU2TXIE;
    property USBIE : TBits_1 read getUSBIE write setUSBIE;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC0 = record
  private
    function  getCS0IP : TBits_3; inline;
    function  getCS0IS : TBits_2; inline;
    function  getCS1IP : TBits_3; inline;
    function  getCS1IS : TBits_2; inline;
    function  getCTIP : TBits_3; inline;
    function  getCTIS : TBits_2; inline;
    function  getINT0IP : TBits_3; inline;
    function  getINT0IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCS0IP(thebits : TBits_3); inline;
    procedure setCS0IS(thebits : TBits_2); inline;
    procedure setCS1IP(thebits : TBits_3); inline;
    procedure setCS1IS(thebits : TBits_2); inline;
    procedure setCTIP(thebits : TBits_3); inline;
    procedure setCTIS(thebits : TBits_2); inline;
    procedure setINT0IP(thebits : TBits_3); inline;
    procedure setINT0IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CS0IP : TBits_3 read getCS0IP write setCS0IP;
    property CS0IS : TBits_2 read getCS0IS write setCS0IS;
    property CS1IP : TBits_3 read getCS1IP write setCS1IP;
    property CS1IS : TBits_2 read getCS1IS write setCS1IS;
    property CTIP : TBits_3 read getCTIP write setCTIP;
    property CTIS : TBits_2 read getCTIS write setCTIS;
    property INT0IP : TBits_3 read getINT0IP write setINT0IP;
    property INT0IS : TBits_2 read getINT0IS write setINT0IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC1 = record
  private
    function  getIC1IP : TBits_3; inline;
    function  getIC1IS : TBits_2; inline;
    function  getINT1IP : TBits_3; inline;
    function  getINT1IS : TBits_2; inline;
    function  getOC1IP : TBits_3; inline;
    function  getOC1IS : TBits_2; inline;
    function  getT1IP : TBits_3; inline;
    function  getT1IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setIC1IP(thebits : TBits_3); inline;
    procedure setIC1IS(thebits : TBits_2); inline;
    procedure setINT1IP(thebits : TBits_3); inline;
    procedure setINT1IS(thebits : TBits_2); inline;
    procedure setOC1IP(thebits : TBits_3); inline;
    procedure setOC1IS(thebits : TBits_2); inline;
    procedure setT1IP(thebits : TBits_3); inline;
    procedure setT1IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property IC1IP : TBits_3 read getIC1IP write setIC1IP;
    property IC1IS : TBits_2 read getIC1IS write setIC1IS;
    property INT1IP : TBits_3 read getINT1IP write setINT1IP;
    property INT1IS : TBits_2 read getINT1IS write setINT1IS;
    property OC1IP : TBits_3 read getOC1IP write setOC1IP;
    property OC1IS : TBits_2 read getOC1IS write setOC1IS;
    property T1IP : TBits_3 read getT1IP write setT1IP;
    property T1IS : TBits_2 read getT1IS write setT1IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC2 = record
  private
    function  getIC2IP : TBits_3; inline;
    function  getIC2IS : TBits_2; inline;
    function  getINT2IP : TBits_3; inline;
    function  getINT2IS : TBits_2; inline;
    function  getOC2IP : TBits_3; inline;
    function  getOC2IS : TBits_2; inline;
    function  getT2IP : TBits_3; inline;
    function  getT2IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setIC2IP(thebits : TBits_3); inline;
    procedure setIC2IS(thebits : TBits_2); inline;
    procedure setINT2IP(thebits : TBits_3); inline;
    procedure setINT2IS(thebits : TBits_2); inline;
    procedure setOC2IP(thebits : TBits_3); inline;
    procedure setOC2IS(thebits : TBits_2); inline;
    procedure setT2IP(thebits : TBits_3); inline;
    procedure setT2IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property IC2IP : TBits_3 read getIC2IP write setIC2IP;
    property IC2IS : TBits_2 read getIC2IS write setIC2IS;
    property INT2IP : TBits_3 read getINT2IP write setINT2IP;
    property INT2IS : TBits_2 read getINT2IS write setINT2IS;
    property OC2IP : TBits_3 read getOC2IP write setOC2IP;
    property OC2IS : TBits_2 read getOC2IS write setOC2IS;
    property T2IP : TBits_3 read getT2IP write setT2IP;
    property T2IS : TBits_2 read getT2IS write setT2IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC3 = record
  private
    function  getIC3IP : TBits_3; inline;
    function  getIC3IS : TBits_2; inline;
    function  getINT3IP : TBits_3; inline;
    function  getINT3IS : TBits_2; inline;
    function  getOC3IP : TBits_3; inline;
    function  getOC3IS : TBits_2; inline;
    function  getT3IP : TBits_3; inline;
    function  getT3IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setIC3IP(thebits : TBits_3); inline;
    procedure setIC3IS(thebits : TBits_2); inline;
    procedure setINT3IP(thebits : TBits_3); inline;
    procedure setINT3IS(thebits : TBits_2); inline;
    procedure setOC3IP(thebits : TBits_3); inline;
    procedure setOC3IS(thebits : TBits_2); inline;
    procedure setT3IP(thebits : TBits_3); inline;
    procedure setT3IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property IC3IP : TBits_3 read getIC3IP write setIC3IP;
    property IC3IS : TBits_2 read getIC3IS write setIC3IS;
    property INT3IP : TBits_3 read getINT3IP write setINT3IP;
    property INT3IS : TBits_2 read getINT3IS write setINT3IS;
    property OC3IP : TBits_3 read getOC3IP write setOC3IP;
    property OC3IS : TBits_2 read getOC3IS write setOC3IS;
    property T3IP : TBits_3 read getT3IP write setT3IP;
    property T3IS : TBits_2 read getT3IS write setT3IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC4 = record
  private
    function  getIC4IP : TBits_3; inline;
    function  getIC4IS : TBits_2; inline;
    function  getINT4IP : TBits_3; inline;
    function  getINT4IS : TBits_2; inline;
    function  getOC4IP : TBits_3; inline;
    function  getOC4IS : TBits_2; inline;
    function  getT4IP : TBits_3; inline;
    function  getT4IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setIC4IP(thebits : TBits_3); inline;
    procedure setIC4IS(thebits : TBits_2); inline;
    procedure setINT4IP(thebits : TBits_3); inline;
    procedure setINT4IS(thebits : TBits_2); inline;
    procedure setOC4IP(thebits : TBits_3); inline;
    procedure setOC4IS(thebits : TBits_2); inline;
    procedure setT4IP(thebits : TBits_3); inline;
    procedure setT4IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property IC4IP : TBits_3 read getIC4IP write setIC4IP;
    property IC4IS : TBits_2 read getIC4IS write setIC4IS;
    property INT4IP : TBits_3 read getINT4IP write setINT4IP;
    property INT4IS : TBits_2 read getINT4IS write setINT4IS;
    property OC4IP : TBits_3 read getOC4IP write setOC4IP;
    property OC4IS : TBits_2 read getOC4IS write setOC4IS;
    property T4IP : TBits_3 read getT4IP write setT4IP;
    property T4IS : TBits_2 read getT4IS write setT4IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC5 = record
  private
    function  getAD1IP : TBits_3; inline;
    function  getAD1IS : TBits_2; inline;
    function  getIC5IP : TBits_3; inline;
    function  getIC5IS : TBits_2; inline;
    function  getOC5IP : TBits_3; inline;
    function  getOC5IS : TBits_2; inline;
    function  getT5IP : TBits_3; inline;
    function  getT5IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setAD1IP(thebits : TBits_3); inline;
    procedure setAD1IS(thebits : TBits_2); inline;
    procedure setIC5IP(thebits : TBits_3); inline;
    procedure setIC5IS(thebits : TBits_2); inline;
    procedure setOC5IP(thebits : TBits_3); inline;
    procedure setOC5IS(thebits : TBits_2); inline;
    procedure setT5IP(thebits : TBits_3); inline;
    procedure setT5IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property AD1IP : TBits_3 read getAD1IP write setAD1IP;
    property AD1IS : TBits_2 read getAD1IS write setAD1IS;
    property IC5IP : TBits_3 read getIC5IP write setIC5IP;
    property IC5IS : TBits_2 read getIC5IS write setIC5IS;
    property OC5IP : TBits_3 read getOC5IP write setOC5IP;
    property OC5IS : TBits_2 read getOC5IS write setOC5IS;
    property T5IP : TBits_3 read getT5IP write setT5IP;
    property T5IS : TBits_2 read getT5IS write setT5IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC6 = record
  private
    function  getCMP1IP : TBits_3; inline;
    function  getCMP1IS : TBits_2; inline;
    function  getFCEIP : TBits_3; inline;
    function  getFCEIS : TBits_2; inline;
    function  getFSCMIP : TBits_3; inline;
    function  getFSCMIS : TBits_2; inline;
    function  getRTCCIP : TBits_3; inline;
    function  getRTCCIS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCMP1IP(thebits : TBits_3); inline;
    procedure setCMP1IS(thebits : TBits_2); inline;
    procedure setFCEIP(thebits : TBits_3); inline;
    procedure setFCEIS(thebits : TBits_2); inline;
    procedure setFSCMIP(thebits : TBits_3); inline;
    procedure setFSCMIS(thebits : TBits_2); inline;
    procedure setRTCCIP(thebits : TBits_3); inline;
    procedure setRTCCIS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CMP1IP : TBits_3 read getCMP1IP write setCMP1IP;
    property CMP1IS : TBits_2 read getCMP1IS write setCMP1IS;
    property FCEIP : TBits_3 read getFCEIP write setFCEIP;
    property FCEIS : TBits_2 read getFCEIS write setFCEIS;
    property FSCMIP : TBits_3 read getFSCMIP write setFSCMIP;
    property FSCMIS : TBits_2 read getFSCMIS write setFSCMIS;
    property RTCCIP : TBits_3 read getRTCCIP write setRTCCIP;
    property RTCCIS : TBits_2 read getRTCCIS write setRTCCIS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC7 = record
  private
    function  getCMP2IP : TBits_3; inline;
    function  getCMP2IS : TBits_2; inline;
    function  getCMP3IP : TBits_3; inline;
    function  getCMP3IS : TBits_2; inline;
    function  getSPI1IP : TBits_3; inline;
    function  getSPI1IS : TBits_2; inline;
    function  getUSBIP : TBits_3; inline;
    function  getUSBIS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCMP2IP(thebits : TBits_3); inline;
    procedure setCMP2IS(thebits : TBits_2); inline;
    procedure setCMP3IP(thebits : TBits_3); inline;
    procedure setCMP3IS(thebits : TBits_2); inline;
    procedure setSPI1IP(thebits : TBits_3); inline;
    procedure setSPI1IS(thebits : TBits_2); inline;
    procedure setUSBIP(thebits : TBits_3); inline;
    procedure setUSBIS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CMP2IP : TBits_3 read getCMP2IP write setCMP2IP;
    property CMP2IS : TBits_2 read getCMP2IS write setCMP2IS;
    property CMP3IP : TBits_3 read getCMP3IP write setCMP3IP;
    property CMP3IS : TBits_2 read getCMP3IS write setCMP3IS;
    property SPI1IP : TBits_3 read getSPI1IP write setSPI1IP;
    property SPI1IS : TBits_2 read getSPI1IS write setSPI1IS;
    property USBIP : TBits_3 read getUSBIP write setUSBIP;
    property USBIS : TBits_2 read getUSBIS write setUSBIS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC8 = record
  private
    function  getCNIP : TBits_3; inline;
    function  getCNIS : TBits_2; inline;
    function  getI2C1IP : TBits_3; inline;
    function  getI2C1IS : TBits_2; inline;
    function  getPMPIP : TBits_3; inline;
    function  getPMPIS : TBits_2; inline;
    function  getU1IP : TBits_3; inline;
    function  getU1IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCNIP(thebits : TBits_3); inline;
    procedure setCNIS(thebits : TBits_2); inline;
    procedure setI2C1IP(thebits : TBits_3); inline;
    procedure setI2C1IS(thebits : TBits_2); inline;
    procedure setPMPIP(thebits : TBits_3); inline;
    procedure setPMPIS(thebits : TBits_2); inline;
    procedure setU1IP(thebits : TBits_3); inline;
    procedure setU1IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CNIP : TBits_3 read getCNIP write setCNIP;
    property CNIS : TBits_2 read getCNIS write setCNIS;
    property I2C1IP : TBits_3 read getI2C1IP write setI2C1IP;
    property I2C1IS : TBits_2 read getI2C1IS write setI2C1IS;
    property PMPIP : TBits_3 read getPMPIP write setPMPIP;
    property PMPIS : TBits_2 read getPMPIS write setPMPIS;
    property U1IP : TBits_3 read getU1IP write setU1IP;
    property U1IS : TBits_2 read getU1IS write setU1IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC9 = record
  private
    function  getCTMUIP : TBits_3; inline;
    function  getCTMUIS : TBits_2; inline;
    function  getI2C2IP : TBits_3; inline;
    function  getI2C2IS : TBits_2; inline;
    function  getSPI2IP : TBits_3; inline;
    function  getSPI2IS : TBits_2; inline;
    function  getU2IP : TBits_3; inline;
    function  getU2IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCTMUIP(thebits : TBits_3); inline;
    procedure setCTMUIS(thebits : TBits_2); inline;
    procedure setI2C2IP(thebits : TBits_3); inline;
    procedure setI2C2IS(thebits : TBits_2); inline;
    procedure setSPI2IP(thebits : TBits_3); inline;
    procedure setSPI2IS(thebits : TBits_2); inline;
    procedure setU2IP(thebits : TBits_3); inline;
    procedure setU2IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property CTMUIP : TBits_3 read getCTMUIP write setCTMUIP;
    property CTMUIS : TBits_2 read getCTMUIS write setCTMUIS;
    property I2C2IP : TBits_3 read getI2C2IP write setI2C2IP;
    property I2C2IS : TBits_2 read getI2C2IS write setI2C2IS;
    property SPI2IP : TBits_3 read getSPI2IP write setSPI2IP;
    property SPI2IS : TBits_2 read getSPI2IS write setSPI2IS;
    property U2IP : TBits_3 read getU2IP write setU2IP;
    property U2IS : TBits_2 read getU2IS write setU2IS;
    property w : TBits_32 read getw write setw;
  end;
  TINT_IPC10 = record
  private
    function  getDMA0IP : TBits_3; inline;
    function  getDMA0IS : TBits_2; inline;
    function  getDMA1IP : TBits_3; inline;
    function  getDMA1IS : TBits_2; inline;
    function  getDMA2IP : TBits_3; inline;
    function  getDMA2IS : TBits_2; inline;
    function  getDMA3IP : TBits_3; inline;
    function  getDMA3IS : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setDMA0IP(thebits : TBits_3); inline;
    procedure setDMA0IS(thebits : TBits_2); inline;
    procedure setDMA1IP(thebits : TBits_3); inline;
    procedure setDMA1IS(thebits : TBits_2); inline;
    procedure setDMA2IP(thebits : TBits_3); inline;
    procedure setDMA2IS(thebits : TBits_2); inline;
    procedure setDMA3IP(thebits : TBits_3); inline;
    procedure setDMA3IS(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    property DMA0IP : TBits_3 read getDMA0IP write setDMA0IP;
    property DMA0IS : TBits_2 read getDMA0IS write setDMA0IS;
    property DMA1IP : TBits_3 read getDMA1IP write setDMA1IP;
    property DMA1IS : TBits_2 read getDMA1IS write setDMA1IS;
    property DMA2IP : TBits_3 read getDMA2IP write setDMA2IP;
    property DMA2IS : TBits_2 read getDMA2IS write setDMA2IS;
    property DMA3IP : TBits_3 read getDMA3IP write setDMA3IP;
    property DMA3IS : TBits_2 read getDMA3IS write setDMA3IS;
    property w : TBits_32 read getw write setw;
  end;
type
  TINTRegisters = record
    INTCONbits : TINT_INTCON;
    INTCON : longWord;
    INTCONCLR : longWord;
    INTCONSET : longWord;
    INTCONINV : longWord;
    INTSTAT : longWord;
    IPTMR : longWord;
    IPTMRCLR : longWord;
    IPTMRSET : longWord;
    IPTMRINV : longWord;
    IFS0bits : TINT_IFS0;
    IFS0 : longWord;
    IFS0CLR : longWord;
    IFS0SET : longWord;
    IFS0INV : longWord;
    IFS1bits : TINT_IFS1;
    IFS1 : longWord;
    IFS1CLR : longWord;
    IFS1SET : longWord;
    IFS1INV : longWord;
    IEC0bits : TINT_IEC0;
    IEC0 : longWord;
    IEC0CLR : longWord;
    IEC0SET : longWord;
    IEC0INV : longWord;
    IEC1bits : TINT_IEC1;
    IEC1 : longWord;
    IEC1CLR : longWord;
    IEC1SET : longWord;
    IEC1INV : longWord;
    IPC0bits : TINT_IPC0;
    IPC0 : longWord;
    IPC0CLR : longWord;
    IPC0SET : longWord;
    IPC0INV : longWord;
    IPC1bits : TINT_IPC1;
    IPC1 : longWord;
    IPC1CLR : longWord;
    IPC1SET : longWord;
    IPC1INV : longWord;
    IPC2bits : TINT_IPC2;
    IPC2 : longWord;
    IPC2CLR : longWord;
    IPC2SET : longWord;
    IPC2INV : longWord;
    IPC3bits : TINT_IPC3;
    IPC3 : longWord;
    IPC3CLR : longWord;
    IPC3SET : longWord;
    IPC3INV : longWord;
    IPC4bits : TINT_IPC4;
    IPC4 : longWord;
    IPC4CLR : longWord;
    IPC4SET : longWord;
    IPC4INV : longWord;
    IPC5bits : TINT_IPC5;
    IPC5 : longWord;
    IPC5CLR : longWord;
    IPC5SET : longWord;
    IPC5INV : longWord;
    IPC6bits : TINT_IPC6;
    IPC6 : longWord;
    IPC6CLR : longWord;
    IPC6SET : longWord;
    IPC6INV : longWord;
    IPC7bits : TINT_IPC7;
    IPC7 : longWord;
    IPC7CLR : longWord;
    IPC7SET : longWord;
    IPC7INV : longWord;
    IPC8bits : TINT_IPC8;
    IPC8 : longWord;
    IPC8CLR : longWord;
    IPC8SET : longWord;
    IPC8INV : longWord;
    IPC9bits : TINT_IPC9;
    IPC9 : longWord;
    IPC9CLR : longWord;
    IPC9SET : longWord;
    IPC9INV : longWord;
    IPC10bits : TINT_IPC10;
    IPC10 : longWord;
    IPC10CLR : longWord;
    IPC10SET : longWord;
    IPC10INV : longWord;
  end;
  TBMX_BMXCON = record
  private
    function  getBMXARB : TBits_3; inline;
    function  getBMXCHEDMA : TBits_1; inline;
    function  getBMXERRDMA : TBits_1; inline;
    function  getBMXERRDS : TBits_1; inline;
    function  getBMXERRICD : TBits_1; inline;
    function  getBMXERRIS : TBits_1; inline;
    function  getBMXERRIXI : TBits_1; inline;
    function  getBMXWSDRM : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBMXARB(thebits : TBits_3); inline;
    procedure setBMXCHEDMA(thebits : TBits_1); inline;
    procedure setBMXERRDMA(thebits : TBits_1); inline;
    procedure setBMXERRDS(thebits : TBits_1); inline;
    procedure setBMXERRICD(thebits : TBits_1); inline;
    procedure setBMXERRIS(thebits : TBits_1); inline;
    procedure setBMXERRIXI(thebits : TBits_1); inline;
    procedure setBMXWSDRM(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBMXCHEDMA; inline;
    procedure clearBMXERRDMA; inline;
    procedure clearBMXERRDS; inline;
    procedure clearBMXERRICD; inline;
    procedure clearBMXERRIS; inline;
    procedure clearBMXERRIXI; inline;
    procedure clearBMXWSDRM; inline;
    procedure setBMXCHEDMA; inline;
    procedure setBMXERRDMA; inline;
    procedure setBMXERRDS; inline;
    procedure setBMXERRICD; inline;
    procedure setBMXERRIS; inline;
    procedure setBMXERRIXI; inline;
    procedure setBMXWSDRM; inline;
    property BMXARB : TBits_3 read getBMXARB write setBMXARB;
    property BMXCHEDMA : TBits_1 read getBMXCHEDMA write setBMXCHEDMA;
    property BMXERRDMA : TBits_1 read getBMXERRDMA write setBMXERRDMA;
    property BMXERRDS : TBits_1 read getBMXERRDS write setBMXERRDS;
    property BMXERRICD : TBits_1 read getBMXERRICD write setBMXERRICD;
    property BMXERRIS : TBits_1 read getBMXERRIS write setBMXERRIS;
    property BMXERRIXI : TBits_1 read getBMXERRIXI write setBMXERRIXI;
    property BMXWSDRM : TBits_1 read getBMXWSDRM write setBMXWSDRM;
    property w : TBits_32 read getw write setw;
  end;
type
  TBMXRegisters = record
    BMXCONbits : TBMX_BMXCON;
    BMXCON : longWord;
    BMXCONCLR : longWord;
    BMXCONSET : longWord;
    BMXCONINV : longWord;
    BMXDKPBA : longWord;
    BMXDKPBACLR : longWord;
    BMXDKPBASET : longWord;
    BMXDKPBAINV : longWord;
    BMXDUDBA : longWord;
    BMXDUDBACLR : longWord;
    BMXDUDBASET : longWord;
    BMXDUDBAINV : longWord;
    BMXDUPBA : longWord;
    BMXDUPBACLR : longWord;
    BMXDUPBASET : longWord;
    BMXDUPBAINV : longWord;
    BMXDRMSZ : longWord;
    BMXPUPBA : longWord;
    BMXPUPBACLR : longWord;
    BMXPUPBASET : longWord;
    BMXPUPBAINV : longWord;
    BMXPFMSZ : longWord;
    BMXBOOTSZ : longWord;
  end;
  TDMAC_DMACON = record
  private
    function  getDMABUSY : TBits_1; inline;
    function  getON : TBits_1; inline;
    function  getSUSPEND : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDMABUSY(thebits : TBits_1); inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSUSPEND(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearDMABUSY; inline;
    procedure clearON; inline;
    procedure clearSUSPEND; inline;
    procedure setDMABUSY; inline;
    procedure setON; inline;
    procedure setSUSPEND; inline;
    property DMABUSY : TBits_1 read getDMABUSY write setDMABUSY;
    property ON : TBits_1 read getON write setON;
    property SUSPEND : TBits_1 read getSUSPEND write setSUSPEND;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC_DMASTAT = record
  private
    function  getDMACH : TBits_3; inline;
    function  getRDWR : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setDMACH(thebits : TBits_3); inline;
    procedure setRDWR(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRDWR; inline;
    procedure setRDWR; inline;
    property DMACH : TBits_3 read getDMACH write setDMACH;
    property RDWR : TBits_1 read getRDWR write setRDWR;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC_DCRCCON = record
  private
    function  getBITO : TBits_1; inline;
    function  getBYTO : TBits_2; inline;
    function  getCRCAPP : TBits_1; inline;
    function  getCRCCH : TBits_3; inline;
    function  getCRCEN : TBits_1; inline;
    function  getCRCTYP : TBits_1; inline;
    function  getPLEN : TBits_5; inline;
    function  getWBO : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setBITO(thebits : TBits_1); inline;
    procedure setBYTO(thebits : TBits_2); inline;
    procedure setCRCAPP(thebits : TBits_1); inline;
    procedure setCRCCH(thebits : TBits_3); inline;
    procedure setCRCEN(thebits : TBits_1); inline;
    procedure setCRCTYP(thebits : TBits_1); inline;
    procedure setPLEN(thebits : TBits_5); inline;
    procedure setWBO(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBITO; inline;
    procedure clearCRCAPP; inline;
    procedure clearCRCEN; inline;
    procedure clearCRCTYP; inline;
    procedure clearWBO; inline;
    procedure setBITO; inline;
    procedure setCRCAPP; inline;
    procedure setCRCEN; inline;
    procedure setCRCTYP; inline;
    procedure setWBO; inline;
    property BITO : TBits_1 read getBITO write setBITO;
    property BYTO : TBits_2 read getBYTO write setBYTO;
    property CRCAPP : TBits_1 read getCRCAPP write setCRCAPP;
    property CRCCH : TBits_3 read getCRCCH write setCRCCH;
    property CRCEN : TBits_1 read getCRCEN write setCRCEN;
    property CRCTYP : TBits_1 read getCRCTYP write setCRCTYP;
    property PLEN : TBits_5 read getPLEN write setPLEN;
    property WBO : TBits_1 read getWBO write setWBO;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMACRegisters = record
    DMACONbits : TDMAC_DMACON;
    DMACON : longWord;
    DMACONCLR : longWord;
    DMACONSET : longWord;
    DMACONINV : longWord;
    DMASTATbits : TDMAC_DMASTAT;
    DMASTAT : longWord;
    DMASTATCLR : longWord;
    DMASTATSET : longWord;
    DMASTATINV : longWord;
    DMAADDR : longWord;
    DMAADDRCLR : longWord;
    DMAADDRSET : longWord;
    DMAADDRINV : longWord;
    DCRCCONbits : TDMAC_DCRCCON;
    DCRCCON : longWord;
    DCRCCONCLR : longWord;
    DCRCCONSET : longWord;
    DCRCCONINV : longWord;
    DCRCDATA : longWord;
    DCRCDATACLR : longWord;
    DCRCDATASET : longWord;
    DCRCDATAINV : longWord;
    DCRCXOR : longWord;
    DCRCXORCLR : longWord;
    DCRCXORSET : longWord;
    DCRCXORINV : longWord;
  end;
  TDMAC0_DCH0CON = record
  private
    function  getCHAED : TBits_1; inline;
    function  getCHAEN : TBits_1; inline;
    function  getCHBUSY : TBits_1; inline;
    function  getCHCHN : TBits_1; inline;
    function  getCHCHNS : TBits_1; inline;
    function  getCHEDET : TBits_1; inline;
    function  getCHEN : TBits_1; inline;
    function  getCHPRI : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHAED(thebits : TBits_1); inline;
    procedure setCHAEN(thebits : TBits_1); inline;
    procedure setCHBUSY(thebits : TBits_1); inline;
    procedure setCHCHN(thebits : TBits_1); inline;
    procedure setCHCHNS(thebits : TBits_1); inline;
    procedure setCHEDET(thebits : TBits_1); inline;
    procedure setCHEN(thebits : TBits_1); inline;
    procedure setCHPRI(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHAED; inline;
    procedure clearCHAEN; inline;
    procedure clearCHBUSY; inline;
    procedure clearCHCHN; inline;
    procedure clearCHCHNS; inline;
    procedure clearCHEDET; inline;
    procedure clearCHEN; inline;
    procedure setCHAED; inline;
    procedure setCHAEN; inline;
    procedure setCHBUSY; inline;
    procedure setCHCHN; inline;
    procedure setCHCHNS; inline;
    procedure setCHEDET; inline;
    procedure setCHEN; inline;
    property CHAED : TBits_1 read getCHAED write setCHAED;
    property CHAEN : TBits_1 read getCHAEN write setCHAEN;
    property CHBUSY : TBits_1 read getCHBUSY write setCHBUSY;
    property CHCHN : TBits_1 read getCHCHN write setCHCHN;
    property CHCHNS : TBits_1 read getCHCHNS write setCHCHNS;
    property CHEDET : TBits_1 read getCHEDET write setCHEDET;
    property CHEN : TBits_1 read getCHEN write setCHEN;
    property CHPRI : TBits_2 read getCHPRI write setCHPRI;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC0_DCH0ECON = record
  private
    function  getAIRQEN : TBits_1; inline;
    function  getCABORT : TBits_1; inline;
    function  getCFORCE : TBits_1; inline;
    function  getCHAIRQ : TBits_8; inline;
    function  getCHSIRQ : TBits_8; inline;
    function  getPATEN : TBits_1; inline;
    function  getSIRQEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAIRQEN(thebits : TBits_1); inline;
    procedure setCABORT(thebits : TBits_1); inline;
    procedure setCFORCE(thebits : TBits_1); inline;
    procedure setCHAIRQ(thebits : TBits_8); inline;
    procedure setCHSIRQ(thebits : TBits_8); inline;
    procedure setPATEN(thebits : TBits_1); inline;
    procedure setSIRQEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAIRQEN; inline;
    procedure clearCABORT; inline;
    procedure clearCFORCE; inline;
    procedure clearPATEN; inline;
    procedure clearSIRQEN; inline;
    procedure setAIRQEN; inline;
    procedure setCABORT; inline;
    procedure setCFORCE; inline;
    procedure setPATEN; inline;
    procedure setSIRQEN; inline;
    property AIRQEN : TBits_1 read getAIRQEN write setAIRQEN;
    property CABORT : TBits_1 read getCABORT write setCABORT;
    property CFORCE : TBits_1 read getCFORCE write setCFORCE;
    property CHAIRQ : TBits_8 read getCHAIRQ write setCHAIRQ;
    property CHSIRQ : TBits_8 read getCHSIRQ write setCHSIRQ;
    property PATEN : TBits_1 read getPATEN write setPATEN;
    property SIRQEN : TBits_1 read getSIRQEN write setSIRQEN;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC0_DCH0INT = record
  private
    function  getCHBCIE : TBits_1; inline;
    function  getCHBCIF : TBits_1; inline;
    function  getCHCCIE : TBits_1; inline;
    function  getCHCCIF : TBits_1; inline;
    function  getCHDDIE : TBits_1; inline;
    function  getCHDDIF : TBits_1; inline;
    function  getCHDHIE : TBits_1; inline;
    function  getCHDHIF : TBits_1; inline;
    function  getCHERIE : TBits_1; inline;
    function  getCHERIF : TBits_1; inline;
    function  getCHSDIE : TBits_1; inline;
    function  getCHSDIF : TBits_1; inline;
    function  getCHSHIE : TBits_1; inline;
    function  getCHSHIF : TBits_1; inline;
    function  getCHTAIE : TBits_1; inline;
    function  getCHTAIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCHBCIE(thebits : TBits_1); inline;
    procedure setCHBCIF(thebits : TBits_1); inline;
    procedure setCHCCIE(thebits : TBits_1); inline;
    procedure setCHCCIF(thebits : TBits_1); inline;
    procedure setCHDDIE(thebits : TBits_1); inline;
    procedure setCHDDIF(thebits : TBits_1); inline;
    procedure setCHDHIE(thebits : TBits_1); inline;
    procedure setCHDHIF(thebits : TBits_1); inline;
    procedure setCHERIE(thebits : TBits_1); inline;
    procedure setCHERIF(thebits : TBits_1); inline;
    procedure setCHSDIE(thebits : TBits_1); inline;
    procedure setCHSDIF(thebits : TBits_1); inline;
    procedure setCHSHIE(thebits : TBits_1); inline;
    procedure setCHSHIF(thebits : TBits_1); inline;
    procedure setCHTAIE(thebits : TBits_1); inline;
    procedure setCHTAIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHBCIE; inline;
    procedure clearCHBCIF; inline;
    procedure clearCHCCIE; inline;
    procedure clearCHCCIF; inline;
    procedure clearCHDDIE; inline;
    procedure clearCHDDIF; inline;
    procedure clearCHDHIE; inline;
    procedure clearCHDHIF; inline;
    procedure clearCHERIE; inline;
    procedure clearCHERIF; inline;
    procedure clearCHSDIE; inline;
    procedure clearCHSDIF; inline;
    procedure clearCHSHIE; inline;
    procedure clearCHSHIF; inline;
    procedure clearCHTAIE; inline;
    procedure clearCHTAIF; inline;
    procedure setCHBCIE; inline;
    procedure setCHBCIF; inline;
    procedure setCHCCIE; inline;
    procedure setCHCCIF; inline;
    procedure setCHDDIE; inline;
    procedure setCHDDIF; inline;
    procedure setCHDHIE; inline;
    procedure setCHDHIF; inline;
    procedure setCHERIE; inline;
    procedure setCHERIF; inline;
    procedure setCHSDIE; inline;
    procedure setCHSDIF; inline;
    procedure setCHSHIE; inline;
    procedure setCHSHIF; inline;
    procedure setCHTAIE; inline;
    procedure setCHTAIF; inline;
    property CHBCIE : TBits_1 read getCHBCIE write setCHBCIE;
    property CHBCIF : TBits_1 read getCHBCIF write setCHBCIF;
    property CHCCIE : TBits_1 read getCHCCIE write setCHCCIE;
    property CHCCIF : TBits_1 read getCHCCIF write setCHCCIF;
    property CHDDIE : TBits_1 read getCHDDIE write setCHDDIE;
    property CHDDIF : TBits_1 read getCHDDIF write setCHDDIF;
    property CHDHIE : TBits_1 read getCHDHIE write setCHDHIE;
    property CHDHIF : TBits_1 read getCHDHIF write setCHDHIF;
    property CHERIE : TBits_1 read getCHERIE write setCHERIE;
    property CHERIF : TBits_1 read getCHERIF write setCHERIF;
    property CHSDIE : TBits_1 read getCHSDIE write setCHSDIE;
    property CHSDIF : TBits_1 read getCHSDIF write setCHSDIF;
    property CHSHIE : TBits_1 read getCHSHIE write setCHSHIE;
    property CHSHIF : TBits_1 read getCHSHIF write setCHSHIF;
    property CHTAIE : TBits_1 read getCHTAIE write setCHTAIE;
    property CHTAIF : TBits_1 read getCHTAIF write setCHTAIF;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMAC0Registers = record
    DCH0CONbits : TDMAC0_DCH0CON;
    DCH0CON : longWord;
    DCH0CONCLR : longWord;
    DCH0CONSET : longWord;
    DCH0CONINV : longWord;
    DCH0ECONbits : TDMAC0_DCH0ECON;
    DCH0ECON : longWord;
    DCH0ECONCLR : longWord;
    DCH0ECONSET : longWord;
    DCH0ECONINV : longWord;
    DCH0INTbits : TDMAC0_DCH0INT;
    DCH0INT : longWord;
    DCH0INTCLR : longWord;
    DCH0INTSET : longWord;
    DCH0INTINV : longWord;
    DCH0SSA : longWord;
    DCH0SSACLR : longWord;
    DCH0SSASET : longWord;
    DCH0SSAINV : longWord;
    DCH0DSA : longWord;
    DCH0DSACLR : longWord;
    DCH0DSASET : longWord;
    DCH0DSAINV : longWord;
    DCH0SSIZ : longWord;
    DCH0SSIZCLR : longWord;
    DCH0SSIZSET : longWord;
    DCH0SSIZINV : longWord;
    DCH0DSIZ : longWord;
    DCH0DSIZCLR : longWord;
    DCH0DSIZSET : longWord;
    DCH0DSIZINV : longWord;
    DCH0SPTR : longWord;
    DCH0SPTRCLR : longWord;
    DCH0SPTRSET : longWord;
    DCH0SPTRINV : longWord;
    DCH0DPTR : longWord;
    DCH0DPTRCLR : longWord;
    DCH0DPTRSET : longWord;
    DCH0DPTRINV : longWord;
    DCH0CSIZ : longWord;
    DCH0CSIZCLR : longWord;
    DCH0CSIZSET : longWord;
    DCH0CSIZINV : longWord;
    DCH0CPTR : longWord;
    DCH0CPTRCLR : longWord;
    DCH0CPTRSET : longWord;
    DCH0CPTRINV : longWord;
    DCH0DAT : longWord;
    DCH0DATCLR : longWord;
    DCH0DATSET : longWord;
    DCH0DATINV : longWord;
  end;
  TDMAC1_DCH1CON = record
  private
    function  getCHAED : TBits_1; inline;
    function  getCHAEN : TBits_1; inline;
    function  getCHBUSY : TBits_1; inline;
    function  getCHCHN : TBits_1; inline;
    function  getCHCHNS : TBits_1; inline;
    function  getCHEDET : TBits_1; inline;
    function  getCHEN : TBits_1; inline;
    function  getCHPRI : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHAED(thebits : TBits_1); inline;
    procedure setCHAEN(thebits : TBits_1); inline;
    procedure setCHBUSY(thebits : TBits_1); inline;
    procedure setCHCHN(thebits : TBits_1); inline;
    procedure setCHCHNS(thebits : TBits_1); inline;
    procedure setCHEDET(thebits : TBits_1); inline;
    procedure setCHEN(thebits : TBits_1); inline;
    procedure setCHPRI(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHAED; inline;
    procedure clearCHAEN; inline;
    procedure clearCHBUSY; inline;
    procedure clearCHCHN; inline;
    procedure clearCHCHNS; inline;
    procedure clearCHEDET; inline;
    procedure clearCHEN; inline;
    procedure setCHAED; inline;
    procedure setCHAEN; inline;
    procedure setCHBUSY; inline;
    procedure setCHCHN; inline;
    procedure setCHCHNS; inline;
    procedure setCHEDET; inline;
    procedure setCHEN; inline;
    property CHAED : TBits_1 read getCHAED write setCHAED;
    property CHAEN : TBits_1 read getCHAEN write setCHAEN;
    property CHBUSY : TBits_1 read getCHBUSY write setCHBUSY;
    property CHCHN : TBits_1 read getCHCHN write setCHCHN;
    property CHCHNS : TBits_1 read getCHCHNS write setCHCHNS;
    property CHEDET : TBits_1 read getCHEDET write setCHEDET;
    property CHEN : TBits_1 read getCHEN write setCHEN;
    property CHPRI : TBits_2 read getCHPRI write setCHPRI;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC1_DCH1ECON = record
  private
    function  getAIRQEN : TBits_1; inline;
    function  getCABORT : TBits_1; inline;
    function  getCFORCE : TBits_1; inline;
    function  getCHAIRQ : TBits_8; inline;
    function  getCHSIRQ : TBits_8; inline;
    function  getPATEN : TBits_1; inline;
    function  getSIRQEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAIRQEN(thebits : TBits_1); inline;
    procedure setCABORT(thebits : TBits_1); inline;
    procedure setCFORCE(thebits : TBits_1); inline;
    procedure setCHAIRQ(thebits : TBits_8); inline;
    procedure setCHSIRQ(thebits : TBits_8); inline;
    procedure setPATEN(thebits : TBits_1); inline;
    procedure setSIRQEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAIRQEN; inline;
    procedure clearCABORT; inline;
    procedure clearCFORCE; inline;
    procedure clearPATEN; inline;
    procedure clearSIRQEN; inline;
    procedure setAIRQEN; inline;
    procedure setCABORT; inline;
    procedure setCFORCE; inline;
    procedure setPATEN; inline;
    procedure setSIRQEN; inline;
    property AIRQEN : TBits_1 read getAIRQEN write setAIRQEN;
    property CABORT : TBits_1 read getCABORT write setCABORT;
    property CFORCE : TBits_1 read getCFORCE write setCFORCE;
    property CHAIRQ : TBits_8 read getCHAIRQ write setCHAIRQ;
    property CHSIRQ : TBits_8 read getCHSIRQ write setCHSIRQ;
    property PATEN : TBits_1 read getPATEN write setPATEN;
    property SIRQEN : TBits_1 read getSIRQEN write setSIRQEN;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC1_DCH1INT = record
  private
    function  getCHBCIE : TBits_1; inline;
    function  getCHBCIF : TBits_1; inline;
    function  getCHCCIE : TBits_1; inline;
    function  getCHCCIF : TBits_1; inline;
    function  getCHDDIE : TBits_1; inline;
    function  getCHDDIF : TBits_1; inline;
    function  getCHDHIE : TBits_1; inline;
    function  getCHDHIF : TBits_1; inline;
    function  getCHERIE : TBits_1; inline;
    function  getCHERIF : TBits_1; inline;
    function  getCHSDIE : TBits_1; inline;
    function  getCHSDIF : TBits_1; inline;
    function  getCHSHIE : TBits_1; inline;
    function  getCHSHIF : TBits_1; inline;
    function  getCHTAIE : TBits_1; inline;
    function  getCHTAIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCHBCIE(thebits : TBits_1); inline;
    procedure setCHBCIF(thebits : TBits_1); inline;
    procedure setCHCCIE(thebits : TBits_1); inline;
    procedure setCHCCIF(thebits : TBits_1); inline;
    procedure setCHDDIE(thebits : TBits_1); inline;
    procedure setCHDDIF(thebits : TBits_1); inline;
    procedure setCHDHIE(thebits : TBits_1); inline;
    procedure setCHDHIF(thebits : TBits_1); inline;
    procedure setCHERIE(thebits : TBits_1); inline;
    procedure setCHERIF(thebits : TBits_1); inline;
    procedure setCHSDIE(thebits : TBits_1); inline;
    procedure setCHSDIF(thebits : TBits_1); inline;
    procedure setCHSHIE(thebits : TBits_1); inline;
    procedure setCHSHIF(thebits : TBits_1); inline;
    procedure setCHTAIE(thebits : TBits_1); inline;
    procedure setCHTAIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHBCIE; inline;
    procedure clearCHBCIF; inline;
    procedure clearCHCCIE; inline;
    procedure clearCHCCIF; inline;
    procedure clearCHDDIE; inline;
    procedure clearCHDDIF; inline;
    procedure clearCHDHIE; inline;
    procedure clearCHDHIF; inline;
    procedure clearCHERIE; inline;
    procedure clearCHERIF; inline;
    procedure clearCHSDIE; inline;
    procedure clearCHSDIF; inline;
    procedure clearCHSHIE; inline;
    procedure clearCHSHIF; inline;
    procedure clearCHTAIE; inline;
    procedure clearCHTAIF; inline;
    procedure setCHBCIE; inline;
    procedure setCHBCIF; inline;
    procedure setCHCCIE; inline;
    procedure setCHCCIF; inline;
    procedure setCHDDIE; inline;
    procedure setCHDDIF; inline;
    procedure setCHDHIE; inline;
    procedure setCHDHIF; inline;
    procedure setCHERIE; inline;
    procedure setCHERIF; inline;
    procedure setCHSDIE; inline;
    procedure setCHSDIF; inline;
    procedure setCHSHIE; inline;
    procedure setCHSHIF; inline;
    procedure setCHTAIE; inline;
    procedure setCHTAIF; inline;
    property CHBCIE : TBits_1 read getCHBCIE write setCHBCIE;
    property CHBCIF : TBits_1 read getCHBCIF write setCHBCIF;
    property CHCCIE : TBits_1 read getCHCCIE write setCHCCIE;
    property CHCCIF : TBits_1 read getCHCCIF write setCHCCIF;
    property CHDDIE : TBits_1 read getCHDDIE write setCHDDIE;
    property CHDDIF : TBits_1 read getCHDDIF write setCHDDIF;
    property CHDHIE : TBits_1 read getCHDHIE write setCHDHIE;
    property CHDHIF : TBits_1 read getCHDHIF write setCHDHIF;
    property CHERIE : TBits_1 read getCHERIE write setCHERIE;
    property CHERIF : TBits_1 read getCHERIF write setCHERIF;
    property CHSDIE : TBits_1 read getCHSDIE write setCHSDIE;
    property CHSDIF : TBits_1 read getCHSDIF write setCHSDIF;
    property CHSHIE : TBits_1 read getCHSHIE write setCHSHIE;
    property CHSHIF : TBits_1 read getCHSHIF write setCHSHIF;
    property CHTAIE : TBits_1 read getCHTAIE write setCHTAIE;
    property CHTAIF : TBits_1 read getCHTAIF write setCHTAIF;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMAC1Registers = record
    DCH1CONbits : TDMAC1_DCH1CON;
    DCH1CON : longWord;
    DCH1CONCLR : longWord;
    DCH1CONSET : longWord;
    DCH1CONINV : longWord;
    DCH1ECONbits : TDMAC1_DCH1ECON;
    DCH1ECON : longWord;
    DCH1ECONCLR : longWord;
    DCH1ECONSET : longWord;
    DCH1ECONINV : longWord;
    DCH1INTbits : TDMAC1_DCH1INT;
    DCH1INT : longWord;
    DCH1INTCLR : longWord;
    DCH1INTSET : longWord;
    DCH1INTINV : longWord;
    DCH1SSA : longWord;
    DCH1SSACLR : longWord;
    DCH1SSASET : longWord;
    DCH1SSAINV : longWord;
    DCH1DSA : longWord;
    DCH1DSACLR : longWord;
    DCH1DSASET : longWord;
    DCH1DSAINV : longWord;
    DCH1SSIZ : longWord;
    DCH1SSIZCLR : longWord;
    DCH1SSIZSET : longWord;
    DCH1SSIZINV : longWord;
    DCH1DSIZ : longWord;
    DCH1DSIZCLR : longWord;
    DCH1DSIZSET : longWord;
    DCH1DSIZINV : longWord;
    DCH1SPTR : longWord;
    DCH1SPTRCLR : longWord;
    DCH1SPTRSET : longWord;
    DCH1SPTRINV : longWord;
    DCH1DPTR : longWord;
    DCH1DPTRCLR : longWord;
    DCH1DPTRSET : longWord;
    DCH1DPTRINV : longWord;
    DCH1CSIZ : longWord;
    DCH1CSIZCLR : longWord;
    DCH1CSIZSET : longWord;
    DCH1CSIZINV : longWord;
    DCH1CPTR : longWord;
    DCH1CPTRCLR : longWord;
    DCH1CPTRSET : longWord;
    DCH1CPTRINV : longWord;
    DCH1DAT : longWord;
    DCH1DATCLR : longWord;
    DCH1DATSET : longWord;
    DCH1DATINV : longWord;
  end;
  TDMAC2_DCH2CON = record
  private
    function  getCHAED : TBits_1; inline;
    function  getCHAEN : TBits_1; inline;
    function  getCHBUSY : TBits_1; inline;
    function  getCHCHN : TBits_1; inline;
    function  getCHCHNS : TBits_1; inline;
    function  getCHEDET : TBits_1; inline;
    function  getCHEN : TBits_1; inline;
    function  getCHPRI : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHAED(thebits : TBits_1); inline;
    procedure setCHAEN(thebits : TBits_1); inline;
    procedure setCHBUSY(thebits : TBits_1); inline;
    procedure setCHCHN(thebits : TBits_1); inline;
    procedure setCHCHNS(thebits : TBits_1); inline;
    procedure setCHEDET(thebits : TBits_1); inline;
    procedure setCHEN(thebits : TBits_1); inline;
    procedure setCHPRI(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHAED; inline;
    procedure clearCHAEN; inline;
    procedure clearCHBUSY; inline;
    procedure clearCHCHN; inline;
    procedure clearCHCHNS; inline;
    procedure clearCHEDET; inline;
    procedure clearCHEN; inline;
    procedure setCHAED; inline;
    procedure setCHAEN; inline;
    procedure setCHBUSY; inline;
    procedure setCHCHN; inline;
    procedure setCHCHNS; inline;
    procedure setCHEDET; inline;
    procedure setCHEN; inline;
    property CHAED : TBits_1 read getCHAED write setCHAED;
    property CHAEN : TBits_1 read getCHAEN write setCHAEN;
    property CHBUSY : TBits_1 read getCHBUSY write setCHBUSY;
    property CHCHN : TBits_1 read getCHCHN write setCHCHN;
    property CHCHNS : TBits_1 read getCHCHNS write setCHCHNS;
    property CHEDET : TBits_1 read getCHEDET write setCHEDET;
    property CHEN : TBits_1 read getCHEN write setCHEN;
    property CHPRI : TBits_2 read getCHPRI write setCHPRI;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC2_DCH2ECON = record
  private
    function  getAIRQEN : TBits_1; inline;
    function  getCABORT : TBits_1; inline;
    function  getCFORCE : TBits_1; inline;
    function  getCHAIRQ : TBits_8; inline;
    function  getCHSIRQ : TBits_8; inline;
    function  getPATEN : TBits_1; inline;
    function  getSIRQEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAIRQEN(thebits : TBits_1); inline;
    procedure setCABORT(thebits : TBits_1); inline;
    procedure setCFORCE(thebits : TBits_1); inline;
    procedure setCHAIRQ(thebits : TBits_8); inline;
    procedure setCHSIRQ(thebits : TBits_8); inline;
    procedure setPATEN(thebits : TBits_1); inline;
    procedure setSIRQEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAIRQEN; inline;
    procedure clearCABORT; inline;
    procedure clearCFORCE; inline;
    procedure clearPATEN; inline;
    procedure clearSIRQEN; inline;
    procedure setAIRQEN; inline;
    procedure setCABORT; inline;
    procedure setCFORCE; inline;
    procedure setPATEN; inline;
    procedure setSIRQEN; inline;
    property AIRQEN : TBits_1 read getAIRQEN write setAIRQEN;
    property CABORT : TBits_1 read getCABORT write setCABORT;
    property CFORCE : TBits_1 read getCFORCE write setCFORCE;
    property CHAIRQ : TBits_8 read getCHAIRQ write setCHAIRQ;
    property CHSIRQ : TBits_8 read getCHSIRQ write setCHSIRQ;
    property PATEN : TBits_1 read getPATEN write setPATEN;
    property SIRQEN : TBits_1 read getSIRQEN write setSIRQEN;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC2_DCH2INT = record
  private
    function  getCHBCIE : TBits_1; inline;
    function  getCHBCIF : TBits_1; inline;
    function  getCHCCIE : TBits_1; inline;
    function  getCHCCIF : TBits_1; inline;
    function  getCHDDIE : TBits_1; inline;
    function  getCHDDIF : TBits_1; inline;
    function  getCHDHIE : TBits_1; inline;
    function  getCHDHIF : TBits_1; inline;
    function  getCHERIE : TBits_1; inline;
    function  getCHERIF : TBits_1; inline;
    function  getCHSDIE : TBits_1; inline;
    function  getCHSDIF : TBits_1; inline;
    function  getCHSHIE : TBits_1; inline;
    function  getCHSHIF : TBits_1; inline;
    function  getCHTAIE : TBits_1; inline;
    function  getCHTAIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCHBCIE(thebits : TBits_1); inline;
    procedure setCHBCIF(thebits : TBits_1); inline;
    procedure setCHCCIE(thebits : TBits_1); inline;
    procedure setCHCCIF(thebits : TBits_1); inline;
    procedure setCHDDIE(thebits : TBits_1); inline;
    procedure setCHDDIF(thebits : TBits_1); inline;
    procedure setCHDHIE(thebits : TBits_1); inline;
    procedure setCHDHIF(thebits : TBits_1); inline;
    procedure setCHERIE(thebits : TBits_1); inline;
    procedure setCHERIF(thebits : TBits_1); inline;
    procedure setCHSDIE(thebits : TBits_1); inline;
    procedure setCHSDIF(thebits : TBits_1); inline;
    procedure setCHSHIE(thebits : TBits_1); inline;
    procedure setCHSHIF(thebits : TBits_1); inline;
    procedure setCHTAIE(thebits : TBits_1); inline;
    procedure setCHTAIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHBCIE; inline;
    procedure clearCHBCIF; inline;
    procedure clearCHCCIE; inline;
    procedure clearCHCCIF; inline;
    procedure clearCHDDIE; inline;
    procedure clearCHDDIF; inline;
    procedure clearCHDHIE; inline;
    procedure clearCHDHIF; inline;
    procedure clearCHERIE; inline;
    procedure clearCHERIF; inline;
    procedure clearCHSDIE; inline;
    procedure clearCHSDIF; inline;
    procedure clearCHSHIE; inline;
    procedure clearCHSHIF; inline;
    procedure clearCHTAIE; inline;
    procedure clearCHTAIF; inline;
    procedure setCHBCIE; inline;
    procedure setCHBCIF; inline;
    procedure setCHCCIE; inline;
    procedure setCHCCIF; inline;
    procedure setCHDDIE; inline;
    procedure setCHDDIF; inline;
    procedure setCHDHIE; inline;
    procedure setCHDHIF; inline;
    procedure setCHERIE; inline;
    procedure setCHERIF; inline;
    procedure setCHSDIE; inline;
    procedure setCHSDIF; inline;
    procedure setCHSHIE; inline;
    procedure setCHSHIF; inline;
    procedure setCHTAIE; inline;
    procedure setCHTAIF; inline;
    property CHBCIE : TBits_1 read getCHBCIE write setCHBCIE;
    property CHBCIF : TBits_1 read getCHBCIF write setCHBCIF;
    property CHCCIE : TBits_1 read getCHCCIE write setCHCCIE;
    property CHCCIF : TBits_1 read getCHCCIF write setCHCCIF;
    property CHDDIE : TBits_1 read getCHDDIE write setCHDDIE;
    property CHDDIF : TBits_1 read getCHDDIF write setCHDDIF;
    property CHDHIE : TBits_1 read getCHDHIE write setCHDHIE;
    property CHDHIF : TBits_1 read getCHDHIF write setCHDHIF;
    property CHERIE : TBits_1 read getCHERIE write setCHERIE;
    property CHERIF : TBits_1 read getCHERIF write setCHERIF;
    property CHSDIE : TBits_1 read getCHSDIE write setCHSDIE;
    property CHSDIF : TBits_1 read getCHSDIF write setCHSDIF;
    property CHSHIE : TBits_1 read getCHSHIE write setCHSHIE;
    property CHSHIF : TBits_1 read getCHSHIF write setCHSHIF;
    property CHTAIE : TBits_1 read getCHTAIE write setCHTAIE;
    property CHTAIF : TBits_1 read getCHTAIF write setCHTAIF;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMAC2Registers = record
    DCH2CONbits : TDMAC2_DCH2CON;
    DCH2CON : longWord;
    DCH2CONCLR : longWord;
    DCH2CONSET : longWord;
    DCH2CONINV : longWord;
    DCH2ECONbits : TDMAC2_DCH2ECON;
    DCH2ECON : longWord;
    DCH2ECONCLR : longWord;
    DCH2ECONSET : longWord;
    DCH2ECONINV : longWord;
    DCH2INTbits : TDMAC2_DCH2INT;
    DCH2INT : longWord;
    DCH2INTCLR : longWord;
    DCH2INTSET : longWord;
    DCH2INTINV : longWord;
    DCH2SSA : longWord;
    DCH2SSACLR : longWord;
    DCH2SSASET : longWord;
    DCH2SSAINV : longWord;
    DCH2DSA : longWord;
    DCH2DSACLR : longWord;
    DCH2DSASET : longWord;
    DCH2DSAINV : longWord;
    DCH2SSIZ : longWord;
    DCH2SSIZCLR : longWord;
    DCH2SSIZSET : longWord;
    DCH2SSIZINV : longWord;
    DCH2DSIZ : longWord;
    DCH2DSIZCLR : longWord;
    DCH2DSIZSET : longWord;
    DCH2DSIZINV : longWord;
    DCH2SPTR : longWord;
    DCH2SPTRCLR : longWord;
    DCH2SPTRSET : longWord;
    DCH2SPTRINV : longWord;
    DCH2DPTR : longWord;
    DCH2DPTRCLR : longWord;
    DCH2DPTRSET : longWord;
    DCH2DPTRINV : longWord;
    DCH2CSIZ : longWord;
    DCH2CSIZCLR : longWord;
    DCH2CSIZSET : longWord;
    DCH2CSIZINV : longWord;
    DCH2CPTR : longWord;
    DCH2CPTRCLR : longWord;
    DCH2CPTRSET : longWord;
    DCH2CPTRINV : longWord;
    DCH2DAT : longWord;
    DCH2DATCLR : longWord;
    DCH2DATSET : longWord;
    DCH2DATINV : longWord;
  end;
  TDMAC3_DCH3CON = record
  private
    function  getCHAED : TBits_1; inline;
    function  getCHAEN : TBits_1; inline;
    function  getCHBUSY : TBits_1; inline;
    function  getCHCHN : TBits_1; inline;
    function  getCHCHNS : TBits_1; inline;
    function  getCHEDET : TBits_1; inline;
    function  getCHEN : TBits_1; inline;
    function  getCHPRI : TBits_2; inline;
    function  getw : TBits_32; inline;
    procedure setCHAED(thebits : TBits_1); inline;
    procedure setCHAEN(thebits : TBits_1); inline;
    procedure setCHBUSY(thebits : TBits_1); inline;
    procedure setCHCHN(thebits : TBits_1); inline;
    procedure setCHCHNS(thebits : TBits_1); inline;
    procedure setCHEDET(thebits : TBits_1); inline;
    procedure setCHEN(thebits : TBits_1); inline;
    procedure setCHPRI(thebits : TBits_2); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHAED; inline;
    procedure clearCHAEN; inline;
    procedure clearCHBUSY; inline;
    procedure clearCHCHN; inline;
    procedure clearCHCHNS; inline;
    procedure clearCHEDET; inline;
    procedure clearCHEN; inline;
    procedure setCHAED; inline;
    procedure setCHAEN; inline;
    procedure setCHBUSY; inline;
    procedure setCHCHN; inline;
    procedure setCHCHNS; inline;
    procedure setCHEDET; inline;
    procedure setCHEN; inline;
    property CHAED : TBits_1 read getCHAED write setCHAED;
    property CHAEN : TBits_1 read getCHAEN write setCHAEN;
    property CHBUSY : TBits_1 read getCHBUSY write setCHBUSY;
    property CHCHN : TBits_1 read getCHCHN write setCHCHN;
    property CHCHNS : TBits_1 read getCHCHNS write setCHCHNS;
    property CHEDET : TBits_1 read getCHEDET write setCHEDET;
    property CHEN : TBits_1 read getCHEN write setCHEN;
    property CHPRI : TBits_2 read getCHPRI write setCHPRI;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC3_DCH3ECON = record
  private
    function  getAIRQEN : TBits_1; inline;
    function  getCABORT : TBits_1; inline;
    function  getCFORCE : TBits_1; inline;
    function  getCHAIRQ : TBits_8; inline;
    function  getCHSIRQ : TBits_8; inline;
    function  getPATEN : TBits_1; inline;
    function  getSIRQEN : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setAIRQEN(thebits : TBits_1); inline;
    procedure setCABORT(thebits : TBits_1); inline;
    procedure setCFORCE(thebits : TBits_1); inline;
    procedure setCHAIRQ(thebits : TBits_8); inline;
    procedure setCHSIRQ(thebits : TBits_8); inline;
    procedure setPATEN(thebits : TBits_1); inline;
    procedure setSIRQEN(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearAIRQEN; inline;
    procedure clearCABORT; inline;
    procedure clearCFORCE; inline;
    procedure clearPATEN; inline;
    procedure clearSIRQEN; inline;
    procedure setAIRQEN; inline;
    procedure setCABORT; inline;
    procedure setCFORCE; inline;
    procedure setPATEN; inline;
    procedure setSIRQEN; inline;
    property AIRQEN : TBits_1 read getAIRQEN write setAIRQEN;
    property CABORT : TBits_1 read getCABORT write setCABORT;
    property CFORCE : TBits_1 read getCFORCE write setCFORCE;
    property CHAIRQ : TBits_8 read getCHAIRQ write setCHAIRQ;
    property CHSIRQ : TBits_8 read getCHSIRQ write setCHSIRQ;
    property PATEN : TBits_1 read getPATEN write setPATEN;
    property SIRQEN : TBits_1 read getSIRQEN write setSIRQEN;
    property w : TBits_32 read getw write setw;
  end;
  TDMAC3_DCH3INT = record
  private
    function  getCHBCIE : TBits_1; inline;
    function  getCHBCIF : TBits_1; inline;
    function  getCHCCIE : TBits_1; inline;
    function  getCHCCIF : TBits_1; inline;
    function  getCHDDIE : TBits_1; inline;
    function  getCHDDIF : TBits_1; inline;
    function  getCHDHIE : TBits_1; inline;
    function  getCHDHIF : TBits_1; inline;
    function  getCHERIE : TBits_1; inline;
    function  getCHERIF : TBits_1; inline;
    function  getCHSDIE : TBits_1; inline;
    function  getCHSDIF : TBits_1; inline;
    function  getCHSHIE : TBits_1; inline;
    function  getCHSHIF : TBits_1; inline;
    function  getCHTAIE : TBits_1; inline;
    function  getCHTAIF : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCHBCIE(thebits : TBits_1); inline;
    procedure setCHBCIF(thebits : TBits_1); inline;
    procedure setCHCCIE(thebits : TBits_1); inline;
    procedure setCHCCIF(thebits : TBits_1); inline;
    procedure setCHDDIE(thebits : TBits_1); inline;
    procedure setCHDDIF(thebits : TBits_1); inline;
    procedure setCHDHIE(thebits : TBits_1); inline;
    procedure setCHDHIF(thebits : TBits_1); inline;
    procedure setCHERIE(thebits : TBits_1); inline;
    procedure setCHERIF(thebits : TBits_1); inline;
    procedure setCHSDIE(thebits : TBits_1); inline;
    procedure setCHSDIF(thebits : TBits_1); inline;
    procedure setCHSHIE(thebits : TBits_1); inline;
    procedure setCHSHIF(thebits : TBits_1); inline;
    procedure setCHTAIE(thebits : TBits_1); inline;
    procedure setCHTAIF(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCHBCIE; inline;
    procedure clearCHBCIF; inline;
    procedure clearCHCCIE; inline;
    procedure clearCHCCIF; inline;
    procedure clearCHDDIE; inline;
    procedure clearCHDDIF; inline;
    procedure clearCHDHIE; inline;
    procedure clearCHDHIF; inline;
    procedure clearCHERIE; inline;
    procedure clearCHERIF; inline;
    procedure clearCHSDIE; inline;
    procedure clearCHSDIF; inline;
    procedure clearCHSHIE; inline;
    procedure clearCHSHIF; inline;
    procedure clearCHTAIE; inline;
    procedure clearCHTAIF; inline;
    procedure setCHBCIE; inline;
    procedure setCHBCIF; inline;
    procedure setCHCCIE; inline;
    procedure setCHCCIF; inline;
    procedure setCHDDIE; inline;
    procedure setCHDDIF; inline;
    procedure setCHDHIE; inline;
    procedure setCHDHIF; inline;
    procedure setCHERIE; inline;
    procedure setCHERIF; inline;
    procedure setCHSDIE; inline;
    procedure setCHSDIF; inline;
    procedure setCHSHIE; inline;
    procedure setCHSHIF; inline;
    procedure setCHTAIE; inline;
    procedure setCHTAIF; inline;
    property CHBCIE : TBits_1 read getCHBCIE write setCHBCIE;
    property CHBCIF : TBits_1 read getCHBCIF write setCHBCIF;
    property CHCCIE : TBits_1 read getCHCCIE write setCHCCIE;
    property CHCCIF : TBits_1 read getCHCCIF write setCHCCIF;
    property CHDDIE : TBits_1 read getCHDDIE write setCHDDIE;
    property CHDDIF : TBits_1 read getCHDDIF write setCHDDIF;
    property CHDHIE : TBits_1 read getCHDHIE write setCHDHIE;
    property CHDHIF : TBits_1 read getCHDHIF write setCHDHIF;
    property CHERIE : TBits_1 read getCHERIE write setCHERIE;
    property CHERIF : TBits_1 read getCHERIF write setCHERIF;
    property CHSDIE : TBits_1 read getCHSDIE write setCHSDIE;
    property CHSDIF : TBits_1 read getCHSDIF write setCHSDIF;
    property CHSHIE : TBits_1 read getCHSHIE write setCHSHIE;
    property CHSHIF : TBits_1 read getCHSHIF write setCHSHIF;
    property CHTAIE : TBits_1 read getCHTAIE write setCHTAIE;
    property CHTAIF : TBits_1 read getCHTAIF write setCHTAIF;
    property w : TBits_32 read getw write setw;
  end;
type
  TDMAC3Registers = record
    DCH3CONbits : TDMAC3_DCH3CON;
    DCH3CON : longWord;
    DCH3CONCLR : longWord;
    DCH3CONSET : longWord;
    DCH3CONINV : longWord;
    DCH3ECONbits : TDMAC3_DCH3ECON;
    DCH3ECON : longWord;
    DCH3ECONCLR : longWord;
    DCH3ECONSET : longWord;
    DCH3ECONINV : longWord;
    DCH3INTbits : TDMAC3_DCH3INT;
    DCH3INT : longWord;
    DCH3INTCLR : longWord;
    DCH3INTSET : longWord;
    DCH3INTINV : longWord;
    DCH3SSA : longWord;
    DCH3SSACLR : longWord;
    DCH3SSASET : longWord;
    DCH3SSAINV : longWord;
    DCH3DSA : longWord;
    DCH3DSACLR : longWord;
    DCH3DSASET : longWord;
    DCH3DSAINV : longWord;
    DCH3SSIZ : longWord;
    DCH3SSIZCLR : longWord;
    DCH3SSIZSET : longWord;
    DCH3SSIZINV : longWord;
    DCH3DSIZ : longWord;
    DCH3DSIZCLR : longWord;
    DCH3DSIZSET : longWord;
    DCH3DSIZINV : longWord;
    DCH3SPTR : longWord;
    DCH3SPTRCLR : longWord;
    DCH3SPTRSET : longWord;
    DCH3SPTRINV : longWord;
    DCH3DPTR : longWord;
    DCH3DPTRCLR : longWord;
    DCH3DPTRSET : longWord;
    DCH3DPTRINV : longWord;
    DCH3CSIZ : longWord;
    DCH3CSIZCLR : longWord;
    DCH3CSIZSET : longWord;
    DCH3CSIZINV : longWord;
    DCH3CPTR : longWord;
    DCH3CPTRCLR : longWord;
    DCH3CPTRSET : longWord;
    DCH3CPTRINV : longWord;
    DCH3DAT : longWord;
    DCH3DATCLR : longWord;
    DCH3DATSET : longWord;
    DCH3DATINV : longWord;
  end;
  TUSB_U1IR = record
  private
    function  getATTACHIF : TBits_1; inline;
    function  getDETACHIF : TBits_1; inline;
    function  getIDLEIF : TBits_1; inline;
    function  getRESUMEIF : TBits_1; inline;
    function  getSOFIF : TBits_1; inline;
    function  getSTALLIF : TBits_1; inline;
    function  getTRNIF : TBits_1; inline;
    function  getUERRIF : TBits_1; inline;
    function  getURSTIF : TBits_1; inline;
    function  getURSTIF_DETACHIF : TBits_1; inline;
    procedure setATTACHIF(thebits : TBits_1); inline;
    procedure setDETACHIF(thebits : TBits_1); inline;
    procedure setIDLEIF(thebits : TBits_1); inline;
    procedure setRESUMEIF(thebits : TBits_1); inline;
    procedure setSOFIF(thebits : TBits_1); inline;
    procedure setSTALLIF(thebits : TBits_1); inline;
    procedure setTRNIF(thebits : TBits_1); inline;
    procedure setUERRIF(thebits : TBits_1); inline;
    procedure setURSTIF(thebits : TBits_1); inline;
    procedure setURSTIF_DETACHIF(thebits : TBits_1); inline;
  public
    procedure clearATTACHIF; inline;
    procedure clearDETACHIF; inline;
    procedure clearIDLEIF; inline;
    procedure clearRESUMEIF; inline;
    procedure clearSOFIF; inline;
    procedure clearSTALLIF; inline;
    procedure clearTRNIF; inline;
    procedure clearUERRIF; inline;
    procedure clearURSTIF; inline;
    procedure clearURSTIF_DETACHIF; inline;
    procedure setATTACHIF; inline;
    procedure setDETACHIF; inline;
    procedure setIDLEIF; inline;
    procedure setRESUMEIF; inline;
    procedure setSOFIF; inline;
    procedure setSTALLIF; inline;
    procedure setTRNIF; inline;
    procedure setUERRIF; inline;
    procedure setURSTIF; inline;
    procedure setURSTIF_DETACHIF; inline;
    property ATTACHIF : TBits_1 read getATTACHIF write setATTACHIF;
    property DETACHIF : TBits_1 read getDETACHIF write setDETACHIF;
    property IDLEIF : TBits_1 read getIDLEIF write setIDLEIF;
    property RESUMEIF : TBits_1 read getRESUMEIF write setRESUMEIF;
    property SOFIF : TBits_1 read getSOFIF write setSOFIF;
    property STALLIF : TBits_1 read getSTALLIF write setSTALLIF;
    property TRNIF : TBits_1 read getTRNIF write setTRNIF;
    property UERRIF : TBits_1 read getUERRIF write setUERRIF;
    property URSTIF : TBits_1 read getURSTIF write setURSTIF;
    property URSTIF_DETACHIF : TBits_1 read getURSTIF_DETACHIF write setURSTIF_DETACHIF;
  end;
  TUSB_U1IE = record
  private
    function  getATTACHIE : TBits_1; inline;
    function  getDETACHIE : TBits_1; inline;
    function  getIDLEIE : TBits_1; inline;
    function  getRESUMEIE : TBits_1; inline;
    function  getSOFIE : TBits_1; inline;
    function  getSTALLIE : TBits_1; inline;
    function  getTRNIE : TBits_1; inline;
    function  getUERRIE : TBits_1; inline;
    function  getURSTIE : TBits_1; inline;
    function  getURSTIE_DETACHIE : TBits_1; inline;
    procedure setATTACHIE(thebits : TBits_1); inline;
    procedure setDETACHIE(thebits : TBits_1); inline;
    procedure setIDLEIE(thebits : TBits_1); inline;
    procedure setRESUMEIE(thebits : TBits_1); inline;
    procedure setSOFIE(thebits : TBits_1); inline;
    procedure setSTALLIE(thebits : TBits_1); inline;
    procedure setTRNIE(thebits : TBits_1); inline;
    procedure setUERRIE(thebits : TBits_1); inline;
    procedure setURSTIE(thebits : TBits_1); inline;
    procedure setURSTIE_DETACHIE(thebits : TBits_1); inline;
  public
    procedure clearATTACHIE; inline;
    procedure clearDETACHIE; inline;
    procedure clearIDLEIE; inline;
    procedure clearRESUMEIE; inline;
    procedure clearSOFIE; inline;
    procedure clearSTALLIE; inline;
    procedure clearTRNIE; inline;
    procedure clearUERRIE; inline;
    procedure clearURSTIE; inline;
    procedure clearURSTIE_DETACHIE; inline;
    procedure setATTACHIE; inline;
    procedure setDETACHIE; inline;
    procedure setIDLEIE; inline;
    procedure setRESUMEIE; inline;
    procedure setSOFIE; inline;
    procedure setSTALLIE; inline;
    procedure setTRNIE; inline;
    procedure setUERRIE; inline;
    procedure setURSTIE; inline;
    procedure setURSTIE_DETACHIE; inline;
    property ATTACHIE : TBits_1 read getATTACHIE write setATTACHIE;
    property DETACHIE : TBits_1 read getDETACHIE write setDETACHIE;
    property IDLEIE : TBits_1 read getIDLEIE write setIDLEIE;
    property RESUMEIE : TBits_1 read getRESUMEIE write setRESUMEIE;
    property SOFIE : TBits_1 read getSOFIE write setSOFIE;
    property STALLIE : TBits_1 read getSTALLIE write setSTALLIE;
    property TRNIE : TBits_1 read getTRNIE write setTRNIE;
    property UERRIE : TBits_1 read getUERRIE write setUERRIE;
    property URSTIE : TBits_1 read getURSTIE write setURSTIE;
    property URSTIE_DETACHIE : TBits_1 read getURSTIE_DETACHIE write setURSTIE_DETACHIE;
  end;
  TUSB_U1EIR = record
  private
    function  getBMXEF : TBits_1; inline;
    function  getBTOEF : TBits_1; inline;
    function  getBTSEF : TBits_1; inline;
    function  getCRC16EF : TBits_1; inline;
    function  getCRC5EF : TBits_1; inline;
    function  getCRC5EF_EOFEF : TBits_1; inline;
    function  getDFN8EF : TBits_1; inline;
    function  getDMAEF : TBits_1; inline;
    function  getEOFEF : TBits_1; inline;
    function  getPIDEF : TBits_1; inline;
    procedure setBMXEF(thebits : TBits_1); inline;
    procedure setBTOEF(thebits : TBits_1); inline;
    procedure setBTSEF(thebits : TBits_1); inline;
    procedure setCRC16EF(thebits : TBits_1); inline;
    procedure setCRC5EF(thebits : TBits_1); inline;
    procedure setCRC5EF_EOFEF(thebits : TBits_1); inline;
    procedure setDFN8EF(thebits : TBits_1); inline;
    procedure setDMAEF(thebits : TBits_1); inline;
    procedure setEOFEF(thebits : TBits_1); inline;
    procedure setPIDEF(thebits : TBits_1); inline;
  public
    procedure clearBMXEF; inline;
    procedure clearBTOEF; inline;
    procedure clearBTSEF; inline;
    procedure clearCRC16EF; inline;
    procedure clearCRC5EF; inline;
    procedure clearCRC5EF_EOFEF; inline;
    procedure clearDFN8EF; inline;
    procedure clearDMAEF; inline;
    procedure clearEOFEF; inline;
    procedure clearPIDEF; inline;
    procedure setBMXEF; inline;
    procedure setBTOEF; inline;
    procedure setBTSEF; inline;
    procedure setCRC16EF; inline;
    procedure setCRC5EF; inline;
    procedure setCRC5EF_EOFEF; inline;
    procedure setDFN8EF; inline;
    procedure setDMAEF; inline;
    procedure setEOFEF; inline;
    procedure setPIDEF; inline;
    property BMXEF : TBits_1 read getBMXEF write setBMXEF;
    property BTOEF : TBits_1 read getBTOEF write setBTOEF;
    property BTSEF : TBits_1 read getBTSEF write setBTSEF;
    property CRC16EF : TBits_1 read getCRC16EF write setCRC16EF;
    property CRC5EF : TBits_1 read getCRC5EF write setCRC5EF;
    property CRC5EF_EOFEF : TBits_1 read getCRC5EF_EOFEF write setCRC5EF_EOFEF;
    property DFN8EF : TBits_1 read getDFN8EF write setDFN8EF;
    property DMAEF : TBits_1 read getDMAEF write setDMAEF;
    property EOFEF : TBits_1 read getEOFEF write setEOFEF;
    property PIDEF : TBits_1 read getPIDEF write setPIDEF;
  end;
  TUSB_U1EIE = record
  private
    function  getBMXEE : TBits_1; inline;
    function  getBTOEE : TBits_1; inline;
    function  getBTSEE : TBits_1; inline;
    function  getCRC16EE : TBits_1; inline;
    function  getCRC5EE : TBits_1; inline;
    function  getCRC5EE_EOFEE : TBits_1; inline;
    function  getDFN8EE : TBits_1; inline;
    function  getDMAEE : TBits_1; inline;
    function  getEOFEE : TBits_1; inline;
    function  getPIDEE : TBits_1; inline;
    procedure setBMXEE(thebits : TBits_1); inline;
    procedure setBTOEE(thebits : TBits_1); inline;
    procedure setBTSEE(thebits : TBits_1); inline;
    procedure setCRC16EE(thebits : TBits_1); inline;
    procedure setCRC5EE(thebits : TBits_1); inline;
    procedure setCRC5EE_EOFEE(thebits : TBits_1); inline;
    procedure setDFN8EE(thebits : TBits_1); inline;
    procedure setDMAEE(thebits : TBits_1); inline;
    procedure setEOFEE(thebits : TBits_1); inline;
    procedure setPIDEE(thebits : TBits_1); inline;
  public
    procedure clearBMXEE; inline;
    procedure clearBTOEE; inline;
    procedure clearBTSEE; inline;
    procedure clearCRC16EE; inline;
    procedure clearCRC5EE; inline;
    procedure clearCRC5EE_EOFEE; inline;
    procedure clearDFN8EE; inline;
    procedure clearDMAEE; inline;
    procedure clearEOFEE; inline;
    procedure clearPIDEE; inline;
    procedure setBMXEE; inline;
    procedure setBTOEE; inline;
    procedure setBTSEE; inline;
    procedure setCRC16EE; inline;
    procedure setCRC5EE; inline;
    procedure setCRC5EE_EOFEE; inline;
    procedure setDFN8EE; inline;
    procedure setDMAEE; inline;
    procedure setEOFEE; inline;
    procedure setPIDEE; inline;
    property BMXEE : TBits_1 read getBMXEE write setBMXEE;
    property BTOEE : TBits_1 read getBTOEE write setBTOEE;
    property BTSEE : TBits_1 read getBTSEE write setBTSEE;
    property CRC16EE : TBits_1 read getCRC16EE write setCRC16EE;
    property CRC5EE : TBits_1 read getCRC5EE write setCRC5EE;
    property CRC5EE_EOFEE : TBits_1 read getCRC5EE_EOFEE write setCRC5EE_EOFEE;
    property DFN8EE : TBits_1 read getDFN8EE write setDFN8EE;
    property DMAEE : TBits_1 read getDMAEE write setDMAEE;
    property EOFEE : TBits_1 read getEOFEE write setEOFEE;
    property PIDEE : TBits_1 read getPIDEE write setPIDEE;
  end;
  TUSB_U1STAT = record
  private
    function  getDIR : TBits_1; inline;
    function  getENDPT : TBits_4; inline;
    function  getENDPT0 : TBits_1; inline;
    function  getENDPT1 : TBits_1; inline;
    function  getENDPT2 : TBits_1; inline;
    function  getENDPT3 : TBits_1; inline;
    function  getPPBI : TBits_1; inline;
    procedure setDIR(thebits : TBits_1); inline;
    procedure setENDPT(thebits : TBits_4); inline;
    procedure setENDPT0(thebits : TBits_1); inline;
    procedure setENDPT1(thebits : TBits_1); inline;
    procedure setENDPT2(thebits : TBits_1); inline;
    procedure setENDPT3(thebits : TBits_1); inline;
    procedure setPPBI(thebits : TBits_1); inline;
  public
    procedure clearDIR; inline;
    procedure clearENDPT0; inline;
    procedure clearENDPT1; inline;
    procedure clearENDPT2; inline;
    procedure clearENDPT3; inline;
    procedure clearPPBI; inline;
    procedure setDIR; inline;
    procedure setENDPT0; inline;
    procedure setENDPT1; inline;
    procedure setENDPT2; inline;
    procedure setENDPT3; inline;
    procedure setPPBI; inline;
    property DIR : TBits_1 read getDIR write setDIR;
    property ENDPT : TBits_4 read getENDPT write setENDPT;
    property ENDPT0 : TBits_1 read getENDPT0 write setENDPT0;
    property ENDPT1 : TBits_1 read getENDPT1 write setENDPT1;
    property ENDPT2 : TBits_1 read getENDPT2 write setENDPT2;
    property ENDPT3 : TBits_1 read getENDPT3 write setENDPT3;
    property PPBI : TBits_1 read getPPBI write setPPBI;
  end;
  TUSB_U1CON = record
  private
    function  getHOSTEN : TBits_1; inline;
    function  getJSTATE : TBits_1; inline;
    function  getPKTDIS : TBits_1; inline;
    function  getPKTDIS_TOKBUSY : TBits_1; inline;
    function  getPPBRST : TBits_1; inline;
    function  getRESUME : TBits_1; inline;
    function  getSE0 : TBits_1; inline;
    function  getSOFEN : TBits_1; inline;
    function  getTOKBUSY : TBits_1; inline;
    function  getUSBEN : TBits_1; inline;
    function  getUSBEN_SOFEN : TBits_1; inline;
    function  getUSBRST : TBits_1; inline;
    procedure setHOSTEN(thebits : TBits_1); inline;
    procedure setJSTATE(thebits : TBits_1); inline;
    procedure setPKTDIS(thebits : TBits_1); inline;
    procedure setPKTDIS_TOKBUSY(thebits : TBits_1); inline;
    procedure setPPBRST(thebits : TBits_1); inline;
    procedure setRESUME(thebits : TBits_1); inline;
    procedure setSE0(thebits : TBits_1); inline;
    procedure setSOFEN(thebits : TBits_1); inline;
    procedure setTOKBUSY(thebits : TBits_1); inline;
    procedure setUSBEN(thebits : TBits_1); inline;
    procedure setUSBEN_SOFEN(thebits : TBits_1); inline;
    procedure setUSBRST(thebits : TBits_1); inline;
  public
    procedure clearHOSTEN; inline;
    procedure clearJSTATE; inline;
    procedure clearPKTDIS; inline;
    procedure clearPKTDIS_TOKBUSY; inline;
    procedure clearPPBRST; inline;
    procedure clearRESUME; inline;
    procedure clearSE0; inline;
    procedure clearSOFEN; inline;
    procedure clearTOKBUSY; inline;
    procedure clearUSBEN; inline;
    procedure clearUSBEN_SOFEN; inline;
    procedure clearUSBRST; inline;
    procedure setHOSTEN; inline;
    procedure setJSTATE; inline;
    procedure setPKTDIS; inline;
    procedure setPKTDIS_TOKBUSY; inline;
    procedure setPPBRST; inline;
    procedure setRESUME; inline;
    procedure setSE0; inline;
    procedure setSOFEN; inline;
    procedure setTOKBUSY; inline;
    procedure setUSBEN; inline;
    procedure setUSBEN_SOFEN; inline;
    procedure setUSBRST; inline;
    property HOSTEN : TBits_1 read getHOSTEN write setHOSTEN;
    property JSTATE : TBits_1 read getJSTATE write setJSTATE;
    property PKTDIS : TBits_1 read getPKTDIS write setPKTDIS;
    property PKTDIS_TOKBUSY : TBits_1 read getPKTDIS_TOKBUSY write setPKTDIS_TOKBUSY;
    property PPBRST : TBits_1 read getPPBRST write setPPBRST;
    property RESUME : TBits_1 read getRESUME write setRESUME;
    property SE0 : TBits_1 read getSE0 write setSE0;
    property SOFEN : TBits_1 read getSOFEN write setSOFEN;
    property TOKBUSY : TBits_1 read getTOKBUSY write setTOKBUSY;
    property USBEN : TBits_1 read getUSBEN write setUSBEN;
    property USBEN_SOFEN : TBits_1 read getUSBEN_SOFEN write setUSBEN_SOFEN;
    property USBRST : TBits_1 read getUSBRST write setUSBRST;
  end;
  TUSB_U1ADDR = record
  private
    function  getDEVADDR : TBits_7; inline;
    function  getDEVADDR0 : TBits_1; inline;
    function  getDEVADDR1 : TBits_1; inline;
    function  getDEVADDR2 : TBits_1; inline;
    function  getDEVADDR3 : TBits_1; inline;
    function  getDEVADDR4 : TBits_1; inline;
    function  getDEVADDR5 : TBits_1; inline;
    function  getDEVADDR6 : TBits_1; inline;
    function  getLSPDEN : TBits_1; inline;
    procedure setDEVADDR(thebits : TBits_7); inline;
    procedure setDEVADDR0(thebits : TBits_1); inline;
    procedure setDEVADDR1(thebits : TBits_1); inline;
    procedure setDEVADDR2(thebits : TBits_1); inline;
    procedure setDEVADDR3(thebits : TBits_1); inline;
    procedure setDEVADDR4(thebits : TBits_1); inline;
    procedure setDEVADDR5(thebits : TBits_1); inline;
    procedure setDEVADDR6(thebits : TBits_1); inline;
    procedure setLSPDEN(thebits : TBits_1); inline;
  public
    procedure clearDEVADDR0; inline;
    procedure clearDEVADDR1; inline;
    procedure clearDEVADDR2; inline;
    procedure clearDEVADDR3; inline;
    procedure clearDEVADDR4; inline;
    procedure clearDEVADDR5; inline;
    procedure clearDEVADDR6; inline;
    procedure clearLSPDEN; inline;
    procedure setDEVADDR0; inline;
    procedure setDEVADDR1; inline;
    procedure setDEVADDR2; inline;
    procedure setDEVADDR3; inline;
    procedure setDEVADDR4; inline;
    procedure setDEVADDR5; inline;
    procedure setDEVADDR6; inline;
    procedure setLSPDEN; inline;
    property DEVADDR : TBits_7 read getDEVADDR write setDEVADDR;
    property DEVADDR0 : TBits_1 read getDEVADDR0 write setDEVADDR0;
    property DEVADDR1 : TBits_1 read getDEVADDR1 write setDEVADDR1;
    property DEVADDR2 : TBits_1 read getDEVADDR2 write setDEVADDR2;
    property DEVADDR3 : TBits_1 read getDEVADDR3 write setDEVADDR3;
    property DEVADDR4 : TBits_1 read getDEVADDR4 write setDEVADDR4;
    property DEVADDR5 : TBits_1 read getDEVADDR5 write setDEVADDR5;
    property DEVADDR6 : TBits_1 read getDEVADDR6 write setDEVADDR6;
    property LSPDEN : TBits_1 read getLSPDEN write setLSPDEN;
  end;
  TUSB_U1FRML = record
  private
    function  getFRM0 : TBits_1; inline;
    function  getFRM1 : TBits_1; inline;
    function  getFRM2 : TBits_1; inline;
    function  getFRM3 : TBits_1; inline;
    function  getFRM4 : TBits_1; inline;
    function  getFRM5 : TBits_1; inline;
    function  getFRM6 : TBits_1; inline;
    function  getFRM7 : TBits_1; inline;
    function  getFRML : TBits_8; inline;
    procedure setFRM0(thebits : TBits_1); inline;
    procedure setFRM1(thebits : TBits_1); inline;
    procedure setFRM2(thebits : TBits_1); inline;
    procedure setFRM3(thebits : TBits_1); inline;
    procedure setFRM4(thebits : TBits_1); inline;
    procedure setFRM5(thebits : TBits_1); inline;
    procedure setFRM6(thebits : TBits_1); inline;
    procedure setFRM7(thebits : TBits_1); inline;
    procedure setFRML(thebits : TBits_8); inline;
  public
    procedure clearFRM0; inline;
    procedure clearFRM1; inline;
    procedure clearFRM2; inline;
    procedure clearFRM3; inline;
    procedure clearFRM4; inline;
    procedure clearFRM5; inline;
    procedure clearFRM6; inline;
    procedure clearFRM7; inline;
    procedure setFRM0; inline;
    procedure setFRM1; inline;
    procedure setFRM2; inline;
    procedure setFRM3; inline;
    procedure setFRM4; inline;
    procedure setFRM5; inline;
    procedure setFRM6; inline;
    procedure setFRM7; inline;
    property FRM0 : TBits_1 read getFRM0 write setFRM0;
    property FRM1 : TBits_1 read getFRM1 write setFRM1;
    property FRM2 : TBits_1 read getFRM2 write setFRM2;
    property FRM3 : TBits_1 read getFRM3 write setFRM3;
    property FRM4 : TBits_1 read getFRM4 write setFRM4;
    property FRM5 : TBits_1 read getFRM5 write setFRM5;
    property FRM6 : TBits_1 read getFRM6 write setFRM6;
    property FRM7 : TBits_1 read getFRM7 write setFRM7;
    property FRML : TBits_8 read getFRML write setFRML;
  end;
  TUSB_U1FRMH = record
  private
    function  getFRM10 : TBits_1; inline;
    function  getFRM8 : TBits_1; inline;
    function  getFRM9 : TBits_1; inline;
    function  getFRMH : TBits_3; inline;
    procedure setFRM10(thebits : TBits_1); inline;
    procedure setFRM8(thebits : TBits_1); inline;
    procedure setFRM9(thebits : TBits_1); inline;
    procedure setFRMH(thebits : TBits_3); inline;
  public
    procedure clearFRM10; inline;
    procedure clearFRM8; inline;
    procedure clearFRM9; inline;
    procedure setFRM10; inline;
    procedure setFRM8; inline;
    procedure setFRM9; inline;
    property FRM10 : TBits_1 read getFRM10 write setFRM10;
    property FRM8 : TBits_1 read getFRM8 write setFRM8;
    property FRM9 : TBits_1 read getFRM9 write setFRM9;
    property FRMH : TBits_3 read getFRMH write setFRMH;
  end;
  TUSB_U1TOK = record
  private
    function  getEP : TBits_4; inline;
    function  getEP0 : TBits_1; inline;
    function  getEP1 : TBits_1; inline;
    function  getEP2 : TBits_1; inline;
    function  getEP3 : TBits_1; inline;
    function  getPID : TBits_4; inline;
    function  getPID0 : TBits_1; inline;
    function  getPID1 : TBits_1; inline;
    function  getPID2 : TBits_1; inline;
    function  getPID3 : TBits_1; inline;
    procedure setEP(thebits : TBits_4); inline;
    procedure setEP0(thebits : TBits_1); inline;
    procedure setEP1(thebits : TBits_1); inline;
    procedure setEP2(thebits : TBits_1); inline;
    procedure setEP3(thebits : TBits_1); inline;
    procedure setPID(thebits : TBits_4); inline;
    procedure setPID0(thebits : TBits_1); inline;
    procedure setPID1(thebits : TBits_1); inline;
    procedure setPID2(thebits : TBits_1); inline;
    procedure setPID3(thebits : TBits_1); inline;
  public
    procedure clearEP0; inline;
    procedure clearEP1; inline;
    procedure clearEP2; inline;
    procedure clearEP3; inline;
    procedure clearPID0; inline;
    procedure clearPID1; inline;
    procedure clearPID2; inline;
    procedure clearPID3; inline;
    procedure setEP0; inline;
    procedure setEP1; inline;
    procedure setEP2; inline;
    procedure setEP3; inline;
    procedure setPID0; inline;
    procedure setPID1; inline;
    procedure setPID2; inline;
    procedure setPID3; inline;
    property EP : TBits_4 read getEP write setEP;
    property EP0 : TBits_1 read getEP0 write setEP0;
    property EP1 : TBits_1 read getEP1 write setEP1;
    property EP2 : TBits_1 read getEP2 write setEP2;
    property EP3 : TBits_1 read getEP3 write setEP3;
    property PID : TBits_4 read getPID write setPID;
    property PID0 : TBits_1 read getPID0 write setPID0;
    property PID1 : TBits_1 read getPID1 write setPID1;
    property PID2 : TBits_1 read getPID2 write setPID2;
    property PID3 : TBits_1 read getPID3 write setPID3;
  end;
type
  TUSBRegisters = record
    U1OTGIR : longWord;
    U1OTGIRCLR : longWord;
    U1OTGIE : longWord;
    U1OTGIECLR : longWord;
    U1OTGIESET : longWord;
    U1OTGIEINV : longWord;
    U1OTGSTAT : longWord;
    U1OTGCON : longWord;
    U1OTGCONCLR : longWord;
    U1OTGCONSET : longWord;
    U1OTGCONINV : longWord;
    U1PWRC : longWord;
    U1PWRCCLR : longWord;
    U1PWRCSET : longWord;
    U1PWRCINV : longWord;
    U1IRbits : TUSB_U1IR;
    U1IR : longWord;
    U1IRCLR : longWord;
    U1IEbits : TUSB_U1IE;
    U1IE : longWord;
    U1IECLR : longWord;
    U1IESET : longWord;
    U1IEINV : longWord;
    U1EIRbits : TUSB_U1EIR;
    U1EIR : longWord;
    U1EIRCLR : longWord;
    U1EIEbits : TUSB_U1EIE;
    U1EIE : longWord;
    U1EIECLR : longWord;
    U1EIESET : longWord;
    U1EIEINV : longWord;
    U1STATbits : TUSB_U1STAT;
    U1STAT : longWord;
    U1CONbits : TUSB_U1CON;
    U1CON : longWord;
    U1CONCLR : longWord;
    U1CONSET : longWord;
    U1CONINV : longWord;
    U1ADDRbits : TUSB_U1ADDR;
    U1ADDR : longWord;
    U1ADDRCLR : longWord;
    U1ADDRSET : longWord;
    U1ADDRINV : longWord;
    U1BDTP1 : longWord;
    U1BDTP1CLR : longWord;
    U1BDTP1SET : longWord;
    U1BDTP1INV : longWord;
    U1FRMLbits : TUSB_U1FRML;
    U1FRML : longWord;
    U1FRMHbits : TUSB_U1FRMH;
    U1FRMH : longWord;
    U1TOKbits : TUSB_U1TOK;
    U1TOK : longWord;
    U1TOKCLR : longWord;
    U1TOKSET : longWord;
    U1TOKINV : longWord;
    U1SOF : longWord;
    U1SOFCLR : longWord;
    U1SOFSET : longWord;
    U1SOFINV : longWord;
    U1BDTP2 : longWord;
    U1BDTP2CLR : longWord;
    U1BDTP2SET : longWord;
    U1BDTP2INV : longWord;
    U1BDTP3 : longWord;
    U1BDTP3CLR : longWord;
    U1BDTP3SET : longWord;
    U1BDTP3INV : longWord;
    U1CNFG1 : longWord;
    U1CNFG1CLR : longWord;
    U1CNFG1SET : longWord;
    U1CNFG1INV : longWord;
    U1EP0 : longWord;
    U1EP0CLR : longWord;
    U1EP0SET : longWord;
    U1EP0INV : longWord;
    U1EP1 : longWord;
    U1EP1CLR : longWord;
    U1EP1SET : longWord;
    U1EP1INV : longWord;
    U1EP2 : longWord;
    U1EP2CLR : longWord;
    U1EP2SET : longWord;
    U1EP2INV : longWord;
    U1EP3 : longWord;
    U1EP3CLR : longWord;
    U1EP3SET : longWord;
    U1EP3INV : longWord;
    U1EP4 : longWord;
    U1EP4CLR : longWord;
    U1EP4SET : longWord;
    U1EP4INV : longWord;
    U1EP5 : longWord;
    U1EP5CLR : longWord;
    U1EP5SET : longWord;
    U1EP5INV : longWord;
    U1EP6 : longWord;
    U1EP6CLR : longWord;
    U1EP6SET : longWord;
    U1EP6INV : longWord;
    U1EP7 : longWord;
    U1EP7CLR : longWord;
    U1EP7SET : longWord;
    U1EP7INV : longWord;
    U1EP8 : longWord;
    U1EP8CLR : longWord;
    U1EP8SET : longWord;
    U1EP8INV : longWord;
    U1EP9 : longWord;
    U1EP9CLR : longWord;
    U1EP9SET : longWord;
    U1EP9INV : longWord;
    U1EP10 : longWord;
    U1EP10CLR : longWord;
    U1EP10SET : longWord;
    U1EP10INV : longWord;
    U1EP11 : longWord;
    U1EP11CLR : longWord;
    U1EP11SET : longWord;
    U1EP11INV : longWord;
    U1EP12 : longWord;
    U1EP12CLR : longWord;
    U1EP12SET : longWord;
    U1EP12INV : longWord;
    U1EP13 : longWord;
    U1EP13CLR : longWord;
    U1EP13SET : longWord;
    U1EP13INV : longWord;
    U1EP14 : longWord;
    U1EP14CLR : longWord;
    U1EP14SET : longWord;
    U1EP14INV : longWord;
    U1EP15 : longWord;
    U1EP15CLR : longWord;
    U1EP15SET : longWord;
    U1EP15INV : longWord;
  end;
  TPORTA_ANSELA = record
  private
    function  getANSA0 : TBits_1; inline;
    function  getANSA1 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setANSA0(thebits : TBits_1); inline;
    procedure setANSA1(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearANSA0; inline;
    procedure clearANSA1; inline;
    procedure setANSA0; inline;
    procedure setANSA1; inline;
    property ANSA0 : TBits_1 read getANSA0 write setANSA0;
    property ANSA1 : TBits_1 read getANSA1 write setANSA1;
    property w : TBits_32 read getw write setw;
  end;
  TPORTA_TRISA = record
  private
    function  getTRISA0 : TBits_1; inline;
    function  getTRISA1 : TBits_1; inline;
    function  getTRISA2 : TBits_1; inline;
    function  getTRISA3 : TBits_1; inline;
    function  getTRISA4 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISA0(thebits : TBits_1); inline;
    procedure setTRISA1(thebits : TBits_1); inline;
    procedure setTRISA2(thebits : TBits_1); inline;
    procedure setTRISA3(thebits : TBits_1); inline;
    procedure setTRISA4(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISA0; inline;
    procedure clearTRISA1; inline;
    procedure clearTRISA2; inline;
    procedure clearTRISA3; inline;
    procedure clearTRISA4; inline;
    procedure setTRISA0; inline;
    procedure setTRISA1; inline;
    procedure setTRISA2; inline;
    procedure setTRISA3; inline;
    procedure setTRISA4; inline;
    property TRISA0 : TBits_1 read getTRISA0 write setTRISA0;
    property TRISA1 : TBits_1 read getTRISA1 write setTRISA1;
    property TRISA2 : TBits_1 read getTRISA2 write setTRISA2;
    property TRISA3 : TBits_1 read getTRISA3 write setTRISA3;
    property TRISA4 : TBits_1 read getTRISA4 write setTRISA4;
    property w : TBits_32 read getw write setw;
  end;
  TPORTA_PORTA = record
  private
    function  getRA0 : TBits_1; inline;
    function  getRA1 : TBits_1; inline;
    function  getRA2 : TBits_1; inline;
    function  getRA3 : TBits_1; inline;
    function  getRA4 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRA0(thebits : TBits_1); inline;
    procedure setRA1(thebits : TBits_1); inline;
    procedure setRA2(thebits : TBits_1); inline;
    procedure setRA3(thebits : TBits_1); inline;
    procedure setRA4(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRA0; inline;
    procedure clearRA1; inline;
    procedure clearRA2; inline;
    procedure clearRA3; inline;
    procedure clearRA4; inline;
    procedure setRA0; inline;
    procedure setRA1; inline;
    procedure setRA2; inline;
    procedure setRA3; inline;
    procedure setRA4; inline;
    property RA0 : TBits_1 read getRA0 write setRA0;
    property RA1 : TBits_1 read getRA1 write setRA1;
    property RA2 : TBits_1 read getRA2 write setRA2;
    property RA3 : TBits_1 read getRA3 write setRA3;
    property RA4 : TBits_1 read getRA4 write setRA4;
    property w : TBits_32 read getw write setw;
  end;
  TPortA_bits=(RA0=0,RA1=1,RA2=2,RA3=3,RA4=4);
  TPortA_bitset = set of TPortA_bits;
  TPORTA_LATA = record
  private
    function  getLATA0 : TBits_1; inline;
    function  getLATA1 : TBits_1; inline;
    function  getLATA2 : TBits_1; inline;
    function  getLATA3 : TBits_1; inline;
    function  getLATA4 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATA0(thebits : TBits_1); inline;
    procedure setLATA1(thebits : TBits_1); inline;
    procedure setLATA2(thebits : TBits_1); inline;
    procedure setLATA3(thebits : TBits_1); inline;
    procedure setLATA4(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATA0; inline;
    procedure clearLATA1; inline;
    procedure clearLATA2; inline;
    procedure clearLATA3; inline;
    procedure clearLATA4; inline;
    procedure setLATA0; inline;
    procedure setLATA1; inline;
    procedure setLATA2; inline;
    procedure setLATA3; inline;
    procedure setLATA4; inline;
    property LATA0 : TBits_1 read getLATA0 write setLATA0;
    property LATA1 : TBits_1 read getLATA1 write setLATA1;
    property LATA2 : TBits_1 read getLATA2 write setLATA2;
    property LATA3 : TBits_1 read getLATA3 write setLATA3;
    property LATA4 : TBits_1 read getLATA4 write setLATA4;
    property w : TBits_32 read getw write setw;
  end;
  TPORTA_CNPUA = record
  private
    function  getCNPUA0 : TBits_1; inline;
    function  getCNPUA1 : TBits_1; inline;
    function  getCNPUA2 : TBits_1; inline;
    function  getCNPUA3 : TBits_1; inline;
    function  getCNPUA4 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPUA0(thebits : TBits_1); inline;
    procedure setCNPUA1(thebits : TBits_1); inline;
    procedure setCNPUA2(thebits : TBits_1); inline;
    procedure setCNPUA3(thebits : TBits_1); inline;
    procedure setCNPUA4(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPUA0; inline;
    procedure clearCNPUA1; inline;
    procedure clearCNPUA2; inline;
    procedure clearCNPUA3; inline;
    procedure clearCNPUA4; inline;
    procedure setCNPUA0; inline;
    procedure setCNPUA1; inline;
    procedure setCNPUA2; inline;
    procedure setCNPUA3; inline;
    procedure setCNPUA4; inline;
    property CNPUA0 : TBits_1 read getCNPUA0 write setCNPUA0;
    property CNPUA1 : TBits_1 read getCNPUA1 write setCNPUA1;
    property CNPUA2 : TBits_1 read getCNPUA2 write setCNPUA2;
    property CNPUA3 : TBits_1 read getCNPUA3 write setCNPUA3;
    property CNPUA4 : TBits_1 read getCNPUA4 write setCNPUA4;
    property w : TBits_32 read getw write setw;
  end;
  TPORTA_CNPDA = record
  private
    function  getCNPDA0 : TBits_1; inline;
    function  getCNPDA1 : TBits_1; inline;
    function  getCNPDA2 : TBits_1; inline;
    function  getCNPDA3 : TBits_1; inline;
    function  getCNPDA4 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPDA0(thebits : TBits_1); inline;
    procedure setCNPDA1(thebits : TBits_1); inline;
    procedure setCNPDA2(thebits : TBits_1); inline;
    procedure setCNPDA3(thebits : TBits_1); inline;
    procedure setCNPDA4(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPDA0; inline;
    procedure clearCNPDA1; inline;
    procedure clearCNPDA2; inline;
    procedure clearCNPDA3; inline;
    procedure clearCNPDA4; inline;
    procedure setCNPDA0; inline;
    procedure setCNPDA1; inline;
    procedure setCNPDA2; inline;
    procedure setCNPDA3; inline;
    procedure setCNPDA4; inline;
    property CNPDA0 : TBits_1 read getCNPDA0 write setCNPDA0;
    property CNPDA1 : TBits_1 read getCNPDA1 write setCNPDA1;
    property CNPDA2 : TBits_1 read getCNPDA2 write setCNPDA2;
    property CNPDA3 : TBits_1 read getCNPDA3 write setCNPDA3;
    property CNPDA4 : TBits_1 read getCNPDA4 write setCNPDA4;
    property w : TBits_32 read getw write setw;
  end;
  TPORTA_CNCONA = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TPORTA_CNENA = record
  private
    function  getCNIEA0 : TBits_1; inline;
    function  getCNIEA1 : TBits_1; inline;
    function  getCNIEA2 : TBits_1; inline;
    function  getCNIEA3 : TBits_1; inline;
    function  getCNIEA4 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNIEA0(thebits : TBits_1); inline;
    procedure setCNIEA1(thebits : TBits_1); inline;
    procedure setCNIEA2(thebits : TBits_1); inline;
    procedure setCNIEA3(thebits : TBits_1); inline;
    procedure setCNIEA4(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNIEA0; inline;
    procedure clearCNIEA1; inline;
    procedure clearCNIEA2; inline;
    procedure clearCNIEA3; inline;
    procedure clearCNIEA4; inline;
    procedure setCNIEA0; inline;
    procedure setCNIEA1; inline;
    procedure setCNIEA2; inline;
    procedure setCNIEA3; inline;
    procedure setCNIEA4; inline;
    property CNIEA0 : TBits_1 read getCNIEA0 write setCNIEA0;
    property CNIEA1 : TBits_1 read getCNIEA1 write setCNIEA1;
    property CNIEA2 : TBits_1 read getCNIEA2 write setCNIEA2;
    property CNIEA3 : TBits_1 read getCNIEA3 write setCNIEA3;
    property CNIEA4 : TBits_1 read getCNIEA4 write setCNIEA4;
    property w : TBits_32 read getw write setw;
  end;
  TPORTA_CNSTATA = record
  private
    function  getCNSTATA0 : TBits_1; inline;
    function  getCNSTATA1 : TBits_1; inline;
    function  getCNSTATA2 : TBits_1; inline;
    function  getCNSTATA3 : TBits_1; inline;
    function  getCNSTATA4 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNSTATA0(thebits : TBits_1); inline;
    procedure setCNSTATA1(thebits : TBits_1); inline;
    procedure setCNSTATA2(thebits : TBits_1); inline;
    procedure setCNSTATA3(thebits : TBits_1); inline;
    procedure setCNSTATA4(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNSTATA0; inline;
    procedure clearCNSTATA1; inline;
    procedure clearCNSTATA2; inline;
    procedure clearCNSTATA3; inline;
    procedure clearCNSTATA4; inline;
    procedure setCNSTATA0; inline;
    procedure setCNSTATA1; inline;
    procedure setCNSTATA2; inline;
    procedure setCNSTATA3; inline;
    procedure setCNSTATA4; inline;
    property CNSTATA0 : TBits_1 read getCNSTATA0 write setCNSTATA0;
    property CNSTATA1 : TBits_1 read getCNSTATA1 write setCNSTATA1;
    property CNSTATA2 : TBits_1 read getCNSTATA2 write setCNSTATA2;
    property CNSTATA3 : TBits_1 read getCNSTATA3 write setCNSTATA3;
    property CNSTATA4 : TBits_1 read getCNSTATA4 write setCNSTATA4;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTARegisters = record
    ANSELAbits : TPORTA_ANSELA;
    ANSELA : longWord;
    ANSELACLR : longWord;
    ANSELASET : longWord;
    ANSELAINV : longWord;
    TRISAbits : TPORTA_TRISA;
    TRISA : longWord;
    TRISACLR : longWord;
    TRISASET : longWord;
    TRISAINV : longWord;
    PORTAbits : TPORTA_PORTA;
    PORTA : longWord;
    PORTACLR : longWord;
    PORTASET : longWord;
    PORTAINV : longWord;
    LATAbits : TPORTA_LATA;
    LATA : longWord;
    LATACLR : longWord;
    LATASET : longWord;
    LATAINV : longWord;
    ODCA : longWord;
    ODCACLR : longWord;
    ODCASET : longWord;
    ODCAINV : longWord;
    CNPUAbits : TPORTA_CNPUA;
    CNPUA : longWord;
    CNPUACLR : longWord;
    CNPUASET : longWord;
    CNPUAINV : longWord;
    CNPDAbits : TPORTA_CNPDA;
    CNPDA : longWord;
    CNPDACLR : longWord;
    CNPDASET : longWord;
    CNPDAINV : longWord;
    CNCONAbits : TPORTA_CNCONA;
    CNCONA : longWord;
    CNCONACLR : longWord;
    CNCONASET : longWord;
    CNCONAINV : longWord;
    CNENAbits : TPORTA_CNENA;
    CNENA : longWord;
    CNENACLR : longWord;
    CNENASET : longWord;
    CNENAINV : longWord;
    CNSTATAbits : TPORTA_CNSTATA;
    CNSTATA : longWord;
    CNSTATACLR : longWord;
    CNSTATASET : longWord;
    CNSTATAINV : longWord;
  end;
  TPORTB_ANSELB = record
  private
    function  getANSB0 : TBits_1; inline;
    function  getANSB1 : TBits_1; inline;
    function  getANSB13 : TBits_1; inline;
    function  getANSB14 : TBits_1; inline;
    function  getANSB15 : TBits_1; inline;
    function  getANSB2 : TBits_1; inline;
    function  getANSB3 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setANSB0(thebits : TBits_1); inline;
    procedure setANSB1(thebits : TBits_1); inline;
    procedure setANSB13(thebits : TBits_1); inline;
    procedure setANSB14(thebits : TBits_1); inline;
    procedure setANSB15(thebits : TBits_1); inline;
    procedure setANSB2(thebits : TBits_1); inline;
    procedure setANSB3(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearANSB0; inline;
    procedure clearANSB13; inline;
    procedure clearANSB14; inline;
    procedure clearANSB15; inline;
    procedure clearANSB1; inline;
    procedure clearANSB2; inline;
    procedure clearANSB3; inline;
    procedure setANSB0; inline;
    procedure setANSB13; inline;
    procedure setANSB14; inline;
    procedure setANSB15; inline;
    procedure setANSB1; inline;
    procedure setANSB2; inline;
    procedure setANSB3; inline;
    property ANSB0 : TBits_1 read getANSB0 write setANSB0;
    property ANSB1 : TBits_1 read getANSB1 write setANSB1;
    property ANSB13 : TBits_1 read getANSB13 write setANSB13;
    property ANSB14 : TBits_1 read getANSB14 write setANSB14;
    property ANSB15 : TBits_1 read getANSB15 write setANSB15;
    property ANSB2 : TBits_1 read getANSB2 write setANSB2;
    property ANSB3 : TBits_1 read getANSB3 write setANSB3;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_TRISB = record
  private
    function  getTRISB0 : TBits_1; inline;
    function  getTRISB1 : TBits_1; inline;
    function  getTRISB10 : TBits_1; inline;
    function  getTRISB11 : TBits_1; inline;
    function  getTRISB13 : TBits_1; inline;
    function  getTRISB14 : TBits_1; inline;
    function  getTRISB15 : TBits_1; inline;
    function  getTRISB2 : TBits_1; inline;
    function  getTRISB3 : TBits_1; inline;
    function  getTRISB4 : TBits_1; inline;
    function  getTRISB5 : TBits_1; inline;
    function  getTRISB7 : TBits_1; inline;
    function  getTRISB8 : TBits_1; inline;
    function  getTRISB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISB0(thebits : TBits_1); inline;
    procedure setTRISB1(thebits : TBits_1); inline;
    procedure setTRISB10(thebits : TBits_1); inline;
    procedure setTRISB11(thebits : TBits_1); inline;
    procedure setTRISB13(thebits : TBits_1); inline;
    procedure setTRISB14(thebits : TBits_1); inline;
    procedure setTRISB15(thebits : TBits_1); inline;
    procedure setTRISB2(thebits : TBits_1); inline;
    procedure setTRISB3(thebits : TBits_1); inline;
    procedure setTRISB4(thebits : TBits_1); inline;
    procedure setTRISB5(thebits : TBits_1); inline;
    procedure setTRISB7(thebits : TBits_1); inline;
    procedure setTRISB8(thebits : TBits_1); inline;
    procedure setTRISB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISB0; inline;
    procedure clearTRISB10; inline;
    procedure clearTRISB11; inline;
    procedure clearTRISB13; inline;
    procedure clearTRISB14; inline;
    procedure clearTRISB15; inline;
    procedure clearTRISB1; inline;
    procedure clearTRISB2; inline;
    procedure clearTRISB3; inline;
    procedure clearTRISB4; inline;
    procedure clearTRISB5; inline;
    procedure clearTRISB7; inline;
    procedure clearTRISB8; inline;
    procedure clearTRISB9; inline;
    procedure setTRISB0; inline;
    procedure setTRISB10; inline;
    procedure setTRISB11; inline;
    procedure setTRISB13; inline;
    procedure setTRISB14; inline;
    procedure setTRISB15; inline;
    procedure setTRISB1; inline;
    procedure setTRISB2; inline;
    procedure setTRISB3; inline;
    procedure setTRISB4; inline;
    procedure setTRISB5; inline;
    procedure setTRISB7; inline;
    procedure setTRISB8; inline;
    procedure setTRISB9; inline;
    property TRISB0 : TBits_1 read getTRISB0 write setTRISB0;
    property TRISB1 : TBits_1 read getTRISB1 write setTRISB1;
    property TRISB10 : TBits_1 read getTRISB10 write setTRISB10;
    property TRISB11 : TBits_1 read getTRISB11 write setTRISB11;
    property TRISB13 : TBits_1 read getTRISB13 write setTRISB13;
    property TRISB14 : TBits_1 read getTRISB14 write setTRISB14;
    property TRISB15 : TBits_1 read getTRISB15 write setTRISB15;
    property TRISB2 : TBits_1 read getTRISB2 write setTRISB2;
    property TRISB3 : TBits_1 read getTRISB3 write setTRISB3;
    property TRISB4 : TBits_1 read getTRISB4 write setTRISB4;
    property TRISB5 : TBits_1 read getTRISB5 write setTRISB5;
    property TRISB7 : TBits_1 read getTRISB7 write setTRISB7;
    property TRISB8 : TBits_1 read getTRISB8 write setTRISB8;
    property TRISB9 : TBits_1 read getTRISB9 write setTRISB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_PORTB = record
  private
    function  getRB0 : TBits_1; inline;
    function  getRB1 : TBits_1; inline;
    function  getRB10 : TBits_1; inline;
    function  getRB11 : TBits_1; inline;
    function  getRB13 : TBits_1; inline;
    function  getRB14 : TBits_1; inline;
    function  getRB15 : TBits_1; inline;
    function  getRB2 : TBits_1; inline;
    function  getRB3 : TBits_1; inline;
    function  getRB4 : TBits_1; inline;
    function  getRB5 : TBits_1; inline;
    function  getRB7 : TBits_1; inline;
    function  getRB8 : TBits_1; inline;
    function  getRB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRB0(thebits : TBits_1); inline;
    procedure setRB1(thebits : TBits_1); inline;
    procedure setRB10(thebits : TBits_1); inline;
    procedure setRB11(thebits : TBits_1); inline;
    procedure setRB13(thebits : TBits_1); inline;
    procedure setRB14(thebits : TBits_1); inline;
    procedure setRB15(thebits : TBits_1); inline;
    procedure setRB2(thebits : TBits_1); inline;
    procedure setRB3(thebits : TBits_1); inline;
    procedure setRB4(thebits : TBits_1); inline;
    procedure setRB5(thebits : TBits_1); inline;
    procedure setRB7(thebits : TBits_1); inline;
    procedure setRB8(thebits : TBits_1); inline;
    procedure setRB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRB0; inline;
    procedure clearRB10; inline;
    procedure clearRB11; inline;
    procedure clearRB13; inline;
    procedure clearRB14; inline;
    procedure clearRB15; inline;
    procedure clearRB1; inline;
    procedure clearRB2; inline;
    procedure clearRB3; inline;
    procedure clearRB4; inline;
    procedure clearRB5; inline;
    procedure clearRB7; inline;
    procedure clearRB8; inline;
    procedure clearRB9; inline;
    procedure setRB0; inline;
    procedure setRB10; inline;
    procedure setRB11; inline;
    procedure setRB13; inline;
    procedure setRB14; inline;
    procedure setRB15; inline;
    procedure setRB1; inline;
    procedure setRB2; inline;
    procedure setRB3; inline;
    procedure setRB4; inline;
    procedure setRB5; inline;
    procedure setRB7; inline;
    procedure setRB8; inline;
    procedure setRB9; inline;
    property RB0 : TBits_1 read getRB0 write setRB0;
    property RB1 : TBits_1 read getRB1 write setRB1;
    property RB10 : TBits_1 read getRB10 write setRB10;
    property RB11 : TBits_1 read getRB11 write setRB11;
    property RB13 : TBits_1 read getRB13 write setRB13;
    property RB14 : TBits_1 read getRB14 write setRB14;
    property RB15 : TBits_1 read getRB15 write setRB15;
    property RB2 : TBits_1 read getRB2 write setRB2;
    property RB3 : TBits_1 read getRB3 write setRB3;
    property RB4 : TBits_1 read getRB4 write setRB4;
    property RB5 : TBits_1 read getRB5 write setRB5;
    property RB7 : TBits_1 read getRB7 write setRB7;
    property RB8 : TBits_1 read getRB8 write setRB8;
    property RB9 : TBits_1 read getRB9 write setRB9;
    property w : TBits_32 read getw write setw;
  end;
  TPortB_bits=(RB0=0,RB1=1,RB2=2,RB3=3,RB4=4,RB5=5,RB7=7,RB8=8,RB9=9,RB10=10,RB11=11,RB13=13,RB14=14,RB15=15);
  TPortB_bitset = set of TPortB_bits;
  TPORTB_LATB = record
  private
    function  getLATB0 : TBits_1; inline;
    function  getLATB1 : TBits_1; inline;
    function  getLATB10 : TBits_1; inline;
    function  getLATB11 : TBits_1; inline;
    function  getLATB13 : TBits_1; inline;
    function  getLATB14 : TBits_1; inline;
    function  getLATB15 : TBits_1; inline;
    function  getLATB2 : TBits_1; inline;
    function  getLATB3 : TBits_1; inline;
    function  getLATB4 : TBits_1; inline;
    function  getLATB5 : TBits_1; inline;
    function  getLATB7 : TBits_1; inline;
    function  getLATB8 : TBits_1; inline;
    function  getLATB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATB0(thebits : TBits_1); inline;
    procedure setLATB1(thebits : TBits_1); inline;
    procedure setLATB10(thebits : TBits_1); inline;
    procedure setLATB11(thebits : TBits_1); inline;
    procedure setLATB13(thebits : TBits_1); inline;
    procedure setLATB14(thebits : TBits_1); inline;
    procedure setLATB15(thebits : TBits_1); inline;
    procedure setLATB2(thebits : TBits_1); inline;
    procedure setLATB3(thebits : TBits_1); inline;
    procedure setLATB4(thebits : TBits_1); inline;
    procedure setLATB5(thebits : TBits_1); inline;
    procedure setLATB7(thebits : TBits_1); inline;
    procedure setLATB8(thebits : TBits_1); inline;
    procedure setLATB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATB0; inline;
    procedure clearLATB10; inline;
    procedure clearLATB11; inline;
    procedure clearLATB13; inline;
    procedure clearLATB14; inline;
    procedure clearLATB15; inline;
    procedure clearLATB1; inline;
    procedure clearLATB2; inline;
    procedure clearLATB3; inline;
    procedure clearLATB4; inline;
    procedure clearLATB5; inline;
    procedure clearLATB7; inline;
    procedure clearLATB8; inline;
    procedure clearLATB9; inline;
    procedure setLATB0; inline;
    procedure setLATB10; inline;
    procedure setLATB11; inline;
    procedure setLATB13; inline;
    procedure setLATB14; inline;
    procedure setLATB15; inline;
    procedure setLATB1; inline;
    procedure setLATB2; inline;
    procedure setLATB3; inline;
    procedure setLATB4; inline;
    procedure setLATB5; inline;
    procedure setLATB7; inline;
    procedure setLATB8; inline;
    procedure setLATB9; inline;
    property LATB0 : TBits_1 read getLATB0 write setLATB0;
    property LATB1 : TBits_1 read getLATB1 write setLATB1;
    property LATB10 : TBits_1 read getLATB10 write setLATB10;
    property LATB11 : TBits_1 read getLATB11 write setLATB11;
    property LATB13 : TBits_1 read getLATB13 write setLATB13;
    property LATB14 : TBits_1 read getLATB14 write setLATB14;
    property LATB15 : TBits_1 read getLATB15 write setLATB15;
    property LATB2 : TBits_1 read getLATB2 write setLATB2;
    property LATB3 : TBits_1 read getLATB3 write setLATB3;
    property LATB4 : TBits_1 read getLATB4 write setLATB4;
    property LATB5 : TBits_1 read getLATB5 write setLATB5;
    property LATB7 : TBits_1 read getLATB7 write setLATB7;
    property LATB8 : TBits_1 read getLATB8 write setLATB8;
    property LATB9 : TBits_1 read getLATB9 write setLATB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_ODCB = record
  private
    function  getODCB10 : TBits_1; inline;
    function  getODCB11 : TBits_1; inline;
    function  getODCB4 : TBits_1; inline;
    function  getODCB5 : TBits_1; inline;
    function  getODCB7 : TBits_1; inline;
    function  getODCB8 : TBits_1; inline;
    function  getODCB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCB10(thebits : TBits_1); inline;
    procedure setODCB11(thebits : TBits_1); inline;
    procedure setODCB4(thebits : TBits_1); inline;
    procedure setODCB5(thebits : TBits_1); inline;
    procedure setODCB7(thebits : TBits_1); inline;
    procedure setODCB8(thebits : TBits_1); inline;
    procedure setODCB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCB10; inline;
    procedure clearODCB11; inline;
    procedure clearODCB4; inline;
    procedure clearODCB5; inline;
    procedure clearODCB7; inline;
    procedure clearODCB8; inline;
    procedure clearODCB9; inline;
    procedure setODCB10; inline;
    procedure setODCB11; inline;
    procedure setODCB4; inline;
    procedure setODCB5; inline;
    procedure setODCB7; inline;
    procedure setODCB8; inline;
    procedure setODCB9; inline;
    property ODCB10 : TBits_1 read getODCB10 write setODCB10;
    property ODCB11 : TBits_1 read getODCB11 write setODCB11;
    property ODCB4 : TBits_1 read getODCB4 write setODCB4;
    property ODCB5 : TBits_1 read getODCB5 write setODCB5;
    property ODCB7 : TBits_1 read getODCB7 write setODCB7;
    property ODCB8 : TBits_1 read getODCB8 write setODCB8;
    property ODCB9 : TBits_1 read getODCB9 write setODCB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_CNPUB = record
  private
    function  getCNPUB0 : TBits_1; inline;
    function  getCNPUB1 : TBits_1; inline;
    function  getCNPUB10 : TBits_1; inline;
    function  getCNPUB11 : TBits_1; inline;
    function  getCNPUB13 : TBits_1; inline;
    function  getCNPUB14 : TBits_1; inline;
    function  getCNPUB15 : TBits_1; inline;
    function  getCNPUB2 : TBits_1; inline;
    function  getCNPUB3 : TBits_1; inline;
    function  getCNPUB4 : TBits_1; inline;
    function  getCNPUB5 : TBits_1; inline;
    function  getCNPUB7 : TBits_1; inline;
    function  getCNPUB8 : TBits_1; inline;
    function  getCNPUB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPUB0(thebits : TBits_1); inline;
    procedure setCNPUB1(thebits : TBits_1); inline;
    procedure setCNPUB10(thebits : TBits_1); inline;
    procedure setCNPUB11(thebits : TBits_1); inline;
    procedure setCNPUB13(thebits : TBits_1); inline;
    procedure setCNPUB14(thebits : TBits_1); inline;
    procedure setCNPUB15(thebits : TBits_1); inline;
    procedure setCNPUB2(thebits : TBits_1); inline;
    procedure setCNPUB3(thebits : TBits_1); inline;
    procedure setCNPUB4(thebits : TBits_1); inline;
    procedure setCNPUB5(thebits : TBits_1); inline;
    procedure setCNPUB7(thebits : TBits_1); inline;
    procedure setCNPUB8(thebits : TBits_1); inline;
    procedure setCNPUB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPUB0; inline;
    procedure clearCNPUB10; inline;
    procedure clearCNPUB11; inline;
    procedure clearCNPUB13; inline;
    procedure clearCNPUB14; inline;
    procedure clearCNPUB15; inline;
    procedure clearCNPUB1; inline;
    procedure clearCNPUB2; inline;
    procedure clearCNPUB3; inline;
    procedure clearCNPUB4; inline;
    procedure clearCNPUB5; inline;
    procedure clearCNPUB7; inline;
    procedure clearCNPUB8; inline;
    procedure clearCNPUB9; inline;
    procedure setCNPUB0; inline;
    procedure setCNPUB10; inline;
    procedure setCNPUB11; inline;
    procedure setCNPUB13; inline;
    procedure setCNPUB14; inline;
    procedure setCNPUB15; inline;
    procedure setCNPUB1; inline;
    procedure setCNPUB2; inline;
    procedure setCNPUB3; inline;
    procedure setCNPUB4; inline;
    procedure setCNPUB5; inline;
    procedure setCNPUB7; inline;
    procedure setCNPUB8; inline;
    procedure setCNPUB9; inline;
    property CNPUB0 : TBits_1 read getCNPUB0 write setCNPUB0;
    property CNPUB1 : TBits_1 read getCNPUB1 write setCNPUB1;
    property CNPUB10 : TBits_1 read getCNPUB10 write setCNPUB10;
    property CNPUB11 : TBits_1 read getCNPUB11 write setCNPUB11;
    property CNPUB13 : TBits_1 read getCNPUB13 write setCNPUB13;
    property CNPUB14 : TBits_1 read getCNPUB14 write setCNPUB14;
    property CNPUB15 : TBits_1 read getCNPUB15 write setCNPUB15;
    property CNPUB2 : TBits_1 read getCNPUB2 write setCNPUB2;
    property CNPUB3 : TBits_1 read getCNPUB3 write setCNPUB3;
    property CNPUB4 : TBits_1 read getCNPUB4 write setCNPUB4;
    property CNPUB5 : TBits_1 read getCNPUB5 write setCNPUB5;
    property CNPUB7 : TBits_1 read getCNPUB7 write setCNPUB7;
    property CNPUB8 : TBits_1 read getCNPUB8 write setCNPUB8;
    property CNPUB9 : TBits_1 read getCNPUB9 write setCNPUB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_CNPDB = record
  private
    function  getCNPDB0 : TBits_1; inline;
    function  getCNPDB1 : TBits_1; inline;
    function  getCNPDB10 : TBits_1; inline;
    function  getCNPDB11 : TBits_1; inline;
    function  getCNPDB13 : TBits_1; inline;
    function  getCNPDB14 : TBits_1; inline;
    function  getCNPDB15 : TBits_1; inline;
    function  getCNPDB2 : TBits_1; inline;
    function  getCNPDB3 : TBits_1; inline;
    function  getCNPDB4 : TBits_1; inline;
    function  getCNPDB5 : TBits_1; inline;
    function  getCNPDB7 : TBits_1; inline;
    function  getCNPDB8 : TBits_1; inline;
    function  getCNPDB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPDB0(thebits : TBits_1); inline;
    procedure setCNPDB1(thebits : TBits_1); inline;
    procedure setCNPDB10(thebits : TBits_1); inline;
    procedure setCNPDB11(thebits : TBits_1); inline;
    procedure setCNPDB13(thebits : TBits_1); inline;
    procedure setCNPDB14(thebits : TBits_1); inline;
    procedure setCNPDB15(thebits : TBits_1); inline;
    procedure setCNPDB2(thebits : TBits_1); inline;
    procedure setCNPDB3(thebits : TBits_1); inline;
    procedure setCNPDB4(thebits : TBits_1); inline;
    procedure setCNPDB5(thebits : TBits_1); inline;
    procedure setCNPDB7(thebits : TBits_1); inline;
    procedure setCNPDB8(thebits : TBits_1); inline;
    procedure setCNPDB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPDB0; inline;
    procedure clearCNPDB10; inline;
    procedure clearCNPDB11; inline;
    procedure clearCNPDB13; inline;
    procedure clearCNPDB14; inline;
    procedure clearCNPDB15; inline;
    procedure clearCNPDB1; inline;
    procedure clearCNPDB2; inline;
    procedure clearCNPDB3; inline;
    procedure clearCNPDB4; inline;
    procedure clearCNPDB5; inline;
    procedure clearCNPDB7; inline;
    procedure clearCNPDB8; inline;
    procedure clearCNPDB9; inline;
    procedure setCNPDB0; inline;
    procedure setCNPDB10; inline;
    procedure setCNPDB11; inline;
    procedure setCNPDB13; inline;
    procedure setCNPDB14; inline;
    procedure setCNPDB15; inline;
    procedure setCNPDB1; inline;
    procedure setCNPDB2; inline;
    procedure setCNPDB3; inline;
    procedure setCNPDB4; inline;
    procedure setCNPDB5; inline;
    procedure setCNPDB7; inline;
    procedure setCNPDB8; inline;
    procedure setCNPDB9; inline;
    property CNPDB0 : TBits_1 read getCNPDB0 write setCNPDB0;
    property CNPDB1 : TBits_1 read getCNPDB1 write setCNPDB1;
    property CNPDB10 : TBits_1 read getCNPDB10 write setCNPDB10;
    property CNPDB11 : TBits_1 read getCNPDB11 write setCNPDB11;
    property CNPDB13 : TBits_1 read getCNPDB13 write setCNPDB13;
    property CNPDB14 : TBits_1 read getCNPDB14 write setCNPDB14;
    property CNPDB15 : TBits_1 read getCNPDB15 write setCNPDB15;
    property CNPDB2 : TBits_1 read getCNPDB2 write setCNPDB2;
    property CNPDB3 : TBits_1 read getCNPDB3 write setCNPDB3;
    property CNPDB4 : TBits_1 read getCNPDB4 write setCNPDB4;
    property CNPDB5 : TBits_1 read getCNPDB5 write setCNPDB5;
    property CNPDB7 : TBits_1 read getCNPDB7 write setCNPDB7;
    property CNPDB8 : TBits_1 read getCNPDB8 write setCNPDB8;
    property CNPDB9 : TBits_1 read getCNPDB9 write setCNPDB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_CNCONB = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_CNENB = record
  private
    function  getCNIEB0 : TBits_1; inline;
    function  getCNIEB1 : TBits_1; inline;
    function  getCNIEB10 : TBits_1; inline;
    function  getCNIEB11 : TBits_1; inline;
    function  getCNIEB13 : TBits_1; inline;
    function  getCNIEB14 : TBits_1; inline;
    function  getCNIEB15 : TBits_1; inline;
    function  getCNIEB2 : TBits_1; inline;
    function  getCNIEB3 : TBits_1; inline;
    function  getCNIEB4 : TBits_1; inline;
    function  getCNIEB5 : TBits_1; inline;
    function  getCNIEB7 : TBits_1; inline;
    function  getCNIEB8 : TBits_1; inline;
    function  getCNIEB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNIEB0(thebits : TBits_1); inline;
    procedure setCNIEB1(thebits : TBits_1); inline;
    procedure setCNIEB10(thebits : TBits_1); inline;
    procedure setCNIEB11(thebits : TBits_1); inline;
    procedure setCNIEB13(thebits : TBits_1); inline;
    procedure setCNIEB14(thebits : TBits_1); inline;
    procedure setCNIEB15(thebits : TBits_1); inline;
    procedure setCNIEB2(thebits : TBits_1); inline;
    procedure setCNIEB3(thebits : TBits_1); inline;
    procedure setCNIEB4(thebits : TBits_1); inline;
    procedure setCNIEB5(thebits : TBits_1); inline;
    procedure setCNIEB7(thebits : TBits_1); inline;
    procedure setCNIEB8(thebits : TBits_1); inline;
    procedure setCNIEB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNIEB0; inline;
    procedure clearCNIEB10; inline;
    procedure clearCNIEB11; inline;
    procedure clearCNIEB13; inline;
    procedure clearCNIEB14; inline;
    procedure clearCNIEB15; inline;
    procedure clearCNIEB1; inline;
    procedure clearCNIEB2; inline;
    procedure clearCNIEB3; inline;
    procedure clearCNIEB4; inline;
    procedure clearCNIEB5; inline;
    procedure clearCNIEB7; inline;
    procedure clearCNIEB8; inline;
    procedure clearCNIEB9; inline;
    procedure setCNIEB0; inline;
    procedure setCNIEB10; inline;
    procedure setCNIEB11; inline;
    procedure setCNIEB13; inline;
    procedure setCNIEB14; inline;
    procedure setCNIEB15; inline;
    procedure setCNIEB1; inline;
    procedure setCNIEB2; inline;
    procedure setCNIEB3; inline;
    procedure setCNIEB4; inline;
    procedure setCNIEB5; inline;
    procedure setCNIEB7; inline;
    procedure setCNIEB8; inline;
    procedure setCNIEB9; inline;
    property CNIEB0 : TBits_1 read getCNIEB0 write setCNIEB0;
    property CNIEB1 : TBits_1 read getCNIEB1 write setCNIEB1;
    property CNIEB10 : TBits_1 read getCNIEB10 write setCNIEB10;
    property CNIEB11 : TBits_1 read getCNIEB11 write setCNIEB11;
    property CNIEB13 : TBits_1 read getCNIEB13 write setCNIEB13;
    property CNIEB14 : TBits_1 read getCNIEB14 write setCNIEB14;
    property CNIEB15 : TBits_1 read getCNIEB15 write setCNIEB15;
    property CNIEB2 : TBits_1 read getCNIEB2 write setCNIEB2;
    property CNIEB3 : TBits_1 read getCNIEB3 write setCNIEB3;
    property CNIEB4 : TBits_1 read getCNIEB4 write setCNIEB4;
    property CNIEB5 : TBits_1 read getCNIEB5 write setCNIEB5;
    property CNIEB7 : TBits_1 read getCNIEB7 write setCNIEB7;
    property CNIEB8 : TBits_1 read getCNIEB8 write setCNIEB8;
    property CNIEB9 : TBits_1 read getCNIEB9 write setCNIEB9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTB_CNSTATB = record
  private
    function  getCNSTATB0 : TBits_1; inline;
    function  getCNSTATB1 : TBits_1; inline;
    function  getCNSTATB10 : TBits_1; inline;
    function  getCNSTATB11 : TBits_1; inline;
    function  getCNSTATB13 : TBits_1; inline;
    function  getCNSTATB14 : TBits_1; inline;
    function  getCNSTATB15 : TBits_1; inline;
    function  getCNSTATB2 : TBits_1; inline;
    function  getCNSTATB3 : TBits_1; inline;
    function  getCNSTATB4 : TBits_1; inline;
    function  getCNSTATB5 : TBits_1; inline;
    function  getCNSTATB7 : TBits_1; inline;
    function  getCNSTATB8 : TBits_1; inline;
    function  getCNSTATB9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNSTATB0(thebits : TBits_1); inline;
    procedure setCNSTATB1(thebits : TBits_1); inline;
    procedure setCNSTATB10(thebits : TBits_1); inline;
    procedure setCNSTATB11(thebits : TBits_1); inline;
    procedure setCNSTATB13(thebits : TBits_1); inline;
    procedure setCNSTATB14(thebits : TBits_1); inline;
    procedure setCNSTATB15(thebits : TBits_1); inline;
    procedure setCNSTATB2(thebits : TBits_1); inline;
    procedure setCNSTATB3(thebits : TBits_1); inline;
    procedure setCNSTATB4(thebits : TBits_1); inline;
    procedure setCNSTATB5(thebits : TBits_1); inline;
    procedure setCNSTATB7(thebits : TBits_1); inline;
    procedure setCNSTATB8(thebits : TBits_1); inline;
    procedure setCNSTATB9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNSTATB0; inline;
    procedure clearCNSTATB10; inline;
    procedure clearCNSTATB11; inline;
    procedure clearCNSTATB13; inline;
    procedure clearCNSTATB14; inline;
    procedure clearCNSTATB15; inline;
    procedure clearCNSTATB1; inline;
    procedure clearCNSTATB2; inline;
    procedure clearCNSTATB3; inline;
    procedure clearCNSTATB4; inline;
    procedure clearCNSTATB5; inline;
    procedure clearCNSTATB7; inline;
    procedure clearCNSTATB8; inline;
    procedure clearCNSTATB9; inline;
    procedure setCNSTATB0; inline;
    procedure setCNSTATB10; inline;
    procedure setCNSTATB11; inline;
    procedure setCNSTATB13; inline;
    procedure setCNSTATB14; inline;
    procedure setCNSTATB15; inline;
    procedure setCNSTATB1; inline;
    procedure setCNSTATB2; inline;
    procedure setCNSTATB3; inline;
    procedure setCNSTATB4; inline;
    procedure setCNSTATB5; inline;
    procedure setCNSTATB7; inline;
    procedure setCNSTATB8; inline;
    procedure setCNSTATB9; inline;
    property CNSTATB0 : TBits_1 read getCNSTATB0 write setCNSTATB0;
    property CNSTATB1 : TBits_1 read getCNSTATB1 write setCNSTATB1;
    property CNSTATB10 : TBits_1 read getCNSTATB10 write setCNSTATB10;
    property CNSTATB11 : TBits_1 read getCNSTATB11 write setCNSTATB11;
    property CNSTATB13 : TBits_1 read getCNSTATB13 write setCNSTATB13;
    property CNSTATB14 : TBits_1 read getCNSTATB14 write setCNSTATB14;
    property CNSTATB15 : TBits_1 read getCNSTATB15 write setCNSTATB15;
    property CNSTATB2 : TBits_1 read getCNSTATB2 write setCNSTATB2;
    property CNSTATB3 : TBits_1 read getCNSTATB3 write setCNSTATB3;
    property CNSTATB4 : TBits_1 read getCNSTATB4 write setCNSTATB4;
    property CNSTATB5 : TBits_1 read getCNSTATB5 write setCNSTATB5;
    property CNSTATB7 : TBits_1 read getCNSTATB7 write setCNSTATB7;
    property CNSTATB8 : TBits_1 read getCNSTATB8 write setCNSTATB8;
    property CNSTATB9 : TBits_1 read getCNSTATB9 write setCNSTATB9;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTBRegisters = record
    ANSELBbits : TPORTB_ANSELB;
    ANSELB : longWord;
    ANSELBCLR : longWord;
    ANSELBSET : longWord;
    ANSELBINV : longWord;
    TRISBbits : TPORTB_TRISB;
    TRISB : longWord;
    TRISBCLR : longWord;
    TRISBSET : longWord;
    TRISBINV : longWord;
    PORTBbits : TPORTB_PORTB;
    PORTB : longWord;
    PORTBCLR : longWord;
    PORTBSET : longWord;
    PORTBINV : longWord;
    LATBbits : TPORTB_LATB;
    LATB : longWord;
    LATBCLR : longWord;
    LATBSET : longWord;
    LATBINV : longWord;
    ODCBbits : TPORTB_ODCB;
    ODCB : longWord;
    ODCBCLR : longWord;
    ODCBSET : longWord;
    ODCBINV : longWord;
    CNPUBbits : TPORTB_CNPUB;
    CNPUB : longWord;
    CNPUBCLR : longWord;
    CNPUBSET : longWord;
    CNPUBINV : longWord;
    CNPDBbits : TPORTB_CNPDB;
    CNPDB : longWord;
    CNPDBCLR : longWord;
    CNPDBSET : longWord;
    CNPDBINV : longWord;
    CNCONBbits : TPORTB_CNCONB;
    CNCONB : longWord;
    CNCONBCLR : longWord;
    CNCONBSET : longWord;
    CNCONBINV : longWord;
    CNENBbits : TPORTB_CNENB;
    CNENB : longWord;
    CNENBCLR : longWord;
    CNENBSET : longWord;
    CNENBINV : longWord;
    CNSTATBbits : TPORTB_CNSTATB;
    CNSTATB : longWord;
    CNSTATBCLR : longWord;
    CNSTATBSET : longWord;
    CNSTATBINV : longWord;
  end;
  TPORTC_ANSELC = record
  private
    function  getANSC0 : TBits_1; inline;
    function  getANSC1 : TBits_1; inline;
    function  getANSC3 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setANSC0(thebits : TBits_1); inline;
    procedure setANSC1(thebits : TBits_1); inline;
    procedure setANSC3(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearANSC0; inline;
    procedure clearANSC1; inline;
    procedure clearANSC3; inline;
    procedure setANSC0; inline;
    procedure setANSC1; inline;
    procedure setANSC3; inline;
    property ANSC0 : TBits_1 read getANSC0 write setANSC0;
    property ANSC1 : TBits_1 read getANSC1 write setANSC1;
    property ANSC3 : TBits_1 read getANSC3 write setANSC3;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_TRISC = record
  private
    function  getTRISC0 : TBits_1; inline;
    function  getTRISC1 : TBits_1; inline;
    function  getTRISC3 : TBits_1; inline;
    function  getTRISC9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setTRISC0(thebits : TBits_1); inline;
    procedure setTRISC1(thebits : TBits_1); inline;
    procedure setTRISC3(thebits : TBits_1); inline;
    procedure setTRISC9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearTRISC0; inline;
    procedure clearTRISC1; inline;
    procedure clearTRISC3; inline;
    procedure clearTRISC9; inline;
    procedure setTRISC0; inline;
    procedure setTRISC1; inline;
    procedure setTRISC3; inline;
    procedure setTRISC9; inline;
    property TRISC0 : TBits_1 read getTRISC0 write setTRISC0;
    property TRISC1 : TBits_1 read getTRISC1 write setTRISC1;
    property TRISC3 : TBits_1 read getTRISC3 write setTRISC3;
    property TRISC9 : TBits_1 read getTRISC9 write setTRISC9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_PORTC = record
  private
    function  getRC0 : TBits_1; inline;
    function  getRC1 : TBits_1; inline;
    function  getRC3 : TBits_1; inline;
    function  getRC9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setRC0(thebits : TBits_1); inline;
    procedure setRC1(thebits : TBits_1); inline;
    procedure setRC3(thebits : TBits_1); inline;
    procedure setRC9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearRC0; inline;
    procedure clearRC1; inline;
    procedure clearRC3; inline;
    procedure clearRC9; inline;
    procedure setRC0; inline;
    procedure setRC1; inline;
    procedure setRC3; inline;
    procedure setRC9; inline;
    property RC0 : TBits_1 read getRC0 write setRC0;
    property RC1 : TBits_1 read getRC1 write setRC1;
    property RC3 : TBits_1 read getRC3 write setRC3;
    property RC9 : TBits_1 read getRC9 write setRC9;
    property w : TBits_32 read getw write setw;
  end;
  TPortC_bits=(RC0=0,RC1=1,RC3=3,RC9=9);
  TPortC_bitset = set of TPortC_bits;
  TPORTC_LATC = record
  private
    function  getLATC0 : TBits_1; inline;
    function  getLATC1 : TBits_1; inline;
    function  getLATC3 : TBits_1; inline;
    function  getLATC9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setLATC0(thebits : TBits_1); inline;
    procedure setLATC1(thebits : TBits_1); inline;
    procedure setLATC3(thebits : TBits_1); inline;
    procedure setLATC9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearLATC0; inline;
    procedure clearLATC1; inline;
    procedure clearLATC3; inline;
    procedure clearLATC9; inline;
    procedure setLATC0; inline;
    procedure setLATC1; inline;
    procedure setLATC3; inline;
    procedure setLATC9; inline;
    property LATC0 : TBits_1 read getLATC0 write setLATC0;
    property LATC1 : TBits_1 read getLATC1 write setLATC1;
    property LATC3 : TBits_1 read getLATC3 write setLATC3;
    property LATC9 : TBits_1 read getLATC9 write setLATC9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_ODCC = record
  private
    function  getODCC9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setODCC9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearODCC9; inline;
    procedure setODCC9; inline;
    property ODCC9 : TBits_1 read getODCC9 write setODCC9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_CNPUC = record
  private
    function  getCNPUC0 : TBits_1; inline;
    function  getCNPUC1 : TBits_1; inline;
    function  getCNPUC3 : TBits_1; inline;
    function  getCNPUC9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPUC0(thebits : TBits_1); inline;
    procedure setCNPUC1(thebits : TBits_1); inline;
    procedure setCNPUC3(thebits : TBits_1); inline;
    procedure setCNPUC9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPUC0; inline;
    procedure clearCNPUC1; inline;
    procedure clearCNPUC3; inline;
    procedure clearCNPUC9; inline;
    procedure setCNPUC0; inline;
    procedure setCNPUC1; inline;
    procedure setCNPUC3; inline;
    procedure setCNPUC9; inline;
    property CNPUC0 : TBits_1 read getCNPUC0 write setCNPUC0;
    property CNPUC1 : TBits_1 read getCNPUC1 write setCNPUC1;
    property CNPUC3 : TBits_1 read getCNPUC3 write setCNPUC3;
    property CNPUC9 : TBits_1 read getCNPUC9 write setCNPUC9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_CNPDC = record
  private
    function  getCNPDC0 : TBits_1; inline;
    function  getCNPDC1 : TBits_1; inline;
    function  getCNPDC3 : TBits_1; inline;
    function  getCNPDC9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNPDC0(thebits : TBits_1); inline;
    procedure setCNPDC1(thebits : TBits_1); inline;
    procedure setCNPDC3(thebits : TBits_1); inline;
    procedure setCNPDC9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNPDC0; inline;
    procedure clearCNPDC1; inline;
    procedure clearCNPDC3; inline;
    procedure clearCNPDC9; inline;
    procedure setCNPDC0; inline;
    procedure setCNPDC1; inline;
    procedure setCNPDC3; inline;
    procedure setCNPDC9; inline;
    property CNPDC0 : TBits_1 read getCNPDC0 write setCNPDC0;
    property CNPDC1 : TBits_1 read getCNPDC1 write setCNPDC1;
    property CNPDC3 : TBits_1 read getCNPDC3 write setCNPDC3;
    property CNPDC9 : TBits_1 read getCNPDC9 write setCNPDC9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_CNCONC = record
  private
    function  getON : TBits_1; inline;
    function  getSIDL : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setON(thebits : TBits_1); inline;
    procedure setSIDL(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearON; inline;
    procedure clearSIDL; inline;
    procedure setON; inline;
    procedure setSIDL; inline;
    property ON : TBits_1 read getON write setON;
    property SIDL : TBits_1 read getSIDL write setSIDL;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_CNENC = record
  private
    function  getCNIEC0 : TBits_1; inline;
    function  getCNIEC1 : TBits_1; inline;
    function  getCNIEC3 : TBits_1; inline;
    function  getCNIEC9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNIEC0(thebits : TBits_1); inline;
    procedure setCNIEC1(thebits : TBits_1); inline;
    procedure setCNIEC3(thebits : TBits_1); inline;
    procedure setCNIEC9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNIEC0; inline;
    procedure clearCNIEC1; inline;
    procedure clearCNIEC3; inline;
    procedure clearCNIEC9; inline;
    procedure setCNIEC0; inline;
    procedure setCNIEC1; inline;
    procedure setCNIEC3; inline;
    procedure setCNIEC9; inline;
    property CNIEC0 : TBits_1 read getCNIEC0 write setCNIEC0;
    property CNIEC1 : TBits_1 read getCNIEC1 write setCNIEC1;
    property CNIEC3 : TBits_1 read getCNIEC3 write setCNIEC3;
    property CNIEC9 : TBits_1 read getCNIEC9 write setCNIEC9;
    property w : TBits_32 read getw write setw;
  end;
  TPORTC_CNSTATC = record
  private
    function  getCNSTATC0 : TBits_1; inline;
    function  getCNSTATC1 : TBits_1; inline;
    function  getCNSTATC3 : TBits_1; inline;
    function  getCNSTATC9 : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setCNSTATC0(thebits : TBits_1); inline;
    procedure setCNSTATC1(thebits : TBits_1); inline;
    procedure setCNSTATC3(thebits : TBits_1); inline;
    procedure setCNSTATC9(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearCNSTATC0; inline;
    procedure clearCNSTATC1; inline;
    procedure clearCNSTATC3; inline;
    procedure clearCNSTATC9; inline;
    procedure setCNSTATC0; inline;
    procedure setCNSTATC1; inline;
    procedure setCNSTATC3; inline;
    procedure setCNSTATC9; inline;
    property CNSTATC0 : TBits_1 read getCNSTATC0 write setCNSTATC0;
    property CNSTATC1 : TBits_1 read getCNSTATC1 write setCNSTATC1;
    property CNSTATC3 : TBits_1 read getCNSTATC3 write setCNSTATC3;
    property CNSTATC9 : TBits_1 read getCNSTATC9 write setCNSTATC9;
    property w : TBits_32 read getw write setw;
  end;
type
  TPORTCRegisters = record
    ANSELCbits : TPORTC_ANSELC;
    ANSELC : longWord;
    ANSELCCLR : longWord;
    ANSELCSET : longWord;
    ANSELCINV : longWord;
    TRISCbits : TPORTC_TRISC;
    TRISC : longWord;
    TRISCCLR : longWord;
    TRISCSET : longWord;
    TRISCINV : longWord;
    PORTCbits : TPORTC_PORTC;
    PORTC : longWord;
    PORTCCLR : longWord;
    PORTCSET : longWord;
    PORTCINV : longWord;
    LATCbits : TPORTC_LATC;
    LATC : longWord;
    LATCCLR : longWord;
    LATCSET : longWord;
    LATCINV : longWord;
    ODCCbits : TPORTC_ODCC;
    ODCC : longWord;
    ODCCCLR : longWord;
    ODCCSET : longWord;
    ODCCINV : longWord;
    CNPUCbits : TPORTC_CNPUC;
    CNPUC : longWord;
    CNPUCCLR : longWord;
    CNPUCSET : longWord;
    CNPUCINV : longWord;
    CNPDCbits : TPORTC_CNPDC;
    CNPDC : longWord;
    CNPDCCLR : longWord;
    CNPDCSET : longWord;
    CNPDCINV : longWord;
    CNCONCbits : TPORTC_CNCONC;
    CNCONC : longWord;
    CNCONCCLR : longWord;
    CNCONCSET : longWord;
    CNCONCINV : longWord;
    CNENCbits : TPORTC_CNENC;
    CNENC : longWord;
    CNENCCLR : longWord;
    CNENCSET : longWord;
    CNENCINV : longWord;
    CNSTATCbits : TPORTC_CNSTATC;
    CNSTATC : longWord;
    CNSTATCCLR : longWord;
    CNSTATCSET : longWord;
    CNSTATCINV : longWord;
  end;
  TDEVCFG_DEVCFG3 = record
  private
    function  getFUSBIDIO : TBits_1; inline;
    function  getFVBUSONIO : TBits_1; inline;
    function  getIOL1WAY : TBits_1; inline;
    function  getPMDL1WAY : TBits_1; inline;
    function  getUSERID : TBits_16; inline;
    function  getw : TBits_32; inline;
    procedure setFUSBIDIO(thebits : TBits_1); inline;
    procedure setFVBUSONIO(thebits : TBits_1); inline;
    procedure setIOL1WAY(thebits : TBits_1); inline;
    procedure setPMDL1WAY(thebits : TBits_1); inline;
    procedure setUSERID(thebits : TBits_16); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFUSBIDIO; inline;
    procedure clearFVBUSONIO; inline;
    procedure clearIOL1WAY; inline;
    procedure clearPMDL1WAY; inline;
    procedure setFUSBIDIO; inline;
    procedure setFVBUSONIO; inline;
    procedure setIOL1WAY; inline;
    procedure setPMDL1WAY; inline;
    property FUSBIDIO : TBits_1 read getFUSBIDIO write setFUSBIDIO;
    property FVBUSONIO : TBits_1 read getFVBUSONIO write setFVBUSONIO;
    property IOL1WAY : TBits_1 read getIOL1WAY write setIOL1WAY;
    property PMDL1WAY : TBits_1 read getPMDL1WAY write setPMDL1WAY;
    property USERID : TBits_16 read getUSERID write setUSERID;
    property w : TBits_32 read getw write setw;
  end;
  TDEVCFG_DEVCFG2 = record
  private
    function  getFPLLIDIV : TBits_3; inline;
    function  getFPLLMUL : TBits_3; inline;
    function  getFPLLODIV : TBits_3; inline;
    function  getUPLLEN : TBits_1; inline;
    function  getUPLLIDIV : TBits_3; inline;
    function  getw : TBits_32; inline;
    procedure setFPLLIDIV(thebits : TBits_3); inline;
    procedure setFPLLMUL(thebits : TBits_3); inline;
    procedure setFPLLODIV(thebits : TBits_3); inline;
    procedure setUPLLEN(thebits : TBits_1); inline;
    procedure setUPLLIDIV(thebits : TBits_3); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearUPLLEN; inline;
    procedure setUPLLEN; inline;
    property FPLLIDIV : TBits_3 read getFPLLIDIV write setFPLLIDIV;
    property FPLLMUL : TBits_3 read getFPLLMUL write setFPLLMUL;
    property FPLLODIV : TBits_3 read getFPLLODIV write setFPLLODIV;
    property UPLLEN : TBits_1 read getUPLLEN write setUPLLEN;
    property UPLLIDIV : TBits_3 read getUPLLIDIV write setUPLLIDIV;
    property w : TBits_32 read getw write setw;
  end;
  TDEVCFG_DEVCFG1 = record
  private
    function  getFCKSM : TBits_2; inline;
    function  getFNOSC : TBits_3; inline;
    function  getFPBDIV : TBits_2; inline;
    function  getFSOSCEN : TBits_1; inline;
    function  getFWDTEN : TBits_1; inline;
    function  getFWDTWINSZ : TBits_2; inline;
    function  getIESO : TBits_1; inline;
    function  getOSCIOFNC : TBits_1; inline;
    function  getPOSCMOD : TBits_2; inline;
    function  getWDTPS : TBits_5; inline;
    function  getWINDIS : TBits_1; inline;
    function  getw : TBits_32; inline;
    procedure setFCKSM(thebits : TBits_2); inline;
    procedure setFNOSC(thebits : TBits_3); inline;
    procedure setFPBDIV(thebits : TBits_2); inline;
    procedure setFSOSCEN(thebits : TBits_1); inline;
    procedure setFWDTEN(thebits : TBits_1); inline;
    procedure setFWDTWINSZ(thebits : TBits_2); inline;
    procedure setIESO(thebits : TBits_1); inline;
    procedure setOSCIOFNC(thebits : TBits_1); inline;
    procedure setPOSCMOD(thebits : TBits_2); inline;
    procedure setWDTPS(thebits : TBits_5); inline;
    procedure setWINDIS(thebits : TBits_1); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearFSOSCEN; inline;
    procedure clearFWDTEN; inline;
    procedure clearIESO; inline;
    procedure clearOSCIOFNC; inline;
    procedure clearWINDIS; inline;
    procedure setFSOSCEN; inline;
    procedure setFWDTEN; inline;
    procedure setIESO; inline;
    procedure setOSCIOFNC; inline;
    procedure setWINDIS; inline;
    property FCKSM : TBits_2 read getFCKSM write setFCKSM;
    property FNOSC : TBits_3 read getFNOSC write setFNOSC;
    property FPBDIV : TBits_2 read getFPBDIV write setFPBDIV;
    property FSOSCEN : TBits_1 read getFSOSCEN write setFSOSCEN;
    property FWDTEN : TBits_1 read getFWDTEN write setFWDTEN;
    property FWDTWINSZ : TBits_2 read getFWDTWINSZ write setFWDTWINSZ;
    property IESO : TBits_1 read getIESO write setIESO;
    property OSCIOFNC : TBits_1 read getOSCIOFNC write setOSCIOFNC;
    property POSCMOD : TBits_2 read getPOSCMOD write setPOSCMOD;
    property WDTPS : TBits_5 read getWDTPS write setWDTPS;
    property WINDIS : TBits_1 read getWINDIS write setWINDIS;
    property w : TBits_32 read getw write setw;
  end;
  TDEVCFG_DEVCFG0 = record
  private
    function  getBWP : TBits_1; inline;
    function  getCP : TBits_1; inline;
    function  getDEBUG : TBits_2; inline;
    function  getFDEBUG : TBits_2; inline;
    function  getICESEL : TBits_2; inline;
    function  getJTAGEN : TBits_1; inline;
    function  getPWP : TBits_6; inline;
    function  getw : TBits_32; inline;
    procedure setBWP(thebits : TBits_1); inline;
    procedure setCP(thebits : TBits_1); inline;
    procedure setDEBUG(thebits : TBits_2); inline;
    procedure setFDEBUG(thebits : TBits_2); inline;
    procedure setICESEL(thebits : TBits_2); inline;
    procedure setJTAGEN(thebits : TBits_1); inline;
    procedure setPWP(thebits : TBits_6); inline;
    procedure setw(thebits : TBits_32); inline;
  public
    procedure clearBWP; inline;
    procedure clearCP; inline;
    procedure clearJTAGEN; inline;
    procedure setBWP; inline;
    procedure setCP; inline;
    procedure setJTAGEN; inline;
    property BWP : TBits_1 read getBWP write setBWP;
    property CP : TBits_1 read getCP write setCP;
    property DEBUG : TBits_2 read getDEBUG write setDEBUG;
    property FDEBUG : TBits_2 read getFDEBUG write setFDEBUG;
    property ICESEL : TBits_2 read getICESEL write setICESEL;
    property JTAGEN : TBits_1 read getJTAGEN write setJTAGEN;
    property PWP : TBits_6 read getPWP write setPWP;
    property w : TBits_32 read getw write setw;
  end;
const
  _CORE_TIMER_IRQ = 0;
  _CORE_SOFTWARE_0_IRQ = 1;
  _CORE_SOFTWARE_1_IRQ = 2;
  _EXTERNAL_0_IRQ = 3;
  _TIMER_1_IRQ = 4;
  _INPUT_CAPTURE_ERROR_1_IRQ = 5;
  _INPUT_CAPTURE_1_IRQ = 6;
  _OUTPUT_COMPARE_1_IRQ = 7;
  _EXTERNAL_1_IRQ = 8;
  _TIMER_2_IRQ = 9;
  _INPUT_CAPTURE_ERROR_2_IRQ = 10;
  _INPUT_CAPTURE_2_IRQ = 11;
  _OUTPUT_COMPARE_2_IRQ = 12;
  _EXTERNAL_2_IRQ = 13;
  _TIMER_3_IRQ = 14;
  _INPUT_CAPTURE_ERROR_3_IRQ = 15;
  _INPUT_CAPTURE_3_IRQ = 16;
  _OUTPUT_COMPARE_3_IRQ = 17;
  _EXTERNAL_3_IRQ = 18;
  _TIMER_4_IRQ = 19;
  _INPUT_CAPTURE_ERROR_4_IRQ = 20;
  _INPUT_CAPTURE_4_IRQ = 21;
  _OUTPUT_COMPARE_4_IRQ = 22;
  _EXTERNAL_4_IRQ = 23;
  _TIMER_5_IRQ = 24;
  _INPUT_CAPTURE_ERROR_5_IRQ = 25;
  _INPUT_CAPTURE_5_IRQ = 26;
  _OUTPUT_COMPARE_5_IRQ = 27;
  _ADC_IRQ = 28;
  _FAIL_SAFE_MONITOR_IRQ = 29;
  _RTCC_IRQ = 30;
  _FLASH_CONTROL_IRQ = 31;
  _COMPARATOR_1_IRQ = 32;
  _COMPARATOR_2_IRQ = 33;
  _COMPARATOR_3_IRQ = 34;
  _USB_IRQ = 35;
  _SPI1_ERR_IRQ = 36;
  _SPI1_RX_IRQ = 37;
  _SPI1_TX_IRQ = 38;
  _UART1_ERR_IRQ = 39;
  _UART1_RX_IRQ = 40;
  _UART1_TX_IRQ = 41;
  _I2C1_BUS_IRQ = 42;
  _I2C1_SLAVE_IRQ = 43;
  _I2C1_MASTER_IRQ = 44;
  _CHANGE_NOTICE_A_IRQ = 45;
  _CHANGE_NOTICE_B_IRQ = 46;
  _CHANGE_NOTICE_C_IRQ = 47;
  _PMP_IRQ = 48;
  _PMP_ERROR_IRQ = 49;
  _SPI2_ERR_IRQ = 50;
  _SPI2_RX_IRQ = 51;
  _SPI2_TX_IRQ = 52;
  _UART2_ERR_IRQ = 53;
  _UART2_RX_IRQ = 54;
  _UART2_TX_IRQ = 55;
  _I2C2_BUS_IRQ = 56;
  _I2C2_SLAVE_IRQ = 57;
  _I2C2_MASTER_IRQ = 58;
  _CTMU_IRQ = 59;
  _DMA0_IRQ = 60;
  _DMA1_IRQ = 61;
  _DMA2_IRQ = 62;
  _DMA3_IRQ = 63;
const
  ADC10_BASE_ADDRESS = $BF809000;
var
  ADC10 : TADC10Registers absolute ADC10_BASE_ADDRESS;
const
  BMX_BASE_ADDRESS = $BF882000;
var
  BMX : TBMXRegisters absolute BMX_BASE_ADDRESS;
const
  CFG_BASE_ADDRESS = $BF80F200;
var
  CFG : TCFGRegisters absolute CFG_BASE_ADDRESS;
const
  CMP_BASE_ADDRESS = $BF80A000;
var
  CMP : TCMPRegisters absolute CMP_BASE_ADDRESS;
const
  CVR_BASE_ADDRESS = $BF809800;
var
  CVR : TCVRRegisters absolute CVR_BASE_ADDRESS;
const
  DMAC_BASE_ADDRESS = $BF883000;
var
  DMAC : TDMACRegisters absolute DMAC_BASE_ADDRESS;
const
  DMAC0_BASE_ADDRESS = $BF883060;
var
  DMAC0 : TDMAC0Registers absolute DMAC0_BASE_ADDRESS;
const
  DMAC1_BASE_ADDRESS = $BF883120;
var
  DMAC1 : TDMAC1Registers absolute DMAC1_BASE_ADDRESS;
const
  DMAC2_BASE_ADDRESS = $BF8831E0;
var
  DMAC2 : TDMAC2Registers absolute DMAC2_BASE_ADDRESS;
const
  DMAC3_BASE_ADDRESS = $BF8832A0;
var
  DMAC3 : TDMAC3Registers absolute DMAC3_BASE_ADDRESS;
const
  I2C1_BASE_ADDRESS = $BF805000;
var
  I2C1 : TI2C1Registers absolute I2C1_BASE_ADDRESS;
const
  I2C2_BASE_ADDRESS = $BF805100;
var
  I2C2 : TI2C2Registers absolute I2C2_BASE_ADDRESS;
const
  ICAP1_BASE_ADDRESS = $BF802000;
var
  ICAP1 : TICAP1Registers absolute ICAP1_BASE_ADDRESS;
const
  ICAP2_BASE_ADDRESS = $BF802200;
var
  ICAP2 : TICAP2Registers absolute ICAP2_BASE_ADDRESS;
const
  ICAP3_BASE_ADDRESS = $BF802400;
var
  ICAP3 : TICAP3Registers absolute ICAP3_BASE_ADDRESS;
const
  ICAP4_BASE_ADDRESS = $BF802600;
var
  ICAP4 : TICAP4Registers absolute ICAP4_BASE_ADDRESS;
const
  ICAP5_BASE_ADDRESS = $BF802800;
var
  ICAP5 : TICAP5Registers absolute ICAP5_BASE_ADDRESS;
const
  INT_BASE_ADDRESS = $BF881000;
var
  INT : TINTRegisters absolute INT_BASE_ADDRESS;
const
  NVM_BASE_ADDRESS = $BF80F400;
var
  NVM : TNVMRegisters absolute NVM_BASE_ADDRESS;
const
  OCMP1_BASE_ADDRESS = $BF803000;
var
  OCMP1 : TOCMP1Registers absolute OCMP1_BASE_ADDRESS;
const
  OCMP2_BASE_ADDRESS = $BF803200;
var
  OCMP2 : TOCMP2Registers absolute OCMP2_BASE_ADDRESS;
const
  OCMP3_BASE_ADDRESS = $BF803400;
var
  OCMP3 : TOCMP3Registers absolute OCMP3_BASE_ADDRESS;
const
  OCMP4_BASE_ADDRESS = $BF803600;
var
  OCMP4 : TOCMP4Registers absolute OCMP4_BASE_ADDRESS;
const
  OCMP5_BASE_ADDRESS = $BF803800;
var
  OCMP5 : TOCMP5Registers absolute OCMP5_BASE_ADDRESS;
const
  OSC_BASE_ADDRESS = $BF80F000;
var
  OSC : TOSCRegisters absolute OSC_BASE_ADDRESS;
const
  PMP_BASE_ADDRESS = $BF807000;
var
  PMP : TPMPRegisters absolute PMP_BASE_ADDRESS;
const
  PORTA_BASE_ADDRESS = $BF886000;
var
  PORTA : TPORTARegisters absolute PORTA_BASE_ADDRESS;
const
  PORTB_BASE_ADDRESS = $BF886100;
var
  PORTB : TPORTBRegisters absolute PORTB_BASE_ADDRESS;
const
  PORTC_BASE_ADDRESS = $BF886200;
var
  PORTC : TPORTCRegisters absolute PORTC_BASE_ADDRESS;
const
  RCON_BASE_ADDRESS = $BF80F600;
var
  RCON : TRCONRegisters absolute RCON_BASE_ADDRESS;
const
  RTCC_BASE_ADDRESS = $BF800200;
var
  RTCC : TRTCCRegisters absolute RTCC_BASE_ADDRESS;
const
  SPI1_BASE_ADDRESS = $BF805800;
var
  SPI1 : TSPI1Registers absolute SPI1_BASE_ADDRESS;
const
  SPI2_BASE_ADDRESS = $BF805A00;
var
  SPI2 : TSPI2Registers absolute SPI2_BASE_ADDRESS;
const
  TMR1_BASE_ADDRESS = $BF800600;
var
  TMR1 : TTMR1Registers absolute TMR1_BASE_ADDRESS;
const
  TMR2_BASE_ADDRESS = $BF800800;
var
  TMR2 : TTMR2Registers absolute TMR2_BASE_ADDRESS;
const
  TMR3_BASE_ADDRESS = $BF800A00;
var
  TMR3 : TTMR3Registers absolute TMR3_BASE_ADDRESS;
const
  TMR4_BASE_ADDRESS = $BF800C00;
var
  TMR4 : TTMR4Registers absolute TMR4_BASE_ADDRESS;
const
  TMR5_BASE_ADDRESS = $BF800E00;
var
  TMR5 : TTMR5Registers absolute TMR5_BASE_ADDRESS;
const
  UART1_BASE_ADDRESS = $BF806000;
var
  UART1 : TUART1Registers absolute UART1_BASE_ADDRESS;
const
  UART2_BASE_ADDRESS = $BF806200;
var
  UART2 : TUART2Registers absolute UART2_BASE_ADDRESS;
const
  USB_BASE_ADDRESS = $BF885040;
var
  USB : TUSBRegisters absolute USB_BASE_ADDRESS;
const
  WDT_BASE_ADDRESS = $BF800000;
var
  WDT : TWDTRegisters absolute WDT_BASE_ADDRESS;
implementation
type
  TDefRegMap = record
    val : longWord;
    clr : longWord;
    &set : longWord;
    inv : longWord;
  end;

  pTDefRegMap = ^TDefRegMap;

procedure TWDT_WDTCON.setWDTCLR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TWDT_WDTCON.clearWDTCLR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TWDT_WDTCON.setWDTCLR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TWDT_WDTCON.getWDTCLR : TBits_1; inline;
begin
  getWDTCLR := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TWDT_WDTCON.setWDTWINEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TWDT_WDTCON.clearWDTWINEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TWDT_WDTCON.setWDTWINEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TWDT_WDTCON.getWDTWINEN : TBits_1; inline;
begin
  getWDTWINEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TWDT_WDTCON.setSWDTPS(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF83 or ( thebits shl 2 );
end;
function  TWDT_WDTCON.getSWDTPS : TBits_5; inline;
begin
  getSWDTPS := (pTDefRegMap(@Self)^.val and $0000007C) shr 2;
end;
procedure TWDT_WDTCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TWDT_WDTCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TWDT_WDTCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TWDT_WDTCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TWDT_WDTCON.setSWDTPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TWDT_WDTCON.clearSWDTPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TWDT_WDTCON.setSWDTPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TWDT_WDTCON.getSWDTPS0 : TBits_1; inline;
begin
  getSWDTPS0 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TWDT_WDTCON.setSWDTPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TWDT_WDTCON.clearSWDTPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TWDT_WDTCON.setSWDTPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TWDT_WDTCON.getSWDTPS1 : TBits_1; inline;
begin
  getSWDTPS1 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TWDT_WDTCON.setSWDTPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TWDT_WDTCON.clearSWDTPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TWDT_WDTCON.setSWDTPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TWDT_WDTCON.getSWDTPS2 : TBits_1; inline;
begin
  getSWDTPS2 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TWDT_WDTCON.setSWDTPS3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TWDT_WDTCON.clearSWDTPS3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TWDT_WDTCON.setSWDTPS3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TWDT_WDTCON.getSWDTPS3 : TBits_1; inline;
begin
  getSWDTPS3 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TWDT_WDTCON.setSWDTPS4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TWDT_WDTCON.clearSWDTPS4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TWDT_WDTCON.setSWDTPS4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TWDT_WDTCON.getSWDTPS4 : TBits_1; inline;
begin
  getSWDTPS4 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TWDT_WDTCON.setWDTPSTA(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF83 or ( thebits shl 2 );
end;
function  TWDT_WDTCON.getWDTPSTA : TBits_5; inline;
begin
  getWDTPSTA := (pTDefRegMap(@Self)^.val and $0000007C) shr 2;
end;
procedure TWDT_WDTCON.setWDTPS(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF83 or ( thebits shl 2 );
end;
function  TWDT_WDTCON.getWDTPS : TBits_5; inline;
begin
  getWDTPS := (pTDefRegMap(@Self)^.val and $0000007C) shr 2;
end;
procedure TWDT_WDTCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TWDT_WDTCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_RTCCON.setRTCOE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TRTCC_RTCCON.clearRTCOE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TRTCC_RTCCON.setRTCOE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TRTCC_RTCCON.getRTCOE : TBits_1; inline;
begin
  getRTCOE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TRTCC_RTCCON.setHALFSEC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TRTCC_RTCCON.clearHALFSEC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TRTCC_RTCCON.setHALFSEC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TRTCC_RTCCON.getHALFSEC : TBits_1; inline;
begin
  getHALFSEC := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TRTCC_RTCCON.setRTCSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TRTCC_RTCCON.clearRTCSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TRTCC_RTCCON.setRTCSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TRTCC_RTCCON.getRTCSYNC : TBits_1; inline;
begin
  getRTCSYNC := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TRTCC_RTCCON.setRTCWREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TRTCC_RTCCON.clearRTCWREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TRTCC_RTCCON.setRTCWREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TRTCC_RTCCON.getRTCWREN : TBits_1; inline;
begin
  getRTCWREN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TRTCC_RTCCON.setRTCCLKON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TRTCC_RTCCON.clearRTCCLKON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TRTCC_RTCCON.setRTCCLKON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TRTCC_RTCCON.getRTCCLKON : TBits_1; inline;
begin
  getRTCCLKON := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TRTCC_RTCCON.setRTSECSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TRTCC_RTCCON.clearRTSECSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TRTCC_RTCCON.setRTSECSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TRTCC_RTCCON.getRTSECSEL : TBits_1; inline;
begin
  getRTSECSEL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TRTCC_RTCCON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TRTCC_RTCCON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TRTCC_RTCCON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TRTCC_RTCCON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TRTCC_RTCCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TRTCC_RTCCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TRTCC_RTCCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TRTCC_RTCCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TRTCC_RTCCON.setCAL(thebits : TBits_10); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FC00FFFF or ( thebits shl 16 );
end;
function  TRTCC_RTCCON.getCAL : TBits_10; inline;
begin
  getCAL := (pTDefRegMap(@Self)^.val and $03FF0000) shr 16;
end;
procedure TRTCC_RTCCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_RTCCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_RTCALRM.setARPT(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF00 or ( thebits shl 0 );
end;
function  TRTCC_RTCALRM.getARPT : TBits_8; inline;
begin
  getARPT := (pTDefRegMap(@Self)^.val and $000000FF) shr 0;
end;
procedure TRTCC_RTCALRM.setAMASK(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_RTCALRM.getAMASK : TBits_4; inline;
begin
  getAMASK := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_RTCALRM.setALRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TRTCC_RTCALRM.clearALRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TRTCC_RTCALRM.setALRMSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TRTCC_RTCALRM.getALRMSYNC : TBits_1; inline;
begin
  getALRMSYNC := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TRTCC_RTCALRM.setPIV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TRTCC_RTCALRM.clearPIV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TRTCC_RTCALRM.setPIV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TRTCC_RTCALRM.getPIV : TBits_1; inline;
begin
  getPIV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TRTCC_RTCALRM.setCHIME; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TRTCC_RTCALRM.clearCHIME; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TRTCC_RTCALRM.setCHIME(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TRTCC_RTCALRM.getCHIME : TBits_1; inline;
begin
  getCHIME := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TRTCC_RTCALRM.setALRMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TRTCC_RTCALRM.clearALRMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TRTCC_RTCALRM.setALRMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TRTCC_RTCALRM.getALRMEN : TBits_1; inline;
begin
  getALRMEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TRTCC_RTCALRM.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_RTCALRM.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_RTCTIME.setSEC01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_RTCTIME.getSEC01 : TBits_4; inline;
begin
  getSEC01 := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_RTCTIME.setSEC10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0FFF or ( thebits shl 12 );
end;
function  TRTCC_RTCTIME.getSEC10 : TBits_4; inline;
begin
  getSEC10 := (pTDefRegMap(@Self)^.val and $0000F000) shr 12;
end;
procedure TRTCC_RTCTIME.setMIN01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TRTCC_RTCTIME.getMIN01 : TBits_4; inline;
begin
  getMIN01 := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TRTCC_RTCTIME.setMIN10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF0FFFFF or ( thebits shl 20 );
end;
function  TRTCC_RTCTIME.getMIN10 : TBits_4; inline;
begin
  getMIN10 := (pTDefRegMap(@Self)^.val and $00F00000) shr 20;
end;
procedure TRTCC_RTCTIME.setHR01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F0FFFFFF or ( thebits shl 24 );
end;
function  TRTCC_RTCTIME.getHR01 : TBits_4; inline;
begin
  getHR01 := (pTDefRegMap(@Self)^.val and $0F000000) shr 24;
end;
procedure TRTCC_RTCTIME.setHR10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $0FFFFFFF or ( thebits shl 28 );
end;
function  TRTCC_RTCTIME.getHR10 : TBits_4; inline;
begin
  getHR10 := (pTDefRegMap(@Self)^.val and $F0000000) shr 28;
end;
procedure TRTCC_RTCTIME.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_RTCTIME.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_RTCDATE.setWDAY01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TRTCC_RTCDATE.getWDAY01 : TBits_4; inline;
begin
  getWDAY01 := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TRTCC_RTCDATE.setDAY01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_RTCDATE.getDAY01 : TBits_4; inline;
begin
  getDAY01 := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_RTCDATE.setDAY10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0FFF or ( thebits shl 12 );
end;
function  TRTCC_RTCDATE.getDAY10 : TBits_4; inline;
begin
  getDAY10 := (pTDefRegMap(@Self)^.val and $0000F000) shr 12;
end;
procedure TRTCC_RTCDATE.setMONTH01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TRTCC_RTCDATE.getMONTH01 : TBits_4; inline;
begin
  getMONTH01 := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TRTCC_RTCDATE.setMONTH10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF0FFFFF or ( thebits shl 20 );
end;
function  TRTCC_RTCDATE.getMONTH10 : TBits_4; inline;
begin
  getMONTH10 := (pTDefRegMap(@Self)^.val and $00F00000) shr 20;
end;
procedure TRTCC_RTCDATE.setYEAR01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F0FFFFFF or ( thebits shl 24 );
end;
function  TRTCC_RTCDATE.getYEAR01 : TBits_4; inline;
begin
  getYEAR01 := (pTDefRegMap(@Self)^.val and $0F000000) shr 24;
end;
procedure TRTCC_RTCDATE.setYEAR10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $0FFFFFFF or ( thebits shl 28 );
end;
function  TRTCC_RTCDATE.getYEAR10 : TBits_4; inline;
begin
  getYEAR10 := (pTDefRegMap(@Self)^.val and $F0000000) shr 28;
end;
procedure TRTCC_RTCDATE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_RTCDATE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_ALRMTIME.setSEC01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_ALRMTIME.getSEC01 : TBits_4; inline;
begin
  getSEC01 := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_ALRMTIME.setSEC10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0FFF or ( thebits shl 12 );
end;
function  TRTCC_ALRMTIME.getSEC10 : TBits_4; inline;
begin
  getSEC10 := (pTDefRegMap(@Self)^.val and $0000F000) shr 12;
end;
procedure TRTCC_ALRMTIME.setMIN01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TRTCC_ALRMTIME.getMIN01 : TBits_4; inline;
begin
  getMIN01 := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TRTCC_ALRMTIME.setMIN10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF0FFFFF or ( thebits shl 20 );
end;
function  TRTCC_ALRMTIME.getMIN10 : TBits_4; inline;
begin
  getMIN10 := (pTDefRegMap(@Self)^.val and $00F00000) shr 20;
end;
procedure TRTCC_ALRMTIME.setHR01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F0FFFFFF or ( thebits shl 24 );
end;
function  TRTCC_ALRMTIME.getHR01 : TBits_4; inline;
begin
  getHR01 := (pTDefRegMap(@Self)^.val and $0F000000) shr 24;
end;
procedure TRTCC_ALRMTIME.setHR10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $0FFFFFFF or ( thebits shl 28 );
end;
function  TRTCC_ALRMTIME.getHR10 : TBits_4; inline;
begin
  getHR10 := (pTDefRegMap(@Self)^.val and $F0000000) shr 28;
end;
procedure TRTCC_ALRMTIME.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_ALRMTIME.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRTCC_ALRMDATE.setWDAY01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TRTCC_ALRMDATE.getWDAY01 : TBits_4; inline;
begin
  getWDAY01 := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TRTCC_ALRMDATE.setDAY01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF0FF or ( thebits shl 8 );
end;
function  TRTCC_ALRMDATE.getDAY01 : TBits_4; inline;
begin
  getDAY01 := (pTDefRegMap(@Self)^.val and $00000F00) shr 8;
end;
procedure TRTCC_ALRMDATE.setDAY10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0FFF or ( thebits shl 12 );
end;
function  TRTCC_ALRMDATE.getDAY10 : TBits_4; inline;
begin
  getDAY10 := (pTDefRegMap(@Self)^.val and $0000F000) shr 12;
end;
procedure TRTCC_ALRMDATE.setMONTH01(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TRTCC_ALRMDATE.getMONTH01 : TBits_4; inline;
begin
  getMONTH01 := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TRTCC_ALRMDATE.setMONTH10(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF0FFFFF or ( thebits shl 20 );
end;
function  TRTCC_ALRMDATE.getMONTH10 : TBits_4; inline;
begin
  getMONTH10 := (pTDefRegMap(@Self)^.val and $00F00000) shr 20;
end;
procedure TRTCC_ALRMDATE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRTCC_ALRMDATE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR1_T1CON.setTCS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TTMR1_T1CON.clearTCS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TTMR1_T1CON.setTCS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TTMR1_T1CON.getTCS : TBits_1; inline;
begin
  getTCS := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TTMR1_T1CON.setTSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TTMR1_T1CON.clearTSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TTMR1_T1CON.setTSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TTMR1_T1CON.getTSYNC : TBits_1; inline;
begin
  getTSYNC := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TTMR1_T1CON.setTCKPS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFCF or ( thebits shl 4 );
end;
function  TTMR1_T1CON.getTCKPS : TBits_2; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000030) shr 4;
end;
procedure TTMR1_T1CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR1_T1CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR1_T1CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR1_T1CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR1_T1CON.setTWIP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TTMR1_T1CON.clearTWIP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TTMR1_T1CON.setTWIP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TTMR1_T1CON.getTWIP : TBits_1; inline;
begin
  getTWIP := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TTMR1_T1CON.setTWDIS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TTMR1_T1CON.clearTWDIS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TTMR1_T1CON.setTWDIS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TTMR1_T1CON.getTWDIS : TBits_1; inline;
begin
  getTWDIS := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TTMR1_T1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR1_T1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR1_T1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR1_T1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR1_T1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR1_T1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR1_T1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR1_T1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR1_T1CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR1_T1CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR1_T1CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR1_T1CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR1_T1CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR1_T1CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR1_T1CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR1_T1CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR1_T1CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR1_T1CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR1_T1CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR1_T1CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR1_T1CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR1_T1CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR1_T1CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR1_T1CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR1_T1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR1_T1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR2_T2CON.setTCS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TTMR2_T2CON.clearTCS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TTMR2_T2CON.setTCS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TTMR2_T2CON.getTCS : TBits_1; inline;
begin
  getTCS := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TTMR2_T2CON.setT32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TTMR2_T2CON.clearT32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TTMR2_T2CON.setT32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TTMR2_T2CON.getT32 : TBits_1; inline;
begin
  getT32 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TTMR2_T2CON.setTCKPS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TTMR2_T2CON.getTCKPS : TBits_3; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TTMR2_T2CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR2_T2CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR2_T2CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR2_T2CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR2_T2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR2_T2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR2_T2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR2_T2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR2_T2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR2_T2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR2_T2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR2_T2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR2_T2CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR2_T2CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR2_T2CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR2_T2CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR2_T2CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR2_T2CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR2_T2CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR2_T2CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR2_T2CON.setTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TTMR2_T2CON.clearTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TTMR2_T2CON.setTCKPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TTMR2_T2CON.getTCKPS2 : TBits_1; inline;
begin
  getTCKPS2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TTMR2_T2CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR2_T2CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR2_T2CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR2_T2CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR2_T2CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR2_T2CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR2_T2CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR2_T2CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR2_T2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR2_T2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR3_T3CON.setTCS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TTMR3_T3CON.clearTCS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TTMR3_T3CON.setTCS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TTMR3_T3CON.getTCS : TBits_1; inline;
begin
  getTCS := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TTMR3_T3CON.setTCKPS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TTMR3_T3CON.getTCKPS : TBits_3; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TTMR3_T3CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR3_T3CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR3_T3CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR3_T3CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR3_T3CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR3_T3CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR3_T3CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR3_T3CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR3_T3CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR3_T3CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR3_T3CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR3_T3CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR3_T3CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR3_T3CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR3_T3CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR3_T3CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR3_T3CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR3_T3CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR3_T3CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR3_T3CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR3_T3CON.setTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TTMR3_T3CON.clearTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TTMR3_T3CON.setTCKPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TTMR3_T3CON.getTCKPS2 : TBits_1; inline;
begin
  getTCKPS2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TTMR3_T3CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR3_T3CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR3_T3CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR3_T3CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR3_T3CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR3_T3CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR3_T3CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR3_T3CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR3_T3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR3_T3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR4_T4CON.setTCS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TTMR4_T4CON.clearTCS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TTMR4_T4CON.setTCS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TTMR4_T4CON.getTCS : TBits_1; inline;
begin
  getTCS := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TTMR4_T4CON.setT32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TTMR4_T4CON.clearT32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TTMR4_T4CON.setT32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TTMR4_T4CON.getT32 : TBits_1; inline;
begin
  getT32 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TTMR4_T4CON.setTCKPS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TTMR4_T4CON.getTCKPS : TBits_3; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TTMR4_T4CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR4_T4CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR4_T4CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR4_T4CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR4_T4CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR4_T4CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR4_T4CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR4_T4CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR4_T4CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR4_T4CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR4_T4CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR4_T4CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR4_T4CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR4_T4CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR4_T4CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR4_T4CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR4_T4CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR4_T4CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR4_T4CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR4_T4CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR4_T4CON.setTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TTMR4_T4CON.clearTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TTMR4_T4CON.setTCKPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TTMR4_T4CON.getTCKPS2 : TBits_1; inline;
begin
  getTCKPS2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TTMR4_T4CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR4_T4CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR4_T4CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR4_T4CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR4_T4CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR4_T4CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR4_T4CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR4_T4CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR4_T4CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR4_T4CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TTMR5_T5CON.setTCS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TTMR5_T5CON.clearTCS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TTMR5_T5CON.setTCS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TTMR5_T5CON.getTCS : TBits_1; inline;
begin
  getTCS := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TTMR5_T5CON.setTCKPS(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TTMR5_T5CON.getTCKPS : TBits_3; inline;
begin
  getTCKPS := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TTMR5_T5CON.setTGATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TTMR5_T5CON.clearTGATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TTMR5_T5CON.setTGATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TTMR5_T5CON.getTGATE : TBits_1; inline;
begin
  getTGATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TTMR5_T5CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR5_T5CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR5_T5CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR5_T5CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR5_T5CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR5_T5CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR5_T5CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR5_T5CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR5_T5CON.setTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TTMR5_T5CON.clearTCKPS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TTMR5_T5CON.setTCKPS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TTMR5_T5CON.getTCKPS0 : TBits_1; inline;
begin
  getTCKPS0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TTMR5_T5CON.setTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TTMR5_T5CON.clearTCKPS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TTMR5_T5CON.setTCKPS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TTMR5_T5CON.getTCKPS1 : TBits_1; inline;
begin
  getTCKPS1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TTMR5_T5CON.setTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TTMR5_T5CON.clearTCKPS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TTMR5_T5CON.setTCKPS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TTMR5_T5CON.getTCKPS2 : TBits_1; inline;
begin
  getTCKPS2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TTMR5_T5CON.setTSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TTMR5_T5CON.clearTSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TTMR5_T5CON.setTSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TTMR5_T5CON.getTSIDL : TBits_1; inline;
begin
  getTSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TTMR5_T5CON.setTON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TTMR5_T5CON.clearTON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TTMR5_T5CON.setTON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TTMR5_T5CON.getTON : TBits_1; inline;
begin
  getTON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TTMR5_T5CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TTMR5_T5CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP1_IC1CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP1_IC1CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP1_IC1CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP1_IC1CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP1_IC1CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP1_IC1CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP1_IC1CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP1_IC1CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP1_IC1CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP1_IC1CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP1_IC1CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP1_IC1CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP1_IC1CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP1_IC1CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP1_IC1CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP1_IC1CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP1_IC1CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP1_IC1CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP1_IC1CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP1_IC1CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP1_IC1CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP1_IC1CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP1_IC1CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP1_IC1CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP1_IC1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP1_IC1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP1_IC1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP1_IC1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP1_IC1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP1_IC1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP1_IC1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP1_IC1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP1_IC1CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP1_IC1CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP1_IC1CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP1_IC1CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP1_IC1CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP1_IC1CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP1_IC1CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP1_IC1CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP1_IC1CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP1_IC1CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP1_IC1CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP1_IC1CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP1_IC1CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP1_IC1CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP1_IC1CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP1_IC1CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP1_IC1CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP1_IC1CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP1_IC1CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP1_IC1CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP1_IC1CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP1_IC1CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP1_IC1CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP1_IC1CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP1_IC1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP1_IC1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP2_IC2CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP2_IC2CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP2_IC2CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP2_IC2CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP2_IC2CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP2_IC2CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP2_IC2CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP2_IC2CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP2_IC2CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP2_IC2CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP2_IC2CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP2_IC2CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP2_IC2CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP2_IC2CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP2_IC2CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP2_IC2CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP2_IC2CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP2_IC2CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP2_IC2CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP2_IC2CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP2_IC2CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP2_IC2CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP2_IC2CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP2_IC2CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP2_IC2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP2_IC2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP2_IC2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP2_IC2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP2_IC2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP2_IC2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP2_IC2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP2_IC2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP2_IC2CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP2_IC2CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP2_IC2CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP2_IC2CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP2_IC2CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP2_IC2CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP2_IC2CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP2_IC2CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP2_IC2CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP2_IC2CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP2_IC2CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP2_IC2CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP2_IC2CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP2_IC2CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP2_IC2CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP2_IC2CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP2_IC2CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP2_IC2CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP2_IC2CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP2_IC2CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP2_IC2CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP2_IC2CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP2_IC2CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP2_IC2CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP2_IC2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP2_IC2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP3_IC3CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP3_IC3CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP3_IC3CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP3_IC3CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP3_IC3CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP3_IC3CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP3_IC3CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP3_IC3CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP3_IC3CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP3_IC3CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP3_IC3CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP3_IC3CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP3_IC3CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP3_IC3CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP3_IC3CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP3_IC3CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP3_IC3CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP3_IC3CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP3_IC3CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP3_IC3CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP3_IC3CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP3_IC3CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP3_IC3CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP3_IC3CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP3_IC3CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP3_IC3CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP3_IC3CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP3_IC3CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP3_IC3CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP3_IC3CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP3_IC3CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP3_IC3CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP3_IC3CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP3_IC3CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP3_IC3CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP3_IC3CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP3_IC3CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP3_IC3CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP3_IC3CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP3_IC3CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP3_IC3CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP3_IC3CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP3_IC3CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP3_IC3CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP3_IC3CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP3_IC3CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP3_IC3CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP3_IC3CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP3_IC3CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP3_IC3CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP3_IC3CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP3_IC3CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP3_IC3CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP3_IC3CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP3_IC3CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP3_IC3CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP3_IC3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP3_IC3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP4_IC4CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP4_IC4CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP4_IC4CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP4_IC4CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP4_IC4CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP4_IC4CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP4_IC4CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP4_IC4CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP4_IC4CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP4_IC4CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP4_IC4CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP4_IC4CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP4_IC4CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP4_IC4CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP4_IC4CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP4_IC4CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP4_IC4CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP4_IC4CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP4_IC4CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP4_IC4CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP4_IC4CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP4_IC4CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP4_IC4CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP4_IC4CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP4_IC4CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP4_IC4CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP4_IC4CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP4_IC4CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP4_IC4CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP4_IC4CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP4_IC4CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP4_IC4CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP4_IC4CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP4_IC4CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP4_IC4CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP4_IC4CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP4_IC4CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP4_IC4CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP4_IC4CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP4_IC4CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP4_IC4CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP4_IC4CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP4_IC4CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP4_IC4CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP4_IC4CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP4_IC4CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP4_IC4CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP4_IC4CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP4_IC4CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP4_IC4CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP4_IC4CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP4_IC4CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP4_IC4CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP4_IC4CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP4_IC4CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP4_IC4CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP4_IC4CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP4_IC4CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TICAP5_IC5CON.setICM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TICAP5_IC5CON.getICM : TBits_3; inline;
begin
  getICM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TICAP5_IC5CON.setICBNE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TICAP5_IC5CON.clearICBNE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TICAP5_IC5CON.setICBNE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TICAP5_IC5CON.getICBNE : TBits_1; inline;
begin
  getICBNE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TICAP5_IC5CON.setICOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TICAP5_IC5CON.clearICOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TICAP5_IC5CON.setICOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TICAP5_IC5CON.getICOV : TBits_1; inline;
begin
  getICOV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TICAP5_IC5CON.setICI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF9F or ( thebits shl 5 );
end;
function  TICAP5_IC5CON.getICI : TBits_2; inline;
begin
  getICI := (pTDefRegMap(@Self)^.val and $00000060) shr 5;
end;
procedure TICAP5_IC5CON.setICTMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TICAP5_IC5CON.clearICTMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TICAP5_IC5CON.setICTMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TICAP5_IC5CON.getICTMR : TBits_1; inline;
begin
  getICTMR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TICAP5_IC5CON.setC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TICAP5_IC5CON.clearC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TICAP5_IC5CON.setC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TICAP5_IC5CON.getC32 : TBits_1; inline;
begin
  getC32 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TICAP5_IC5CON.setFEDGE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TICAP5_IC5CON.clearFEDGE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TICAP5_IC5CON.setFEDGE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TICAP5_IC5CON.getFEDGE : TBits_1; inline;
begin
  getFEDGE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TICAP5_IC5CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP5_IC5CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP5_IC5CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP5_IC5CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP5_IC5CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TICAP5_IC5CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TICAP5_IC5CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TICAP5_IC5CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TICAP5_IC5CON.setICM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TICAP5_IC5CON.clearICM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TICAP5_IC5CON.setICM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TICAP5_IC5CON.getICM0 : TBits_1; inline;
begin
  getICM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TICAP5_IC5CON.setICM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TICAP5_IC5CON.clearICM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TICAP5_IC5CON.setICM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TICAP5_IC5CON.getICM1 : TBits_1; inline;
begin
  getICM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TICAP5_IC5CON.setICM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TICAP5_IC5CON.clearICM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TICAP5_IC5CON.setICM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TICAP5_IC5CON.getICM2 : TBits_1; inline;
begin
  getICM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TICAP5_IC5CON.setICI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TICAP5_IC5CON.clearICI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TICAP5_IC5CON.setICI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TICAP5_IC5CON.getICI0 : TBits_1; inline;
begin
  getICI0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TICAP5_IC5CON.setICI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TICAP5_IC5CON.clearICI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TICAP5_IC5CON.setICI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TICAP5_IC5CON.getICI1 : TBits_1; inline;
begin
  getICI1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TICAP5_IC5CON.setICSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TICAP5_IC5CON.clearICSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TICAP5_IC5CON.setICSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TICAP5_IC5CON.getICSIDL : TBits_1; inline;
begin
  getICSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TICAP5_IC5CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TICAP5_IC5CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP1_OC1CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP1_OC1CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP1_OC1CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP1_OC1CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP1_OC1CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP1_OC1CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP1_OC1CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP1_OC1CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP1_OC1CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP1_OC1CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP1_OC1CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP1_OC1CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP1_OC1CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP1_OC1CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP1_OC1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP1_OC1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP1_OC1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP1_OC1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP1_OC1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP1_OC1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP1_OC1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP1_OC1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP1_OC1CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP1_OC1CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP1_OC1CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP1_OC1CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP1_OC1CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP1_OC1CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP1_OC1CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP1_OC1CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP1_OC1CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP1_OC1CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP1_OC1CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP1_OC1CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP1_OC1CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP1_OC1CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP1_OC1CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP1_OC1CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP1_OC1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP1_OC1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP2_OC2CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP2_OC2CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP2_OC2CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP2_OC2CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP2_OC2CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP2_OC2CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP2_OC2CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP2_OC2CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP2_OC2CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP2_OC2CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP2_OC2CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP2_OC2CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP2_OC2CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP2_OC2CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP2_OC2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP2_OC2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP2_OC2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP2_OC2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP2_OC2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP2_OC2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP2_OC2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP2_OC2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP2_OC2CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP2_OC2CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP2_OC2CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP2_OC2CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP2_OC2CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP2_OC2CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP2_OC2CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP2_OC2CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP2_OC2CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP2_OC2CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP2_OC2CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP2_OC2CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP2_OC2CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP2_OC2CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP2_OC2CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP2_OC2CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP2_OC2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP2_OC2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP3_OC3CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP3_OC3CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP3_OC3CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP3_OC3CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP3_OC3CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP3_OC3CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP3_OC3CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP3_OC3CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP3_OC3CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP3_OC3CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP3_OC3CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP3_OC3CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP3_OC3CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP3_OC3CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP3_OC3CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP3_OC3CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP3_OC3CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP3_OC3CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP3_OC3CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP3_OC3CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP3_OC3CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP3_OC3CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP3_OC3CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP3_OC3CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP3_OC3CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP3_OC3CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP3_OC3CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP3_OC3CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP3_OC3CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP3_OC3CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP3_OC3CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP3_OC3CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP3_OC3CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP3_OC3CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP3_OC3CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP3_OC3CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP3_OC3CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP3_OC3CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP3_OC3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP3_OC3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP4_OC4CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP4_OC4CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP4_OC4CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP4_OC4CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP4_OC4CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP4_OC4CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP4_OC4CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP4_OC4CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP4_OC4CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP4_OC4CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP4_OC4CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP4_OC4CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP4_OC4CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP4_OC4CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP4_OC4CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP4_OC4CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP4_OC4CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP4_OC4CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP4_OC4CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP4_OC4CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP4_OC4CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP4_OC4CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP4_OC4CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP4_OC4CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP4_OC4CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP4_OC4CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP4_OC4CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP4_OC4CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP4_OC4CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP4_OC4CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP4_OC4CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP4_OC4CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP4_OC4CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP4_OC4CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP4_OC4CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP4_OC4CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP4_OC4CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP4_OC4CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP4_OC4CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP4_OC4CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOCMP5_OC5CON.setOCM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TOCMP5_OC5CON.getOCM : TBits_3; inline;
begin
  getOCM := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TOCMP5_OC5CON.setOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOCMP5_OC5CON.clearOCTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOCMP5_OC5CON.setOCTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOCMP5_OC5CON.getOCTSEL : TBits_1; inline;
begin
  getOCTSEL := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOCMP5_OC5CON.setOCFLT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOCMP5_OC5CON.clearOCFLT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOCMP5_OC5CON.setOCFLT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOCMP5_OC5CON.getOCFLT : TBits_1; inline;
begin
  getOCFLT := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOCMP5_OC5CON.setOC32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOCMP5_OC5CON.clearOC32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOCMP5_OC5CON.setOC32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOCMP5_OC5CON.getOC32 : TBits_1; inline;
begin
  getOC32 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOCMP5_OC5CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP5_OC5CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP5_OC5CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP5_OC5CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP5_OC5CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOCMP5_OC5CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOCMP5_OC5CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOCMP5_OC5CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOCMP5_OC5CON.setOCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOCMP5_OC5CON.clearOCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOCMP5_OC5CON.setOCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOCMP5_OC5CON.getOCM0 : TBits_1; inline;
begin
  getOCM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOCMP5_OC5CON.setOCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOCMP5_OC5CON.clearOCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOCMP5_OC5CON.setOCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOCMP5_OC5CON.getOCM1 : TBits_1; inline;
begin
  getOCM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOCMP5_OC5CON.setOCM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOCMP5_OC5CON.clearOCM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOCMP5_OC5CON.setOCM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOCMP5_OC5CON.getOCM2 : TBits_1; inline;
begin
  getOCM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOCMP5_OC5CON.setOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOCMP5_OC5CON.clearOCSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOCMP5_OC5CON.setOCSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOCMP5_OC5CON.getOCSIDL : TBits_1; inline;
begin
  getOCSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOCMP5_OC5CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOCMP5_OC5CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1_I2C1ACON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1_I2C1ACON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1_I2C1ACON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1_I2C1ACON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1_I2C1ACON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1_I2C1ACON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1_I2C1ACON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1_I2C1ACON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1_I2C1ACON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1_I2C1ACON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1_I2C1ACON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1_I2C1ACON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1_I2C1ACON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1_I2C1ACON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1_I2C1ACON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1_I2C1ACON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1_I2C1ACON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1_I2C1ACON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1_I2C1ACON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1_I2C1ACON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1_I2C1ACON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1_I2C1ACON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1_I2C1ACON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1_I2C1ACON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1_I2C1ACON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1ACON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1ACON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1ACON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1ACON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1_I2C1ACON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1_I2C1ACON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1_I2C1ACON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1_I2C1ACON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1_I2C1ACON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1_I2C1ACON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1_I2C1ACON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1_I2C1ACON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1_I2C1ACON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1_I2C1ACON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1_I2C1ACON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1_I2C1ACON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1_I2C1ACON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1_I2C1ACON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1_I2C1ACON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1_I2C1ACON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1_I2C1ACON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1_I2C1ACON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1_I2C1ACON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1_I2C1ACON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C1_I2C1ACON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C1_I2C1ACON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C1_I2C1ACON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C1_I2C1ACON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1_I2C1ACON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1_I2C1ACON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1_I2C1ACON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1_I2C1ACON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1ACON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1ACON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1ACON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1ACON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1_I2C1ACON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1_I2C1ACON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1_I2C1ACON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1_I2C1ACON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1_I2C1ACON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1_I2C1ACON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1_I2C1ACON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1_I2C1ACON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1ACON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1ACON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1ACON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1ACON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1_I2C1ACON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1_I2C1CON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1_I2C1CON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1_I2C1CON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1_I2C1CON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1_I2C1CON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1_I2C1CON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1_I2C1CON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1_I2C1CON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1_I2C1CON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1_I2C1CON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1_I2C1CON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1_I2C1CON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1_I2C1CON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1_I2C1CON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1_I2C1CON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1_I2C1CON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1_I2C1CON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1_I2C1CON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1_I2C1CON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1_I2C1CON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1_I2C1CON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1_I2C1CON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1_I2C1CON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1_I2C1CON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1_I2C1CON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1CON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1CON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1CON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1CON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1_I2C1CON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1_I2C1CON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1_I2C1CON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1_I2C1CON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1_I2C1CON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1_I2C1CON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1_I2C1CON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1_I2C1CON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1_I2C1CON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1_I2C1CON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1_I2C1CON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1_I2C1CON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1_I2C1CON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1_I2C1CON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1_I2C1CON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1_I2C1CON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1_I2C1CON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1_I2C1CON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1_I2C1CON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1_I2C1CON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C1_I2C1CON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C1_I2C1CON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C1_I2C1CON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C1_I2C1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1_I2C1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1_I2C1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1_I2C1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1_I2C1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1CON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C1_I2C1CON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C1_I2C1CON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C1_I2C1CON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C1_I2C1CON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C1_I2C1CON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C1_I2C1CON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C1_I2C1CON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C1_I2C1CON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1CON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1CON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1CON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1_I2C1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1_I2C1ASTAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1_I2C1ASTAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1_I2C1ASTAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1_I2C1ASTAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1_I2C1ASTAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1_I2C1ASTAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1_I2C1ASTAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1_I2C1ASTAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1_I2C1ASTAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1_I2C1ASTAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1_I2C1ASTAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1_I2C1ASTAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1_I2C1ASTAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1_I2C1ASTAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1_I2C1ASTAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1_I2C1ASTAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1_I2C1ASTAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1_I2C1ASTAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1_I2C1ASTAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1_I2C1ASTAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1_I2C1ASTAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1_I2C1ASTAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1_I2C1ASTAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1_I2C1ASTAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1_I2C1ASTAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1ASTAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1ASTAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1ASTAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1ASTAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1_I2C1ASTAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1_I2C1ASTAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1_I2C1ASTAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1_I2C1ASTAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1_I2C1ASTAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1_I2C1ASTAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1_I2C1ASTAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1_I2C1ASTAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1_I2C1ASTAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1_I2C1ASTAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1_I2C1ASTAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1_I2C1ASTAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1_I2C1ASTAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1_I2C1ASTAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1_I2C1ASTAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1_I2C1ASTAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C1_I2C1ASTAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C1_I2C1ASTAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C1_I2C1ASTAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C1_I2C1ASTAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1ASTAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1ASTAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1ASTAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1ASTAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1ASTAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1ASTAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1ASTAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1ASTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1_I2C1ASTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C1_I2C1STAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C1_I2C1STAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C1_I2C1STAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C1_I2C1STAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C1_I2C1STAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C1_I2C1STAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C1_I2C1STAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C1_I2C1STAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C1_I2C1STAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C1_I2C1STAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C1_I2C1STAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C1_I2C1STAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C1_I2C1STAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C1_I2C1STAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C1_I2C1STAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C1_I2C1STAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C1_I2C1STAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C1_I2C1STAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C1_I2C1STAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C1_I2C1STAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C1_I2C1STAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C1_I2C1STAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C1_I2C1STAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C1_I2C1STAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C1_I2C1STAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1STAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1STAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1STAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1STAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C1_I2C1STAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C1_I2C1STAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C1_I2C1STAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C1_I2C1STAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C1_I2C1STAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C1_I2C1STAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C1_I2C1STAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C1_I2C1STAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C1_I2C1STAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C1_I2C1STAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C1_I2C1STAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C1_I2C1STAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C1_I2C1STAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C1_I2C1STAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C1_I2C1STAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C1_I2C1STAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C1_I2C1STAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C1_I2C1STAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C1_I2C1STAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C1_I2C1STAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C1_I2C1STAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C1_I2C1STAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C1_I2C1STAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C1_I2C1STAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C1_I2C1STAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C1_I2C1STAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C1_I2C1STAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C1_I2C1STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C1_I2C1STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C2_I2C2ACON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C2_I2C2ACON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C2_I2C2ACON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C2_I2C2ACON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C2_I2C2ACON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C2_I2C2ACON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C2_I2C2ACON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C2_I2C2ACON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C2_I2C2ACON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C2_I2C2ACON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C2_I2C2ACON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C2_I2C2ACON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C2_I2C2ACON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C2_I2C2ACON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C2_I2C2ACON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C2_I2C2ACON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C2_I2C2ACON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C2_I2C2ACON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C2_I2C2ACON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C2_I2C2ACON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C2_I2C2ACON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C2_I2C2ACON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C2_I2C2ACON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C2_I2C2ACON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C2_I2C2ACON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2_I2C2ACON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2_I2C2ACON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2_I2C2ACON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2_I2C2ACON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C2_I2C2ACON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C2_I2C2ACON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C2_I2C2ACON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C2_I2C2ACON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C2_I2C2ACON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C2_I2C2ACON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C2_I2C2ACON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C2_I2C2ACON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C2_I2C2ACON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C2_I2C2ACON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C2_I2C2ACON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C2_I2C2ACON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C2_I2C2ACON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C2_I2C2ACON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C2_I2C2ACON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C2_I2C2ACON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C2_I2C2ACON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C2_I2C2ACON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C2_I2C2ACON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C2_I2C2ACON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C2_I2C2ACON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C2_I2C2ACON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C2_I2C2ACON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C2_I2C2ACON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C2_I2C2ACON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C2_I2C2ACON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C2_I2C2ACON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C2_I2C2ACON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2_I2C2ACON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2_I2C2ACON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2_I2C2ACON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2_I2C2ACON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C2_I2C2ACON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C2_I2C2ACON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C2_I2C2ACON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C2_I2C2ACON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C2_I2C2ACON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C2_I2C2ACON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C2_I2C2ACON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C2_I2C2ACON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2_I2C2ACON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2_I2C2ACON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2_I2C2ACON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2_I2C2ACON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C2_I2C2ACON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C2_I2C2CON.setSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C2_I2C2CON.clearSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C2_I2C2CON.setSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C2_I2C2CON.getSEN : TBits_1; inline;
begin
  getSEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C2_I2C2CON.setRSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C2_I2C2CON.clearRSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C2_I2C2CON.setRSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C2_I2C2CON.getRSEN : TBits_1; inline;
begin
  getRSEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C2_I2C2CON.setPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C2_I2C2CON.clearPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C2_I2C2CON.setPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C2_I2C2CON.getPEN : TBits_1; inline;
begin
  getPEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C2_I2C2CON.setRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C2_I2C2CON.clearRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C2_I2C2CON.setRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C2_I2C2CON.getRCEN : TBits_1; inline;
begin
  getRCEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C2_I2C2CON.setACKEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C2_I2C2CON.clearACKEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C2_I2C2CON.setACKEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C2_I2C2CON.getACKEN : TBits_1; inline;
begin
  getACKEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C2_I2C2CON.setACKDT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C2_I2C2CON.clearACKDT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C2_I2C2CON.setACKDT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C2_I2C2CON.getACKDT : TBits_1; inline;
begin
  getACKDT := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C2_I2C2CON.setSTREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2_I2C2CON.clearSTREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2_I2C2CON.setSTREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2_I2C2CON.getSTREN : TBits_1; inline;
begin
  getSTREN := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2_I2C2CON.setGCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C2_I2C2CON.clearGCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C2_I2C2CON.setGCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C2_I2C2CON.getGCEN : TBits_1; inline;
begin
  getGCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C2_I2C2CON.setSMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C2_I2C2CON.clearSMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C2_I2C2CON.setSMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C2_I2C2CON.getSMEN : TBits_1; inline;
begin
  getSMEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C2_I2C2CON.setDISSLW; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C2_I2C2CON.clearDISSLW; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C2_I2C2CON.setDISSLW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C2_I2C2CON.getDISSLW : TBits_1; inline;
begin
  getDISSLW := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C2_I2C2CON.setA10M; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C2_I2C2CON.clearA10M; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C2_I2C2CON.setA10M(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C2_I2C2CON.getA10M : TBits_1; inline;
begin
  getA10M := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C2_I2C2CON.setSTRICT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C2_I2C2CON.clearSTRICT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C2_I2C2CON.setSTRICT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C2_I2C2CON.getSTRICT : TBits_1; inline;
begin
  getSTRICT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C2_I2C2CON.setSCLREL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TI2C2_I2C2CON.clearSCLREL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TI2C2_I2C2CON.setSCLREL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TI2C2_I2C2CON.getSCLREL : TBits_1; inline;
begin
  getSCLREL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TI2C2_I2C2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C2_I2C2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C2_I2C2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C2_I2C2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C2_I2C2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2_I2C2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2_I2C2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2_I2C2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2_I2C2CON.setIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TI2C2_I2C2CON.clearIPMIEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TI2C2_I2C2CON.setIPMIEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TI2C2_I2C2CON.getIPMIEN : TBits_1; inline;
begin
  getIPMIEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TI2C2_I2C2CON.setI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TI2C2_I2C2CON.clearI2CSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TI2C2_I2C2CON.setI2CSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TI2C2_I2C2CON.getI2CSIDL : TBits_1; inline;
begin
  getI2CSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TI2C2_I2C2CON.setI2CEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2_I2C2CON.clearI2CEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2_I2C2CON.setI2CEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2_I2C2CON.getI2CEN : TBits_1; inline;
begin
  getI2CEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2_I2C2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C2_I2C2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C2_I2C2ASTAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C2_I2C2ASTAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C2_I2C2ASTAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C2_I2C2ASTAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C2_I2C2ASTAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C2_I2C2ASTAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C2_I2C2ASTAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C2_I2C2ASTAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C2_I2C2ASTAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C2_I2C2ASTAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C2_I2C2ASTAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C2_I2C2ASTAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C2_I2C2ASTAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C2_I2C2ASTAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C2_I2C2ASTAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C2_I2C2ASTAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C2_I2C2ASTAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C2_I2C2ASTAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C2_I2C2ASTAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C2_I2C2ASTAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C2_I2C2ASTAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C2_I2C2ASTAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C2_I2C2ASTAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C2_I2C2ASTAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C2_I2C2ASTAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2_I2C2ASTAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2_I2C2ASTAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2_I2C2ASTAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2_I2C2ASTAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C2_I2C2ASTAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C2_I2C2ASTAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C2_I2C2ASTAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C2_I2C2ASTAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C2_I2C2ASTAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C2_I2C2ASTAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C2_I2C2ASTAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C2_I2C2ASTAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C2_I2C2ASTAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C2_I2C2ASTAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C2_I2C2ASTAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C2_I2C2ASTAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C2_I2C2ASTAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C2_I2C2ASTAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C2_I2C2ASTAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C2_I2C2ASTAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C2_I2C2ASTAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C2_I2C2ASTAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C2_I2C2ASTAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C2_I2C2ASTAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2_I2C2ASTAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2_I2C2ASTAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2_I2C2ASTAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2_I2C2ASTAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2_I2C2ASTAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2_I2C2ASTAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2_I2C2ASTAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2_I2C2ASTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C2_I2C2ASTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TI2C2_I2C2STAT.setTBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TI2C2_I2C2STAT.clearTBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TI2C2_I2C2STAT.setTBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TI2C2_I2C2STAT.getTBF : TBits_1; inline;
begin
  getTBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TI2C2_I2C2STAT.setRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TI2C2_I2C2STAT.clearRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TI2C2_I2C2STAT.setRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TI2C2_I2C2STAT.getRBF : TBits_1; inline;
begin
  getRBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TI2C2_I2C2STAT.setR_W; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TI2C2_I2C2STAT.clearR_W; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TI2C2_I2C2STAT.setR_W(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TI2C2_I2C2STAT.getR_W : TBits_1; inline;
begin
  getR_W := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TI2C2_I2C2STAT.setS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TI2C2_I2C2STAT.clearS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TI2C2_I2C2STAT.setS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TI2C2_I2C2STAT.getS : TBits_1; inline;
begin
  getS := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TI2C2_I2C2STAT.setP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TI2C2_I2C2STAT.clearP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TI2C2_I2C2STAT.setP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TI2C2_I2C2STAT.getP : TBits_1; inline;
begin
  getP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TI2C2_I2C2STAT.setD_A; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TI2C2_I2C2STAT.clearD_A; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TI2C2_I2C2STAT.setD_A(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TI2C2_I2C2STAT.getD_A : TBits_1; inline;
begin
  getD_A := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TI2C2_I2C2STAT.setI2COV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2_I2C2STAT.clearI2COV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2_I2C2STAT.setI2COV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2_I2C2STAT.getI2COV : TBits_1; inline;
begin
  getI2COV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2_I2C2STAT.setIWCOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TI2C2_I2C2STAT.clearIWCOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TI2C2_I2C2STAT.setIWCOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TI2C2_I2C2STAT.getIWCOL : TBits_1; inline;
begin
  getIWCOL := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TI2C2_I2C2STAT.setADD10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TI2C2_I2C2STAT.clearADD10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TI2C2_I2C2STAT.setADD10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TI2C2_I2C2STAT.getADD10 : TBits_1; inline;
begin
  getADD10 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TI2C2_I2C2STAT.setGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TI2C2_I2C2STAT.clearGCSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TI2C2_I2C2STAT.setGCSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TI2C2_I2C2STAT.getGCSTAT : TBits_1; inline;
begin
  getGCSTAT := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TI2C2_I2C2STAT.setBCL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TI2C2_I2C2STAT.clearBCL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TI2C2_I2C2STAT.setBCL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TI2C2_I2C2STAT.getBCL : TBits_1; inline;
begin
  getBCL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TI2C2_I2C2STAT.setTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TI2C2_I2C2STAT.clearTRSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TI2C2_I2C2STAT.setTRSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TI2C2_I2C2STAT.getTRSTAT : TBits_1; inline;
begin
  getTRSTAT := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TI2C2_I2C2STAT.setACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TI2C2_I2C2STAT.clearACKSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TI2C2_I2C2STAT.setACKSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TI2C2_I2C2STAT.getACKSTAT : TBits_1; inline;
begin
  getACKSTAT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TI2C2_I2C2STAT.setI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TI2C2_I2C2STAT.clearI2CPOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TI2C2_I2C2STAT.setI2CPOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TI2C2_I2C2STAT.getI2CPOV : TBits_1; inline;
begin
  getI2CPOV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TI2C2_I2C2STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TI2C2_I2C2STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI1_SPI1CON.setSRXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI1_SPI1CON.getSRXISEL : TBits_2; inline;
begin
  getSRXISEL := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI1_SPI1CON.setSTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF3 or ( thebits shl 2 );
end;
function  TSPI1_SPI1CON.getSTXISEL : TBits_2; inline;
begin
  getSTXISEL := (pTDefRegMap(@Self)^.val and $0000000C) shr 2;
end;
procedure TSPI1_SPI1CON.setDISSDI; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TSPI1_SPI1CON.clearDISSDI; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TSPI1_SPI1CON.setDISSDI(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TSPI1_SPI1CON.getDISSDI : TBits_1; inline;
begin
  getDISSDI := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TSPI1_SPI1CON.setMSTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI1_SPI1CON.clearMSTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI1_SPI1CON.setMSTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI1_SPI1CON.getMSTEN : TBits_1; inline;
begin
  getMSTEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI1_SPI1CON.setCKP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI1_SPI1CON.clearCKP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI1_SPI1CON.setCKP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI1_SPI1CON.getCKP : TBits_1; inline;
begin
  getCKP := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI1_SPI1CON.setSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI1_SPI1CON.clearSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI1_SPI1CON.setSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI1_SPI1CON.getSSEN : TBits_1; inline;
begin
  getSSEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI1_SPI1CON.setCKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI1_SPI1CON.clearCKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI1_SPI1CON.setCKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI1_SPI1CON.getCKE : TBits_1; inline;
begin
  getCKE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI1_SPI1CON.setSMP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI1_SPI1CON.clearSMP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI1_SPI1CON.setSMP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI1_SPI1CON.getSMP : TBits_1; inline;
begin
  getSMP := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI1_SPI1CON.setMODE16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI1_SPI1CON.clearMODE16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI1_SPI1CON.setMODE16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI1_SPI1CON.getMODE16 : TBits_1; inline;
begin
  getMODE16 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI1_SPI1CON.setMODE32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI1_SPI1CON.clearMODE32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI1_SPI1CON.setMODE32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI1_SPI1CON.getMODE32 : TBits_1; inline;
begin
  getMODE32 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI1_SPI1CON.setDISSDO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI1_SPI1CON.clearDISSDO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI1_SPI1CON.setDISSDO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI1_SPI1CON.getDISSDO : TBits_1; inline;
begin
  getDISSDO := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI1_SPI1CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TSPI1_SPI1CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TSPI1_SPI1CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TSPI1_SPI1CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TSPI1_SPI1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI1_SPI1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI1_SPI1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI1_SPI1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI1_SPI1CON.setENHBUF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TSPI1_SPI1CON.clearENHBUF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TSPI1_SPI1CON.setENHBUF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TSPI1_SPI1CON.getENHBUF : TBits_1; inline;
begin
  getENHBUF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TSPI1_SPI1CON.setSPIFE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TSPI1_SPI1CON.clearSPIFE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TSPI1_SPI1CON.setSPIFE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TSPI1_SPI1CON.getSPIFE : TBits_1; inline;
begin
  getSPIFE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TSPI1_SPI1CON.setMCLKSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TSPI1_SPI1CON.clearMCLKSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TSPI1_SPI1CON.setMCLKSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TSPI1_SPI1CON.getMCLKSEL : TBits_1; inline;
begin
  getMCLKSEL := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TSPI1_SPI1CON.setFRMCNT(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TSPI1_SPI1CON.getFRMCNT : TBits_3; inline;
begin
  getFRMCNT := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TSPI1_SPI1CON.setFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TSPI1_SPI1CON.clearFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TSPI1_SPI1CON.setFRMSYPW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TSPI1_SPI1CON.getFRMSYPW : TBits_1; inline;
begin
  getFRMSYPW := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TSPI1_SPI1CON.setMSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TSPI1_SPI1CON.clearMSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TSPI1_SPI1CON.setMSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TSPI1_SPI1CON.getMSSEN : TBits_1; inline;
begin
  getMSSEN := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TSPI1_SPI1CON.setFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TSPI1_SPI1CON.clearFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TSPI1_SPI1CON.setFRMPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TSPI1_SPI1CON.getFRMPOL : TBits_1; inline;
begin
  getFRMPOL := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TSPI1_SPI1CON.setFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TSPI1_SPI1CON.clearFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TSPI1_SPI1CON.setFRMSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TSPI1_SPI1CON.getFRMSYNC : TBits_1; inline;
begin
  getFRMSYNC := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TSPI1_SPI1CON.setFRMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TSPI1_SPI1CON.clearFRMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TSPI1_SPI1CON.setFRMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TSPI1_SPI1CON.getFRMEN : TBits_1; inline;
begin
  getFRMEN := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TSPI1_SPI1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI1_SPI1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI1_SPI1STAT.setSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI1_SPI1STAT.clearSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI1_SPI1STAT.setSPIRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI1_SPI1STAT.getSPIRBF : TBits_1; inline;
begin
  getSPIRBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI1_SPI1STAT.setSPITBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI1_SPI1STAT.clearSPITBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI1_SPI1STAT.setSPITBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI1_SPI1STAT.getSPITBF : TBits_1; inline;
begin
  getSPITBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI1_SPI1STAT.setSPITBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI1_SPI1STAT.clearSPITBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI1_SPI1STAT.setSPITBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI1_SPI1STAT.getSPITBE : TBits_1; inline;
begin
  getSPITBE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI1_SPI1STAT.setSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI1_SPI1STAT.clearSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI1_SPI1STAT.setSPIRBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI1_SPI1STAT.getSPIRBE : TBits_1; inline;
begin
  getSPIRBE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI1_SPI1STAT.setSPIROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI1_SPI1STAT.clearSPIROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI1_SPI1STAT.setSPIROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI1_SPI1STAT.getSPIROV : TBits_1; inline;
begin
  getSPIROV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI1_SPI1STAT.setSRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI1_SPI1STAT.clearSRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI1_SPI1STAT.setSRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI1_SPI1STAT.getSRMT : TBits_1; inline;
begin
  getSRMT := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI1_SPI1STAT.setSPITUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI1_SPI1STAT.clearSPITUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI1_SPI1STAT.setSPITUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI1_SPI1STAT.getSPITUR : TBits_1; inline;
begin
  getSPITUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI1_SPI1STAT.setSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI1_SPI1STAT.clearSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI1_SPI1STAT.setSPIBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI1_SPI1STAT.getSPIBUSY : TBits_1; inline;
begin
  getSPIBUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI1_SPI1STAT.setFRMERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI1_SPI1STAT.clearFRMERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI1_SPI1STAT.setFRMERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI1_SPI1STAT.getFRMERR : TBits_1; inline;
begin
  getFRMERR := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI1_SPI1STAT.setTXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TSPI1_SPI1STAT.getTXBUFELM : TBits_5; inline;
begin
  getTXBUFELM := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TSPI1_SPI1STAT.setRXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TSPI1_SPI1STAT.getRXBUFELM : TBits_5; inline;
begin
  getRXBUFELM := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TSPI1_SPI1STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI1_SPI1STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI1_SPI1CON2.setAUDMOD(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI1_SPI1CON2.getAUDMOD : TBits_2; inline;
begin
  getAUDMOD := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI1_SPI1CON2.setAUDMONO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI1_SPI1CON2.clearAUDMONO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI1_SPI1CON2.setAUDMONO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI1_SPI1CON2.getAUDMONO : TBits_1; inline;
begin
  getAUDMONO := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI1_SPI1CON2.setAUDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI1_SPI1CON2.clearAUDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI1_SPI1CON2.setAUDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI1_SPI1CON2.getAUDEN : TBits_1; inline;
begin
  getAUDEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI1_SPI1CON2.setIGNTUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI1_SPI1CON2.clearIGNTUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI1_SPI1CON2.setIGNTUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI1_SPI1CON2.getIGNTUR : TBits_1; inline;
begin
  getIGNTUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI1_SPI1CON2.setIGNROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI1_SPI1CON2.clearIGNROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI1_SPI1CON2.setIGNROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI1_SPI1CON2.getIGNROV : TBits_1; inline;
begin
  getIGNROV := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI1_SPI1CON2.setSPITUREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI1_SPI1CON2.clearSPITUREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI1_SPI1CON2.setSPITUREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI1_SPI1CON2.getSPITUREN : TBits_1; inline;
begin
  getSPITUREN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI1_SPI1CON2.setSPIROVEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI1_SPI1CON2.clearSPIROVEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI1_SPI1CON2.setSPIROVEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI1_SPI1CON2.getSPIROVEN : TBits_1; inline;
begin
  getSPIROVEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI1_SPI1CON2.setFRMERREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI1_SPI1CON2.clearFRMERREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI1_SPI1CON2.setFRMERREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI1_SPI1CON2.getFRMERREN : TBits_1; inline;
begin
  getFRMERREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI1_SPI1CON2.setSPISGNEXT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI1_SPI1CON2.clearSPISGNEXT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI1_SPI1CON2.setSPISGNEXT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI1_SPI1CON2.getSPISGNEXT : TBits_1; inline;
begin
  getSPISGNEXT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI1_SPI1CON2.setAUDMOD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI1_SPI1CON2.clearAUDMOD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI1_SPI1CON2.setAUDMOD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI1_SPI1CON2.getAUDMOD0 : TBits_1; inline;
begin
  getAUDMOD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI1_SPI1CON2.setAUDMOD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI1_SPI1CON2.clearAUDMOD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI1_SPI1CON2.setAUDMOD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI1_SPI1CON2.getAUDMOD1 : TBits_1; inline;
begin
  getAUDMOD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI1_SPI1CON2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI1_SPI1CON2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI2_SPI2CON.setSRXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI2_SPI2CON.getSRXISEL : TBits_2; inline;
begin
  getSRXISEL := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI2_SPI2CON.setSTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF3 or ( thebits shl 2 );
end;
function  TSPI2_SPI2CON.getSTXISEL : TBits_2; inline;
begin
  getSTXISEL := (pTDefRegMap(@Self)^.val and $0000000C) shr 2;
end;
procedure TSPI2_SPI2CON.setDISSDI; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TSPI2_SPI2CON.clearDISSDI; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TSPI2_SPI2CON.setDISSDI(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TSPI2_SPI2CON.getDISSDI : TBits_1; inline;
begin
  getDISSDI := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TSPI2_SPI2CON.setMSTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI2_SPI2CON.clearMSTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI2_SPI2CON.setMSTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI2_SPI2CON.getMSTEN : TBits_1; inline;
begin
  getMSTEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI2_SPI2CON.setCKP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI2_SPI2CON.clearCKP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI2_SPI2CON.setCKP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI2_SPI2CON.getCKP : TBits_1; inline;
begin
  getCKP := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI2_SPI2CON.setSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI2_SPI2CON.clearSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI2_SPI2CON.setSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI2_SPI2CON.getSSEN : TBits_1; inline;
begin
  getSSEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI2_SPI2CON.setCKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI2_SPI2CON.clearCKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI2_SPI2CON.setCKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI2_SPI2CON.getCKE : TBits_1; inline;
begin
  getCKE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI2_SPI2CON.setSMP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI2_SPI2CON.clearSMP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI2_SPI2CON.setSMP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI2_SPI2CON.getSMP : TBits_1; inline;
begin
  getSMP := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI2_SPI2CON.setMODE16; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI2_SPI2CON.clearMODE16; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI2_SPI2CON.setMODE16(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI2_SPI2CON.getMODE16 : TBits_1; inline;
begin
  getMODE16 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI2_SPI2CON.setMODE32; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI2_SPI2CON.clearMODE32; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI2_SPI2CON.setMODE32(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI2_SPI2CON.getMODE32 : TBits_1; inline;
begin
  getMODE32 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI2_SPI2CON.setDISSDO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI2_SPI2CON.clearDISSDO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI2_SPI2CON.setDISSDO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI2_SPI2CON.getDISSDO : TBits_1; inline;
begin
  getDISSDO := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI2_SPI2CON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TSPI2_SPI2CON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TSPI2_SPI2CON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TSPI2_SPI2CON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TSPI2_SPI2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI2_SPI2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI2_SPI2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI2_SPI2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI2_SPI2CON.setENHBUF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TSPI2_SPI2CON.clearENHBUF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TSPI2_SPI2CON.setENHBUF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TSPI2_SPI2CON.getENHBUF : TBits_1; inline;
begin
  getENHBUF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TSPI2_SPI2CON.setSPIFE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TSPI2_SPI2CON.clearSPIFE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TSPI2_SPI2CON.setSPIFE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TSPI2_SPI2CON.getSPIFE : TBits_1; inline;
begin
  getSPIFE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TSPI2_SPI2CON.setMCLKSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TSPI2_SPI2CON.clearMCLKSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TSPI2_SPI2CON.setMCLKSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TSPI2_SPI2CON.getMCLKSEL : TBits_1; inline;
begin
  getMCLKSEL := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TSPI2_SPI2CON.setFRMCNT(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TSPI2_SPI2CON.getFRMCNT : TBits_3; inline;
begin
  getFRMCNT := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TSPI2_SPI2CON.setFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TSPI2_SPI2CON.clearFRMSYPW; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TSPI2_SPI2CON.setFRMSYPW(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TSPI2_SPI2CON.getFRMSYPW : TBits_1; inline;
begin
  getFRMSYPW := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TSPI2_SPI2CON.setMSSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TSPI2_SPI2CON.clearMSSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TSPI2_SPI2CON.setMSSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TSPI2_SPI2CON.getMSSEN : TBits_1; inline;
begin
  getMSSEN := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TSPI2_SPI2CON.setFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TSPI2_SPI2CON.clearFRMPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TSPI2_SPI2CON.setFRMPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TSPI2_SPI2CON.getFRMPOL : TBits_1; inline;
begin
  getFRMPOL := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TSPI2_SPI2CON.setFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TSPI2_SPI2CON.clearFRMSYNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TSPI2_SPI2CON.setFRMSYNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TSPI2_SPI2CON.getFRMSYNC : TBits_1; inline;
begin
  getFRMSYNC := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TSPI2_SPI2CON.setFRMEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TSPI2_SPI2CON.clearFRMEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TSPI2_SPI2CON.setFRMEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TSPI2_SPI2CON.getFRMEN : TBits_1; inline;
begin
  getFRMEN := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TSPI2_SPI2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI2_SPI2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI2_SPI2STAT.setSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI2_SPI2STAT.clearSPIRBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI2_SPI2STAT.setSPIRBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI2_SPI2STAT.getSPIRBF : TBits_1; inline;
begin
  getSPIRBF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI2_SPI2STAT.setSPITBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI2_SPI2STAT.clearSPITBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI2_SPI2STAT.setSPITBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI2_SPI2STAT.getSPITBF : TBits_1; inline;
begin
  getSPITBF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI2_SPI2STAT.setSPITBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI2_SPI2STAT.clearSPITBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI2_SPI2STAT.setSPITBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI2_SPI2STAT.getSPITBE : TBits_1; inline;
begin
  getSPITBE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI2_SPI2STAT.setSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TSPI2_SPI2STAT.clearSPIRBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TSPI2_SPI2STAT.setSPIRBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TSPI2_SPI2STAT.getSPIRBE : TBits_1; inline;
begin
  getSPIRBE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TSPI2_SPI2STAT.setSPIROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TSPI2_SPI2STAT.clearSPIROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TSPI2_SPI2STAT.setSPIROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TSPI2_SPI2STAT.getSPIROV : TBits_1; inline;
begin
  getSPIROV := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TSPI2_SPI2STAT.setSRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI2_SPI2STAT.clearSRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI2_SPI2STAT.setSRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI2_SPI2STAT.getSRMT : TBits_1; inline;
begin
  getSRMT := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI2_SPI2STAT.setSPITUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI2_SPI2STAT.clearSPITUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI2_SPI2STAT.setSPITUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI2_SPI2STAT.getSPITUR : TBits_1; inline;
begin
  getSPITUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI2_SPI2STAT.setSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI2_SPI2STAT.clearSPIBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI2_SPI2STAT.setSPIBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI2_SPI2STAT.getSPIBUSY : TBits_1; inline;
begin
  getSPIBUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI2_SPI2STAT.setFRMERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI2_SPI2STAT.clearFRMERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI2_SPI2STAT.setFRMERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI2_SPI2STAT.getFRMERR : TBits_1; inline;
begin
  getFRMERR := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI2_SPI2STAT.setTXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TSPI2_SPI2STAT.getTXBUFELM : TBits_5; inline;
begin
  getTXBUFELM := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TSPI2_SPI2STAT.setRXBUFELM(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E0FFFFFF or ( thebits shl 24 );
end;
function  TSPI2_SPI2STAT.getRXBUFELM : TBits_5; inline;
begin
  getRXBUFELM := (pTDefRegMap(@Self)^.val and $1F000000) shr 24;
end;
procedure TSPI2_SPI2STAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI2_SPI2STAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TSPI2_SPI2CON2.setAUDMOD(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TSPI2_SPI2CON2.getAUDMOD : TBits_2; inline;
begin
  getAUDMOD := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TSPI2_SPI2CON2.setAUDMONO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TSPI2_SPI2CON2.clearAUDMONO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TSPI2_SPI2CON2.setAUDMONO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TSPI2_SPI2CON2.getAUDMONO : TBits_1; inline;
begin
  getAUDMONO := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TSPI2_SPI2CON2.setAUDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TSPI2_SPI2CON2.clearAUDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TSPI2_SPI2CON2.setAUDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TSPI2_SPI2CON2.getAUDEN : TBits_1; inline;
begin
  getAUDEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TSPI2_SPI2CON2.setIGNTUR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TSPI2_SPI2CON2.clearIGNTUR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TSPI2_SPI2CON2.setIGNTUR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TSPI2_SPI2CON2.getIGNTUR : TBits_1; inline;
begin
  getIGNTUR := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TSPI2_SPI2CON2.setIGNROV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TSPI2_SPI2CON2.clearIGNROV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TSPI2_SPI2CON2.setIGNROV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TSPI2_SPI2CON2.getIGNROV : TBits_1; inline;
begin
  getIGNROV := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TSPI2_SPI2CON2.setSPITUREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TSPI2_SPI2CON2.clearSPITUREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TSPI2_SPI2CON2.setSPITUREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TSPI2_SPI2CON2.getSPITUREN : TBits_1; inline;
begin
  getSPITUREN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TSPI2_SPI2CON2.setSPIROVEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TSPI2_SPI2CON2.clearSPIROVEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TSPI2_SPI2CON2.setSPIROVEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TSPI2_SPI2CON2.getSPIROVEN : TBits_1; inline;
begin
  getSPIROVEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TSPI2_SPI2CON2.setFRMERREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TSPI2_SPI2CON2.clearFRMERREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TSPI2_SPI2CON2.setFRMERREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TSPI2_SPI2CON2.getFRMERREN : TBits_1; inline;
begin
  getFRMERREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TSPI2_SPI2CON2.setSPISGNEXT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TSPI2_SPI2CON2.clearSPISGNEXT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TSPI2_SPI2CON2.setSPISGNEXT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TSPI2_SPI2CON2.getSPISGNEXT : TBits_1; inline;
begin
  getSPISGNEXT := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TSPI2_SPI2CON2.setAUDMOD0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TSPI2_SPI2CON2.clearAUDMOD0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TSPI2_SPI2CON2.setAUDMOD0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TSPI2_SPI2CON2.getAUDMOD0 : TBits_1; inline;
begin
  getAUDMOD0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TSPI2_SPI2CON2.setAUDMOD1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TSPI2_SPI2CON2.clearAUDMOD1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TSPI2_SPI2CON2.setAUDMOD1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TSPI2_SPI2CON2.getAUDMOD1 : TBits_1; inline;
begin
  getAUDMOD1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TSPI2_SPI2CON2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TSPI2_SPI2CON2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART1_U1AMODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART1_U1AMODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART1_U1AMODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART1_U1AMODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART1_U1AMODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART1_U1AMODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART1_U1AMODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART1_U1AMODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART1_U1AMODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART1_U1AMODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART1_U1AMODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART1_U1AMODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART1_U1AMODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART1_U1AMODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART1_U1AMODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART1_U1AMODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART1_U1AMODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART1_U1AMODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART1_U1AMODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART1_U1AMODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART1_U1AMODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART1_U1AMODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART1_U1AMODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART1_U1AMODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART1_U1AMODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART1_U1AMODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART1_U1AMODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART1_U1AMODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART1_U1AMODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART1_U1AMODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART1_U1AMODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART1_U1AMODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART1_U1AMODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART1_U1AMODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART1_U1AMODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART1_U1AMODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART1_U1AMODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1_U1AMODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1_U1AMODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1_U1AMODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1_U1AMODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1_U1AMODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1_U1AMODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1_U1AMODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1_U1AMODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART1_U1AMODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART1_U1AMODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART1_U1AMODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART1_U1AMODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART1_U1AMODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART1_U1AMODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART1_U1AMODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART1_U1AMODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART1_U1AMODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART1_U1AMODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART1_U1AMODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART1_U1AMODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART1_U1AMODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART1_U1AMODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART1_U1AMODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART1_U1AMODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1_U1AMODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1_U1AMODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1_U1AMODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1_U1AMODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1_U1AMODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1_U1AMODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1_U1AMODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1_U1AMODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART1_U1AMODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART1_U1MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART1_U1MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART1_U1MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART1_U1MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART1_U1MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART1_U1MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART1_U1MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART1_U1MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART1_U1MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART1_U1MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART1_U1MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART1_U1MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART1_U1MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART1_U1MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART1_U1MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART1_U1MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART1_U1MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART1_U1MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART1_U1MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART1_U1MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART1_U1MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART1_U1MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART1_U1MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART1_U1MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART1_U1MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART1_U1MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART1_U1MODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART1_U1MODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART1_U1MODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART1_U1MODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART1_U1MODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART1_U1MODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART1_U1MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART1_U1MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART1_U1MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART1_U1MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART1_U1MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1_U1MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1_U1MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1_U1MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1_U1MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1_U1MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1_U1MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1_U1MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1_U1MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART1_U1MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART1_U1MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART1_U1MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART1_U1MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART1_U1MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART1_U1MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART1_U1MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART1_U1MODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART1_U1MODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART1_U1MODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART1_U1MODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART1_U1MODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART1_U1MODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART1_U1MODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART1_U1MODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART1_U1MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1_U1MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1_U1MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1_U1MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1_U1MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1_U1MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1_U1MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1_U1MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1_U1MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART1_U1MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART1_U1ASTA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART1_U1ASTA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART1_U1ASTA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART1_U1ASTA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART1_U1ASTA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART1_U1ASTA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART1_U1ASTA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART1_U1ASTA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART1_U1ASTA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART1_U1ASTA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART1_U1ASTA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART1_U1ASTA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART1_U1ASTA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART1_U1ASTA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART1_U1ASTA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART1_U1ASTA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART1_U1ASTA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART1_U1ASTA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART1_U1ASTA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART1_U1ASTA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART1_U1ASTA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART1_U1ASTA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART1_U1ASTA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART1_U1ASTA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART1_U1ASTA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART1_U1ASTA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART1_U1ASTA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART1_U1ASTA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART1_U1ASTA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART1_U1ASTA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART1_U1ASTA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART1_U1ASTA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART1_U1ASTA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART1_U1ASTA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART1_U1ASTA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART1_U1ASTA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART1_U1ASTA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART1_U1ASTA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART1_U1ASTA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART1_U1ASTA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART1_U1ASTA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART1_U1ASTA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART1_U1ASTA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART1_U1ASTA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART1_U1ASTA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART1_U1ASTA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART1_U1ASTA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1_U1ASTA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1_U1ASTA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1_U1ASTA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1_U1ASTA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART1_U1ASTA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART1_U1ASTA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART1_U1ASTA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART1_U1ASTA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART1_U1ASTA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART1_U1ASTA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART1_U1ASTA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART1_U1ASTA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART1_U1ASTA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART1_U1ASTA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART1_U1ASTA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART1_U1ASTA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART1_U1ASTA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART1_U1ASTA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART1_U1ASTA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART1_U1ASTA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART1_U1ASTA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART1_U1ASTA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART1_U1ASTA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART1_U1ASTA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1_U1ASTA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1_U1ASTA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1_U1ASTA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1_U1ASTA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART1_U1ASTA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART1_U1ASTA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART1_U1ASTA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART1_U1STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART1_U1STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART1_U1STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART1_U1STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART1_U1STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART1_U1STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART1_U1STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART1_U1STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART1_U1STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART1_U1STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART1_U1STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART1_U1STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART1_U1STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART1_U1STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART1_U1STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART1_U1STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART1_U1STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART1_U1STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART1_U1STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART1_U1STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART1_U1STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART1_U1STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART1_U1STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART1_U1STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART1_U1STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART1_U1STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART1_U1STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART1_U1STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART1_U1STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART1_U1STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART1_U1STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART1_U1STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART1_U1STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART1_U1STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART1_U1STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART1_U1STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART1_U1STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART1_U1STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART1_U1STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART1_U1STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART1_U1STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART1_U1STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART1_U1STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART1_U1STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART1_U1STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART1_U1STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART1_U1STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART1_U1STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART1_U1STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART1_U1STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART1_U1STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART1_U1STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART1_U1STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART1_U1STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART1_U1STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART1_U1STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART1_U1STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART1_U1STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART1_U1STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART1_U1STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART1_U1STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART1_U1STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART1_U1STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART1_U1STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART1_U1STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART1_U1STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART1_U1STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART1_U1STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART1_U1STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART1_U1STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART1_U1STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART1_U1STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART1_U1STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART1_U1STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART1_U1STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART1_U1STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART1_U1STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART1_U1STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2_U2MODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2_U2MODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2_U2MODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2_U2MODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2_U2MODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART2_U2MODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART2_U2MODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2_U2MODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2_U2MODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2_U2MODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2_U2MODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2_U2MODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2_U2MODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2_U2MODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2_U2MODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2_U2MODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2_U2MODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2_U2MODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2_U2MODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2_U2MODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2_U2MODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2_U2MODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2_U2MODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2_U2MODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2_U2MODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2_U2MODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2_U2MODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART2_U2MODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART2_U2MODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2_U2MODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2_U2MODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2_U2MODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2_U2MODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2_U2MODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2_U2MODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2_U2MODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2_U2MODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U2MODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U2MODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U2MODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U2MODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U2MODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U2MODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U2MODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U2MODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2_U2MODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2_U2MODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2_U2MODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2_U2MODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2_U2MODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2_U2MODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2_U2MODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2_U2MODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2_U2MODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2_U2MODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2_U2MODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2_U2MODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2_U2MODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2_U2MODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2_U2MODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2_U2MODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U2MODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U2MODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U2MODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U2MODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U2MODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U2MODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U2MODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U2MODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2_U2MODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2_U3AMODE.setSTSEL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2_U3AMODE.clearSTSEL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2_U3AMODE.setSTSEL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2_U3AMODE.getSTSEL : TBits_1; inline;
begin
  getSTSEL := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2_U3AMODE.setPDSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF9 or ( thebits shl 1 );
end;
function  TUART2_U3AMODE.getPDSEL : TBits_2; inline;
begin
  getPDSEL := (pTDefRegMap(@Self)^.val and $00000006) shr 1;
end;
procedure TUART2_U3AMODE.setBRGH; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2_U3AMODE.clearBRGH; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2_U3AMODE.setBRGH(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2_U3AMODE.getBRGH : TBits_1; inline;
begin
  getBRGH := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2_U3AMODE.setRXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2_U3AMODE.clearRXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2_U3AMODE.setRXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2_U3AMODE.getRXINV : TBits_1; inline;
begin
  getRXINV := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2_U3AMODE.setABAUD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2_U3AMODE.clearABAUD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2_U3AMODE.setABAUD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2_U3AMODE.getABAUD : TBits_1; inline;
begin
  getABAUD := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2_U3AMODE.setLPBACK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2_U3AMODE.clearLPBACK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2_U3AMODE.setLPBACK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2_U3AMODE.getLPBACK : TBits_1; inline;
begin
  getLPBACK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2_U3AMODE.setWAKE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2_U3AMODE.clearWAKE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2_U3AMODE.setWAKE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2_U3AMODE.getWAKE : TBits_1; inline;
begin
  getWAKE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2_U3AMODE.setUEN(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TUART2_U3AMODE.getUEN : TBits_2; inline;
begin
  getUEN := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TUART2_U3AMODE.setRTSMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2_U3AMODE.clearRTSMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2_U3AMODE.setRTSMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2_U3AMODE.getRTSMD : TBits_1; inline;
begin
  getRTSMD := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2_U3AMODE.setIREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2_U3AMODE.clearIREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2_U3AMODE.setIREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2_U3AMODE.getIREN : TBits_1; inline;
begin
  getIREN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2_U3AMODE.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U3AMODE.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U3AMODE.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U3AMODE.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U3AMODE.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U3AMODE.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U3AMODE.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U3AMODE.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U3AMODE.setPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2_U3AMODE.clearPDSEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2_U3AMODE.setPDSEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2_U3AMODE.getPDSEL0 : TBits_1; inline;
begin
  getPDSEL0 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2_U3AMODE.setPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2_U3AMODE.clearPDSEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2_U3AMODE.setPDSEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2_U3AMODE.getPDSEL1 : TBits_1; inline;
begin
  getPDSEL1 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2_U3AMODE.setUEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2_U3AMODE.clearUEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2_U3AMODE.setUEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2_U3AMODE.getUEN0 : TBits_1; inline;
begin
  getUEN0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2_U3AMODE.setUEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2_U3AMODE.clearUEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2_U3AMODE.setUEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2_U3AMODE.getUEN1 : TBits_1; inline;
begin
  getUEN1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2_U3AMODE.setUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U3AMODE.clearUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U3AMODE.setUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U3AMODE.getUSIDL : TBits_1; inline;
begin
  getUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U3AMODE.setUARTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U3AMODE.clearUARTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U3AMODE.setUARTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U3AMODE.getUARTEN : TBits_1; inline;
begin
  getUARTEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U3AMODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2_U3AMODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2_U2STA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2_U2STA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2_U2STA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2_U2STA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2_U2STA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2_U2STA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2_U2STA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2_U2STA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2_U2STA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2_U2STA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2_U2STA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2_U2STA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2_U2STA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2_U2STA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2_U2STA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2_U2STA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2_U2STA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2_U2STA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2_U2STA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2_U2STA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2_U2STA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2_U2STA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2_U2STA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2_U2STA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2_U2STA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART2_U2STA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART2_U2STA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2_U2STA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2_U2STA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2_U2STA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2_U2STA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2_U2STA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2_U2STA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2_U2STA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2_U2STA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART2_U2STA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART2_U2STA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART2_U2STA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART2_U2STA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2_U2STA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2_U2STA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2_U2STA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2_U2STA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2_U2STA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2_U2STA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2_U2STA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2_U2STA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U2STA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U2STA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U2STA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U2STA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2_U2STA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2_U2STA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART2_U2STA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART2_U2STA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART2_U2STA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART2_U2STA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART2_U2STA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART2_U2STA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2_U2STA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2_U2STA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2_U2STA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2_U2STA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2_U2STA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2_U2STA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2_U2STA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2_U2STA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART2_U2STA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART2_U2STA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART2_U2STA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART2_U2STA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U2STA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U2STA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U2STA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U2STA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2_U2STA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2_U2STA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2_U2STA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUART2_U3ASTA.setURXDA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUART2_U3ASTA.clearURXDA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUART2_U3ASTA.setURXDA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUART2_U3ASTA.getURXDA : TBits_1; inline;
begin
  getURXDA := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUART2_U3ASTA.setOERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUART2_U3ASTA.clearOERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUART2_U3ASTA.setOERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUART2_U3ASTA.getOERR : TBits_1; inline;
begin
  getOERR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUART2_U3ASTA.setFERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUART2_U3ASTA.clearFERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUART2_U3ASTA.setFERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUART2_U3ASTA.getFERR : TBits_1; inline;
begin
  getFERR := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUART2_U3ASTA.setPERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUART2_U3ASTA.clearPERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUART2_U3ASTA.setPERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUART2_U3ASTA.getPERR : TBits_1; inline;
begin
  getPERR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUART2_U3ASTA.setRIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUART2_U3ASTA.clearRIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUART2_U3ASTA.setRIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUART2_U3ASTA.getRIDLE : TBits_1; inline;
begin
  getRIDLE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUART2_U3ASTA.setADDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUART2_U3ASTA.clearADDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUART2_U3ASTA.setADDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUART2_U3ASTA.getADDEN : TBits_1; inline;
begin
  getADDEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUART2_U3ASTA.setURXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TUART2_U3ASTA.getURXISEL : TBits_2; inline;
begin
  getURXISEL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TUART2_U3ASTA.setTRMT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TUART2_U3ASTA.clearTRMT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TUART2_U3ASTA.setTRMT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TUART2_U3ASTA.getTRMT : TBits_1; inline;
begin
  getTRMT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TUART2_U3ASTA.setUTXBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TUART2_U3ASTA.clearUTXBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TUART2_U3ASTA.setUTXBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TUART2_U3ASTA.getUTXBF : TBits_1; inline;
begin
  getUTXBF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TUART2_U3ASTA.setUTXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TUART2_U3ASTA.clearUTXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TUART2_U3ASTA.setUTXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TUART2_U3ASTA.getUTXEN : TBits_1; inline;
begin
  getUTXEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TUART2_U3ASTA.setUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TUART2_U3ASTA.clearUTXBRK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TUART2_U3ASTA.setUTXBRK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TUART2_U3ASTA.getUTXBRK : TBits_1; inline;
begin
  getUTXBRK := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TUART2_U3ASTA.setURXEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TUART2_U3ASTA.clearURXEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TUART2_U3ASTA.setURXEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TUART2_U3ASTA.getURXEN : TBits_1; inline;
begin
  getURXEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TUART2_U3ASTA.setUTXINV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TUART2_U3ASTA.clearUTXINV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TUART2_U3ASTA.setUTXINV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TUART2_U3ASTA.getUTXINV : TBits_1; inline;
begin
  getUTXINV := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TUART2_U3ASTA.setUTXISEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2_U3ASTA.getUTXISEL : TBits_2; inline;
begin
  getUTXISEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2_U3ASTA.setADDR(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TUART2_U3ASTA.getADDR : TBits_8; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TUART2_U3ASTA.setADM_EN; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TUART2_U3ASTA.clearADM_EN; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TUART2_U3ASTA.setADM_EN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TUART2_U3ASTA.getADM_EN : TBits_1; inline;
begin
  getADM_EN := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TUART2_U3ASTA.setURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUART2_U3ASTA.clearURXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUART2_U3ASTA.setURXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUART2_U3ASTA.getURXISEL0 : TBits_1; inline;
begin
  getURXISEL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUART2_U3ASTA.setURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUART2_U3ASTA.clearURXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUART2_U3ASTA.setURXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUART2_U3ASTA.getURXISEL1 : TBits_1; inline;
begin
  getURXISEL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUART2_U3ASTA.setUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TUART2_U3ASTA.clearUTXISEL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TUART2_U3ASTA.setUTXISEL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TUART2_U3ASTA.getUTXISEL0 : TBits_1; inline;
begin
  getUTXISEL0 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TUART2_U3ASTA.setUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TUART2_U3ASTA.clearUTXISEL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TUART2_U3ASTA.setUTXISEL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TUART2_U3ASTA.getUTXISEL1 : TBits_1; inline;
begin
  getUTXISEL1 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TUART2_U3ASTA.setUTXSEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TUART2_U3ASTA.getUTXSEL : TBits_2; inline;
begin
  getUTXSEL := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TUART2_U3ASTA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TUART2_U3ASTA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMCON.setRDSP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPMP_PMCON.clearRDSP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPMP_PMCON.setRDSP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPMP_PMCON.getRDSP : TBits_1; inline;
begin
  getRDSP := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPMP_PMCON.setWRSP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPMP_PMCON.clearWRSP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPMP_PMCON.setWRSP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPMP_PMCON.getWRSP : TBits_1; inline;
begin
  getWRSP := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPMP_PMCON.setCS1P; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPMP_PMCON.clearCS1P; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPMP_PMCON.setCS1P(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPMP_PMCON.getCS1P : TBits_1; inline;
begin
  getCS1P := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPMP_PMCON.setALP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPMP_PMCON.clearALP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPMP_PMCON.setALP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPMP_PMCON.getALP : TBits_1; inline;
begin
  getALP := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPMP_PMCON.setCSF(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TPMP_PMCON.getCSF : TBits_2; inline;
begin
  getCSF := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TPMP_PMCON.setPTRDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPMP_PMCON.clearPTRDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPMP_PMCON.setPTRDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPMP_PMCON.getPTRDEN : TBits_1; inline;
begin
  getPTRDEN := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPMP_PMCON.setPTWREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPMP_PMCON.clearPTWREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPMP_PMCON.setPTWREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPMP_PMCON.getPTWREN : TBits_1; inline;
begin
  getPTWREN := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPMP_PMCON.setPMPTTL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPMP_PMCON.clearPMPTTL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPMP_PMCON.setPMPTTL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPMP_PMCON.getPMPTTL : TBits_1; inline;
begin
  getPMPTTL := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPMP_PMCON.setADRMUX(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE7FF or ( thebits shl 11 );
end;
function  TPMP_PMCON.getADRMUX : TBits_2; inline;
begin
  getADRMUX := (pTDefRegMap(@Self)^.val and $00001800) shr 11;
end;
procedure TPMP_PMCON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPMP_PMCON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPMP_PMCON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPMP_PMCON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPMP_PMCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMCON.setCSF0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPMP_PMCON.clearCSF0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPMP_PMCON.setCSF0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPMP_PMCON.getCSF0 : TBits_1; inline;
begin
  getCSF0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPMP_PMCON.setCSF1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPMP_PMCON.clearCSF1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPMP_PMCON.setCSF1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPMP_PMCON.getCSF1 : TBits_1; inline;
begin
  getCSF1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPMP_PMCON.setADRMUX0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPMP_PMCON.clearADRMUX0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPMP_PMCON.setADRMUX0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPMP_PMCON.getADRMUX0 : TBits_1; inline;
begin
  getADRMUX0 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPMP_PMCON.setADRMUX1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPMP_PMCON.clearADRMUX1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPMP_PMCON.setADRMUX1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPMP_PMCON.getADRMUX1 : TBits_1; inline;
begin
  getADRMUX1 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPMP_PMCON.setPSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPMP_PMCON.clearPSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPMP_PMCON.setPSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPMP_PMCON.getPSIDL : TBits_1; inline;
begin
  getPSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPMP_PMCON.setPMPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMCON.clearPMPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMCON.setPMPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMCON.getPMPEN : TBits_1; inline;
begin
  getPMPEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMMODE.setWAITE(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TPMP_PMMODE.getWAITE : TBits_2; inline;
begin
  getWAITE := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TPMP_PMMODE.setWAITM(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFC3 or ( thebits shl 2 );
end;
function  TPMP_PMMODE.getWAITM : TBits_4; inline;
begin
  getWAITM := (pTDefRegMap(@Self)^.val and $0000003C) shr 2;
end;
procedure TPMP_PMMODE.setWAITB(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TPMP_PMMODE.getWAITB : TBits_2; inline;
begin
  getWAITB := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TPMP_PMMODE.setMODE(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TPMP_PMMODE.getMODE : TBits_2; inline;
begin
  getMODE := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TPMP_PMMODE.setINCM(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE7FF or ( thebits shl 11 );
end;
function  TPMP_PMMODE.getINCM : TBits_2; inline;
begin
  getINCM := (pTDefRegMap(@Self)^.val and $00001800) shr 11;
end;
procedure TPMP_PMMODE.setIRQM(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF9FFF or ( thebits shl 13 );
end;
function  TPMP_PMMODE.getIRQM : TBits_2; inline;
begin
  getIRQM := (pTDefRegMap(@Self)^.val and $00006000) shr 13;
end;
procedure TPMP_PMMODE.setBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMMODE.clearBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMMODE.setBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMMODE.getBUSY : TBits_1; inline;
begin
  getBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMMODE.setWAITE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPMP_PMMODE.clearWAITE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPMP_PMMODE.setWAITE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPMP_PMMODE.getWAITE0 : TBits_1; inline;
begin
  getWAITE0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPMP_PMMODE.setWAITE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPMP_PMMODE.clearWAITE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPMP_PMMODE.setWAITE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPMP_PMMODE.getWAITE1 : TBits_1; inline;
begin
  getWAITE1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPMP_PMMODE.setWAITM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPMP_PMMODE.clearWAITM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPMP_PMMODE.setWAITM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPMP_PMMODE.getWAITM0 : TBits_1; inline;
begin
  getWAITM0 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPMP_PMMODE.setWAITM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPMP_PMMODE.clearWAITM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPMP_PMMODE.setWAITM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPMP_PMMODE.getWAITM1 : TBits_1; inline;
begin
  getWAITM1 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPMP_PMMODE.setWAITM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPMP_PMMODE.clearWAITM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPMP_PMMODE.setWAITM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPMP_PMMODE.getWAITM2 : TBits_1; inline;
begin
  getWAITM2 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPMP_PMMODE.setWAITM3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPMP_PMMODE.clearWAITM3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPMP_PMMODE.setWAITM3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPMP_PMMODE.getWAITM3 : TBits_1; inline;
begin
  getWAITM3 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPMP_PMMODE.setWAITB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPMP_PMMODE.clearWAITB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPMP_PMMODE.setWAITB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPMP_PMMODE.getWAITB0 : TBits_1; inline;
begin
  getWAITB0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPMP_PMMODE.setWAITB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPMP_PMMODE.clearWAITB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPMP_PMMODE.setWAITB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPMP_PMMODE.getWAITB1 : TBits_1; inline;
begin
  getWAITB1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPMP_PMMODE.setMODE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPMP_PMMODE.clearMODE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPMP_PMMODE.setMODE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPMP_PMMODE.getMODE0 : TBits_1; inline;
begin
  getMODE0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPMP_PMMODE.setMODE1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPMP_PMMODE.clearMODE1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPMP_PMMODE.setMODE1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPMP_PMMODE.getMODE1 : TBits_1; inline;
begin
  getMODE1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPMP_PMMODE.setINCM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPMP_PMMODE.clearINCM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPMP_PMMODE.setINCM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPMP_PMMODE.getINCM0 : TBits_1; inline;
begin
  getINCM0 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPMP_PMMODE.setINCM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPMP_PMMODE.clearINCM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPMP_PMMODE.setINCM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPMP_PMMODE.getINCM1 : TBits_1; inline;
begin
  getINCM1 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPMP_PMMODE.setIRQM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPMP_PMMODE.clearIRQM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPMP_PMMODE.setIRQM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPMP_PMMODE.getIRQM0 : TBits_1; inline;
begin
  getIRQM0 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPMP_PMMODE.setIRQM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPMP_PMMODE.clearIRQM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPMP_PMMODE.setIRQM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPMP_PMMODE.getIRQM1 : TBits_1; inline;
begin
  getIRQM1 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPMP_PMMODE.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMMODE.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMADDR.setADDR(thebits : TBits_14); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFC000 or ( thebits shl 0 );
end;
function  TPMP_PMADDR.getADDR : TBits_14; inline;
begin
  getADDR := (pTDefRegMap(@Self)^.val and $00003FFF) shr 0;
end;
procedure TPMP_PMADDR.setCS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TPMP_PMADDR.getCS : TBits_2; inline;
begin
  getCS := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TPMP_PMADDR.setPADDR(thebits : TBits_14); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFC000 or ( thebits shl 0 );
end;
function  TPMP_PMADDR.getPADDR : TBits_14; inline;
begin
  getPADDR := (pTDefRegMap(@Self)^.val and $00003FFF) shr 0;
end;
procedure TPMP_PMADDR.setCS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPMP_PMADDR.clearCS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPMP_PMADDR.setCS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPMP_PMADDR.getCS1 : TBits_1; inline;
begin
  getCS1 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPMP_PMADDR.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMADDR.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMDOUT.setDATAOUT(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMDOUT.getDATAOUT : TBits_32; inline;
begin
  getDATAOUT := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMDOUT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMDOUT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMDIN.setDATAIN(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMDIN.getDATAIN : TBits_32; inline;
begin
  getDATAIN := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMDIN.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMDIN.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMAEN.setPTEN(thebits : TBits_16); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0000 or ( thebits shl 0 );
end;
function  TPMP_PMAEN.getPTEN : TBits_16; inline;
begin
  getPTEN := (pTDefRegMap(@Self)^.val and $0000FFFF) shr 0;
end;
procedure TPMP_PMAEN.setPTEN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPMP_PMAEN.clearPTEN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPMP_PMAEN.setPTEN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPMP_PMAEN.getPTEN0 : TBits_1; inline;
begin
  getPTEN0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPMP_PMAEN.setPTEN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPMP_PMAEN.clearPTEN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPMP_PMAEN.setPTEN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPMP_PMAEN.getPTEN1 : TBits_1; inline;
begin
  getPTEN1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPMP_PMAEN.setPTEN2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPMP_PMAEN.clearPTEN2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPMP_PMAEN.setPTEN2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPMP_PMAEN.getPTEN2 : TBits_1; inline;
begin
  getPTEN2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPMP_PMAEN.setPTEN3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPMP_PMAEN.clearPTEN3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPMP_PMAEN.setPTEN3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPMP_PMAEN.getPTEN3 : TBits_1; inline;
begin
  getPTEN3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPMP_PMAEN.setPTEN4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPMP_PMAEN.clearPTEN4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPMP_PMAEN.setPTEN4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPMP_PMAEN.getPTEN4 : TBits_1; inline;
begin
  getPTEN4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPMP_PMAEN.setPTEN5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPMP_PMAEN.clearPTEN5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPMP_PMAEN.setPTEN5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPMP_PMAEN.getPTEN5 : TBits_1; inline;
begin
  getPTEN5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPMP_PMAEN.setPTEN6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPMP_PMAEN.clearPTEN6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPMP_PMAEN.setPTEN6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPMP_PMAEN.getPTEN6 : TBits_1; inline;
begin
  getPTEN6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPMP_PMAEN.setPTEN7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPMP_PMAEN.clearPTEN7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPMP_PMAEN.setPTEN7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPMP_PMAEN.getPTEN7 : TBits_1; inline;
begin
  getPTEN7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPMP_PMAEN.setPTEN8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPMP_PMAEN.clearPTEN8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPMP_PMAEN.setPTEN8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPMP_PMAEN.getPTEN8 : TBits_1; inline;
begin
  getPTEN8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPMP_PMAEN.setPTEN9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPMP_PMAEN.clearPTEN9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPMP_PMAEN.setPTEN9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPMP_PMAEN.getPTEN9 : TBits_1; inline;
begin
  getPTEN9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPMP_PMAEN.setPTEN10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPMP_PMAEN.clearPTEN10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPMP_PMAEN.setPTEN10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPMP_PMAEN.getPTEN10 : TBits_1; inline;
begin
  getPTEN10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPMP_PMAEN.setPTEN11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPMP_PMAEN.clearPTEN11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPMP_PMAEN.setPTEN11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPMP_PMAEN.getPTEN11 : TBits_1; inline;
begin
  getPTEN11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPMP_PMAEN.setPTEN12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TPMP_PMAEN.clearPTEN12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TPMP_PMAEN.setPTEN12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TPMP_PMAEN.getPTEN12 : TBits_1; inline;
begin
  getPTEN12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TPMP_PMAEN.setPTEN13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPMP_PMAEN.clearPTEN13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPMP_PMAEN.setPTEN13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPMP_PMAEN.getPTEN13 : TBits_1; inline;
begin
  getPTEN13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPMP_PMAEN.setPTEN14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPMP_PMAEN.clearPTEN14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPMP_PMAEN.setPTEN14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPMP_PMAEN.getPTEN14 : TBits_1; inline;
begin
  getPTEN14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPMP_PMAEN.setPTEN15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMAEN.clearPTEN15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMAEN.setPTEN15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMAEN.getPTEN15 : TBits_1; inline;
begin
  getPTEN15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMAEN.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMAEN.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPMP_PMSTAT.setOB0E; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPMP_PMSTAT.clearOB0E; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPMP_PMSTAT.setOB0E(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPMP_PMSTAT.getOB0E : TBits_1; inline;
begin
  getOB0E := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPMP_PMSTAT.setOB1E; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPMP_PMSTAT.clearOB1E; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPMP_PMSTAT.setOB1E(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPMP_PMSTAT.getOB1E : TBits_1; inline;
begin
  getOB1E := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPMP_PMSTAT.setOB2E; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPMP_PMSTAT.clearOB2E; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPMP_PMSTAT.setOB2E(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPMP_PMSTAT.getOB2E : TBits_1; inline;
begin
  getOB2E := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPMP_PMSTAT.setOB3E; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPMP_PMSTAT.clearOB3E; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPMP_PMSTAT.setOB3E(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPMP_PMSTAT.getOB3E : TBits_1; inline;
begin
  getOB3E := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPMP_PMSTAT.setOBUF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TPMP_PMSTAT.clearOBUF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TPMP_PMSTAT.setOBUF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TPMP_PMSTAT.getOBUF : TBits_1; inline;
begin
  getOBUF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TPMP_PMSTAT.setOBE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPMP_PMSTAT.clearOBE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPMP_PMSTAT.setOBE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPMP_PMSTAT.getOBE : TBits_1; inline;
begin
  getOBE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPMP_PMSTAT.setIB0F; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPMP_PMSTAT.clearIB0F; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPMP_PMSTAT.setIB0F(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPMP_PMSTAT.getIB0F : TBits_1; inline;
begin
  getIB0F := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPMP_PMSTAT.setIB1F; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPMP_PMSTAT.clearIB1F; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPMP_PMSTAT.setIB1F(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPMP_PMSTAT.getIB1F : TBits_1; inline;
begin
  getIB1F := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPMP_PMSTAT.setIB2F; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPMP_PMSTAT.clearIB2F; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPMP_PMSTAT.setIB2F(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPMP_PMSTAT.getIB2F : TBits_1; inline;
begin
  getIB2F := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPMP_PMSTAT.setIB3F; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPMP_PMSTAT.clearIB3F; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPMP_PMSTAT.setIB3F(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPMP_PMSTAT.getIB3F : TBits_1; inline;
begin
  getIB3F := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPMP_PMSTAT.setIBOV; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPMP_PMSTAT.clearIBOV; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPMP_PMSTAT.setIBOV(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPMP_PMSTAT.getIBOV : TBits_1; inline;
begin
  getIBOV := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPMP_PMSTAT.setIBF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPMP_PMSTAT.clearIBF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPMP_PMSTAT.setIBF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPMP_PMSTAT.getIBF : TBits_1; inline;
begin
  getIBF := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPMP_PMSTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPMP_PMSTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CON1.setDONE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TADC10_AD1CON1.clearDONE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TADC10_AD1CON1.setDONE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TADC10_AD1CON1.getDONE : TBits_1; inline;
begin
  getDONE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TADC10_AD1CON1.setSAMP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TADC10_AD1CON1.clearSAMP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TADC10_AD1CON1.setSAMP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TADC10_AD1CON1.getSAMP : TBits_1; inline;
begin
  getSAMP := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TADC10_AD1CON1.setASAM; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TADC10_AD1CON1.clearASAM; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TADC10_AD1CON1.setASAM(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TADC10_AD1CON1.getASAM : TBits_1; inline;
begin
  getASAM := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TADC10_AD1CON1.setCLRASAM; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TADC10_AD1CON1.clearCLRASAM; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TADC10_AD1CON1.setCLRASAM(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TADC10_AD1CON1.getCLRASAM : TBits_1; inline;
begin
  getCLRASAM := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TADC10_AD1CON1.setSSRC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF1F or ( thebits shl 5 );
end;
function  TADC10_AD1CON1.getSSRC : TBits_3; inline;
begin
  getSSRC := (pTDefRegMap(@Self)^.val and $000000E0) shr 5;
end;
procedure TADC10_AD1CON1.setFORM(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF8FF or ( thebits shl 8 );
end;
function  TADC10_AD1CON1.getFORM : TBits_3; inline;
begin
  getFORM := (pTDefRegMap(@Self)^.val and $00000700) shr 8;
end;
procedure TADC10_AD1CON1.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TADC10_AD1CON1.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TADC10_AD1CON1.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TADC10_AD1CON1.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TADC10_AD1CON1.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CON1.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CON1.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CON1.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CON1.setSSRC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TADC10_AD1CON1.clearSSRC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TADC10_AD1CON1.setSSRC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TADC10_AD1CON1.getSSRC0 : TBits_1; inline;
begin
  getSSRC0 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TADC10_AD1CON1.setSSRC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TADC10_AD1CON1.clearSSRC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TADC10_AD1CON1.setSSRC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TADC10_AD1CON1.getSSRC1 : TBits_1; inline;
begin
  getSSRC1 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TADC10_AD1CON1.setSSRC2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TADC10_AD1CON1.clearSSRC2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TADC10_AD1CON1.setSSRC2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TADC10_AD1CON1.getSSRC2 : TBits_1; inline;
begin
  getSSRC2 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TADC10_AD1CON1.setFORM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TADC10_AD1CON1.clearFORM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TADC10_AD1CON1.setFORM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TADC10_AD1CON1.getFORM0 : TBits_1; inline;
begin
  getFORM0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TADC10_AD1CON1.setFORM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TADC10_AD1CON1.clearFORM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TADC10_AD1CON1.setFORM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TADC10_AD1CON1.getFORM1 : TBits_1; inline;
begin
  getFORM1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TADC10_AD1CON1.setFORM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TADC10_AD1CON1.clearFORM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TADC10_AD1CON1.setFORM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TADC10_AD1CON1.getFORM2 : TBits_1; inline;
begin
  getFORM2 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TADC10_AD1CON1.setADSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TADC10_AD1CON1.clearADSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TADC10_AD1CON1.setADSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TADC10_AD1CON1.getADSIDL : TBits_1; inline;
begin
  getADSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TADC10_AD1CON1.setADON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CON1.clearADON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CON1.setADON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CON1.getADON : TBits_1; inline;
begin
  getADON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CON1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CON1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CON2.setALTS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TADC10_AD1CON2.clearALTS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TADC10_AD1CON2.setALTS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TADC10_AD1CON2.getALTS : TBits_1; inline;
begin
  getALTS := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TADC10_AD1CON2.setBUFM; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TADC10_AD1CON2.clearBUFM; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TADC10_AD1CON2.setBUFM(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TADC10_AD1CON2.getBUFM : TBits_1; inline;
begin
  getBUFM := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TADC10_AD1CON2.setSMPI(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFC3 or ( thebits shl 2 );
end;
function  TADC10_AD1CON2.getSMPI : TBits_4; inline;
begin
  getSMPI := (pTDefRegMap(@Self)^.val and $0000003C) shr 2;
end;
procedure TADC10_AD1CON2.setBUFS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TADC10_AD1CON2.clearBUFS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TADC10_AD1CON2.setBUFS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TADC10_AD1CON2.getBUFS : TBits_1; inline;
begin
  getBUFS := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TADC10_AD1CON2.setCSCNA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TADC10_AD1CON2.clearCSCNA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TADC10_AD1CON2.setCSCNA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TADC10_AD1CON2.getCSCNA : TBits_1; inline;
begin
  getCSCNA := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TADC10_AD1CON2.setOFFCAL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TADC10_AD1CON2.clearOFFCAL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TADC10_AD1CON2.setOFFCAL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TADC10_AD1CON2.getOFFCAL : TBits_1; inline;
begin
  getOFFCAL := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TADC10_AD1CON2.setVCFG(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF1FFF or ( thebits shl 13 );
end;
function  TADC10_AD1CON2.getVCFG : TBits_3; inline;
begin
  getVCFG := (pTDefRegMap(@Self)^.val and $0000E000) shr 13;
end;
procedure TADC10_AD1CON2.setSMPI0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TADC10_AD1CON2.clearSMPI0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TADC10_AD1CON2.setSMPI0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TADC10_AD1CON2.getSMPI0 : TBits_1; inline;
begin
  getSMPI0 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TADC10_AD1CON2.setSMPI1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TADC10_AD1CON2.clearSMPI1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TADC10_AD1CON2.setSMPI1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TADC10_AD1CON2.getSMPI1 : TBits_1; inline;
begin
  getSMPI1 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TADC10_AD1CON2.setSMPI2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TADC10_AD1CON2.clearSMPI2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TADC10_AD1CON2.setSMPI2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TADC10_AD1CON2.getSMPI2 : TBits_1; inline;
begin
  getSMPI2 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TADC10_AD1CON2.setSMPI3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TADC10_AD1CON2.clearSMPI3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TADC10_AD1CON2.setSMPI3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TADC10_AD1CON2.getSMPI3 : TBits_1; inline;
begin
  getSMPI3 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TADC10_AD1CON2.setVCFG0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TADC10_AD1CON2.clearVCFG0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TADC10_AD1CON2.setVCFG0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TADC10_AD1CON2.getVCFG0 : TBits_1; inline;
begin
  getVCFG0 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TADC10_AD1CON2.setVCFG1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TADC10_AD1CON2.clearVCFG1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TADC10_AD1CON2.setVCFG1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TADC10_AD1CON2.getVCFG1 : TBits_1; inline;
begin
  getVCFG1 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TADC10_AD1CON2.setVCFG2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CON2.clearVCFG2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CON2.setVCFG2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CON2.getVCFG2 : TBits_1; inline;
begin
  getVCFG2 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CON2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CON2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CON3.setADCS(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF00 or ( thebits shl 0 );
end;
function  TADC10_AD1CON3.getADCS : TBits_8; inline;
begin
  getADCS := (pTDefRegMap(@Self)^.val and $000000FF) shr 0;
end;
procedure TADC10_AD1CON3.setSAMC(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TADC10_AD1CON3.getSAMC : TBits_5; inline;
begin
  getSAMC := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TADC10_AD1CON3.setADRC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CON3.clearADRC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CON3.setADRC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CON3.getADRC : TBits_1; inline;
begin
  getADRC := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CON3.setADCS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TADC10_AD1CON3.clearADCS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TADC10_AD1CON3.setADCS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TADC10_AD1CON3.getADCS0 : TBits_1; inline;
begin
  getADCS0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TADC10_AD1CON3.setADCS1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TADC10_AD1CON3.clearADCS1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TADC10_AD1CON3.setADCS1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TADC10_AD1CON3.getADCS1 : TBits_1; inline;
begin
  getADCS1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TADC10_AD1CON3.setADCS2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TADC10_AD1CON3.clearADCS2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TADC10_AD1CON3.setADCS2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TADC10_AD1CON3.getADCS2 : TBits_1; inline;
begin
  getADCS2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TADC10_AD1CON3.setADCS3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TADC10_AD1CON3.clearADCS3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TADC10_AD1CON3.setADCS3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TADC10_AD1CON3.getADCS3 : TBits_1; inline;
begin
  getADCS3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TADC10_AD1CON3.setADCS4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TADC10_AD1CON3.clearADCS4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TADC10_AD1CON3.setADCS4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TADC10_AD1CON3.getADCS4 : TBits_1; inline;
begin
  getADCS4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TADC10_AD1CON3.setADCS5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TADC10_AD1CON3.clearADCS5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TADC10_AD1CON3.setADCS5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TADC10_AD1CON3.getADCS5 : TBits_1; inline;
begin
  getADCS5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TADC10_AD1CON3.setADCS6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TADC10_AD1CON3.clearADCS6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TADC10_AD1CON3.setADCS6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TADC10_AD1CON3.getADCS6 : TBits_1; inline;
begin
  getADCS6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TADC10_AD1CON3.setADCS7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TADC10_AD1CON3.clearADCS7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TADC10_AD1CON3.setADCS7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TADC10_AD1CON3.getADCS7 : TBits_1; inline;
begin
  getADCS7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TADC10_AD1CON3.setSAMC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TADC10_AD1CON3.clearSAMC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TADC10_AD1CON3.setSAMC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TADC10_AD1CON3.getSAMC0 : TBits_1; inline;
begin
  getSAMC0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TADC10_AD1CON3.setSAMC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TADC10_AD1CON3.clearSAMC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TADC10_AD1CON3.setSAMC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TADC10_AD1CON3.getSAMC1 : TBits_1; inline;
begin
  getSAMC1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TADC10_AD1CON3.setSAMC2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TADC10_AD1CON3.clearSAMC2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TADC10_AD1CON3.setSAMC2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TADC10_AD1CON3.getSAMC2 : TBits_1; inline;
begin
  getSAMC2 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TADC10_AD1CON3.setSAMC3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TADC10_AD1CON3.clearSAMC3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TADC10_AD1CON3.setSAMC3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TADC10_AD1CON3.getSAMC3 : TBits_1; inline;
begin
  getSAMC3 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TADC10_AD1CON3.setSAMC4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TADC10_AD1CON3.clearSAMC4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TADC10_AD1CON3.setSAMC4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TADC10_AD1CON3.getSAMC4 : TBits_1; inline;
begin
  getSAMC4 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TADC10_AD1CON3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CON3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CHS.setCH0SA(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF0FFFF or ( thebits shl 16 );
end;
function  TADC10_AD1CHS.getCH0SA : TBits_4; inline;
begin
  getCH0SA := (pTDefRegMap(@Self)^.val and $000F0000) shr 16;
end;
procedure TADC10_AD1CHS.setCH0NA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TADC10_AD1CHS.clearCH0NA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TADC10_AD1CHS.setCH0NA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TADC10_AD1CHS.getCH0NA : TBits_1; inline;
begin
  getCH0NA := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TADC10_AD1CHS.setCH0SB(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F0FFFFFF or ( thebits shl 24 );
end;
function  TADC10_AD1CHS.getCH0SB : TBits_4; inline;
begin
  getCH0SB := (pTDefRegMap(@Self)^.val and $0F000000) shr 24;
end;
procedure TADC10_AD1CHS.setCH0NB; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TADC10_AD1CHS.clearCH0NB; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TADC10_AD1CHS.setCH0NB(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TADC10_AD1CHS.getCH0NB : TBits_1; inline;
begin
  getCH0NB := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TADC10_AD1CHS.setCH0SA0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TADC10_AD1CHS.clearCH0SA0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TADC10_AD1CHS.setCH0SA0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TADC10_AD1CHS.getCH0SA0 : TBits_1; inline;
begin
  getCH0SA0 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TADC10_AD1CHS.setCH0SA1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TADC10_AD1CHS.clearCH0SA1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TADC10_AD1CHS.setCH0SA1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TADC10_AD1CHS.getCH0SA1 : TBits_1; inline;
begin
  getCH0SA1 := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TADC10_AD1CHS.setCH0SA2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TADC10_AD1CHS.clearCH0SA2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TADC10_AD1CHS.setCH0SA2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TADC10_AD1CHS.getCH0SA2 : TBits_1; inline;
begin
  getCH0SA2 := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TADC10_AD1CHS.setCH0SA3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TADC10_AD1CHS.clearCH0SA3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TADC10_AD1CHS.setCH0SA3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TADC10_AD1CHS.getCH0SA3 : TBits_1; inline;
begin
  getCH0SA3 := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TADC10_AD1CHS.setCH0SB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TADC10_AD1CHS.clearCH0SB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TADC10_AD1CHS.setCH0SB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TADC10_AD1CHS.getCH0SB0 : TBits_1; inline;
begin
  getCH0SB0 := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TADC10_AD1CHS.setCH0SB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TADC10_AD1CHS.clearCH0SB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TADC10_AD1CHS.setCH0SB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TADC10_AD1CHS.getCH0SB1 : TBits_1; inline;
begin
  getCH0SB1 := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TADC10_AD1CHS.setCH0SB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TADC10_AD1CHS.clearCH0SB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TADC10_AD1CHS.setCH0SB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TADC10_AD1CHS.getCH0SB2 : TBits_1; inline;
begin
  getCH0SB2 := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TADC10_AD1CHS.setCH0SB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TADC10_AD1CHS.clearCH0SB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TADC10_AD1CHS.setCH0SB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TADC10_AD1CHS.getCH0SB3 : TBits_1; inline;
begin
  getCH0SB3 := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TADC10_AD1CHS.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CHS.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TADC10_AD1CSSL.setCSSL(thebits : TBits_16); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0000 or ( thebits shl 0 );
end;
function  TADC10_AD1CSSL.getCSSL : TBits_16; inline;
begin
  getCSSL := (pTDefRegMap(@Self)^.val and $0000FFFF) shr 0;
end;
procedure TADC10_AD1CSSL.setCSSL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TADC10_AD1CSSL.clearCSSL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TADC10_AD1CSSL.setCSSL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TADC10_AD1CSSL.getCSSL0 : TBits_1; inline;
begin
  getCSSL0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TADC10_AD1CSSL.setCSSL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TADC10_AD1CSSL.clearCSSL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TADC10_AD1CSSL.setCSSL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TADC10_AD1CSSL.getCSSL1 : TBits_1; inline;
begin
  getCSSL1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TADC10_AD1CSSL.setCSSL2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TADC10_AD1CSSL.clearCSSL2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TADC10_AD1CSSL.setCSSL2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TADC10_AD1CSSL.getCSSL2 : TBits_1; inline;
begin
  getCSSL2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TADC10_AD1CSSL.setCSSL3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TADC10_AD1CSSL.clearCSSL3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TADC10_AD1CSSL.setCSSL3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TADC10_AD1CSSL.getCSSL3 : TBits_1; inline;
begin
  getCSSL3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TADC10_AD1CSSL.setCSSL4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TADC10_AD1CSSL.clearCSSL4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TADC10_AD1CSSL.setCSSL4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TADC10_AD1CSSL.getCSSL4 : TBits_1; inline;
begin
  getCSSL4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TADC10_AD1CSSL.setCSSL5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TADC10_AD1CSSL.clearCSSL5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TADC10_AD1CSSL.setCSSL5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TADC10_AD1CSSL.getCSSL5 : TBits_1; inline;
begin
  getCSSL5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TADC10_AD1CSSL.setCSSL6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TADC10_AD1CSSL.clearCSSL6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TADC10_AD1CSSL.setCSSL6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TADC10_AD1CSSL.getCSSL6 : TBits_1; inline;
begin
  getCSSL6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TADC10_AD1CSSL.setCSSL7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TADC10_AD1CSSL.clearCSSL7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TADC10_AD1CSSL.setCSSL7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TADC10_AD1CSSL.getCSSL7 : TBits_1; inline;
begin
  getCSSL7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TADC10_AD1CSSL.setCSSL8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TADC10_AD1CSSL.clearCSSL8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TADC10_AD1CSSL.setCSSL8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TADC10_AD1CSSL.getCSSL8 : TBits_1; inline;
begin
  getCSSL8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TADC10_AD1CSSL.setCSSL9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TADC10_AD1CSSL.clearCSSL9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TADC10_AD1CSSL.setCSSL9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TADC10_AD1CSSL.getCSSL9 : TBits_1; inline;
begin
  getCSSL9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TADC10_AD1CSSL.setCSSL10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TADC10_AD1CSSL.clearCSSL10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TADC10_AD1CSSL.setCSSL10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TADC10_AD1CSSL.getCSSL10 : TBits_1; inline;
begin
  getCSSL10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TADC10_AD1CSSL.setCSSL11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TADC10_AD1CSSL.clearCSSL11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TADC10_AD1CSSL.setCSSL11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TADC10_AD1CSSL.getCSSL11 : TBits_1; inline;
begin
  getCSSL11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TADC10_AD1CSSL.setCSSL12; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TADC10_AD1CSSL.clearCSSL12; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TADC10_AD1CSSL.setCSSL12(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TADC10_AD1CSSL.getCSSL12 : TBits_1; inline;
begin
  getCSSL12 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TADC10_AD1CSSL.setCSSL13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TADC10_AD1CSSL.clearCSSL13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TADC10_AD1CSSL.setCSSL13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TADC10_AD1CSSL.getCSSL13 : TBits_1; inline;
begin
  getCSSL13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TADC10_AD1CSSL.setCSSL14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TADC10_AD1CSSL.clearCSSL14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TADC10_AD1CSSL.setCSSL14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TADC10_AD1CSSL.getCSSL14 : TBits_1; inline;
begin
  getCSSL14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TADC10_AD1CSSL.setCSSL15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TADC10_AD1CSSL.clearCSSL15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TADC10_AD1CSSL.setCSSL15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TADC10_AD1CSSL.getCSSL15 : TBits_1; inline;
begin
  getCSSL15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TADC10_AD1CSSL.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TADC10_AD1CSSL.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCVR_CVRCON.setCVR(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TCVR_CVRCON.getCVR : TBits_4; inline;
begin
  getCVR := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TCVR_CVRCON.setCVRSS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCVR_CVRCON.clearCVRSS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCVR_CVRCON.setCVRSS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCVR_CVRCON.getCVRSS : TBits_1; inline;
begin
  getCVRSS := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCVR_CVRCON.setCVRR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TCVR_CVRCON.clearCVRR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TCVR_CVRCON.setCVRR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TCVR_CVRCON.getCVRR : TBits_1; inline;
begin
  getCVRR := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TCVR_CVRCON.setCVROE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCVR_CVRCON.clearCVROE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCVR_CVRCON.setCVROE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCVR_CVRCON.getCVROE : TBits_1; inline;
begin
  getCVROE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCVR_CVRCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCVR_CVRCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCVR_CVRCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCVR_CVRCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCVR_CVRCON.setCVR0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCVR_CVRCON.clearCVR0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCVR_CVRCON.setCVR0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCVR_CVRCON.getCVR0 : TBits_1; inline;
begin
  getCVR0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCVR_CVRCON.setCVR1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCVR_CVRCON.clearCVR1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCVR_CVRCON.setCVR1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCVR_CVRCON.getCVR1 : TBits_1; inline;
begin
  getCVR1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCVR_CVRCON.setCVR2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCVR_CVRCON.clearCVR2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCVR_CVRCON.setCVR2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCVR_CVRCON.getCVR2 : TBits_1; inline;
begin
  getCVR2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCVR_CVRCON.setCVR3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TCVR_CVRCON.clearCVR3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TCVR_CVRCON.setCVR3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TCVR_CVRCON.getCVR3 : TBits_1; inline;
begin
  getCVR3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TCVR_CVRCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCVR_CVRCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCMP_CM1CON.setCCH(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCMP_CM1CON.getCCH : TBits_2; inline;
begin
  getCCH := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCMP_CM1CON.setCREF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCMP_CM1CON.clearCREF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCMP_CM1CON.setCREF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCMP_CM1CON.getCREF : TBits_1; inline;
begin
  getCREF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCMP_CM1CON.setEVPOL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TCMP_CM1CON.getEVPOL : TBits_2; inline;
begin
  getEVPOL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TCMP_CM1CON.setCOUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCMP_CM1CON.clearCOUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCMP_CM1CON.setCOUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCMP_CM1CON.getCOUT : TBits_1; inline;
begin
  getCOUT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCMP_CM1CON.setCPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCMP_CM1CON.clearCPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCMP_CM1CON.setCPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCMP_CM1CON.getCPOL : TBits_1; inline;
begin
  getCPOL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCMP_CM1CON.setCOE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCMP_CM1CON.clearCOE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCMP_CM1CON.setCOE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCMP_CM1CON.getCOE : TBits_1; inline;
begin
  getCOE := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCMP_CM1CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCMP_CM1CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCMP_CM1CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCMP_CM1CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCMP_CM1CON.setCCH0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCMP_CM1CON.clearCCH0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCMP_CM1CON.setCCH0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCMP_CM1CON.getCCH0 : TBits_1; inline;
begin
  getCCH0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCMP_CM1CON.setCCH1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCMP_CM1CON.clearCCH1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCMP_CM1CON.setCCH1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCMP_CM1CON.getCCH1 : TBits_1; inline;
begin
  getCCH1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCMP_CM1CON.setEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCMP_CM1CON.clearEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCMP_CM1CON.setEVPOL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCMP_CM1CON.getEVPOL0 : TBits_1; inline;
begin
  getEVPOL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCMP_CM1CON.setEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCMP_CM1CON.clearEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCMP_CM1CON.setEVPOL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCMP_CM1CON.getEVPOL1 : TBits_1; inline;
begin
  getEVPOL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCMP_CM1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCMP_CM1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCMP_CM2CON.setCCH(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCMP_CM2CON.getCCH : TBits_2; inline;
begin
  getCCH := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCMP_CM2CON.setCREF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCMP_CM2CON.clearCREF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCMP_CM2CON.setCREF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCMP_CM2CON.getCREF : TBits_1; inline;
begin
  getCREF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCMP_CM2CON.setEVPOL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TCMP_CM2CON.getEVPOL : TBits_2; inline;
begin
  getEVPOL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TCMP_CM2CON.setCOUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCMP_CM2CON.clearCOUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCMP_CM2CON.setCOUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCMP_CM2CON.getCOUT : TBits_1; inline;
begin
  getCOUT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCMP_CM2CON.setCPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCMP_CM2CON.clearCPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCMP_CM2CON.setCPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCMP_CM2CON.getCPOL : TBits_1; inline;
begin
  getCPOL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCMP_CM2CON.setCOE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCMP_CM2CON.clearCOE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCMP_CM2CON.setCOE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCMP_CM2CON.getCOE : TBits_1; inline;
begin
  getCOE := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCMP_CM2CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCMP_CM2CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCMP_CM2CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCMP_CM2CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCMP_CM2CON.setCCH0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCMP_CM2CON.clearCCH0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCMP_CM2CON.setCCH0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCMP_CM2CON.getCCH0 : TBits_1; inline;
begin
  getCCH0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCMP_CM2CON.setCCH1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCMP_CM2CON.clearCCH1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCMP_CM2CON.setCCH1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCMP_CM2CON.getCCH1 : TBits_1; inline;
begin
  getCCH1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCMP_CM2CON.setEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCMP_CM2CON.clearEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCMP_CM2CON.setEVPOL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCMP_CM2CON.getEVPOL0 : TBits_1; inline;
begin
  getEVPOL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCMP_CM2CON.setEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCMP_CM2CON.clearEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCMP_CM2CON.setEVPOL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCMP_CM2CON.getEVPOL1 : TBits_1; inline;
begin
  getEVPOL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCMP_CM2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCMP_CM2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCMP_CM3CON.setCCH(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCMP_CM3CON.getCCH : TBits_2; inline;
begin
  getCCH := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCMP_CM3CON.setCREF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TCMP_CM3CON.clearCREF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TCMP_CM3CON.setCREF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TCMP_CM3CON.getCREF : TBits_1; inline;
begin
  getCREF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TCMP_CM3CON.setEVPOL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF3F or ( thebits shl 6 );
end;
function  TCMP_CM3CON.getEVPOL : TBits_2; inline;
begin
  getEVPOL := (pTDefRegMap(@Self)^.val and $000000C0) shr 6;
end;
procedure TCMP_CM3CON.setCOUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCMP_CM3CON.clearCOUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCMP_CM3CON.setCOUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCMP_CM3CON.getCOUT : TBits_1; inline;
begin
  getCOUT := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCMP_CM3CON.setCPOL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCMP_CM3CON.clearCPOL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCMP_CM3CON.setCPOL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCMP_CM3CON.getCPOL : TBits_1; inline;
begin
  getCPOL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCMP_CM3CON.setCOE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TCMP_CM3CON.clearCOE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TCMP_CM3CON.setCOE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TCMP_CM3CON.getCOE : TBits_1; inline;
begin
  getCOE := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TCMP_CM3CON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCMP_CM3CON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCMP_CM3CON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCMP_CM3CON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCMP_CM3CON.setCCH0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCMP_CM3CON.clearCCH0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCMP_CM3CON.setCCH0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCMP_CM3CON.getCCH0 : TBits_1; inline;
begin
  getCCH0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCMP_CM3CON.setCCH1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCMP_CM3CON.clearCCH1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCMP_CM3CON.setCCH1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCMP_CM3CON.getCCH1 : TBits_1; inline;
begin
  getCCH1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCMP_CM3CON.setEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TCMP_CM3CON.clearEVPOL0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TCMP_CM3CON.setEVPOL0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TCMP_CM3CON.getEVPOL0 : TBits_1; inline;
begin
  getEVPOL0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TCMP_CM3CON.setEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TCMP_CM3CON.clearEVPOL1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TCMP_CM3CON.setEVPOL1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TCMP_CM3CON.getEVPOL1 : TBits_1; inline;
begin
  getEVPOL1 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TCMP_CM3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCMP_CM3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCMP_CMSTAT.setC1OUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCMP_CMSTAT.clearC1OUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCMP_CMSTAT.setC1OUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCMP_CMSTAT.getC1OUT : TBits_1; inline;
begin
  getC1OUT := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCMP_CMSTAT.setC2OUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCMP_CMSTAT.clearC2OUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCMP_CMSTAT.setC2OUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCMP_CMSTAT.getC2OUT : TBits_1; inline;
begin
  getC2OUT := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCMP_CMSTAT.setC3OUT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TCMP_CMSTAT.clearC3OUT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TCMP_CMSTAT.setC3OUT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TCMP_CMSTAT.getC3OUT : TBits_1; inline;
begin
  getC3OUT := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TCMP_CMSTAT.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCMP_CMSTAT.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCMP_CMSTAT.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCMP_CMSTAT.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCMP_CMSTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCMP_CMSTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCMP_CTMUCON.setIRNG(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TCMP_CTMUCON.getIRNG : TBits_2; inline;
begin
  getIRNG := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TCMP_CTMUCON.setITRIM(thebits : TBits_6); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF03 or ( thebits shl 2 );
end;
function  TCMP_CTMUCON.getITRIM : TBits_6; inline;
begin
  getITRIM := (pTDefRegMap(@Self)^.val and $000000FC) shr 2;
end;
procedure TCMP_CTMUCON.setCTTRIG; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCMP_CTMUCON.clearCTTRIG; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCMP_CTMUCON.setCTTRIG(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCMP_CTMUCON.getCTTRIG : TBits_1; inline;
begin
  getCTTRIG := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCMP_CTMUCON.setIDISSEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCMP_CTMUCON.clearIDISSEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCMP_CTMUCON.setIDISSEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCMP_CTMUCON.getIDISSEN : TBits_1; inline;
begin
  getIDISSEN := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCMP_CTMUCON.setEDGSEQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TCMP_CTMUCON.clearEDGSEQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TCMP_CTMUCON.setEDGSEQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TCMP_CTMUCON.getEDGSEQEN : TBits_1; inline;
begin
  getEDGSEQEN := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TCMP_CTMUCON.setEDGEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TCMP_CTMUCON.clearEDGEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TCMP_CTMUCON.setEDGEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TCMP_CTMUCON.getEDGEN : TBits_1; inline;
begin
  getEDGEN := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TCMP_CTMUCON.setTGEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TCMP_CTMUCON.clearTGEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TCMP_CTMUCON.setTGEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TCMP_CTMUCON.getTGEN : TBits_1; inline;
begin
  getTGEN := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TCMP_CTMUCON.setCTMUSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TCMP_CTMUCON.clearCTMUSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TCMP_CTMUCON.setCTMUSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TCMP_CTMUCON.getCTMUSIDL : TBits_1; inline;
begin
  getCTMUSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TCMP_CTMUCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TCMP_CTMUCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TCMP_CTMUCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TCMP_CTMUCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TCMP_CTMUCON.setEDG2SEL(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFC3FFFF or ( thebits shl 18 );
end;
function  TCMP_CTMUCON.getEDG2SEL : TBits_4; inline;
begin
  getEDG2SEL := (pTDefRegMap(@Self)^.val and $003C0000) shr 18;
end;
procedure TCMP_CTMUCON.setEDG2POL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TCMP_CTMUCON.clearEDG2POL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TCMP_CTMUCON.setEDG2POL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TCMP_CTMUCON.getEDG2POL : TBits_1; inline;
begin
  getEDG2POL := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TCMP_CTMUCON.setEDG2MOD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TCMP_CTMUCON.clearEDG2MOD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TCMP_CTMUCON.setEDG2MOD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TCMP_CTMUCON.getEDG2MOD : TBits_1; inline;
begin
  getEDG2MOD := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TCMP_CTMUCON.setEDG1STAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCMP_CTMUCON.clearEDG1STAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCMP_CTMUCON.setEDG1STAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCMP_CTMUCON.getEDG1STAT : TBits_1; inline;
begin
  getEDG1STAT := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCMP_CTMUCON.setEDG2STAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TCMP_CTMUCON.clearEDG2STAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TCMP_CTMUCON.setEDG2STAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TCMP_CTMUCON.getEDG2STAT : TBits_1; inline;
begin
  getEDG2STAT := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TCMP_CTMUCON.setEDG1SEL(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $C3FFFFFF or ( thebits shl 26 );
end;
function  TCMP_CTMUCON.getEDG1SEL : TBits_4; inline;
begin
  getEDG1SEL := (pTDefRegMap(@Self)^.val and $3C000000) shr 26;
end;
procedure TCMP_CTMUCON.setEDG1POL; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TCMP_CTMUCON.clearEDG1POL; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TCMP_CTMUCON.setEDG1POL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TCMP_CTMUCON.getEDG1POL : TBits_1; inline;
begin
  getEDG1POL := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TCMP_CTMUCON.setEDG1MOD; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TCMP_CTMUCON.clearEDG1MOD; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TCMP_CTMUCON.setEDG1MOD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TCMP_CTMUCON.getEDG1MOD : TBits_1; inline;
begin
  getEDG1MOD := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TCMP_CTMUCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TCMP_CTMUCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOSC_OSCCON.setOSWEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOSC_OSCCON.clearOSWEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOSC_OSCCON.setOSWEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOSC_OSCCON.getOSWEN : TBits_1; inline;
begin
  getOSWEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOSC_OSCCON.setSOSCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOSC_OSCCON.clearSOSCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOSC_OSCCON.setSOSCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOSC_OSCCON.getSOSCEN : TBits_1; inline;
begin
  getSOSCEN := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOSC_OSCCON.setUFRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOSC_OSCCON.clearUFRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOSC_OSCCON.setUFRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOSC_OSCCON.getUFRCEN : TBits_1; inline;
begin
  getUFRCEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOSC_OSCCON.setCF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOSC_OSCCON.clearCF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOSC_OSCCON.setCF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOSC_OSCCON.getCF : TBits_1; inline;
begin
  getCF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOSC_OSCCON.setSLPEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOSC_OSCCON.clearSLPEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOSC_OSCCON.setSLPEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOSC_OSCCON.getSLPEN : TBits_1; inline;
begin
  getSLPEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOSC_OSCCON.setSLOCK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOSC_OSCCON.clearSLOCK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOSC_OSCCON.setSLOCK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOSC_OSCCON.getSLOCK : TBits_1; inline;
begin
  getSLOCK := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOSC_OSCCON.setULOCK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TOSC_OSCCON.clearULOCK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TOSC_OSCCON.setULOCK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TOSC_OSCCON.getULOCK : TBits_1; inline;
begin
  getULOCK := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TOSC_OSCCON.setCLKLOCK; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TOSC_OSCCON.clearCLKLOCK; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TOSC_OSCCON.setCLKLOCK(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TOSC_OSCCON.getCLKLOCK : TBits_1; inline;
begin
  getCLKLOCK := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TOSC_OSCCON.setNOSC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF8FF or ( thebits shl 8 );
end;
function  TOSC_OSCCON.getNOSC : TBits_3; inline;
begin
  getNOSC := (pTDefRegMap(@Self)^.val and $00000700) shr 8;
end;
procedure TOSC_OSCCON.setCOSC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF8FFF or ( thebits shl 12 );
end;
function  TOSC_OSCCON.getCOSC : TBits_3; inline;
begin
  getCOSC := (pTDefRegMap(@Self)^.val and $00007000) shr 12;
end;
procedure TOSC_OSCCON.setPLLMULT(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF8FFFF or ( thebits shl 16 );
end;
function  TOSC_OSCCON.getPLLMULT : TBits_3; inline;
begin
  getPLLMULT := (pTDefRegMap(@Self)^.val and $00070000) shr 16;
end;
procedure TOSC_OSCCON.setPBDIV(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE7FFFF or ( thebits shl 19 );
end;
function  TOSC_OSCCON.getPBDIV : TBits_2; inline;
begin
  getPBDIV := (pTDefRegMap(@Self)^.val and $00180000) shr 19;
end;
procedure TOSC_OSCCON.setPBDIVRDY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TOSC_OSCCON.clearPBDIVRDY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TOSC_OSCCON.setPBDIVRDY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TOSC_OSCCON.getPBDIVRDY : TBits_1; inline;
begin
  getPBDIVRDY := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TOSC_OSCCON.setSOSCRDY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TOSC_OSCCON.clearSOSCRDY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TOSC_OSCCON.setSOSCRDY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TOSC_OSCCON.getSOSCRDY : TBits_1; inline;
begin
  getSOSCRDY := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TOSC_OSCCON.setFRCDIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $F8FFFFFF or ( thebits shl 24 );
end;
function  TOSC_OSCCON.getFRCDIV : TBits_3; inline;
begin
  getFRCDIV := (pTDefRegMap(@Self)^.val and $07000000) shr 24;
end;
procedure TOSC_OSCCON.setPLLODIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $C7FFFFFF or ( thebits shl 27 );
end;
function  TOSC_OSCCON.getPLLODIV : TBits_3; inline;
begin
  getPLLODIV := (pTDefRegMap(@Self)^.val and $38000000) shr 27;
end;
procedure TOSC_OSCCON.setNOSC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TOSC_OSCCON.clearNOSC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TOSC_OSCCON.setNOSC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TOSC_OSCCON.getNOSC0 : TBits_1; inline;
begin
  getNOSC0 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TOSC_OSCCON.setNOSC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TOSC_OSCCON.clearNOSC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TOSC_OSCCON.setNOSC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TOSC_OSCCON.getNOSC1 : TBits_1; inline;
begin
  getNOSC1 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TOSC_OSCCON.setNOSC2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TOSC_OSCCON.clearNOSC2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TOSC_OSCCON.setNOSC2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TOSC_OSCCON.getNOSC2 : TBits_1; inline;
begin
  getNOSC2 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TOSC_OSCCON.setCOSC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TOSC_OSCCON.clearCOSC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TOSC_OSCCON.setCOSC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TOSC_OSCCON.getCOSC0 : TBits_1; inline;
begin
  getCOSC0 := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TOSC_OSCCON.setCOSC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOSC_OSCCON.clearCOSC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOSC_OSCCON.setCOSC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOSC_OSCCON.getCOSC1 : TBits_1; inline;
begin
  getCOSC1 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOSC_OSCCON.setCOSC2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TOSC_OSCCON.clearCOSC2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TOSC_OSCCON.setCOSC2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TOSC_OSCCON.getCOSC2 : TBits_1; inline;
begin
  getCOSC2 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TOSC_OSCCON.setPLLMULT0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TOSC_OSCCON.clearPLLMULT0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TOSC_OSCCON.setPLLMULT0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TOSC_OSCCON.getPLLMULT0 : TBits_1; inline;
begin
  getPLLMULT0 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TOSC_OSCCON.setPLLMULT1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TOSC_OSCCON.clearPLLMULT1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TOSC_OSCCON.setPLLMULT1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TOSC_OSCCON.getPLLMULT1 : TBits_1; inline;
begin
  getPLLMULT1 := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TOSC_OSCCON.setPLLMULT2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TOSC_OSCCON.clearPLLMULT2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TOSC_OSCCON.setPLLMULT2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TOSC_OSCCON.getPLLMULT2 : TBits_1; inline;
begin
  getPLLMULT2 := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TOSC_OSCCON.setPBDIV0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TOSC_OSCCON.clearPBDIV0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TOSC_OSCCON.setPBDIV0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TOSC_OSCCON.getPBDIV0 : TBits_1; inline;
begin
  getPBDIV0 := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TOSC_OSCCON.setPBDIV1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TOSC_OSCCON.clearPBDIV1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TOSC_OSCCON.setPBDIV1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TOSC_OSCCON.getPBDIV1 : TBits_1; inline;
begin
  getPBDIV1 := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TOSC_OSCCON.setFRCDIV0; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TOSC_OSCCON.clearFRCDIV0; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TOSC_OSCCON.setFRCDIV0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TOSC_OSCCON.getFRCDIV0 : TBits_1; inline;
begin
  getFRCDIV0 := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TOSC_OSCCON.setFRCDIV1; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TOSC_OSCCON.clearFRCDIV1; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TOSC_OSCCON.setFRCDIV1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TOSC_OSCCON.getFRCDIV1 : TBits_1; inline;
begin
  getFRCDIV1 := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TOSC_OSCCON.setFRCDIV2; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TOSC_OSCCON.clearFRCDIV2; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TOSC_OSCCON.setFRCDIV2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TOSC_OSCCON.getFRCDIV2 : TBits_1; inline;
begin
  getFRCDIV2 := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TOSC_OSCCON.setPLLODIV0; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TOSC_OSCCON.clearPLLODIV0; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TOSC_OSCCON.setPLLODIV0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TOSC_OSCCON.getPLLODIV0 : TBits_1; inline;
begin
  getPLLODIV0 := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TOSC_OSCCON.setPLLODIV1; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TOSC_OSCCON.clearPLLODIV1; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TOSC_OSCCON.setPLLODIV1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TOSC_OSCCON.getPLLODIV1 : TBits_1; inline;
begin
  getPLLODIV1 := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TOSC_OSCCON.setPLLODIV2; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TOSC_OSCCON.clearPLLODIV2; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TOSC_OSCCON.setPLLODIV2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TOSC_OSCCON.getPLLODIV2 : TBits_1; inline;
begin
  getPLLODIV2 := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TOSC_OSCCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOSC_OSCCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOSC_OSCTUN.setTUN(thebits : TBits_6); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFC0 or ( thebits shl 0 );
end;
function  TOSC_OSCTUN.getTUN : TBits_6; inline;
begin
  getTUN := (pTDefRegMap(@Self)^.val and $0000003F) shr 0;
end;
procedure TOSC_OSCTUN.setTUN0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TOSC_OSCTUN.clearTUN0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TOSC_OSCTUN.setTUN0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TOSC_OSCTUN.getTUN0 : TBits_1; inline;
begin
  getTUN0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TOSC_OSCTUN.setTUN1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TOSC_OSCTUN.clearTUN1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TOSC_OSCTUN.setTUN1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TOSC_OSCTUN.getTUN1 : TBits_1; inline;
begin
  getTUN1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TOSC_OSCTUN.setTUN2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TOSC_OSCTUN.clearTUN2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TOSC_OSCTUN.setTUN2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TOSC_OSCTUN.getTUN2 : TBits_1; inline;
begin
  getTUN2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TOSC_OSCTUN.setTUN3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TOSC_OSCTUN.clearTUN3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TOSC_OSCTUN.setTUN3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TOSC_OSCTUN.getTUN3 : TBits_1; inline;
begin
  getTUN3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TOSC_OSCTUN.setTUN4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TOSC_OSCTUN.clearTUN4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TOSC_OSCTUN.setTUN4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TOSC_OSCTUN.getTUN4 : TBits_1; inline;
begin
  getTUN4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TOSC_OSCTUN.setTUN5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TOSC_OSCTUN.clearTUN5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TOSC_OSCTUN.setTUN5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TOSC_OSCTUN.getTUN5 : TBits_1; inline;
begin
  getTUN5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TOSC_OSCTUN.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOSC_OSCTUN.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOSC_REFOCON.setROSEL(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TOSC_REFOCON.getROSEL : TBits_4; inline;
begin
  getROSEL := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TOSC_REFOCON.setACTIVE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TOSC_REFOCON.clearACTIVE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TOSC_REFOCON.setACTIVE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TOSC_REFOCON.getACTIVE : TBits_1; inline;
begin
  getACTIVE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TOSC_REFOCON.setDIVSWEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TOSC_REFOCON.clearDIVSWEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TOSC_REFOCON.setDIVSWEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TOSC_REFOCON.getDIVSWEN : TBits_1; inline;
begin
  getDIVSWEN := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TOSC_REFOCON.setRSLP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TOSC_REFOCON.clearRSLP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TOSC_REFOCON.setRSLP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TOSC_REFOCON.getRSLP : TBits_1; inline;
begin
  getRSLP := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TOSC_REFOCON.setOE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TOSC_REFOCON.clearOE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TOSC_REFOCON.setOE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TOSC_REFOCON.getOE : TBits_1; inline;
begin
  getOE := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TOSC_REFOCON.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TOSC_REFOCON.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TOSC_REFOCON.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TOSC_REFOCON.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TOSC_REFOCON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TOSC_REFOCON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TOSC_REFOCON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TOSC_REFOCON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TOSC_REFOCON.setRODIV(thebits : TBits_15); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $8000FFFF or ( thebits shl 16 );
end;
function  TOSC_REFOCON.getRODIV : TBits_15; inline;
begin
  getRODIV := (pTDefRegMap(@Self)^.val and $7FFF0000) shr 16;
end;
procedure TOSC_REFOCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOSC_REFOCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TOSC_REFOTRIM.setROTRIM(thebits : TBits_9); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $007FFFFF or ( thebits shl 23 );
end;
function  TOSC_REFOTRIM.getROTRIM : TBits_9; inline;
begin
  getROTRIM := (pTDefRegMap(@Self)^.val and $FF800000) shr 23;
end;
procedure TOSC_REFOTRIM.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TOSC_REFOTRIM.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TCFG_PMD5.setU1MD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TCFG_PMD5.clearU1MD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TCFG_PMD5.setU1MD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TCFG_PMD5.getU1MD : TBits_1; inline;
begin
  getU1MD := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TCFG_PMD5.setU2MD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TCFG_PMD5.clearU2MD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TCFG_PMD5.setU2MD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TCFG_PMD5.getU2MD : TBits_1; inline;
begin
  getU2MD := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TCFG_PMD5.setSPI1MD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TCFG_PMD5.clearSPI1MD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TCFG_PMD5.setSPI1MD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TCFG_PMD5.getSPI1MD : TBits_1; inline;
begin
  getSPI1MD := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TCFG_PMD5.setSPI2MD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TCFG_PMD5.clearSPI2MD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TCFG_PMD5.setSPI2MD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TCFG_PMD5.getSPI2MD : TBits_1; inline;
begin
  getSPI2MD := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TCFG_PMD5.setI2C1MD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TCFG_PMD5.clearI2C1MD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TCFG_PMD5.setI2C1MD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TCFG_PMD5.getI2C1MD : TBits_1; inline;
begin
  getI2C1MD := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TCFG_PMD5.setI2C2MD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TCFG_PMD5.clearI2C2MD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TCFG_PMD5.setI2C2MD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TCFG_PMD5.getI2C2MD : TBits_1; inline;
begin
  getI2C2MD := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TCFG_PMD5.setUSB1MD; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCFG_PMD5.clearUSB1MD; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCFG_PMD5.setUSB1MD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCFG_PMD5.getUSB1MD : TBits_1; inline;
begin
  getUSB1MD := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TCFG_PMD5.setUSBMD; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TCFG_PMD5.clearUSBMD; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TCFG_PMD5.setUSBMD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TCFG_PMD5.getUSBMD : TBits_1; inline;
begin
  getUSBMD := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TNVM_NVMCON.setNVMOP(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TNVM_NVMCON.getNVMOP : TBits_4; inline;
begin
  getNVMOP := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TNVM_NVMCON.setLVDSTAT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TNVM_NVMCON.clearLVDSTAT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TNVM_NVMCON.setLVDSTAT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TNVM_NVMCON.getLVDSTAT : TBits_1; inline;
begin
  getLVDSTAT := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TNVM_NVMCON.setLVDERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TNVM_NVMCON.clearLVDERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TNVM_NVMCON.setLVDERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TNVM_NVMCON.getLVDERR : TBits_1; inline;
begin
  getLVDERR := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TNVM_NVMCON.setWRERR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TNVM_NVMCON.clearWRERR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TNVM_NVMCON.setWRERR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TNVM_NVMCON.getWRERR : TBits_1; inline;
begin
  getWRERR := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TNVM_NVMCON.setWREN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TNVM_NVMCON.clearWREN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TNVM_NVMCON.setWREN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TNVM_NVMCON.getWREN : TBits_1; inline;
begin
  getWREN := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TNVM_NVMCON.setWR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TNVM_NVMCON.clearWR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TNVM_NVMCON.setWR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TNVM_NVMCON.getWR : TBits_1; inline;
begin
  getWR := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TNVM_NVMCON.setNVMOP0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TNVM_NVMCON.clearNVMOP0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TNVM_NVMCON.setNVMOP0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TNVM_NVMCON.getNVMOP0 : TBits_1; inline;
begin
  getNVMOP0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TNVM_NVMCON.setNVMOP1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TNVM_NVMCON.clearNVMOP1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TNVM_NVMCON.setNVMOP1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TNVM_NVMCON.getNVMOP1 : TBits_1; inline;
begin
  getNVMOP1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TNVM_NVMCON.setNVMOP2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TNVM_NVMCON.clearNVMOP2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TNVM_NVMCON.setNVMOP2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TNVM_NVMCON.getNVMOP2 : TBits_1; inline;
begin
  getNVMOP2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TNVM_NVMCON.setNVMOP3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TNVM_NVMCON.clearNVMOP3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TNVM_NVMCON.setNVMOP3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TNVM_NVMCON.getNVMOP3 : TBits_1; inline;
begin
  getNVMOP3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TNVM_NVMCON.setPROGOP(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TNVM_NVMCON.getPROGOP : TBits_4; inline;
begin
  getPROGOP := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TNVM_NVMCON.setPROGOP0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TNVM_NVMCON.clearPROGOP0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TNVM_NVMCON.setPROGOP0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TNVM_NVMCON.getPROGOP0 : TBits_1; inline;
begin
  getPROGOP0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TNVM_NVMCON.setPROGOP1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TNVM_NVMCON.clearPROGOP1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TNVM_NVMCON.setPROGOP1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TNVM_NVMCON.getPROGOP1 : TBits_1; inline;
begin
  getPROGOP1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TNVM_NVMCON.setPROGOP2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TNVM_NVMCON.clearPROGOP2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TNVM_NVMCON.setPROGOP2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TNVM_NVMCON.getPROGOP2 : TBits_1; inline;
begin
  getPROGOP2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TNVM_NVMCON.setPROGOP3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TNVM_NVMCON.clearPROGOP3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TNVM_NVMCON.setPROGOP3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TNVM_NVMCON.getPROGOP3 : TBits_1; inline;
begin
  getPROGOP3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TNVM_NVMCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TNVM_NVMCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRCON_RCON.setPOR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TRCON_RCON.clearPOR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TRCON_RCON.setPOR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TRCON_RCON.getPOR : TBits_1; inline;
begin
  getPOR := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TRCON_RCON.setBOR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TRCON_RCON.clearBOR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TRCON_RCON.setBOR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TRCON_RCON.getBOR : TBits_1; inline;
begin
  getBOR := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TRCON_RCON.setIDLE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TRCON_RCON.clearIDLE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TRCON_RCON.setIDLE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TRCON_RCON.getIDLE : TBits_1; inline;
begin
  getIDLE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TRCON_RCON.setSLEEP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TRCON_RCON.clearSLEEP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TRCON_RCON.setSLEEP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TRCON_RCON.getSLEEP : TBits_1; inline;
begin
  getSLEEP := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TRCON_RCON.setWDTO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TRCON_RCON.clearWDTO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TRCON_RCON.setWDTO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TRCON_RCON.getWDTO : TBits_1; inline;
begin
  getWDTO := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TRCON_RCON.setSWR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TRCON_RCON.clearSWR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TRCON_RCON.setSWR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TRCON_RCON.getSWR : TBits_1; inline;
begin
  getSWR := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TRCON_RCON.setEXTR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TRCON_RCON.clearEXTR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TRCON_RCON.setEXTR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TRCON_RCON.getEXTR : TBits_1; inline;
begin
  getEXTR := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TRCON_RCON.setVREGS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TRCON_RCON.clearVREGS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TRCON_RCON.setVREGS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TRCON_RCON.getVREGS : TBits_1; inline;
begin
  getVREGS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TRCON_RCON.setCMR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TRCON_RCON.clearCMR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TRCON_RCON.setCMR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TRCON_RCON.getCMR : TBits_1; inline;
begin
  getCMR := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TRCON_RCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRCON_RCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TRCON_RSWRST.setSWRST; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TRCON_RSWRST.clearSWRST; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TRCON_RSWRST.setSWRST(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TRCON_RSWRST.getSWRST : TBits_1; inline;
begin
  getSWRST := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TRCON_RSWRST.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TRCON_RSWRST.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_INTCON.setINT0EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_INTCON.clearINT0EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_INTCON.setINT0EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_INTCON.getINT0EP : TBits_1; inline;
begin
  getINT0EP := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_INTCON.setINT1EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_INTCON.clearINT1EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_INTCON.setINT1EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_INTCON.getINT1EP : TBits_1; inline;
begin
  getINT1EP := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_INTCON.setINT2EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_INTCON.clearINT2EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_INTCON.setINT2EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_INTCON.getINT2EP : TBits_1; inline;
begin
  getINT2EP := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_INTCON.setINT3EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_INTCON.clearINT3EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_INTCON.setINT3EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_INTCON.getINT3EP : TBits_1; inline;
begin
  getINT3EP := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_INTCON.setINT4EP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_INTCON.clearINT4EP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_INTCON.setINT4EP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_INTCON.getINT4EP : TBits_1; inline;
begin
  getINT4EP := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_INTCON.setTPC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF8FF or ( thebits shl 8 );
end;
function  TINT_INTCON.getTPC : TBits_3; inline;
begin
  getTPC := (pTDefRegMap(@Self)^.val and $00000700) shr 8;
end;
procedure TINT_INTCON.setMVEC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TINT_INTCON.clearMVEC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TINT_INTCON.setMVEC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TINT_INTCON.getMVEC : TBits_1; inline;
begin
  getMVEC := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TINT_INTCON.setSS0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_INTCON.clearSS0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_INTCON.setSS0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_INTCON.getSS0 : TBits_1; inline;
begin
  getSS0 := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_INTCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_INTCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IFS0.setCTIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IFS0.clearCTIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IFS0.setCTIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IFS0.getCTIF : TBits_1; inline;
begin
  getCTIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IFS0.setCS0IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IFS0.clearCS0IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IFS0.setCS0IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IFS0.getCS0IF : TBits_1; inline;
begin
  getCS0IF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IFS0.setCS1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IFS0.clearCS1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IFS0.setCS1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IFS0.getCS1IF : TBits_1; inline;
begin
  getCS1IF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IFS0.setINT0IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IFS0.clearINT0IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IFS0.setINT0IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IFS0.getINT0IF : TBits_1; inline;
begin
  getINT0IF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IFS0.setT1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IFS0.clearT1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IFS0.setT1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IFS0.getT1IF : TBits_1; inline;
begin
  getT1IF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IFS0.setIC1EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IFS0.clearIC1EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IFS0.setIC1EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IFS0.getIC1EIF : TBits_1; inline;
begin
  getIC1EIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IFS0.setIC1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IFS0.clearIC1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IFS0.setIC1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IFS0.getIC1IF : TBits_1; inline;
begin
  getIC1IF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IFS0.setOC1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IFS0.clearOC1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IFS0.setOC1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IFS0.getOC1IF : TBits_1; inline;
begin
  getOC1IF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IFS0.setINT1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IFS0.clearINT1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IFS0.setINT1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IFS0.getINT1IF : TBits_1; inline;
begin
  getINT1IF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IFS0.setT2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IFS0.clearT2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IFS0.setT2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IFS0.getT2IF : TBits_1; inline;
begin
  getT2IF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IFS0.setIC2EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IFS0.clearIC2EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IFS0.setIC2EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IFS0.getIC2EIF : TBits_1; inline;
begin
  getIC2EIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IFS0.setIC2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IFS0.clearIC2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IFS0.setIC2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IFS0.getIC2IF : TBits_1; inline;
begin
  getIC2IF := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IFS0.setOC2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TINT_IFS0.clearOC2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TINT_IFS0.setOC2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TINT_IFS0.getOC2IF : TBits_1; inline;
begin
  getOC2IF := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TINT_IFS0.setINT2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TINT_IFS0.clearINT2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TINT_IFS0.setINT2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TINT_IFS0.getINT2IF : TBits_1; inline;
begin
  getINT2IF := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TINT_IFS0.setT3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TINT_IFS0.clearT3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TINT_IFS0.setT3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TINT_IFS0.getT3IF : TBits_1; inline;
begin
  getT3IF := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TINT_IFS0.setIC3EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TINT_IFS0.clearIC3EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TINT_IFS0.setIC3EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TINT_IFS0.getIC3EIF : TBits_1; inline;
begin
  getIC3EIF := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TINT_IFS0.setIC3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_IFS0.clearIC3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_IFS0.setIC3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_IFS0.getIC3IF : TBits_1; inline;
begin
  getIC3IF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_IFS0.setOC3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TINT_IFS0.clearOC3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TINT_IFS0.setOC3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TINT_IFS0.getOC3IF : TBits_1; inline;
begin
  getOC3IF := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TINT_IFS0.setINT3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TINT_IFS0.clearINT3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TINT_IFS0.setINT3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TINT_IFS0.getINT3IF : TBits_1; inline;
begin
  getINT3IF := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TINT_IFS0.setT4IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TINT_IFS0.clearT4IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TINT_IFS0.setT4IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TINT_IFS0.getT4IF : TBits_1; inline;
begin
  getT4IF := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TINT_IFS0.setIC4EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TINT_IFS0.clearIC4EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TINT_IFS0.setIC4EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TINT_IFS0.getIC4EIF : TBits_1; inline;
begin
  getIC4EIF := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TINT_IFS0.setIC4IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TINT_IFS0.clearIC4IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TINT_IFS0.setIC4IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TINT_IFS0.getIC4IF : TBits_1; inline;
begin
  getIC4IF := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TINT_IFS0.setOC4IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TINT_IFS0.clearOC4IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TINT_IFS0.setOC4IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TINT_IFS0.getOC4IF : TBits_1; inline;
begin
  getOC4IF := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TINT_IFS0.setINT4IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TINT_IFS0.clearINT4IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TINT_IFS0.setINT4IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TINT_IFS0.getINT4IF : TBits_1; inline;
begin
  getINT4IF := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TINT_IFS0.setT5IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TINT_IFS0.clearT5IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TINT_IFS0.setT5IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TINT_IFS0.getT5IF : TBits_1; inline;
begin
  getT5IF := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TINT_IFS0.setIC5EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TINT_IFS0.clearIC5EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TINT_IFS0.setIC5EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TINT_IFS0.getIC5EIF : TBits_1; inline;
begin
  getIC5EIF := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TINT_IFS0.setIC5IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IFS0.clearIC5IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IFS0.setIC5IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IFS0.getIC5IF : TBits_1; inline;
begin
  getIC5IF := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IFS0.setOC5IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IFS0.clearOC5IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IFS0.setOC5IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IFS0.getOC5IF : TBits_1; inline;
begin
  getOC5IF := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IFS0.setAD1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IFS0.clearAD1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IFS0.setAD1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IFS0.getAD1IF : TBits_1; inline;
begin
  getAD1IF := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IFS0.setFSCMIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TINT_IFS0.clearFSCMIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TINT_IFS0.setFSCMIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TINT_IFS0.getFSCMIF : TBits_1; inline;
begin
  getFSCMIF := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TINT_IFS0.setRTCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TINT_IFS0.clearRTCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TINT_IFS0.setRTCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TINT_IFS0.getRTCCIF : TBits_1; inline;
begin
  getRTCCIF := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TINT_IFS0.setFCEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TINT_IFS0.clearFCEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TINT_IFS0.setFCEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TINT_IFS0.getFCEIF : TBits_1; inline;
begin
  getFCEIF := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TINT_IFS0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IFS0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IFS1.setCMP1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IFS1.clearCMP1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IFS1.setCMP1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IFS1.getCMP1IF : TBits_1; inline;
begin
  getCMP1IF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IFS1.setCMP2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IFS1.clearCMP2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IFS1.setCMP2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IFS1.getCMP2IF : TBits_1; inline;
begin
  getCMP2IF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IFS1.setCMP3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IFS1.clearCMP3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IFS1.setCMP3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IFS1.getCMP3IF : TBits_1; inline;
begin
  getCMP3IF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IFS1.setUSBIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IFS1.clearUSBIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IFS1.setUSBIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IFS1.getUSBIF : TBits_1; inline;
begin
  getUSBIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IFS1.setSPI1EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IFS1.clearSPI1EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IFS1.setSPI1EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IFS1.getSPI1EIF : TBits_1; inline;
begin
  getSPI1EIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IFS1.setSPI1RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IFS1.clearSPI1RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IFS1.setSPI1RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IFS1.getSPI1RXIF : TBits_1; inline;
begin
  getSPI1RXIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IFS1.setSPI1TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IFS1.clearSPI1TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IFS1.setSPI1TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IFS1.getSPI1TXIF : TBits_1; inline;
begin
  getSPI1TXIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IFS1.setU1EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IFS1.clearU1EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IFS1.setU1EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IFS1.getU1EIF : TBits_1; inline;
begin
  getU1EIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IFS1.setU1RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IFS1.clearU1RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IFS1.setU1RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IFS1.getU1RXIF : TBits_1; inline;
begin
  getU1RXIF := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IFS1.setU1TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IFS1.clearU1TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IFS1.setU1TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IFS1.getU1TXIF : TBits_1; inline;
begin
  getU1TXIF := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IFS1.setI2C1BIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IFS1.clearI2C1BIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IFS1.setI2C1BIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IFS1.getI2C1BIF : TBits_1; inline;
begin
  getI2C1BIF := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IFS1.setI2C1SIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IFS1.clearI2C1SIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IFS1.setI2C1SIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IFS1.getI2C1SIF : TBits_1; inline;
begin
  getI2C1SIF := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IFS1.setI2C1MIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TINT_IFS1.clearI2C1MIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TINT_IFS1.setI2C1MIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TINT_IFS1.getI2C1MIF : TBits_1; inline;
begin
  getI2C1MIF := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TINT_IFS1.setCNAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TINT_IFS1.clearCNAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TINT_IFS1.setCNAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TINT_IFS1.getCNAIF : TBits_1; inline;
begin
  getCNAIF := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TINT_IFS1.setCNBIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TINT_IFS1.clearCNBIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TINT_IFS1.setCNBIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TINT_IFS1.getCNBIF : TBits_1; inline;
begin
  getCNBIF := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TINT_IFS1.setCNCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TINT_IFS1.clearCNCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TINT_IFS1.setCNCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TINT_IFS1.getCNCIF : TBits_1; inline;
begin
  getCNCIF := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TINT_IFS1.setPMPIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_IFS1.clearPMPIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_IFS1.setPMPIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_IFS1.getPMPIF : TBits_1; inline;
begin
  getPMPIF := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_IFS1.setPMPEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TINT_IFS1.clearPMPEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TINT_IFS1.setPMPEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TINT_IFS1.getPMPEIF : TBits_1; inline;
begin
  getPMPEIF := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TINT_IFS1.setSPI2EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TINT_IFS1.clearSPI2EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TINT_IFS1.setSPI2EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TINT_IFS1.getSPI2EIF : TBits_1; inline;
begin
  getSPI2EIF := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TINT_IFS1.setSPI2RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TINT_IFS1.clearSPI2RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TINT_IFS1.setSPI2RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TINT_IFS1.getSPI2RXIF : TBits_1; inline;
begin
  getSPI2RXIF := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TINT_IFS1.setSPI2TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TINT_IFS1.clearSPI2TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TINT_IFS1.setSPI2TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TINT_IFS1.getSPI2TXIF : TBits_1; inline;
begin
  getSPI2TXIF := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TINT_IFS1.setU2EIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TINT_IFS1.clearU2EIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TINT_IFS1.setU2EIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TINT_IFS1.getU2EIF : TBits_1; inline;
begin
  getU2EIF := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TINT_IFS1.setU2RXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TINT_IFS1.clearU2RXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TINT_IFS1.setU2RXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TINT_IFS1.getU2RXIF : TBits_1; inline;
begin
  getU2RXIF := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TINT_IFS1.setU2TXIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TINT_IFS1.clearU2TXIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TINT_IFS1.setU2TXIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TINT_IFS1.getU2TXIF : TBits_1; inline;
begin
  getU2TXIF := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TINT_IFS1.setI2C2BIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TINT_IFS1.clearI2C2BIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TINT_IFS1.setI2C2BIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TINT_IFS1.getI2C2BIF : TBits_1; inline;
begin
  getI2C2BIF := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TINT_IFS1.setI2C2SIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TINT_IFS1.clearI2C2SIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TINT_IFS1.setI2C2SIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TINT_IFS1.getI2C2SIF : TBits_1; inline;
begin
  getI2C2SIF := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TINT_IFS1.setI2C2MIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IFS1.clearI2C2MIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IFS1.setI2C2MIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IFS1.getI2C2MIF : TBits_1; inline;
begin
  getI2C2MIF := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IFS1.setCTMUIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IFS1.clearCTMUIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IFS1.setCTMUIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IFS1.getCTMUIF : TBits_1; inline;
begin
  getCTMUIF := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IFS1.setDMA0IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IFS1.clearDMA0IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IFS1.setDMA0IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IFS1.getDMA0IF : TBits_1; inline;
begin
  getDMA0IF := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IFS1.setDMA1IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TINT_IFS1.clearDMA1IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TINT_IFS1.setDMA1IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TINT_IFS1.getDMA1IF : TBits_1; inline;
begin
  getDMA1IF := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TINT_IFS1.setDMA2IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TINT_IFS1.clearDMA2IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TINT_IFS1.setDMA2IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TINT_IFS1.getDMA2IF : TBits_1; inline;
begin
  getDMA2IF := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TINT_IFS1.setDMA3IF; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TINT_IFS1.clearDMA3IF; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TINT_IFS1.setDMA3IF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TINT_IFS1.getDMA3IF : TBits_1; inline;
begin
  getDMA3IF := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TINT_IFS1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IFS1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IEC0.setCTIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IEC0.clearCTIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IEC0.setCTIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IEC0.getCTIE : TBits_1; inline;
begin
  getCTIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IEC0.setCS0IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IEC0.clearCS0IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IEC0.setCS0IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IEC0.getCS0IE : TBits_1; inline;
begin
  getCS0IE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IEC0.setCS1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IEC0.clearCS1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IEC0.setCS1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IEC0.getCS1IE : TBits_1; inline;
begin
  getCS1IE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IEC0.setINT0IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IEC0.clearINT0IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IEC0.setINT0IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IEC0.getINT0IE : TBits_1; inline;
begin
  getINT0IE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IEC0.setT1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IEC0.clearT1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IEC0.setT1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IEC0.getT1IE : TBits_1; inline;
begin
  getT1IE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IEC0.setIC1EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IEC0.clearIC1EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IEC0.setIC1EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IEC0.getIC1EIE : TBits_1; inline;
begin
  getIC1EIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IEC0.setIC1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IEC0.clearIC1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IEC0.setIC1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IEC0.getIC1IE : TBits_1; inline;
begin
  getIC1IE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IEC0.setOC1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IEC0.clearOC1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IEC0.setOC1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IEC0.getOC1IE : TBits_1; inline;
begin
  getOC1IE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IEC0.setINT1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IEC0.clearINT1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IEC0.setINT1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IEC0.getINT1IE : TBits_1; inline;
begin
  getINT1IE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IEC0.setT2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IEC0.clearT2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IEC0.setT2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IEC0.getT2IE : TBits_1; inline;
begin
  getT2IE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IEC0.setIC2EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IEC0.clearIC2EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IEC0.setIC2EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IEC0.getIC2EIE : TBits_1; inline;
begin
  getIC2EIE := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IEC0.setIC2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IEC0.clearIC2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IEC0.setIC2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IEC0.getIC2IE : TBits_1; inline;
begin
  getIC2IE := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IEC0.setOC2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TINT_IEC0.clearOC2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TINT_IEC0.setOC2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TINT_IEC0.getOC2IE : TBits_1; inline;
begin
  getOC2IE := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TINT_IEC0.setINT2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TINT_IEC0.clearINT2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TINT_IEC0.setINT2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TINT_IEC0.getINT2IE : TBits_1; inline;
begin
  getINT2IE := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TINT_IEC0.setT3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TINT_IEC0.clearT3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TINT_IEC0.setT3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TINT_IEC0.getT3IE : TBits_1; inline;
begin
  getT3IE := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TINT_IEC0.setIC3EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TINT_IEC0.clearIC3EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TINT_IEC0.setIC3EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TINT_IEC0.getIC3EIE : TBits_1; inline;
begin
  getIC3EIE := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TINT_IEC0.setIC3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_IEC0.clearIC3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_IEC0.setIC3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_IEC0.getIC3IE : TBits_1; inline;
begin
  getIC3IE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_IEC0.setOC3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TINT_IEC0.clearOC3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TINT_IEC0.setOC3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TINT_IEC0.getOC3IE : TBits_1; inline;
begin
  getOC3IE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TINT_IEC0.setINT3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TINT_IEC0.clearINT3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TINT_IEC0.setINT3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TINT_IEC0.getINT3IE : TBits_1; inline;
begin
  getINT3IE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TINT_IEC0.setT4IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TINT_IEC0.clearT4IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TINT_IEC0.setT4IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TINT_IEC0.getT4IE : TBits_1; inline;
begin
  getT4IE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TINT_IEC0.setIC4EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TINT_IEC0.clearIC4EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TINT_IEC0.setIC4EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TINT_IEC0.getIC4EIE : TBits_1; inline;
begin
  getIC4EIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TINT_IEC0.setIC4IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TINT_IEC0.clearIC4IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TINT_IEC0.setIC4IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TINT_IEC0.getIC4IE : TBits_1; inline;
begin
  getIC4IE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TINT_IEC0.setOC4IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TINT_IEC0.clearOC4IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TINT_IEC0.setOC4IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TINT_IEC0.getOC4IE : TBits_1; inline;
begin
  getOC4IE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TINT_IEC0.setINT4IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TINT_IEC0.clearINT4IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TINT_IEC0.setINT4IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TINT_IEC0.getINT4IE : TBits_1; inline;
begin
  getINT4IE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TINT_IEC0.setT5IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TINT_IEC0.clearT5IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TINT_IEC0.setT5IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TINT_IEC0.getT5IE : TBits_1; inline;
begin
  getT5IE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TINT_IEC0.setIC5EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TINT_IEC0.clearIC5EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TINT_IEC0.setIC5EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TINT_IEC0.getIC5EIE : TBits_1; inline;
begin
  getIC5EIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TINT_IEC0.setIC5IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IEC0.clearIC5IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IEC0.setIC5IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IEC0.getIC5IE : TBits_1; inline;
begin
  getIC5IE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IEC0.setOC5IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IEC0.clearOC5IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IEC0.setOC5IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IEC0.getOC5IE : TBits_1; inline;
begin
  getOC5IE := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IEC0.setAD1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IEC0.clearAD1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IEC0.setAD1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IEC0.getAD1IE : TBits_1; inline;
begin
  getAD1IE := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IEC0.setFSCMIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TINT_IEC0.clearFSCMIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TINT_IEC0.setFSCMIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TINT_IEC0.getFSCMIE : TBits_1; inline;
begin
  getFSCMIE := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TINT_IEC0.setRTCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TINT_IEC0.clearRTCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TINT_IEC0.setRTCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TINT_IEC0.getRTCCIE : TBits_1; inline;
begin
  getRTCCIE := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TINT_IEC0.setFCEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TINT_IEC0.clearFCEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TINT_IEC0.setFCEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TINT_IEC0.getFCEIE : TBits_1; inline;
begin
  getFCEIE := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TINT_IEC0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IEC0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IEC1.setCMP1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TINT_IEC1.clearCMP1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TINT_IEC1.setCMP1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TINT_IEC1.getCMP1IE : TBits_1; inline;
begin
  getCMP1IE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TINT_IEC1.setCMP2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TINT_IEC1.clearCMP2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TINT_IEC1.setCMP2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TINT_IEC1.getCMP2IE : TBits_1; inline;
begin
  getCMP2IE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TINT_IEC1.setCMP3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TINT_IEC1.clearCMP3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TINT_IEC1.setCMP3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TINT_IEC1.getCMP3IE : TBits_1; inline;
begin
  getCMP3IE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TINT_IEC1.setUSBIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TINT_IEC1.clearUSBIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TINT_IEC1.setUSBIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TINT_IEC1.getUSBIE : TBits_1; inline;
begin
  getUSBIE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TINT_IEC1.setSPI1EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TINT_IEC1.clearSPI1EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TINT_IEC1.setSPI1EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TINT_IEC1.getSPI1EIE : TBits_1; inline;
begin
  getSPI1EIE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TINT_IEC1.setSPI1RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TINT_IEC1.clearSPI1RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TINT_IEC1.setSPI1RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TINT_IEC1.getSPI1RXIE : TBits_1; inline;
begin
  getSPI1RXIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TINT_IEC1.setSPI1TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TINT_IEC1.clearSPI1TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TINT_IEC1.setSPI1TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TINT_IEC1.getSPI1TXIE : TBits_1; inline;
begin
  getSPI1TXIE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TINT_IEC1.setU1EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TINT_IEC1.clearU1EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TINT_IEC1.setU1EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TINT_IEC1.getU1EIE : TBits_1; inline;
begin
  getU1EIE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TINT_IEC1.setU1RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TINT_IEC1.clearU1RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TINT_IEC1.setU1RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TINT_IEC1.getU1RXIE : TBits_1; inline;
begin
  getU1RXIE := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TINT_IEC1.setU1TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TINT_IEC1.clearU1TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TINT_IEC1.setU1TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TINT_IEC1.getU1TXIE : TBits_1; inline;
begin
  getU1TXIE := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TINT_IEC1.setI2C1BIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TINT_IEC1.clearI2C1BIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TINT_IEC1.setI2C1BIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TINT_IEC1.getI2C1BIE : TBits_1; inline;
begin
  getI2C1BIE := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TINT_IEC1.setI2C1SIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TINT_IEC1.clearI2C1SIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TINT_IEC1.setI2C1SIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TINT_IEC1.getI2C1SIE : TBits_1; inline;
begin
  getI2C1SIE := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TINT_IEC1.setI2C1MIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TINT_IEC1.clearI2C1MIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TINT_IEC1.setI2C1MIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TINT_IEC1.getI2C1MIE : TBits_1; inline;
begin
  getI2C1MIE := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TINT_IEC1.setCNAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TINT_IEC1.clearCNAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TINT_IEC1.setCNAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TINT_IEC1.getCNAIE : TBits_1; inline;
begin
  getCNAIE := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TINT_IEC1.setCNBIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TINT_IEC1.clearCNBIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TINT_IEC1.setCNBIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TINT_IEC1.getCNBIE : TBits_1; inline;
begin
  getCNBIE := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TINT_IEC1.setCNCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TINT_IEC1.clearCNCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TINT_IEC1.setCNCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TINT_IEC1.getCNCIE : TBits_1; inline;
begin
  getCNCIE := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TINT_IEC1.setPMPIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TINT_IEC1.clearPMPIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TINT_IEC1.setPMPIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TINT_IEC1.getPMPIE : TBits_1; inline;
begin
  getPMPIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TINT_IEC1.setPMPEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TINT_IEC1.clearPMPEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TINT_IEC1.setPMPEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TINT_IEC1.getPMPEIE : TBits_1; inline;
begin
  getPMPEIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TINT_IEC1.setSPI2EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TINT_IEC1.clearSPI2EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TINT_IEC1.setSPI2EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TINT_IEC1.getSPI2EIE : TBits_1; inline;
begin
  getSPI2EIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TINT_IEC1.setSPI2RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TINT_IEC1.clearSPI2RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TINT_IEC1.setSPI2RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TINT_IEC1.getSPI2RXIE : TBits_1; inline;
begin
  getSPI2RXIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TINT_IEC1.setSPI2TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TINT_IEC1.clearSPI2TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TINT_IEC1.setSPI2TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TINT_IEC1.getSPI2TXIE : TBits_1; inline;
begin
  getSPI2TXIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TINT_IEC1.setU2EIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TINT_IEC1.clearU2EIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TINT_IEC1.setU2EIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TINT_IEC1.getU2EIE : TBits_1; inline;
begin
  getU2EIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TINT_IEC1.setU2RXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TINT_IEC1.clearU2RXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TINT_IEC1.setU2RXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TINT_IEC1.getU2RXIE : TBits_1; inline;
begin
  getU2RXIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TINT_IEC1.setU2TXIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TINT_IEC1.clearU2TXIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TINT_IEC1.setU2TXIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TINT_IEC1.getU2TXIE : TBits_1; inline;
begin
  getU2TXIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TINT_IEC1.setI2C2BIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TINT_IEC1.clearI2C2BIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TINT_IEC1.setI2C2BIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TINT_IEC1.getI2C2BIE : TBits_1; inline;
begin
  getI2C2BIE := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TINT_IEC1.setI2C2SIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $02000000;
end;
procedure TINT_IEC1.clearI2C2SIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $02000000;
end;
procedure TINT_IEC1.setI2C2SIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $02000000
  else
    pTDefRegMap(@Self)^.&set := $02000000;
end;
function  TINT_IEC1.getI2C2SIE : TBits_1; inline;
begin
  getI2C2SIE := (pTDefRegMap(@Self)^.val and $02000000) shr 25;
end;
procedure TINT_IEC1.setI2C2MIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TINT_IEC1.clearI2C2MIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TINT_IEC1.setI2C2MIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TINT_IEC1.getI2C2MIE : TBits_1; inline;
begin
  getI2C2MIE := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TINT_IEC1.setCTMUIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TINT_IEC1.clearCTMUIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TINT_IEC1.setCTMUIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TINT_IEC1.getCTMUIE : TBits_1; inline;
begin
  getCTMUIE := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TINT_IEC1.setDMA0IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TINT_IEC1.clearDMA0IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TINT_IEC1.setDMA0IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TINT_IEC1.getDMA0IE : TBits_1; inline;
begin
  getDMA0IE := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TINT_IEC1.setDMA1IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TINT_IEC1.clearDMA1IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TINT_IEC1.setDMA1IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TINT_IEC1.getDMA1IE : TBits_1; inline;
begin
  getDMA1IE := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TINT_IEC1.setDMA2IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TINT_IEC1.clearDMA2IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TINT_IEC1.setDMA2IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TINT_IEC1.getDMA2IE : TBits_1; inline;
begin
  getDMA2IE := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TINT_IEC1.setDMA3IE; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TINT_IEC1.clearDMA3IE; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TINT_IEC1.setDMA3IE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TINT_IEC1.getDMA3IE : TBits_1; inline;
begin
  getDMA3IE := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TINT_IEC1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IEC1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC0.setCTIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC0.getCTIS : TBits_2; inline;
begin
  getCTIS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC0.setCTIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC0.getCTIP : TBits_3; inline;
begin
  getCTIP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC0.setCS0IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC0.getCS0IS : TBits_2; inline;
begin
  getCS0IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC0.setCS0IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC0.getCS0IP : TBits_3; inline;
begin
  getCS0IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC0.setCS1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC0.getCS1IS : TBits_2; inline;
begin
  getCS1IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC0.setCS1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC0.getCS1IP : TBits_3; inline;
begin
  getCS1IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC0.setINT0IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC0.getINT0IS : TBits_2; inline;
begin
  getINT0IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC0.setINT0IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC0.getINT0IP : TBits_3; inline;
begin
  getINT0IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC1.setT1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC1.getT1IS : TBits_2; inline;
begin
  getT1IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC1.setT1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC1.getT1IP : TBits_3; inline;
begin
  getT1IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC1.setIC1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC1.getIC1IS : TBits_2; inline;
begin
  getIC1IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC1.setIC1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC1.getIC1IP : TBits_3; inline;
begin
  getIC1IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC1.setOC1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC1.getOC1IS : TBits_2; inline;
begin
  getOC1IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC1.setOC1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC1.getOC1IP : TBits_3; inline;
begin
  getOC1IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC1.setINT1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC1.getINT1IS : TBits_2; inline;
begin
  getINT1IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC1.setINT1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC1.getINT1IP : TBits_3; inline;
begin
  getINT1IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC2.setT2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC2.getT2IS : TBits_2; inline;
begin
  getT2IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC2.setT2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC2.getT2IP : TBits_3; inline;
begin
  getT2IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC2.setIC2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC2.getIC2IS : TBits_2; inline;
begin
  getIC2IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC2.setIC2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC2.getIC2IP : TBits_3; inline;
begin
  getIC2IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC2.setOC2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC2.getOC2IS : TBits_2; inline;
begin
  getOC2IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC2.setOC2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC2.getOC2IP : TBits_3; inline;
begin
  getOC2IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC2.setINT2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC2.getINT2IS : TBits_2; inline;
begin
  getINT2IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC2.setINT2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC2.getINT2IP : TBits_3; inline;
begin
  getINT2IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC3.setT3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC3.getT3IS : TBits_2; inline;
begin
  getT3IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC3.setT3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC3.getT3IP : TBits_3; inline;
begin
  getT3IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC3.setIC3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC3.getIC3IS : TBits_2; inline;
begin
  getIC3IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC3.setIC3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC3.getIC3IP : TBits_3; inline;
begin
  getIC3IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC3.setOC3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC3.getOC3IS : TBits_2; inline;
begin
  getOC3IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC3.setOC3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC3.getOC3IP : TBits_3; inline;
begin
  getOC3IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC3.setINT3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC3.getINT3IS : TBits_2; inline;
begin
  getINT3IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC3.setINT3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC3.getINT3IP : TBits_3; inline;
begin
  getINT3IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC4.setT4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC4.getT4IS : TBits_2; inline;
begin
  getT4IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC4.setT4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC4.getT4IP : TBits_3; inline;
begin
  getT4IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC4.setIC4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC4.getIC4IS : TBits_2; inline;
begin
  getIC4IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC4.setIC4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC4.getIC4IP : TBits_3; inline;
begin
  getIC4IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC4.setOC4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC4.getOC4IS : TBits_2; inline;
begin
  getOC4IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC4.setOC4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC4.getOC4IP : TBits_3; inline;
begin
  getOC4IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC4.setINT4IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC4.getINT4IS : TBits_2; inline;
begin
  getINT4IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC4.setINT4IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC4.getINT4IP : TBits_3; inline;
begin
  getINT4IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC4.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC4.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC5.setT5IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC5.getT5IS : TBits_2; inline;
begin
  getT5IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC5.setT5IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC5.getT5IP : TBits_3; inline;
begin
  getT5IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC5.setIC5IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC5.getIC5IS : TBits_2; inline;
begin
  getIC5IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC5.setIC5IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC5.getIC5IP : TBits_3; inline;
begin
  getIC5IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC5.setOC5IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC5.getOC5IS : TBits_2; inline;
begin
  getOC5IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC5.setOC5IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC5.getOC5IP : TBits_3; inline;
begin
  getOC5IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC5.setAD1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC5.getAD1IS : TBits_2; inline;
begin
  getAD1IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC5.setAD1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC5.getAD1IP : TBits_3; inline;
begin
  getAD1IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC5.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC5.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC6.setFSCMIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC6.getFSCMIS : TBits_2; inline;
begin
  getFSCMIS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC6.setFSCMIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC6.getFSCMIP : TBits_3; inline;
begin
  getFSCMIP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC6.setRTCCIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC6.getRTCCIS : TBits_2; inline;
begin
  getRTCCIS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC6.setRTCCIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC6.getRTCCIP : TBits_3; inline;
begin
  getRTCCIP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC6.setFCEIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC6.getFCEIS : TBits_2; inline;
begin
  getFCEIS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC6.setFCEIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC6.getFCEIP : TBits_3; inline;
begin
  getFCEIP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC6.setCMP1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC6.getCMP1IS : TBits_2; inline;
begin
  getCMP1IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC6.setCMP1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC6.getCMP1IP : TBits_3; inline;
begin
  getCMP1IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC6.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC6.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC7.setCMP2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC7.getCMP2IS : TBits_2; inline;
begin
  getCMP2IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC7.setCMP2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC7.getCMP2IP : TBits_3; inline;
begin
  getCMP2IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC7.setCMP3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC7.getCMP3IS : TBits_2; inline;
begin
  getCMP3IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC7.setCMP3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC7.getCMP3IP : TBits_3; inline;
begin
  getCMP3IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC7.setUSBIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC7.getUSBIS : TBits_2; inline;
begin
  getUSBIS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC7.setUSBIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC7.getUSBIP : TBits_3; inline;
begin
  getUSBIP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC7.setSPI1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC7.getSPI1IS : TBits_2; inline;
begin
  getSPI1IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC7.setSPI1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC7.getSPI1IP : TBits_3; inline;
begin
  getSPI1IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC7.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC7.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC8.setU1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC8.getU1IS : TBits_2; inline;
begin
  getU1IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC8.setU1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC8.getU1IP : TBits_3; inline;
begin
  getU1IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC8.setI2C1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC8.getI2C1IS : TBits_2; inline;
begin
  getI2C1IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC8.setI2C1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC8.getI2C1IP : TBits_3; inline;
begin
  getI2C1IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC8.setCNIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC8.getCNIS : TBits_2; inline;
begin
  getCNIS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC8.setCNIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC8.getCNIP : TBits_3; inline;
begin
  getCNIP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC8.setPMPIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC8.getPMPIS : TBits_2; inline;
begin
  getPMPIS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC8.setPMPIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC8.getPMPIP : TBits_3; inline;
begin
  getPMPIP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC8.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC8.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC9.setSPI2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC9.getSPI2IS : TBits_2; inline;
begin
  getSPI2IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC9.setSPI2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC9.getSPI2IP : TBits_3; inline;
begin
  getSPI2IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC9.setU2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC9.getU2IS : TBits_2; inline;
begin
  getU2IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC9.setU2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC9.getU2IP : TBits_3; inline;
begin
  getU2IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC9.setI2C2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC9.getI2C2IS : TBits_2; inline;
begin
  getI2C2IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC9.setI2C2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC9.getI2C2IP : TBits_3; inline;
begin
  getI2C2IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC9.setCTMUIS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC9.getCTMUIS : TBits_2; inline;
begin
  getCTMUIS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC9.setCTMUIP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC9.getCTMUIP : TBits_3; inline;
begin
  getCTMUIP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC9.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC9.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TINT_IPC10.setDMA0IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TINT_IPC10.getDMA0IS : TBits_2; inline;
begin
  getDMA0IS := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TINT_IPC10.setDMA0IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE3 or ( thebits shl 2 );
end;
function  TINT_IPC10.getDMA0IP : TBits_3; inline;
begin
  getDMA0IP := (pTDefRegMap(@Self)^.val and $0000001C) shr 2;
end;
procedure TINT_IPC10.setDMA1IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TINT_IPC10.getDMA1IS : TBits_2; inline;
begin
  getDMA1IS := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TINT_IPC10.setDMA1IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE3FF or ( thebits shl 10 );
end;
function  TINT_IPC10.getDMA1IP : TBits_3; inline;
begin
  getDMA1IP := (pTDefRegMap(@Self)^.val and $00001C00) shr 10;
end;
procedure TINT_IPC10.setDMA2IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFCFFFF or ( thebits shl 16 );
end;
function  TINT_IPC10.getDMA2IS : TBits_2; inline;
begin
  getDMA2IS := (pTDefRegMap(@Self)^.val and $00030000) shr 16;
end;
procedure TINT_IPC10.setDMA2IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE3FFFF or ( thebits shl 18 );
end;
function  TINT_IPC10.getDMA2IP : TBits_3; inline;
begin
  getDMA2IP := (pTDefRegMap(@Self)^.val and $001C0000) shr 18;
end;
procedure TINT_IPC10.setDMA3IS(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TINT_IPC10.getDMA3IS : TBits_2; inline;
begin
  getDMA3IS := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TINT_IPC10.setDMA3IP(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $E3FFFFFF or ( thebits shl 26 );
end;
function  TINT_IPC10.getDMA3IP : TBits_3; inline;
begin
  getDMA3IP := (pTDefRegMap(@Self)^.val and $1C000000) shr 26;
end;
procedure TINT_IPC10.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TINT_IPC10.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TBMX_BMXCON.setBMXARB(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TBMX_BMXCON.getBMXARB : TBits_3; inline;
begin
  getBMXARB := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TBMX_BMXCON.setBMXWSDRM; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TBMX_BMXCON.clearBMXWSDRM; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TBMX_BMXCON.setBMXWSDRM(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TBMX_BMXCON.getBMXWSDRM : TBits_1; inline;
begin
  getBMXWSDRM := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TBMX_BMXCON.setBMXERRIS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TBMX_BMXCON.clearBMXERRIS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TBMX_BMXCON.setBMXERRIS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TBMX_BMXCON.getBMXERRIS : TBits_1; inline;
begin
  getBMXERRIS := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TBMX_BMXCON.setBMXERRDS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TBMX_BMXCON.clearBMXERRDS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TBMX_BMXCON.setBMXERRDS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TBMX_BMXCON.getBMXERRDS : TBits_1; inline;
begin
  getBMXERRDS := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TBMX_BMXCON.setBMXERRDMA; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TBMX_BMXCON.clearBMXERRDMA; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TBMX_BMXCON.setBMXERRDMA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TBMX_BMXCON.getBMXERRDMA : TBits_1; inline;
begin
  getBMXERRDMA := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TBMX_BMXCON.setBMXERRICD; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TBMX_BMXCON.clearBMXERRICD; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TBMX_BMXCON.setBMXERRICD(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TBMX_BMXCON.getBMXERRICD : TBits_1; inline;
begin
  getBMXERRICD := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TBMX_BMXCON.setBMXERRIXI; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TBMX_BMXCON.clearBMXERRIXI; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TBMX_BMXCON.setBMXERRIXI(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TBMX_BMXCON.getBMXERRIXI : TBits_1; inline;
begin
  getBMXERRIXI := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TBMX_BMXCON.setBMXCHEDMA; inline;
begin
  pTDefRegMap(@Self)^.&set := $04000000;
end;
procedure TBMX_BMXCON.clearBMXCHEDMA; inline;
begin
  pTDefRegMap(@Self)^.clr := $04000000;
end;
procedure TBMX_BMXCON.setBMXCHEDMA(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $04000000
  else
    pTDefRegMap(@Self)^.&set := $04000000;
end;
function  TBMX_BMXCON.getBMXCHEDMA : TBits_1; inline;
begin
  getBMXCHEDMA := (pTDefRegMap(@Self)^.val and $04000000) shr 26;
end;
procedure TBMX_BMXCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TBMX_BMXCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC_DMACON.setDMABUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TDMAC_DMACON.clearDMABUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TDMAC_DMACON.setDMABUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TDMAC_DMACON.getDMABUSY : TBits_1; inline;
begin
  getDMABUSY := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TDMAC_DMACON.setSUSPEND; inline;
begin
  pTDefRegMap(@Self)^.&set := $00001000;
end;
procedure TDMAC_DMACON.clearSUSPEND; inline;
begin
  pTDefRegMap(@Self)^.clr := $00001000;
end;
procedure TDMAC_DMACON.setSUSPEND(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00001000
  else
    pTDefRegMap(@Self)^.&set := $00001000;
end;
function  TDMAC_DMACON.getSUSPEND : TBits_1; inline;
begin
  getSUSPEND := (pTDefRegMap(@Self)^.val and $00001000) shr 12;
end;
procedure TDMAC_DMACON.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC_DMACON.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC_DMACON.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC_DMACON.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC_DMACON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC_DMACON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC_DMASTAT.setDMACH(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TDMAC_DMASTAT.getDMACH : TBits_3; inline;
begin
  getDMACH := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TDMAC_DMASTAT.setRDWR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC_DMASTAT.clearRDWR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC_DMASTAT.setRDWR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC_DMASTAT.getRDWR : TBits_1; inline;
begin
  getRDWR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC_DMASTAT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC_DMASTAT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC_DCRCCON.setCRCCH(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TDMAC_DCRCCON.getCRCCH : TBits_3; inline;
begin
  getCRCCH := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TDMAC_DCRCCON.setCRCTYP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC_DCRCCON.clearCRCTYP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC_DCRCCON.setCRCTYP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC_DCRCCON.getCRCTYP : TBits_1; inline;
begin
  getCRCTYP := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC_DCRCCON.setCRCAPP; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC_DCRCCON.clearCRCAPP; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC_DCRCCON.setCRCAPP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC_DCRCCON.getCRCAPP : TBits_1; inline;
begin
  getCRCAPP := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC_DCRCCON.setCRCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC_DCRCCON.clearCRCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC_DCRCCON.setCRCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC_DCRCCON.getCRCEN : TBits_1; inline;
begin
  getCRCEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC_DCRCCON.setPLEN(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFE0FF or ( thebits shl 8 );
end;
function  TDMAC_DCRCCON.getPLEN : TBits_5; inline;
begin
  getPLEN := (pTDefRegMap(@Self)^.val and $00001F00) shr 8;
end;
procedure TDMAC_DCRCCON.setBITO; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TDMAC_DCRCCON.clearBITO; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TDMAC_DCRCCON.setBITO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TDMAC_DCRCCON.getBITO : TBits_1; inline;
begin
  getBITO := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TDMAC_DCRCCON.setWBO; inline;
begin
  pTDefRegMap(@Self)^.&set := $08000000;
end;
procedure TDMAC_DCRCCON.clearWBO; inline;
begin
  pTDefRegMap(@Self)^.clr := $08000000;
end;
procedure TDMAC_DCRCCON.setWBO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $08000000
  else
    pTDefRegMap(@Self)^.&set := $08000000;
end;
function  TDMAC_DCRCCON.getWBO : TBits_1; inline;
begin
  getWBO := (pTDefRegMap(@Self)^.val and $08000000) shr 27;
end;
procedure TDMAC_DCRCCON.setBYTO(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $CFFFFFFF or ( thebits shl 28 );
end;
function  TDMAC_DCRCCON.getBYTO : TBits_2; inline;
begin
  getBYTO := (pTDefRegMap(@Self)^.val and $30000000) shr 28;
end;
procedure TDMAC_DCRCCON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC_DCRCCON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC0_DCH0CON.setCHPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDMAC0_DCH0CON.getCHPRI : TBits_2; inline;
begin
  getCHPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDMAC0_DCH0CON.setCHEDET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC0_DCH0CON.clearCHEDET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC0_DCH0CON.setCHEDET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC0_DCH0CON.getCHEDET : TBits_1; inline;
begin
  getCHEDET := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC0_DCH0CON.setCHAEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC0_DCH0CON.clearCHAEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC0_DCH0CON.setCHAEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC0_DCH0CON.getCHAEN : TBits_1; inline;
begin
  getCHAEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC0_DCH0CON.setCHCHN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC0_DCH0CON.clearCHCHN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC0_DCH0CON.setCHCHN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC0_DCH0CON.getCHCHN : TBits_1; inline;
begin
  getCHCHN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC0_DCH0CON.setCHAED; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC0_DCH0CON.clearCHAED; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC0_DCH0CON.setCHAED(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC0_DCH0CON.getCHAED : TBits_1; inline;
begin
  getCHAED := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC0_DCH0CON.setCHEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC0_DCH0CON.clearCHEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC0_DCH0CON.setCHEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC0_DCH0CON.getCHEN : TBits_1; inline;
begin
  getCHEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC0_DCH0CON.setCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TDMAC0_DCH0CON.clearCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TDMAC0_DCH0CON.setCHCHNS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TDMAC0_DCH0CON.getCHCHNS : TBits_1; inline;
begin
  getCHCHNS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TDMAC0_DCH0CON.setCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC0_DCH0CON.clearCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC0_DCH0CON.setCHBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC0_DCH0CON.getCHBUSY : TBits_1; inline;
begin
  getCHBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC0_DCH0CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC0_DCH0CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC0_DCH0ECON.setAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC0_DCH0ECON.clearAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC0_DCH0ECON.setAIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC0_DCH0ECON.getAIRQEN : TBits_1; inline;
begin
  getAIRQEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC0_DCH0ECON.setSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC0_DCH0ECON.clearSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC0_DCH0ECON.setSIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC0_DCH0ECON.getSIRQEN : TBits_1; inline;
begin
  getSIRQEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC0_DCH0ECON.setPATEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC0_DCH0ECON.clearPATEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC0_DCH0ECON.setPATEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC0_DCH0ECON.getPATEN : TBits_1; inline;
begin
  getPATEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC0_DCH0ECON.setCABORT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC0_DCH0ECON.clearCABORT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC0_DCH0ECON.setCABORT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC0_DCH0ECON.getCABORT : TBits_1; inline;
begin
  getCABORT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC0_DCH0ECON.setCFORCE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC0_DCH0ECON.clearCFORCE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC0_DCH0ECON.setCFORCE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC0_DCH0ECON.getCFORCE : TBits_1; inline;
begin
  getCFORCE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC0_DCH0ECON.setCHSIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF00FF or ( thebits shl 8 );
end;
function  TDMAC0_DCH0ECON.getCHSIRQ : TBits_8; inline;
begin
  getCHSIRQ := (pTDefRegMap(@Self)^.val and $0000FF00) shr 8;
end;
procedure TDMAC0_DCH0ECON.setCHAIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TDMAC0_DCH0ECON.getCHAIRQ : TBits_8; inline;
begin
  getCHAIRQ := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TDMAC0_DCH0ECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC0_DCH0ECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC0_DCH0INT.setCHERIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TDMAC0_DCH0INT.clearCHERIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TDMAC0_DCH0INT.setCHERIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TDMAC0_DCH0INT.getCHERIF : TBits_1; inline;
begin
  getCHERIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TDMAC0_DCH0INT.setCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TDMAC0_DCH0INT.clearCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TDMAC0_DCH0INT.setCHTAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TDMAC0_DCH0INT.getCHTAIF : TBits_1; inline;
begin
  getCHTAIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TDMAC0_DCH0INT.setCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC0_DCH0INT.clearCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC0_DCH0INT.setCHCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC0_DCH0INT.getCHCCIF : TBits_1; inline;
begin
  getCHCCIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC0_DCH0INT.setCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC0_DCH0INT.clearCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC0_DCH0INT.setCHBCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC0_DCH0INT.getCHBCIF : TBits_1; inline;
begin
  getCHBCIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC0_DCH0INT.setCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC0_DCH0INT.clearCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC0_DCH0INT.setCHDHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC0_DCH0INT.getCHDHIF : TBits_1; inline;
begin
  getCHDHIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC0_DCH0INT.setCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC0_DCH0INT.clearCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC0_DCH0INT.setCHDDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC0_DCH0INT.getCHDDIF : TBits_1; inline;
begin
  getCHDDIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC0_DCH0INT.setCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC0_DCH0INT.clearCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC0_DCH0INT.setCHSHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC0_DCH0INT.getCHSHIF : TBits_1; inline;
begin
  getCHSHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC0_DCH0INT.setCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC0_DCH0INT.clearCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC0_DCH0INT.setCHSDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC0_DCH0INT.getCHSDIF : TBits_1; inline;
begin
  getCHSDIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC0_DCH0INT.setCHERIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TDMAC0_DCH0INT.clearCHERIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TDMAC0_DCH0INT.setCHERIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TDMAC0_DCH0INT.getCHERIE : TBits_1; inline;
begin
  getCHERIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TDMAC0_DCH0INT.setCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TDMAC0_DCH0INT.clearCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TDMAC0_DCH0INT.setCHTAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TDMAC0_DCH0INT.getCHTAIE : TBits_1; inline;
begin
  getCHTAIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TDMAC0_DCH0INT.setCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TDMAC0_DCH0INT.clearCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TDMAC0_DCH0INT.setCHCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TDMAC0_DCH0INT.getCHCCIE : TBits_1; inline;
begin
  getCHCCIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TDMAC0_DCH0INT.setCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TDMAC0_DCH0INT.clearCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TDMAC0_DCH0INT.setCHBCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TDMAC0_DCH0INT.getCHBCIE : TBits_1; inline;
begin
  getCHBCIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TDMAC0_DCH0INT.setCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TDMAC0_DCH0INT.clearCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TDMAC0_DCH0INT.setCHDHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TDMAC0_DCH0INT.getCHDHIE : TBits_1; inline;
begin
  getCHDHIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TDMAC0_DCH0INT.setCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TDMAC0_DCH0INT.clearCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TDMAC0_DCH0INT.setCHDDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TDMAC0_DCH0INT.getCHDDIE : TBits_1; inline;
begin
  getCHDDIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TDMAC0_DCH0INT.setCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDMAC0_DCH0INT.clearCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDMAC0_DCH0INT.setCHSHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDMAC0_DCH0INT.getCHSHIE : TBits_1; inline;
begin
  getCHSHIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDMAC0_DCH0INT.setCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDMAC0_DCH0INT.clearCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDMAC0_DCH0INT.setCHSDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDMAC0_DCH0INT.getCHSDIE : TBits_1; inline;
begin
  getCHSDIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDMAC0_DCH0INT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC0_DCH0INT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC1_DCH1CON.setCHPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDMAC1_DCH1CON.getCHPRI : TBits_2; inline;
begin
  getCHPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDMAC1_DCH1CON.setCHEDET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC1_DCH1CON.clearCHEDET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC1_DCH1CON.setCHEDET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC1_DCH1CON.getCHEDET : TBits_1; inline;
begin
  getCHEDET := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC1_DCH1CON.setCHAEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC1_DCH1CON.clearCHAEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC1_DCH1CON.setCHAEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC1_DCH1CON.getCHAEN : TBits_1; inline;
begin
  getCHAEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC1_DCH1CON.setCHCHN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC1_DCH1CON.clearCHCHN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC1_DCH1CON.setCHCHN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC1_DCH1CON.getCHCHN : TBits_1; inline;
begin
  getCHCHN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC1_DCH1CON.setCHAED; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC1_DCH1CON.clearCHAED; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC1_DCH1CON.setCHAED(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC1_DCH1CON.getCHAED : TBits_1; inline;
begin
  getCHAED := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC1_DCH1CON.setCHEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC1_DCH1CON.clearCHEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC1_DCH1CON.setCHEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC1_DCH1CON.getCHEN : TBits_1; inline;
begin
  getCHEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC1_DCH1CON.setCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TDMAC1_DCH1CON.clearCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TDMAC1_DCH1CON.setCHCHNS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TDMAC1_DCH1CON.getCHCHNS : TBits_1; inline;
begin
  getCHCHNS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TDMAC1_DCH1CON.setCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC1_DCH1CON.clearCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC1_DCH1CON.setCHBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC1_DCH1CON.getCHBUSY : TBits_1; inline;
begin
  getCHBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC1_DCH1CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC1_DCH1CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC1_DCH1ECON.setAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC1_DCH1ECON.clearAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC1_DCH1ECON.setAIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC1_DCH1ECON.getAIRQEN : TBits_1; inline;
begin
  getAIRQEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC1_DCH1ECON.setSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC1_DCH1ECON.clearSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC1_DCH1ECON.setSIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC1_DCH1ECON.getSIRQEN : TBits_1; inline;
begin
  getSIRQEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC1_DCH1ECON.setPATEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC1_DCH1ECON.clearPATEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC1_DCH1ECON.setPATEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC1_DCH1ECON.getPATEN : TBits_1; inline;
begin
  getPATEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC1_DCH1ECON.setCABORT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC1_DCH1ECON.clearCABORT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC1_DCH1ECON.setCABORT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC1_DCH1ECON.getCABORT : TBits_1; inline;
begin
  getCABORT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC1_DCH1ECON.setCFORCE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC1_DCH1ECON.clearCFORCE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC1_DCH1ECON.setCFORCE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC1_DCH1ECON.getCFORCE : TBits_1; inline;
begin
  getCFORCE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC1_DCH1ECON.setCHSIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF00FF or ( thebits shl 8 );
end;
function  TDMAC1_DCH1ECON.getCHSIRQ : TBits_8; inline;
begin
  getCHSIRQ := (pTDefRegMap(@Self)^.val and $0000FF00) shr 8;
end;
procedure TDMAC1_DCH1ECON.setCHAIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TDMAC1_DCH1ECON.getCHAIRQ : TBits_8; inline;
begin
  getCHAIRQ := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TDMAC1_DCH1ECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC1_DCH1ECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC1_DCH1INT.setCHERIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TDMAC1_DCH1INT.clearCHERIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TDMAC1_DCH1INT.setCHERIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TDMAC1_DCH1INT.getCHERIF : TBits_1; inline;
begin
  getCHERIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TDMAC1_DCH1INT.setCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TDMAC1_DCH1INT.clearCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TDMAC1_DCH1INT.setCHTAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TDMAC1_DCH1INT.getCHTAIF : TBits_1; inline;
begin
  getCHTAIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TDMAC1_DCH1INT.setCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC1_DCH1INT.clearCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC1_DCH1INT.setCHCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC1_DCH1INT.getCHCCIF : TBits_1; inline;
begin
  getCHCCIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC1_DCH1INT.setCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC1_DCH1INT.clearCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC1_DCH1INT.setCHBCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC1_DCH1INT.getCHBCIF : TBits_1; inline;
begin
  getCHBCIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC1_DCH1INT.setCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC1_DCH1INT.clearCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC1_DCH1INT.setCHDHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC1_DCH1INT.getCHDHIF : TBits_1; inline;
begin
  getCHDHIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC1_DCH1INT.setCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC1_DCH1INT.clearCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC1_DCH1INT.setCHDDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC1_DCH1INT.getCHDDIF : TBits_1; inline;
begin
  getCHDDIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC1_DCH1INT.setCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC1_DCH1INT.clearCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC1_DCH1INT.setCHSHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC1_DCH1INT.getCHSHIF : TBits_1; inline;
begin
  getCHSHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC1_DCH1INT.setCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC1_DCH1INT.clearCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC1_DCH1INT.setCHSDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC1_DCH1INT.getCHSDIF : TBits_1; inline;
begin
  getCHSDIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC1_DCH1INT.setCHERIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TDMAC1_DCH1INT.clearCHERIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TDMAC1_DCH1INT.setCHERIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TDMAC1_DCH1INT.getCHERIE : TBits_1; inline;
begin
  getCHERIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TDMAC1_DCH1INT.setCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TDMAC1_DCH1INT.clearCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TDMAC1_DCH1INT.setCHTAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TDMAC1_DCH1INT.getCHTAIE : TBits_1; inline;
begin
  getCHTAIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TDMAC1_DCH1INT.setCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TDMAC1_DCH1INT.clearCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TDMAC1_DCH1INT.setCHCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TDMAC1_DCH1INT.getCHCCIE : TBits_1; inline;
begin
  getCHCCIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TDMAC1_DCH1INT.setCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TDMAC1_DCH1INT.clearCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TDMAC1_DCH1INT.setCHBCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TDMAC1_DCH1INT.getCHBCIE : TBits_1; inline;
begin
  getCHBCIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TDMAC1_DCH1INT.setCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TDMAC1_DCH1INT.clearCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TDMAC1_DCH1INT.setCHDHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TDMAC1_DCH1INT.getCHDHIE : TBits_1; inline;
begin
  getCHDHIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TDMAC1_DCH1INT.setCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TDMAC1_DCH1INT.clearCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TDMAC1_DCH1INT.setCHDDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TDMAC1_DCH1INT.getCHDDIE : TBits_1; inline;
begin
  getCHDDIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TDMAC1_DCH1INT.setCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDMAC1_DCH1INT.clearCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDMAC1_DCH1INT.setCHSHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDMAC1_DCH1INT.getCHSHIE : TBits_1; inline;
begin
  getCHSHIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDMAC1_DCH1INT.setCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDMAC1_DCH1INT.clearCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDMAC1_DCH1INT.setCHSDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDMAC1_DCH1INT.getCHSDIE : TBits_1; inline;
begin
  getCHSDIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDMAC1_DCH1INT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC1_DCH1INT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC2_DCH2CON.setCHPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDMAC2_DCH2CON.getCHPRI : TBits_2; inline;
begin
  getCHPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDMAC2_DCH2CON.setCHEDET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC2_DCH2CON.clearCHEDET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC2_DCH2CON.setCHEDET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC2_DCH2CON.getCHEDET : TBits_1; inline;
begin
  getCHEDET := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC2_DCH2CON.setCHAEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC2_DCH2CON.clearCHAEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC2_DCH2CON.setCHAEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC2_DCH2CON.getCHAEN : TBits_1; inline;
begin
  getCHAEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC2_DCH2CON.setCHCHN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC2_DCH2CON.clearCHCHN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC2_DCH2CON.setCHCHN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC2_DCH2CON.getCHCHN : TBits_1; inline;
begin
  getCHCHN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC2_DCH2CON.setCHAED; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC2_DCH2CON.clearCHAED; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC2_DCH2CON.setCHAED(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC2_DCH2CON.getCHAED : TBits_1; inline;
begin
  getCHAED := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC2_DCH2CON.setCHEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC2_DCH2CON.clearCHEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC2_DCH2CON.setCHEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC2_DCH2CON.getCHEN : TBits_1; inline;
begin
  getCHEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC2_DCH2CON.setCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TDMAC2_DCH2CON.clearCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TDMAC2_DCH2CON.setCHCHNS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TDMAC2_DCH2CON.getCHCHNS : TBits_1; inline;
begin
  getCHCHNS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TDMAC2_DCH2CON.setCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC2_DCH2CON.clearCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC2_DCH2CON.setCHBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC2_DCH2CON.getCHBUSY : TBits_1; inline;
begin
  getCHBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC2_DCH2CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC2_DCH2CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC2_DCH2ECON.setAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC2_DCH2ECON.clearAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC2_DCH2ECON.setAIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC2_DCH2ECON.getAIRQEN : TBits_1; inline;
begin
  getAIRQEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC2_DCH2ECON.setSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC2_DCH2ECON.clearSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC2_DCH2ECON.setSIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC2_DCH2ECON.getSIRQEN : TBits_1; inline;
begin
  getSIRQEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC2_DCH2ECON.setPATEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC2_DCH2ECON.clearPATEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC2_DCH2ECON.setPATEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC2_DCH2ECON.getPATEN : TBits_1; inline;
begin
  getPATEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC2_DCH2ECON.setCABORT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC2_DCH2ECON.clearCABORT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC2_DCH2ECON.setCABORT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC2_DCH2ECON.getCABORT : TBits_1; inline;
begin
  getCABORT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC2_DCH2ECON.setCFORCE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC2_DCH2ECON.clearCFORCE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC2_DCH2ECON.setCFORCE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC2_DCH2ECON.getCFORCE : TBits_1; inline;
begin
  getCFORCE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC2_DCH2ECON.setCHSIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF00FF or ( thebits shl 8 );
end;
function  TDMAC2_DCH2ECON.getCHSIRQ : TBits_8; inline;
begin
  getCHSIRQ := (pTDefRegMap(@Self)^.val and $0000FF00) shr 8;
end;
procedure TDMAC2_DCH2ECON.setCHAIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TDMAC2_DCH2ECON.getCHAIRQ : TBits_8; inline;
begin
  getCHAIRQ := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TDMAC2_DCH2ECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC2_DCH2ECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC2_DCH2INT.setCHERIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TDMAC2_DCH2INT.clearCHERIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TDMAC2_DCH2INT.setCHERIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TDMAC2_DCH2INT.getCHERIF : TBits_1; inline;
begin
  getCHERIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TDMAC2_DCH2INT.setCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TDMAC2_DCH2INT.clearCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TDMAC2_DCH2INT.setCHTAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TDMAC2_DCH2INT.getCHTAIF : TBits_1; inline;
begin
  getCHTAIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TDMAC2_DCH2INT.setCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC2_DCH2INT.clearCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC2_DCH2INT.setCHCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC2_DCH2INT.getCHCCIF : TBits_1; inline;
begin
  getCHCCIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC2_DCH2INT.setCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC2_DCH2INT.clearCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC2_DCH2INT.setCHBCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC2_DCH2INT.getCHBCIF : TBits_1; inline;
begin
  getCHBCIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC2_DCH2INT.setCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC2_DCH2INT.clearCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC2_DCH2INT.setCHDHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC2_DCH2INT.getCHDHIF : TBits_1; inline;
begin
  getCHDHIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC2_DCH2INT.setCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC2_DCH2INT.clearCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC2_DCH2INT.setCHDDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC2_DCH2INT.getCHDDIF : TBits_1; inline;
begin
  getCHDDIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC2_DCH2INT.setCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC2_DCH2INT.clearCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC2_DCH2INT.setCHSHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC2_DCH2INT.getCHSHIF : TBits_1; inline;
begin
  getCHSHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC2_DCH2INT.setCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC2_DCH2INT.clearCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC2_DCH2INT.setCHSDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC2_DCH2INT.getCHSDIF : TBits_1; inline;
begin
  getCHSDIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC2_DCH2INT.setCHERIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TDMAC2_DCH2INT.clearCHERIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TDMAC2_DCH2INT.setCHERIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TDMAC2_DCH2INT.getCHERIE : TBits_1; inline;
begin
  getCHERIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TDMAC2_DCH2INT.setCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TDMAC2_DCH2INT.clearCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TDMAC2_DCH2INT.setCHTAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TDMAC2_DCH2INT.getCHTAIE : TBits_1; inline;
begin
  getCHTAIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TDMAC2_DCH2INT.setCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TDMAC2_DCH2INT.clearCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TDMAC2_DCH2INT.setCHCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TDMAC2_DCH2INT.getCHCCIE : TBits_1; inline;
begin
  getCHCCIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TDMAC2_DCH2INT.setCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TDMAC2_DCH2INT.clearCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TDMAC2_DCH2INT.setCHBCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TDMAC2_DCH2INT.getCHBCIE : TBits_1; inline;
begin
  getCHBCIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TDMAC2_DCH2INT.setCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TDMAC2_DCH2INT.clearCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TDMAC2_DCH2INT.setCHDHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TDMAC2_DCH2INT.getCHDHIE : TBits_1; inline;
begin
  getCHDHIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TDMAC2_DCH2INT.setCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TDMAC2_DCH2INT.clearCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TDMAC2_DCH2INT.setCHDDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TDMAC2_DCH2INT.getCHDDIE : TBits_1; inline;
begin
  getCHDDIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TDMAC2_DCH2INT.setCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDMAC2_DCH2INT.clearCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDMAC2_DCH2INT.setCHSHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDMAC2_DCH2INT.getCHSHIE : TBits_1; inline;
begin
  getCHSHIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDMAC2_DCH2INT.setCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDMAC2_DCH2INT.clearCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDMAC2_DCH2INT.setCHSDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDMAC2_DCH2INT.getCHSDIE : TBits_1; inline;
begin
  getCHSDIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDMAC2_DCH2INT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC2_DCH2INT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC3_DCH3CON.setCHPRI(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDMAC3_DCH3CON.getCHPRI : TBits_2; inline;
begin
  getCHPRI := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDMAC3_DCH3CON.setCHEDET; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC3_DCH3CON.clearCHEDET; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC3_DCH3CON.setCHEDET(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC3_DCH3CON.getCHEDET : TBits_1; inline;
begin
  getCHEDET := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC3_DCH3CON.setCHAEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC3_DCH3CON.clearCHAEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC3_DCH3CON.setCHAEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC3_DCH3CON.getCHAEN : TBits_1; inline;
begin
  getCHAEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC3_DCH3CON.setCHCHN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC3_DCH3CON.clearCHCHN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC3_DCH3CON.setCHCHN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC3_DCH3CON.getCHCHN : TBits_1; inline;
begin
  getCHCHN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC3_DCH3CON.setCHAED; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC3_DCH3CON.clearCHAED; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC3_DCH3CON.setCHAED(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC3_DCH3CON.getCHAED : TBits_1; inline;
begin
  getCHAED := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC3_DCH3CON.setCHEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC3_DCH3CON.clearCHEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC3_DCH3CON.setCHEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC3_DCH3CON.getCHEN : TBits_1; inline;
begin
  getCHEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC3_DCH3CON.setCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TDMAC3_DCH3CON.clearCHCHNS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TDMAC3_DCH3CON.setCHCHNS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TDMAC3_DCH3CON.getCHCHNS : TBits_1; inline;
begin
  getCHCHNS := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TDMAC3_DCH3CON.setCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDMAC3_DCH3CON.clearCHBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDMAC3_DCH3CON.setCHBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDMAC3_DCH3CON.getCHBUSY : TBits_1; inline;
begin
  getCHBUSY := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDMAC3_DCH3CON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC3_DCH3CON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC3_DCH3ECON.setAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC3_DCH3ECON.clearAIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC3_DCH3ECON.setAIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC3_DCH3ECON.getAIRQEN : TBits_1; inline;
begin
  getAIRQEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC3_DCH3ECON.setSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC3_DCH3ECON.clearSIRQEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC3_DCH3ECON.setSIRQEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC3_DCH3ECON.getSIRQEN : TBits_1; inline;
begin
  getSIRQEN := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC3_DCH3ECON.setPATEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC3_DCH3ECON.clearPATEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC3_DCH3ECON.setPATEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC3_DCH3ECON.getPATEN : TBits_1; inline;
begin
  getPATEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC3_DCH3ECON.setCABORT; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC3_DCH3ECON.clearCABORT; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC3_DCH3ECON.setCABORT(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC3_DCH3ECON.getCABORT : TBits_1; inline;
begin
  getCABORT := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC3_DCH3ECON.setCFORCE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC3_DCH3ECON.clearCFORCE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC3_DCH3ECON.setCFORCE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC3_DCH3ECON.getCFORCE : TBits_1; inline;
begin
  getCFORCE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC3_DCH3ECON.setCHSIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF00FF or ( thebits shl 8 );
end;
function  TDMAC3_DCH3ECON.getCHSIRQ : TBits_8; inline;
begin
  getCHSIRQ := (pTDefRegMap(@Self)^.val and $0000FF00) shr 8;
end;
procedure TDMAC3_DCH3ECON.setCHAIRQ(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FF00FFFF or ( thebits shl 16 );
end;
function  TDMAC3_DCH3ECON.getCHAIRQ : TBits_8; inline;
begin
  getCHAIRQ := (pTDefRegMap(@Self)^.val and $00FF0000) shr 16;
end;
procedure TDMAC3_DCH3ECON.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC3_DCH3ECON.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDMAC3_DCH3INT.setCHERIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TDMAC3_DCH3INT.clearCHERIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TDMAC3_DCH3INT.setCHERIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TDMAC3_DCH3INT.getCHERIF : TBits_1; inline;
begin
  getCHERIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TDMAC3_DCH3INT.setCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TDMAC3_DCH3INT.clearCHTAIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TDMAC3_DCH3INT.setCHTAIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TDMAC3_DCH3INT.getCHTAIF : TBits_1; inline;
begin
  getCHTAIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TDMAC3_DCH3INT.setCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDMAC3_DCH3INT.clearCHCCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDMAC3_DCH3INT.setCHCCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDMAC3_DCH3INT.getCHCCIF : TBits_1; inline;
begin
  getCHCCIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDMAC3_DCH3INT.setCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TDMAC3_DCH3INT.clearCHBCIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TDMAC3_DCH3INT.setCHBCIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TDMAC3_DCH3INT.getCHBCIF : TBits_1; inline;
begin
  getCHBCIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TDMAC3_DCH3INT.setCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TDMAC3_DCH3INT.clearCHDHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TDMAC3_DCH3INT.setCHDHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TDMAC3_DCH3INT.getCHDHIF : TBits_1; inline;
begin
  getCHDHIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TDMAC3_DCH3INT.setCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDMAC3_DCH3INT.clearCHDDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDMAC3_DCH3INT.setCHDDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDMAC3_DCH3INT.getCHDDIF : TBits_1; inline;
begin
  getCHDDIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDMAC3_DCH3INT.setCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TDMAC3_DCH3INT.clearCHSHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TDMAC3_DCH3INT.setCHSHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TDMAC3_DCH3INT.getCHSHIF : TBits_1; inline;
begin
  getCHSHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TDMAC3_DCH3INT.setCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDMAC3_DCH3INT.clearCHSDIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDMAC3_DCH3INT.setCHSDIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDMAC3_DCH3INT.getCHSDIF : TBits_1; inline;
begin
  getCHSDIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDMAC3_DCH3INT.setCHERIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00010000;
end;
procedure TDMAC3_DCH3INT.clearCHERIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00010000;
end;
procedure TDMAC3_DCH3INT.setCHERIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00010000
  else
    pTDefRegMap(@Self)^.&set := $00010000;
end;
function  TDMAC3_DCH3INT.getCHERIE : TBits_1; inline;
begin
  getCHERIE := (pTDefRegMap(@Self)^.val and $00010000) shr 16;
end;
procedure TDMAC3_DCH3INT.setCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00020000;
end;
procedure TDMAC3_DCH3INT.clearCHTAIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00020000;
end;
procedure TDMAC3_DCH3INT.setCHTAIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00020000
  else
    pTDefRegMap(@Self)^.&set := $00020000;
end;
function  TDMAC3_DCH3INT.getCHTAIE : TBits_1; inline;
begin
  getCHTAIE := (pTDefRegMap(@Self)^.val and $00020000) shr 17;
end;
procedure TDMAC3_DCH3INT.setCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00040000;
end;
procedure TDMAC3_DCH3INT.clearCHCCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00040000;
end;
procedure TDMAC3_DCH3INT.setCHCCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00040000
  else
    pTDefRegMap(@Self)^.&set := $00040000;
end;
function  TDMAC3_DCH3INT.getCHCCIE : TBits_1; inline;
begin
  getCHCCIE := (pTDefRegMap(@Self)^.val and $00040000) shr 18;
end;
procedure TDMAC3_DCH3INT.setCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00080000;
end;
procedure TDMAC3_DCH3INT.clearCHBCIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00080000;
end;
procedure TDMAC3_DCH3INT.setCHBCIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00080000
  else
    pTDefRegMap(@Self)^.&set := $00080000;
end;
function  TDMAC3_DCH3INT.getCHBCIE : TBits_1; inline;
begin
  getCHBCIE := (pTDefRegMap(@Self)^.val and $00080000) shr 19;
end;
procedure TDMAC3_DCH3INT.setCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00100000;
end;
procedure TDMAC3_DCH3INT.clearCHDHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00100000;
end;
procedure TDMAC3_DCH3INT.setCHDHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00100000
  else
    pTDefRegMap(@Self)^.&set := $00100000;
end;
function  TDMAC3_DCH3INT.getCHDHIE : TBits_1; inline;
begin
  getCHDHIE := (pTDefRegMap(@Self)^.val and $00100000) shr 20;
end;
procedure TDMAC3_DCH3INT.setCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00200000;
end;
procedure TDMAC3_DCH3INT.clearCHDDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00200000;
end;
procedure TDMAC3_DCH3INT.setCHDDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00200000
  else
    pTDefRegMap(@Self)^.&set := $00200000;
end;
function  TDMAC3_DCH3INT.getCHDDIE : TBits_1; inline;
begin
  getCHDDIE := (pTDefRegMap(@Self)^.val and $00200000) shr 21;
end;
procedure TDMAC3_DCH3INT.setCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDMAC3_DCH3INT.clearCHSHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDMAC3_DCH3INT.setCHSHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDMAC3_DCH3INT.getCHSHIE : TBits_1; inline;
begin
  getCHSHIE := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDMAC3_DCH3INT.setCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDMAC3_DCH3INT.clearCHSDIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDMAC3_DCH3INT.setCHSDIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDMAC3_DCH3INT.getCHSDIE : TBits_1; inline;
begin
  getCHSDIE := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDMAC3_DCH3INT.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDMAC3_DCH3INT.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TUSB_U1IR.setURSTIF_DETACHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IR.clearURSTIF_DETACHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IR.setURSTIF_DETACHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IR.getURSTIF_DETACHIF : TBits_1; inline;
begin
  getURSTIF_DETACHIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IR.setUERRIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1IR.clearUERRIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1IR.setUERRIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1IR.getUERRIF : TBits_1; inline;
begin
  getUERRIF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1IR.setSOFIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1IR.clearSOFIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1IR.setSOFIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1IR.getSOFIF : TBits_1; inline;
begin
  getSOFIF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1IR.setTRNIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1IR.clearTRNIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1IR.setTRNIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1IR.getTRNIF : TBits_1; inline;
begin
  getTRNIF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1IR.setIDLEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1IR.clearIDLEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1IR.setIDLEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1IR.getIDLEIF : TBits_1; inline;
begin
  getIDLEIF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1IR.setRESUMEIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1IR.clearRESUMEIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1IR.setRESUMEIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1IR.getRESUMEIF : TBits_1; inline;
begin
  getRESUMEIF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1IR.setATTACHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1IR.clearATTACHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1IR.setATTACHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1IR.getATTACHIF : TBits_1; inline;
begin
  getATTACHIF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1IR.setSTALLIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1IR.clearSTALLIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1IR.setSTALLIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1IR.getSTALLIF : TBits_1; inline;
begin
  getSTALLIF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1IR.setDETACHIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IR.clearDETACHIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IR.setDETACHIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IR.getDETACHIF : TBits_1; inline;
begin
  getDETACHIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IR.setURSTIF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IR.clearURSTIF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IR.setURSTIF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IR.getURSTIF : TBits_1; inline;
begin
  getURSTIF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IE.setURSTIE_DETACHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IE.clearURSTIE_DETACHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IE.setURSTIE_DETACHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IE.getURSTIE_DETACHIE : TBits_1; inline;
begin
  getURSTIE_DETACHIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IE.setUERRIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1IE.clearUERRIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1IE.setUERRIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1IE.getUERRIE : TBits_1; inline;
begin
  getUERRIE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1IE.setSOFIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1IE.clearSOFIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1IE.setSOFIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1IE.getSOFIE : TBits_1; inline;
begin
  getSOFIE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1IE.setTRNIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1IE.clearTRNIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1IE.setTRNIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1IE.getTRNIE : TBits_1; inline;
begin
  getTRNIE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1IE.setIDLEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1IE.clearIDLEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1IE.setIDLEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1IE.getIDLEIE : TBits_1; inline;
begin
  getIDLEIE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1IE.setRESUMEIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1IE.clearRESUMEIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1IE.setRESUMEIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1IE.getRESUMEIE : TBits_1; inline;
begin
  getRESUMEIE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1IE.setATTACHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1IE.clearATTACHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1IE.setATTACHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1IE.getATTACHIE : TBits_1; inline;
begin
  getATTACHIE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1IE.setSTALLIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1IE.clearSTALLIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1IE.setSTALLIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1IE.getSTALLIE : TBits_1; inline;
begin
  getSTALLIE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1IE.setDETACHIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IE.clearDETACHIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IE.setDETACHIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IE.getDETACHIE : TBits_1; inline;
begin
  getDETACHIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1IE.setURSTIE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1IE.clearURSTIE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1IE.setURSTIE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1IE.getURSTIE : TBits_1; inline;
begin
  getURSTIE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1EIR.setPIDEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1EIR.clearPIDEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1EIR.setPIDEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1EIR.getPIDEF : TBits_1; inline;
begin
  getPIDEF := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1EIR.setCRC5EF_EOFEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIR.clearCRC5EF_EOFEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIR.setCRC5EF_EOFEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIR.getCRC5EF_EOFEF : TBits_1; inline;
begin
  getCRC5EF_EOFEF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIR.setCRC16EF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1EIR.clearCRC16EF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1EIR.setCRC16EF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1EIR.getCRC16EF : TBits_1; inline;
begin
  getCRC16EF := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1EIR.setDFN8EF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1EIR.clearDFN8EF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1EIR.setDFN8EF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1EIR.getDFN8EF : TBits_1; inline;
begin
  getDFN8EF := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1EIR.setBTOEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1EIR.clearBTOEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1EIR.setBTOEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1EIR.getBTOEF : TBits_1; inline;
begin
  getBTOEF := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1EIR.setDMAEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1EIR.clearDMAEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1EIR.setDMAEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1EIR.getDMAEF : TBits_1; inline;
begin
  getDMAEF := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1EIR.setBMXEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1EIR.clearBMXEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1EIR.setBMXEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1EIR.getBMXEF : TBits_1; inline;
begin
  getBMXEF := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1EIR.setBTSEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1EIR.clearBTSEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1EIR.setBTSEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1EIR.getBTSEF : TBits_1; inline;
begin
  getBTSEF := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1EIR.setCRC5EF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIR.clearCRC5EF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIR.setCRC5EF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIR.getCRC5EF : TBits_1; inline;
begin
  getCRC5EF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIR.setEOFEF; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIR.clearEOFEF; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIR.setEOFEF(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIR.getEOFEF : TBits_1; inline;
begin
  getEOFEF := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIE.setPIDEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1EIE.clearPIDEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1EIE.setPIDEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1EIE.getPIDEE : TBits_1; inline;
begin
  getPIDEE := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1EIE.setCRC5EE_EOFEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIE.clearCRC5EE_EOFEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIE.setCRC5EE_EOFEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIE.getCRC5EE_EOFEE : TBits_1; inline;
begin
  getCRC5EE_EOFEE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIE.setCRC16EE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1EIE.clearCRC16EE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1EIE.setCRC16EE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1EIE.getCRC16EE : TBits_1; inline;
begin
  getCRC16EE := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1EIE.setDFN8EE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1EIE.clearDFN8EE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1EIE.setDFN8EE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1EIE.getDFN8EE : TBits_1; inline;
begin
  getDFN8EE := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1EIE.setBTOEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1EIE.clearBTOEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1EIE.setBTOEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1EIE.getBTOEE : TBits_1; inline;
begin
  getBTOEE := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1EIE.setDMAEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1EIE.clearDMAEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1EIE.setDMAEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1EIE.getDMAEE : TBits_1; inline;
begin
  getDMAEE := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1EIE.setBMXEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1EIE.clearBMXEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1EIE.setBMXEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1EIE.getBMXEE : TBits_1; inline;
begin
  getBMXEE := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1EIE.setBTSEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1EIE.clearBTSEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1EIE.setBTSEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1EIE.getBTSEE : TBits_1; inline;
begin
  getBTSEE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1EIE.setCRC5EE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIE.clearCRC5EE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIE.setCRC5EE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIE.getCRC5EE : TBits_1; inline;
begin
  getCRC5EE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1EIE.setEOFEE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1EIE.clearEOFEE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1EIE.setEOFEE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1EIE.getEOFEE : TBits_1; inline;
begin
  getEOFEE := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1STAT.setPPBI; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1STAT.clearPPBI; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1STAT.setPPBI(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1STAT.getPPBI : TBits_1; inline;
begin
  getPPBI := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1STAT.setDIR; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1STAT.clearDIR; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1STAT.setDIR(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1STAT.getDIR : TBits_1; inline;
begin
  getDIR := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1STAT.setENDPT(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF0F or ( thebits shl 4 );
end;
function  TUSB_U1STAT.getENDPT : TBits_4; inline;
begin
  getENDPT := (pTDefRegMap(@Self)^.val and $000000F0) shr 4;
end;
procedure TUSB_U1STAT.setENDPT0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1STAT.clearENDPT0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1STAT.setENDPT0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1STAT.getENDPT0 : TBits_1; inline;
begin
  getENDPT0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1STAT.setENDPT1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1STAT.clearENDPT1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1STAT.setENDPT1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1STAT.getENDPT1 : TBits_1; inline;
begin
  getENDPT1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1STAT.setENDPT2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1STAT.clearENDPT2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1STAT.setENDPT2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1STAT.getENDPT2 : TBits_1; inline;
begin
  getENDPT2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1STAT.setENDPT3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1STAT.clearENDPT3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1STAT.setENDPT3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1STAT.getENDPT3 : TBits_1; inline;
begin
  getENDPT3 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1CON.setUSBEN_SOFEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1CON.clearUSBEN_SOFEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1CON.setUSBEN_SOFEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1CON.getUSBEN_SOFEN : TBits_1; inline;
begin
  getUSBEN_SOFEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1CON.setPPBRST; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1CON.clearPPBRST; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1CON.setPPBRST(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1CON.getPPBRST : TBits_1; inline;
begin
  getPPBRST := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1CON.setRESUME; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1CON.clearRESUME; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1CON.setRESUME(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1CON.getRESUME : TBits_1; inline;
begin
  getRESUME := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1CON.setHOSTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1CON.clearHOSTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1CON.setHOSTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1CON.getHOSTEN : TBits_1; inline;
begin
  getHOSTEN := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1CON.setUSBRST; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1CON.clearUSBRST; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1CON.setUSBRST(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1CON.getUSBRST : TBits_1; inline;
begin
  getUSBRST := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1CON.setPKTDIS_TOKBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1CON.clearPKTDIS_TOKBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1CON.setPKTDIS_TOKBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1CON.getPKTDIS_TOKBUSY : TBits_1; inline;
begin
  getPKTDIS_TOKBUSY := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1CON.setSE0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1CON.clearSE0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1CON.setSE0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1CON.getSE0 : TBits_1; inline;
begin
  getSE0 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1CON.setJSTATE; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1CON.clearJSTATE; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1CON.setJSTATE(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1CON.getJSTATE : TBits_1; inline;
begin
  getJSTATE := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1CON.setUSBEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1CON.clearUSBEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1CON.setUSBEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1CON.getUSBEN : TBits_1; inline;
begin
  getUSBEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1CON.setSOFEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1CON.clearSOFEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1CON.setSOFEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1CON.getSOFEN : TBits_1; inline;
begin
  getSOFEN := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1CON.setPKTDIS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1CON.clearPKTDIS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1CON.setPKTDIS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1CON.getPKTDIS : TBits_1; inline;
begin
  getPKTDIS := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1CON.setTOKBUSY; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1CON.clearTOKBUSY; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1CON.setTOKBUSY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1CON.getTOKBUSY : TBits_1; inline;
begin
  getTOKBUSY := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1ADDR.setDEVADDR(thebits : TBits_7); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF80 or ( thebits shl 0 );
end;
function  TUSB_U1ADDR.getDEVADDR : TBits_7; inline;
begin
  getDEVADDR := (pTDefRegMap(@Self)^.val and $0000007F) shr 0;
end;
procedure TUSB_U1ADDR.setLSPDEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1ADDR.clearLSPDEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1ADDR.setLSPDEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1ADDR.getLSPDEN : TBits_1; inline;
begin
  getLSPDEN := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1ADDR.setDEVADDR0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1ADDR.clearDEVADDR0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1ADDR.setDEVADDR0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1ADDR.getDEVADDR0 : TBits_1; inline;
begin
  getDEVADDR0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1ADDR.setDEVADDR1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1ADDR.clearDEVADDR1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1ADDR.setDEVADDR1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1ADDR.getDEVADDR1 : TBits_1; inline;
begin
  getDEVADDR1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1ADDR.setDEVADDR2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1ADDR.clearDEVADDR2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1ADDR.setDEVADDR2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1ADDR.getDEVADDR2 : TBits_1; inline;
begin
  getDEVADDR2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1ADDR.setDEVADDR3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1ADDR.clearDEVADDR3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1ADDR.setDEVADDR3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1ADDR.getDEVADDR3 : TBits_1; inline;
begin
  getDEVADDR3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1ADDR.setDEVADDR4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1ADDR.clearDEVADDR4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1ADDR.setDEVADDR4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1ADDR.getDEVADDR4 : TBits_1; inline;
begin
  getDEVADDR4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1ADDR.setDEVADDR5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1ADDR.clearDEVADDR5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1ADDR.setDEVADDR5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1ADDR.getDEVADDR5 : TBits_1; inline;
begin
  getDEVADDR5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1ADDR.setDEVADDR6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1ADDR.clearDEVADDR6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1ADDR.setDEVADDR6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1ADDR.getDEVADDR6 : TBits_1; inline;
begin
  getDEVADDR6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1FRML.setFRML(thebits : TBits_8); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF00 or ( thebits shl 0 );
end;
function  TUSB_U1FRML.getFRML : TBits_8; inline;
begin
  getFRML := (pTDefRegMap(@Self)^.val and $000000FF) shr 0;
end;
procedure TUSB_U1FRML.setFRM0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1FRML.clearFRM0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1FRML.setFRM0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1FRML.getFRM0 : TBits_1; inline;
begin
  getFRM0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1FRML.setFRM1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1FRML.clearFRM1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1FRML.setFRM1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1FRML.getFRM1 : TBits_1; inline;
begin
  getFRM1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1FRML.setFRM2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1FRML.clearFRM2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1FRML.setFRM2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1FRML.getFRM2 : TBits_1; inline;
begin
  getFRM2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1FRML.setFRM3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1FRML.clearFRM3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1FRML.setFRM3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1FRML.getFRM3 : TBits_1; inline;
begin
  getFRM3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1FRML.setFRM4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1FRML.clearFRM4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1FRML.setFRM4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1FRML.getFRM4 : TBits_1; inline;
begin
  getFRM4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1FRML.setFRM5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1FRML.clearFRM5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1FRML.setFRM5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1FRML.getFRM5 : TBits_1; inline;
begin
  getFRM5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1FRML.setFRM6; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1FRML.clearFRM6; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1FRML.setFRM6(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1FRML.getFRM6 : TBits_1; inline;
begin
  getFRM6 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1FRML.setFRM7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1FRML.clearFRM7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1FRML.setFRM7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1FRML.getFRM7 : TBits_1; inline;
begin
  getFRM7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TUSB_U1FRMH.setFRMH(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TUSB_U1FRMH.getFRMH : TBits_3; inline;
begin
  getFRMH := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TUSB_U1FRMH.setFRM8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1FRMH.clearFRM8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1FRMH.setFRM8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1FRMH.getFRM8 : TBits_1; inline;
begin
  getFRM8 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1FRMH.setFRM9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1FRMH.clearFRM9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1FRMH.setFRM9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1FRMH.getFRM9 : TBits_1; inline;
begin
  getFRM9 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1FRMH.setFRM10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1FRMH.clearFRM10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1FRMH.setFRM10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1FRMH.getFRM10 : TBits_1; inline;
begin
  getFRM10 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1TOK.setEP(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF0 or ( thebits shl 0 );
end;
function  TUSB_U1TOK.getEP : TBits_4; inline;
begin
  getEP := (pTDefRegMap(@Self)^.val and $0000000F) shr 0;
end;
procedure TUSB_U1TOK.setPID(thebits : TBits_4); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF0F or ( thebits shl 4 );
end;
function  TUSB_U1TOK.getPID : TBits_4; inline;
begin
  getPID := (pTDefRegMap(@Self)^.val and $000000F0) shr 4;
end;
procedure TUSB_U1TOK.setEP0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TUSB_U1TOK.clearEP0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TUSB_U1TOK.setEP0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TUSB_U1TOK.getEP0 : TBits_1; inline;
begin
  getEP0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TUSB_U1TOK.setEP1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TUSB_U1TOK.clearEP1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TUSB_U1TOK.setEP1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TUSB_U1TOK.getEP1 : TBits_1; inline;
begin
  getEP1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TUSB_U1TOK.setEP2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TUSB_U1TOK.clearEP2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TUSB_U1TOK.setEP2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TUSB_U1TOK.getEP2 : TBits_1; inline;
begin
  getEP2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TUSB_U1TOK.setEP3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TUSB_U1TOK.clearEP3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TUSB_U1TOK.setEP3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TUSB_U1TOK.getEP3 : TBits_1; inline;
begin
  getEP3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TUSB_U1TOK.setPID0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TUSB_U1TOK.clearPID0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TUSB_U1TOK.setPID0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TUSB_U1TOK.getPID0 : TBits_1; inline;
begin
  getPID0 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TUSB_U1TOK.setPID1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TUSB_U1TOK.clearPID1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TUSB_U1TOK.setPID1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TUSB_U1TOK.getPID1 : TBits_1; inline;
begin
  getPID1 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TUSB_U1TOK.setPID2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000040;
end;
procedure TUSB_U1TOK.clearPID2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000040;
end;
procedure TUSB_U1TOK.setPID2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000040
  else
    pTDefRegMap(@Self)^.&set := $00000040;
end;
function  TUSB_U1TOK.getPID2 : TBits_1; inline;
begin
  getPID2 := (pTDefRegMap(@Self)^.val and $00000040) shr 6;
end;
procedure TUSB_U1TOK.setPID3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TUSB_U1TOK.clearPID3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TUSB_U1TOK.setPID3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TUSB_U1TOK.getPID3 : TBits_1; inline;
begin
  getPID3 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTA_ANSELA.setANSA0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTA_ANSELA.clearANSA0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTA_ANSELA.setANSA0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTA_ANSELA.getANSA0 : TBits_1; inline;
begin
  getANSA0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTA_ANSELA.setANSA1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTA_ANSELA.clearANSA1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTA_ANSELA.setANSA1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTA_ANSELA.getANSA1 : TBits_1; inline;
begin
  getANSA1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTA_ANSELA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTA_ANSELA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTA_TRISA.setTRISA0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTA_TRISA.clearTRISA0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTA_TRISA.setTRISA0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTA_TRISA.getTRISA0 : TBits_1; inline;
begin
  getTRISA0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTA_TRISA.setTRISA1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTA_TRISA.clearTRISA1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTA_TRISA.setTRISA1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTA_TRISA.getTRISA1 : TBits_1; inline;
begin
  getTRISA1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTA_TRISA.setTRISA2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTA_TRISA.clearTRISA2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTA_TRISA.setTRISA2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTA_TRISA.getTRISA2 : TBits_1; inline;
begin
  getTRISA2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTA_TRISA.setTRISA3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTA_TRISA.clearTRISA3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTA_TRISA.setTRISA3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTA_TRISA.getTRISA3 : TBits_1; inline;
begin
  getTRISA3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTA_TRISA.setTRISA4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTA_TRISA.clearTRISA4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTA_TRISA.setTRISA4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTA_TRISA.getTRISA4 : TBits_1; inline;
begin
  getTRISA4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTA_TRISA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTA_TRISA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTA_PORTA.setRA0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTA_PORTA.clearRA0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTA_PORTA.setRA0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTA_PORTA.getRA0 : TBits_1; inline;
begin
  getRA0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTA_PORTA.setRA1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTA_PORTA.clearRA1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTA_PORTA.setRA1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTA_PORTA.getRA1 : TBits_1; inline;
begin
  getRA1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTA_PORTA.setRA2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTA_PORTA.clearRA2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTA_PORTA.setRA2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTA_PORTA.getRA2 : TBits_1; inline;
begin
  getRA2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTA_PORTA.setRA3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTA_PORTA.clearRA3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTA_PORTA.setRA3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTA_PORTA.getRA3 : TBits_1; inline;
begin
  getRA3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTA_PORTA.setRA4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTA_PORTA.clearRA4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTA_PORTA.setRA4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTA_PORTA.getRA4 : TBits_1; inline;
begin
  getRA4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTA_PORTA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTA_PORTA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTA_LATA.setLATA0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTA_LATA.clearLATA0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTA_LATA.setLATA0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTA_LATA.getLATA0 : TBits_1; inline;
begin
  getLATA0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTA_LATA.setLATA1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTA_LATA.clearLATA1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTA_LATA.setLATA1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTA_LATA.getLATA1 : TBits_1; inline;
begin
  getLATA1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTA_LATA.setLATA2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTA_LATA.clearLATA2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTA_LATA.setLATA2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTA_LATA.getLATA2 : TBits_1; inline;
begin
  getLATA2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTA_LATA.setLATA3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTA_LATA.clearLATA3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTA_LATA.setLATA3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTA_LATA.getLATA3 : TBits_1; inline;
begin
  getLATA3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTA_LATA.setLATA4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTA_LATA.clearLATA4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTA_LATA.setLATA4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTA_LATA.getLATA4 : TBits_1; inline;
begin
  getLATA4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTA_LATA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTA_LATA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTA_CNPUA.setCNPUA0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTA_CNPUA.clearCNPUA0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTA_CNPUA.setCNPUA0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTA_CNPUA.getCNPUA0 : TBits_1; inline;
begin
  getCNPUA0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTA_CNPUA.setCNPUA1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTA_CNPUA.clearCNPUA1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTA_CNPUA.setCNPUA1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTA_CNPUA.getCNPUA1 : TBits_1; inline;
begin
  getCNPUA1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTA_CNPUA.setCNPUA2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTA_CNPUA.clearCNPUA2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTA_CNPUA.setCNPUA2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTA_CNPUA.getCNPUA2 : TBits_1; inline;
begin
  getCNPUA2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTA_CNPUA.setCNPUA3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTA_CNPUA.clearCNPUA3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTA_CNPUA.setCNPUA3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTA_CNPUA.getCNPUA3 : TBits_1; inline;
begin
  getCNPUA3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTA_CNPUA.setCNPUA4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTA_CNPUA.clearCNPUA4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTA_CNPUA.setCNPUA4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTA_CNPUA.getCNPUA4 : TBits_1; inline;
begin
  getCNPUA4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTA_CNPUA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTA_CNPUA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTA_CNPDA.setCNPDA0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTA_CNPDA.clearCNPDA0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTA_CNPDA.setCNPDA0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTA_CNPDA.getCNPDA0 : TBits_1; inline;
begin
  getCNPDA0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTA_CNPDA.setCNPDA1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTA_CNPDA.clearCNPDA1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTA_CNPDA.setCNPDA1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTA_CNPDA.getCNPDA1 : TBits_1; inline;
begin
  getCNPDA1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTA_CNPDA.setCNPDA2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTA_CNPDA.clearCNPDA2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTA_CNPDA.setCNPDA2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTA_CNPDA.getCNPDA2 : TBits_1; inline;
begin
  getCNPDA2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTA_CNPDA.setCNPDA3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTA_CNPDA.clearCNPDA3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTA_CNPDA.setCNPDA3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTA_CNPDA.getCNPDA3 : TBits_1; inline;
begin
  getCNPDA3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTA_CNPDA.setCNPDA4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTA_CNPDA.clearCNPDA4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTA_CNPDA.setCNPDA4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTA_CNPDA.getCNPDA4 : TBits_1; inline;
begin
  getCNPDA4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTA_CNPDA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTA_CNPDA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTA_CNCONA.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTA_CNCONA.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTA_CNCONA.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTA_CNCONA.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTA_CNCONA.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTA_CNCONA.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTA_CNCONA.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTA_CNCONA.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTA_CNCONA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTA_CNCONA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTA_CNENA.setCNIEA0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTA_CNENA.clearCNIEA0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTA_CNENA.setCNIEA0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTA_CNENA.getCNIEA0 : TBits_1; inline;
begin
  getCNIEA0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTA_CNENA.setCNIEA1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTA_CNENA.clearCNIEA1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTA_CNENA.setCNIEA1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTA_CNENA.getCNIEA1 : TBits_1; inline;
begin
  getCNIEA1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTA_CNENA.setCNIEA2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTA_CNENA.clearCNIEA2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTA_CNENA.setCNIEA2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTA_CNENA.getCNIEA2 : TBits_1; inline;
begin
  getCNIEA2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTA_CNENA.setCNIEA3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTA_CNENA.clearCNIEA3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTA_CNENA.setCNIEA3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTA_CNENA.getCNIEA3 : TBits_1; inline;
begin
  getCNIEA3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTA_CNENA.setCNIEA4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTA_CNENA.clearCNIEA4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTA_CNENA.setCNIEA4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTA_CNENA.getCNIEA4 : TBits_1; inline;
begin
  getCNIEA4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTA_CNENA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTA_CNENA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTA_CNSTATA.setCNSTATA0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTA_CNSTATA.clearCNSTATA0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTA_CNSTATA.setCNSTATA0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTA_CNSTATA.getCNSTATA0 : TBits_1; inline;
begin
  getCNSTATA0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTA_CNSTATA.setCNSTATA1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTA_CNSTATA.clearCNSTATA1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTA_CNSTATA.setCNSTATA1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTA_CNSTATA.getCNSTATA1 : TBits_1; inline;
begin
  getCNSTATA1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTA_CNSTATA.setCNSTATA2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTA_CNSTATA.clearCNSTATA2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTA_CNSTATA.setCNSTATA2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTA_CNSTATA.getCNSTATA2 : TBits_1; inline;
begin
  getCNSTATA2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTA_CNSTATA.setCNSTATA3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTA_CNSTATA.clearCNSTATA3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTA_CNSTATA.setCNSTATA3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTA_CNSTATA.getCNSTATA3 : TBits_1; inline;
begin
  getCNSTATA3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTA_CNSTATA.setCNSTATA4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTA_CNSTATA.clearCNSTATA4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTA_CNSTATA.setCNSTATA4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTA_CNSTATA.getCNSTATA4 : TBits_1; inline;
begin
  getCNSTATA4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTA_CNSTATA.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTA_CNSTATA.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_ANSELB.setANSB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_ANSELB.clearANSB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_ANSELB.setANSB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_ANSELB.getANSB0 : TBits_1; inline;
begin
  getANSB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_ANSELB.setANSB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_ANSELB.clearANSB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_ANSELB.setANSB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_ANSELB.getANSB1 : TBits_1; inline;
begin
  getANSB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_ANSELB.setANSB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_ANSELB.clearANSB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_ANSELB.setANSB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_ANSELB.getANSB2 : TBits_1; inline;
begin
  getANSB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_ANSELB.setANSB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_ANSELB.clearANSB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_ANSELB.setANSB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_ANSELB.getANSB3 : TBits_1; inline;
begin
  getANSB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_ANSELB.setANSB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_ANSELB.clearANSB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_ANSELB.setANSB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_ANSELB.getANSB13 : TBits_1; inline;
begin
  getANSB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_ANSELB.setANSB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_ANSELB.clearANSB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_ANSELB.setANSB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_ANSELB.getANSB14 : TBits_1; inline;
begin
  getANSB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_ANSELB.setANSB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_ANSELB.clearANSB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_ANSELB.setANSB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_ANSELB.getANSB15 : TBits_1; inline;
begin
  getANSB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_ANSELB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_ANSELB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_TRISB.setTRISB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_TRISB.clearTRISB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_TRISB.setTRISB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_TRISB.getTRISB0 : TBits_1; inline;
begin
  getTRISB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_TRISB.setTRISB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_TRISB.clearTRISB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_TRISB.setTRISB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_TRISB.getTRISB1 : TBits_1; inline;
begin
  getTRISB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_TRISB.setTRISB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_TRISB.clearTRISB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_TRISB.setTRISB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_TRISB.getTRISB2 : TBits_1; inline;
begin
  getTRISB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_TRISB.setTRISB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_TRISB.clearTRISB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_TRISB.setTRISB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_TRISB.getTRISB3 : TBits_1; inline;
begin
  getTRISB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_TRISB.setTRISB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_TRISB.clearTRISB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_TRISB.setTRISB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_TRISB.getTRISB4 : TBits_1; inline;
begin
  getTRISB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_TRISB.setTRISB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_TRISB.clearTRISB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_TRISB.setTRISB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_TRISB.getTRISB5 : TBits_1; inline;
begin
  getTRISB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_TRISB.setTRISB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_TRISB.clearTRISB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_TRISB.setTRISB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_TRISB.getTRISB7 : TBits_1; inline;
begin
  getTRISB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_TRISB.setTRISB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_TRISB.clearTRISB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_TRISB.setTRISB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_TRISB.getTRISB8 : TBits_1; inline;
begin
  getTRISB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_TRISB.setTRISB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_TRISB.clearTRISB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_TRISB.setTRISB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_TRISB.getTRISB9 : TBits_1; inline;
begin
  getTRISB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_TRISB.setTRISB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_TRISB.clearTRISB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_TRISB.setTRISB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_TRISB.getTRISB10 : TBits_1; inline;
begin
  getTRISB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_TRISB.setTRISB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_TRISB.clearTRISB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_TRISB.setTRISB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_TRISB.getTRISB11 : TBits_1; inline;
begin
  getTRISB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_TRISB.setTRISB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_TRISB.clearTRISB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_TRISB.setTRISB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_TRISB.getTRISB13 : TBits_1; inline;
begin
  getTRISB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_TRISB.setTRISB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_TRISB.clearTRISB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_TRISB.setTRISB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_TRISB.getTRISB14 : TBits_1; inline;
begin
  getTRISB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_TRISB.setTRISB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_TRISB.clearTRISB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_TRISB.setTRISB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_TRISB.getTRISB15 : TBits_1; inline;
begin
  getTRISB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_TRISB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_TRISB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_PORTB.setRB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_PORTB.clearRB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_PORTB.setRB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_PORTB.getRB0 : TBits_1; inline;
begin
  getRB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_PORTB.setRB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_PORTB.clearRB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_PORTB.setRB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_PORTB.getRB1 : TBits_1; inline;
begin
  getRB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_PORTB.setRB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_PORTB.clearRB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_PORTB.setRB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_PORTB.getRB2 : TBits_1; inline;
begin
  getRB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_PORTB.setRB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_PORTB.clearRB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_PORTB.setRB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_PORTB.getRB3 : TBits_1; inline;
begin
  getRB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_PORTB.setRB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_PORTB.clearRB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_PORTB.setRB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_PORTB.getRB4 : TBits_1; inline;
begin
  getRB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_PORTB.setRB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_PORTB.clearRB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_PORTB.setRB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_PORTB.getRB5 : TBits_1; inline;
begin
  getRB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_PORTB.setRB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_PORTB.clearRB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_PORTB.setRB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_PORTB.getRB7 : TBits_1; inline;
begin
  getRB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_PORTB.setRB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_PORTB.clearRB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_PORTB.setRB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_PORTB.getRB8 : TBits_1; inline;
begin
  getRB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_PORTB.setRB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_PORTB.clearRB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_PORTB.setRB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_PORTB.getRB9 : TBits_1; inline;
begin
  getRB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_PORTB.setRB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_PORTB.clearRB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_PORTB.setRB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_PORTB.getRB10 : TBits_1; inline;
begin
  getRB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_PORTB.setRB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_PORTB.clearRB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_PORTB.setRB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_PORTB.getRB11 : TBits_1; inline;
begin
  getRB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_PORTB.setRB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_PORTB.clearRB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_PORTB.setRB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_PORTB.getRB13 : TBits_1; inline;
begin
  getRB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_PORTB.setRB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_PORTB.clearRB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_PORTB.setRB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_PORTB.getRB14 : TBits_1; inline;
begin
  getRB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_PORTB.setRB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_PORTB.clearRB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_PORTB.setRB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_PORTB.getRB15 : TBits_1; inline;
begin
  getRB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_PORTB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_PORTB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_LATB.setLATB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_LATB.clearLATB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_LATB.setLATB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_LATB.getLATB0 : TBits_1; inline;
begin
  getLATB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_LATB.setLATB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_LATB.clearLATB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_LATB.setLATB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_LATB.getLATB1 : TBits_1; inline;
begin
  getLATB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_LATB.setLATB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_LATB.clearLATB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_LATB.setLATB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_LATB.getLATB2 : TBits_1; inline;
begin
  getLATB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_LATB.setLATB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_LATB.clearLATB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_LATB.setLATB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_LATB.getLATB3 : TBits_1; inline;
begin
  getLATB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_LATB.setLATB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_LATB.clearLATB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_LATB.setLATB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_LATB.getLATB4 : TBits_1; inline;
begin
  getLATB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_LATB.setLATB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_LATB.clearLATB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_LATB.setLATB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_LATB.getLATB5 : TBits_1; inline;
begin
  getLATB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_LATB.setLATB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_LATB.clearLATB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_LATB.setLATB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_LATB.getLATB7 : TBits_1; inline;
begin
  getLATB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_LATB.setLATB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_LATB.clearLATB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_LATB.setLATB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_LATB.getLATB8 : TBits_1; inline;
begin
  getLATB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_LATB.setLATB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_LATB.clearLATB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_LATB.setLATB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_LATB.getLATB9 : TBits_1; inline;
begin
  getLATB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_LATB.setLATB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_LATB.clearLATB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_LATB.setLATB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_LATB.getLATB10 : TBits_1; inline;
begin
  getLATB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_LATB.setLATB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_LATB.clearLATB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_LATB.setLATB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_LATB.getLATB11 : TBits_1; inline;
begin
  getLATB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_LATB.setLATB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_LATB.clearLATB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_LATB.setLATB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_LATB.getLATB13 : TBits_1; inline;
begin
  getLATB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_LATB.setLATB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_LATB.clearLATB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_LATB.setLATB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_LATB.getLATB14 : TBits_1; inline;
begin
  getLATB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_LATB.setLATB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_LATB.clearLATB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_LATB.setLATB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_LATB.getLATB15 : TBits_1; inline;
begin
  getLATB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_LATB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_LATB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_ODCB.setODCB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_ODCB.clearODCB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_ODCB.setODCB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_ODCB.getODCB4 : TBits_1; inline;
begin
  getODCB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_ODCB.setODCB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_ODCB.clearODCB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_ODCB.setODCB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_ODCB.getODCB5 : TBits_1; inline;
begin
  getODCB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_ODCB.setODCB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_ODCB.clearODCB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_ODCB.setODCB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_ODCB.getODCB7 : TBits_1; inline;
begin
  getODCB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_ODCB.setODCB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_ODCB.clearODCB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_ODCB.setODCB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_ODCB.getODCB8 : TBits_1; inline;
begin
  getODCB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_ODCB.setODCB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_ODCB.clearODCB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_ODCB.setODCB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_ODCB.getODCB9 : TBits_1; inline;
begin
  getODCB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_ODCB.setODCB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_ODCB.clearODCB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_ODCB.setODCB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_ODCB.getODCB10 : TBits_1; inline;
begin
  getODCB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_ODCB.setODCB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_ODCB.clearODCB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_ODCB.setODCB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_ODCB.getODCB11 : TBits_1; inline;
begin
  getODCB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_ODCB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_ODCB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_CNPUB.setCNPUB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_CNPUB.clearCNPUB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_CNPUB.setCNPUB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_CNPUB.getCNPUB0 : TBits_1; inline;
begin
  getCNPUB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_CNPUB.setCNPUB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_CNPUB.clearCNPUB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_CNPUB.setCNPUB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_CNPUB.getCNPUB1 : TBits_1; inline;
begin
  getCNPUB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_CNPUB.setCNPUB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_CNPUB.clearCNPUB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_CNPUB.setCNPUB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_CNPUB.getCNPUB2 : TBits_1; inline;
begin
  getCNPUB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_CNPUB.setCNPUB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_CNPUB.clearCNPUB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_CNPUB.setCNPUB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_CNPUB.getCNPUB3 : TBits_1; inline;
begin
  getCNPUB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_CNPUB.setCNPUB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_CNPUB.clearCNPUB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_CNPUB.setCNPUB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_CNPUB.getCNPUB4 : TBits_1; inline;
begin
  getCNPUB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_CNPUB.setCNPUB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_CNPUB.clearCNPUB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_CNPUB.setCNPUB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_CNPUB.getCNPUB5 : TBits_1; inline;
begin
  getCNPUB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_CNPUB.setCNPUB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_CNPUB.clearCNPUB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_CNPUB.setCNPUB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_CNPUB.getCNPUB7 : TBits_1; inline;
begin
  getCNPUB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_CNPUB.setCNPUB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_CNPUB.clearCNPUB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_CNPUB.setCNPUB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_CNPUB.getCNPUB8 : TBits_1; inline;
begin
  getCNPUB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_CNPUB.setCNPUB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_CNPUB.clearCNPUB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_CNPUB.setCNPUB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_CNPUB.getCNPUB9 : TBits_1; inline;
begin
  getCNPUB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_CNPUB.setCNPUB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_CNPUB.clearCNPUB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_CNPUB.setCNPUB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_CNPUB.getCNPUB10 : TBits_1; inline;
begin
  getCNPUB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_CNPUB.setCNPUB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_CNPUB.clearCNPUB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_CNPUB.setCNPUB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_CNPUB.getCNPUB11 : TBits_1; inline;
begin
  getCNPUB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_CNPUB.setCNPUB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_CNPUB.clearCNPUB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_CNPUB.setCNPUB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_CNPUB.getCNPUB13 : TBits_1; inline;
begin
  getCNPUB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_CNPUB.setCNPUB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_CNPUB.clearCNPUB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_CNPUB.setCNPUB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_CNPUB.getCNPUB14 : TBits_1; inline;
begin
  getCNPUB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_CNPUB.setCNPUB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_CNPUB.clearCNPUB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_CNPUB.setCNPUB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_CNPUB.getCNPUB15 : TBits_1; inline;
begin
  getCNPUB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_CNPUB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_CNPUB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_CNPDB.setCNPDB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_CNPDB.clearCNPDB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_CNPDB.setCNPDB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_CNPDB.getCNPDB0 : TBits_1; inline;
begin
  getCNPDB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_CNPDB.setCNPDB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_CNPDB.clearCNPDB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_CNPDB.setCNPDB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_CNPDB.getCNPDB1 : TBits_1; inline;
begin
  getCNPDB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_CNPDB.setCNPDB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_CNPDB.clearCNPDB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_CNPDB.setCNPDB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_CNPDB.getCNPDB2 : TBits_1; inline;
begin
  getCNPDB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_CNPDB.setCNPDB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_CNPDB.clearCNPDB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_CNPDB.setCNPDB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_CNPDB.getCNPDB3 : TBits_1; inline;
begin
  getCNPDB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_CNPDB.setCNPDB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_CNPDB.clearCNPDB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_CNPDB.setCNPDB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_CNPDB.getCNPDB4 : TBits_1; inline;
begin
  getCNPDB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_CNPDB.setCNPDB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_CNPDB.clearCNPDB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_CNPDB.setCNPDB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_CNPDB.getCNPDB5 : TBits_1; inline;
begin
  getCNPDB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_CNPDB.setCNPDB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_CNPDB.clearCNPDB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_CNPDB.setCNPDB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_CNPDB.getCNPDB7 : TBits_1; inline;
begin
  getCNPDB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_CNPDB.setCNPDB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_CNPDB.clearCNPDB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_CNPDB.setCNPDB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_CNPDB.getCNPDB8 : TBits_1; inline;
begin
  getCNPDB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_CNPDB.setCNPDB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_CNPDB.clearCNPDB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_CNPDB.setCNPDB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_CNPDB.getCNPDB9 : TBits_1; inline;
begin
  getCNPDB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_CNPDB.setCNPDB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_CNPDB.clearCNPDB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_CNPDB.setCNPDB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_CNPDB.getCNPDB10 : TBits_1; inline;
begin
  getCNPDB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_CNPDB.setCNPDB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_CNPDB.clearCNPDB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_CNPDB.setCNPDB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_CNPDB.getCNPDB11 : TBits_1; inline;
begin
  getCNPDB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_CNPDB.setCNPDB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_CNPDB.clearCNPDB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_CNPDB.setCNPDB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_CNPDB.getCNPDB13 : TBits_1; inline;
begin
  getCNPDB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_CNPDB.setCNPDB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_CNPDB.clearCNPDB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_CNPDB.setCNPDB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_CNPDB.getCNPDB14 : TBits_1; inline;
begin
  getCNPDB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_CNPDB.setCNPDB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_CNPDB.clearCNPDB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_CNPDB.setCNPDB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_CNPDB.getCNPDB15 : TBits_1; inline;
begin
  getCNPDB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_CNPDB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_CNPDB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_CNCONB.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_CNCONB.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_CNCONB.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_CNCONB.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_CNCONB.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_CNCONB.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_CNCONB.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_CNCONB.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_CNCONB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_CNCONB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_CNENB.setCNIEB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_CNENB.clearCNIEB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_CNENB.setCNIEB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_CNENB.getCNIEB0 : TBits_1; inline;
begin
  getCNIEB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_CNENB.setCNIEB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_CNENB.clearCNIEB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_CNENB.setCNIEB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_CNENB.getCNIEB1 : TBits_1; inline;
begin
  getCNIEB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_CNENB.setCNIEB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_CNENB.clearCNIEB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_CNENB.setCNIEB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_CNENB.getCNIEB2 : TBits_1; inline;
begin
  getCNIEB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_CNENB.setCNIEB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_CNENB.clearCNIEB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_CNENB.setCNIEB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_CNENB.getCNIEB3 : TBits_1; inline;
begin
  getCNIEB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_CNENB.setCNIEB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_CNENB.clearCNIEB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_CNENB.setCNIEB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_CNENB.getCNIEB4 : TBits_1; inline;
begin
  getCNIEB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_CNENB.setCNIEB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_CNENB.clearCNIEB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_CNENB.setCNIEB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_CNENB.getCNIEB5 : TBits_1; inline;
begin
  getCNIEB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_CNENB.setCNIEB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_CNENB.clearCNIEB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_CNENB.setCNIEB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_CNENB.getCNIEB7 : TBits_1; inline;
begin
  getCNIEB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_CNENB.setCNIEB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_CNENB.clearCNIEB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_CNENB.setCNIEB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_CNENB.getCNIEB8 : TBits_1; inline;
begin
  getCNIEB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_CNENB.setCNIEB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_CNENB.clearCNIEB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_CNENB.setCNIEB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_CNENB.getCNIEB9 : TBits_1; inline;
begin
  getCNIEB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_CNENB.setCNIEB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_CNENB.clearCNIEB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_CNENB.setCNIEB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_CNENB.getCNIEB10 : TBits_1; inline;
begin
  getCNIEB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_CNENB.setCNIEB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_CNENB.clearCNIEB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_CNENB.setCNIEB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_CNENB.getCNIEB11 : TBits_1; inline;
begin
  getCNIEB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_CNENB.setCNIEB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_CNENB.clearCNIEB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_CNENB.setCNIEB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_CNENB.getCNIEB13 : TBits_1; inline;
begin
  getCNIEB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_CNENB.setCNIEB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_CNENB.clearCNIEB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_CNENB.setCNIEB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_CNENB.getCNIEB14 : TBits_1; inline;
begin
  getCNIEB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_CNENB.setCNIEB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_CNENB.clearCNIEB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_CNENB.setCNIEB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_CNENB.getCNIEB15 : TBits_1; inline;
begin
  getCNIEB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_CNENB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_CNENB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTB_CNSTATB.setCNSTATB0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTB_CNSTATB.clearCNSTATB0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTB_CNSTATB.setCNSTATB0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTB_CNSTATB.getCNSTATB0 : TBits_1; inline;
begin
  getCNSTATB0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTB_CNSTATB.setCNSTATB1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTB_CNSTATB.clearCNSTATB1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTB_CNSTATB.setCNSTATB1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTB_CNSTATB.getCNSTATB1 : TBits_1; inline;
begin
  getCNSTATB1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTB_CNSTATB.setCNSTATB2; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TPORTB_CNSTATB.clearCNSTATB2; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TPORTB_CNSTATB.setCNSTATB2(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TPORTB_CNSTATB.getCNSTATB2 : TBits_1; inline;
begin
  getCNSTATB2 := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TPORTB_CNSTATB.setCNSTATB3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTB_CNSTATB.clearCNSTATB3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTB_CNSTATB.setCNSTATB3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTB_CNSTATB.getCNSTATB3 : TBits_1; inline;
begin
  getCNSTATB3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTB_CNSTATB.setCNSTATB4; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000010;
end;
procedure TPORTB_CNSTATB.clearCNSTATB4; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000010;
end;
procedure TPORTB_CNSTATB.setCNSTATB4(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000010
  else
    pTDefRegMap(@Self)^.&set := $00000010;
end;
function  TPORTB_CNSTATB.getCNSTATB4 : TBits_1; inline;
begin
  getCNSTATB4 := (pTDefRegMap(@Self)^.val and $00000010) shr 4;
end;
procedure TPORTB_CNSTATB.setCNSTATB5; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TPORTB_CNSTATB.clearCNSTATB5; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TPORTB_CNSTATB.setCNSTATB5(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TPORTB_CNSTATB.getCNSTATB5 : TBits_1; inline;
begin
  getCNSTATB5 := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TPORTB_CNSTATB.setCNSTATB7; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TPORTB_CNSTATB.clearCNSTATB7; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TPORTB_CNSTATB.setCNSTATB7(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TPORTB_CNSTATB.getCNSTATB7 : TBits_1; inline;
begin
  getCNSTATB7 := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TPORTB_CNSTATB.setCNSTATB8; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000100;
end;
procedure TPORTB_CNSTATB.clearCNSTATB8; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000100;
end;
procedure TPORTB_CNSTATB.setCNSTATB8(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000100
  else
    pTDefRegMap(@Self)^.&set := $00000100;
end;
function  TPORTB_CNSTATB.getCNSTATB8 : TBits_1; inline;
begin
  getCNSTATB8 := (pTDefRegMap(@Self)^.val and $00000100) shr 8;
end;
procedure TPORTB_CNSTATB.setCNSTATB9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTB_CNSTATB.clearCNSTATB9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTB_CNSTATB.setCNSTATB9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTB_CNSTATB.getCNSTATB9 : TBits_1; inline;
begin
  getCNSTATB9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTB_CNSTATB.setCNSTATB10; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TPORTB_CNSTATB.clearCNSTATB10; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TPORTB_CNSTATB.setCNSTATB10(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TPORTB_CNSTATB.getCNSTATB10 : TBits_1; inline;
begin
  getCNSTATB10 := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TPORTB_CNSTATB.setCNSTATB11; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000800;
end;
procedure TPORTB_CNSTATB.clearCNSTATB11; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000800;
end;
procedure TPORTB_CNSTATB.setCNSTATB11(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000800
  else
    pTDefRegMap(@Self)^.&set := $00000800;
end;
function  TPORTB_CNSTATB.getCNSTATB11 : TBits_1; inline;
begin
  getCNSTATB11 := (pTDefRegMap(@Self)^.val and $00000800) shr 11;
end;
procedure TPORTB_CNSTATB.setCNSTATB13; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTB_CNSTATB.clearCNSTATB13; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTB_CNSTATB.setCNSTATB13(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTB_CNSTATB.getCNSTATB13 : TBits_1; inline;
begin
  getCNSTATB13 := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTB_CNSTATB.setCNSTATB14; inline;
begin
  pTDefRegMap(@Self)^.&set := $00004000;
end;
procedure TPORTB_CNSTATB.clearCNSTATB14; inline;
begin
  pTDefRegMap(@Self)^.clr := $00004000;
end;
procedure TPORTB_CNSTATB.setCNSTATB14(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00004000
  else
    pTDefRegMap(@Self)^.&set := $00004000;
end;
function  TPORTB_CNSTATB.getCNSTATB14 : TBits_1; inline;
begin
  getCNSTATB14 := (pTDefRegMap(@Self)^.val and $00004000) shr 14;
end;
procedure TPORTB_CNSTATB.setCNSTATB15; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTB_CNSTATB.clearCNSTATB15; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTB_CNSTATB.setCNSTATB15(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTB_CNSTATB.getCNSTATB15 : TBits_1; inline;
begin
  getCNSTATB15 := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTB_CNSTATB.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTB_CNSTATB.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_ANSELC.setANSC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTC_ANSELC.clearANSC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTC_ANSELC.setANSC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTC_ANSELC.getANSC0 : TBits_1; inline;
begin
  getANSC0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTC_ANSELC.setANSC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTC_ANSELC.clearANSC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTC_ANSELC.setANSC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTC_ANSELC.getANSC1 : TBits_1; inline;
begin
  getANSC1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTC_ANSELC.setANSC3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTC_ANSELC.clearANSC3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTC_ANSELC.setANSC3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTC_ANSELC.getANSC3 : TBits_1; inline;
begin
  getANSC3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTC_ANSELC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_ANSELC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_TRISC.setTRISC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTC_TRISC.clearTRISC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTC_TRISC.setTRISC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTC_TRISC.getTRISC0 : TBits_1; inline;
begin
  getTRISC0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTC_TRISC.setTRISC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTC_TRISC.clearTRISC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTC_TRISC.setTRISC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTC_TRISC.getTRISC1 : TBits_1; inline;
begin
  getTRISC1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTC_TRISC.setTRISC3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTC_TRISC.clearTRISC3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTC_TRISC.setTRISC3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTC_TRISC.getTRISC3 : TBits_1; inline;
begin
  getTRISC3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTC_TRISC.setTRISC9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTC_TRISC.clearTRISC9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTC_TRISC.setTRISC9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTC_TRISC.getTRISC9 : TBits_1; inline;
begin
  getTRISC9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTC_TRISC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_TRISC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_PORTC.setRC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTC_PORTC.clearRC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTC_PORTC.setRC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTC_PORTC.getRC0 : TBits_1; inline;
begin
  getRC0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTC_PORTC.setRC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTC_PORTC.clearRC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTC_PORTC.setRC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTC_PORTC.getRC1 : TBits_1; inline;
begin
  getRC1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTC_PORTC.setRC3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTC_PORTC.clearRC3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTC_PORTC.setRC3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTC_PORTC.getRC3 : TBits_1; inline;
begin
  getRC3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTC_PORTC.setRC9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTC_PORTC.clearRC9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTC_PORTC.setRC9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTC_PORTC.getRC9 : TBits_1; inline;
begin
  getRC9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTC_PORTC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_PORTC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_LATC.setLATC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTC_LATC.clearLATC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTC_LATC.setLATC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTC_LATC.getLATC0 : TBits_1; inline;
begin
  getLATC0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTC_LATC.setLATC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTC_LATC.clearLATC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTC_LATC.setLATC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTC_LATC.getLATC1 : TBits_1; inline;
begin
  getLATC1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTC_LATC.setLATC3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTC_LATC.clearLATC3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTC_LATC.setLATC3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTC_LATC.getLATC3 : TBits_1; inline;
begin
  getLATC3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTC_LATC.setLATC9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTC_LATC.clearLATC9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTC_LATC.setLATC9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTC_LATC.getLATC9 : TBits_1; inline;
begin
  getLATC9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTC_LATC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_LATC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_ODCC.setODCC9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTC_ODCC.clearODCC9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTC_ODCC.setODCC9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTC_ODCC.getODCC9 : TBits_1; inline;
begin
  getODCC9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTC_ODCC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_ODCC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_CNPUC.setCNPUC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTC_CNPUC.clearCNPUC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTC_CNPUC.setCNPUC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTC_CNPUC.getCNPUC0 : TBits_1; inline;
begin
  getCNPUC0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTC_CNPUC.setCNPUC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTC_CNPUC.clearCNPUC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTC_CNPUC.setCNPUC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTC_CNPUC.getCNPUC1 : TBits_1; inline;
begin
  getCNPUC1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTC_CNPUC.setCNPUC3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTC_CNPUC.clearCNPUC3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTC_CNPUC.setCNPUC3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTC_CNPUC.getCNPUC3 : TBits_1; inline;
begin
  getCNPUC3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTC_CNPUC.setCNPUC9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTC_CNPUC.clearCNPUC9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTC_CNPUC.setCNPUC9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTC_CNPUC.getCNPUC9 : TBits_1; inline;
begin
  getCNPUC9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTC_CNPUC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_CNPUC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_CNPDC.setCNPDC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTC_CNPDC.clearCNPDC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTC_CNPDC.setCNPDC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTC_CNPDC.getCNPDC0 : TBits_1; inline;
begin
  getCNPDC0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTC_CNPDC.setCNPDC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTC_CNPDC.clearCNPDC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTC_CNPDC.setCNPDC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTC_CNPDC.getCNPDC1 : TBits_1; inline;
begin
  getCNPDC1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTC_CNPDC.setCNPDC3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTC_CNPDC.clearCNPDC3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTC_CNPDC.setCNPDC3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTC_CNPDC.getCNPDC3 : TBits_1; inline;
begin
  getCNPDC3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTC_CNPDC.setCNPDC9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTC_CNPDC.clearCNPDC9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTC_CNPDC.setCNPDC9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTC_CNPDC.getCNPDC9 : TBits_1; inline;
begin
  getCNPDC9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTC_CNPDC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_CNPDC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_CNCONC.setSIDL; inline;
begin
  pTDefRegMap(@Self)^.&set := $00002000;
end;
procedure TPORTC_CNCONC.clearSIDL; inline;
begin
  pTDefRegMap(@Self)^.clr := $00002000;
end;
procedure TPORTC_CNCONC.setSIDL(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00002000
  else
    pTDefRegMap(@Self)^.&set := $00002000;
end;
function  TPORTC_CNCONC.getSIDL : TBits_1; inline;
begin
  getSIDL := (pTDefRegMap(@Self)^.val and $00002000) shr 13;
end;
procedure TPORTC_CNCONC.setON; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TPORTC_CNCONC.clearON; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TPORTC_CNCONC.setON(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TPORTC_CNCONC.getON : TBits_1; inline;
begin
  getON := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TPORTC_CNCONC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_CNCONC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_CNENC.setCNIEC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTC_CNENC.clearCNIEC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTC_CNENC.setCNIEC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTC_CNENC.getCNIEC0 : TBits_1; inline;
begin
  getCNIEC0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTC_CNENC.setCNIEC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTC_CNENC.clearCNIEC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTC_CNENC.setCNIEC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTC_CNENC.getCNIEC1 : TBits_1; inline;
begin
  getCNIEC1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTC_CNENC.setCNIEC3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTC_CNENC.clearCNIEC3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTC_CNENC.setCNIEC3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTC_CNENC.getCNIEC3 : TBits_1; inline;
begin
  getCNIEC3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTC_CNENC.setCNIEC9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTC_CNENC.clearCNIEC9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTC_CNENC.setCNIEC9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTC_CNENC.getCNIEC9 : TBits_1; inline;
begin
  getCNIEC9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTC_CNENC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_CNENC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TPORTC_CNSTATC.setCNSTATC0; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000001;
end;
procedure TPORTC_CNSTATC.clearCNSTATC0; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000001;
end;
procedure TPORTC_CNSTATC.setCNSTATC0(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000001
  else
    pTDefRegMap(@Self)^.&set := $00000001;
end;
function  TPORTC_CNSTATC.getCNSTATC0 : TBits_1; inline;
begin
  getCNSTATC0 := (pTDefRegMap(@Self)^.val and $00000001) shr 0;
end;
procedure TPORTC_CNSTATC.setCNSTATC1; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000002;
end;
procedure TPORTC_CNSTATC.clearCNSTATC1; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000002;
end;
procedure TPORTC_CNSTATC.setCNSTATC1(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000002
  else
    pTDefRegMap(@Self)^.&set := $00000002;
end;
function  TPORTC_CNSTATC.getCNSTATC1 : TBits_1; inline;
begin
  getCNSTATC1 := (pTDefRegMap(@Self)^.val and $00000002) shr 1;
end;
procedure TPORTC_CNSTATC.setCNSTATC3; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000008;
end;
procedure TPORTC_CNSTATC.clearCNSTATC3; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000008;
end;
procedure TPORTC_CNSTATC.setCNSTATC3(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000008
  else
    pTDefRegMap(@Self)^.&set := $00000008;
end;
function  TPORTC_CNSTATC.getCNSTATC3 : TBits_1; inline;
begin
  getCNSTATC3 := (pTDefRegMap(@Self)^.val and $00000008) shr 3;
end;
procedure TPORTC_CNSTATC.setCNSTATC9; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000200;
end;
procedure TPORTC_CNSTATC.clearCNSTATC9; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000200;
end;
procedure TPORTC_CNSTATC.setCNSTATC9(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000200
  else
    pTDefRegMap(@Self)^.&set := $00000200;
end;
function  TPORTC_CNSTATC.getCNSTATC9 : TBits_1; inline;
begin
  getCNSTATC9 := (pTDefRegMap(@Self)^.val and $00000200) shr 9;
end;
procedure TPORTC_CNSTATC.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TPORTC_CNSTATC.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG3.setUSERID(thebits : TBits_16); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF0000 or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG3.getUSERID : TBits_16; inline;
begin
  getUSERID := (pTDefRegMap(@Self)^.val and $0000FFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG3.setPMDL1WAY; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TDEVCFG_DEVCFG3.clearPMDL1WAY; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TDEVCFG_DEVCFG3.setPMDL1WAY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TDEVCFG_DEVCFG3.getPMDL1WAY : TBits_1; inline;
begin
  getPMDL1WAY := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TDEVCFG_DEVCFG3.setIOL1WAY; inline;
begin
  pTDefRegMap(@Self)^.&set := $20000000;
end;
procedure TDEVCFG_DEVCFG3.clearIOL1WAY; inline;
begin
  pTDefRegMap(@Self)^.clr := $20000000;
end;
procedure TDEVCFG_DEVCFG3.setIOL1WAY(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $20000000
  else
    pTDefRegMap(@Self)^.&set := $20000000;
end;
function  TDEVCFG_DEVCFG3.getIOL1WAY : TBits_1; inline;
begin
  getIOL1WAY := (pTDefRegMap(@Self)^.val and $20000000) shr 29;
end;
procedure TDEVCFG_DEVCFG3.setFUSBIDIO; inline;
begin
  pTDefRegMap(@Self)^.&set := $40000000;
end;
procedure TDEVCFG_DEVCFG3.clearFUSBIDIO; inline;
begin
  pTDefRegMap(@Self)^.clr := $40000000;
end;
procedure TDEVCFG_DEVCFG3.setFUSBIDIO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $40000000
  else
    pTDefRegMap(@Self)^.&set := $40000000;
end;
function  TDEVCFG_DEVCFG3.getFUSBIDIO : TBits_1; inline;
begin
  getFUSBIDIO := (pTDefRegMap(@Self)^.val and $40000000) shr 30;
end;
procedure TDEVCFG_DEVCFG3.setFVBUSONIO; inline;
begin
  pTDefRegMap(@Self)^.&set := $80000000;
end;
procedure TDEVCFG_DEVCFG3.clearFVBUSONIO; inline;
begin
  pTDefRegMap(@Self)^.clr := $80000000;
end;
procedure TDEVCFG_DEVCFG3.setFVBUSONIO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $80000000
  else
    pTDefRegMap(@Self)^.&set := $80000000;
end;
function  TDEVCFG_DEVCFG3.getFVBUSONIO : TBits_1; inline;
begin
  getFVBUSONIO := (pTDefRegMap(@Self)^.val and $80000000) shr 31;
end;
procedure TDEVCFG_DEVCFG3.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDEVCFG_DEVCFG3.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG2.setFPLLIDIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG2.getFPLLIDIV : TBits_3; inline;
begin
  getFPLLIDIV := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TDEVCFG_DEVCFG2.setFPLLMUL(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFF8F or ( thebits shl 4 );
end;
function  TDEVCFG_DEVCFG2.getFPLLMUL : TBits_3; inline;
begin
  getFPLLMUL := (pTDefRegMap(@Self)^.val and $00000070) shr 4;
end;
procedure TDEVCFG_DEVCFG2.setUPLLIDIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFF8FF or ( thebits shl 8 );
end;
function  TDEVCFG_DEVCFG2.getUPLLIDIV : TBits_3; inline;
begin
  getUPLLIDIV := (pTDefRegMap(@Self)^.val and $00000700) shr 8;
end;
procedure TDEVCFG_DEVCFG2.setUPLLEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00008000;
end;
procedure TDEVCFG_DEVCFG2.clearUPLLEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00008000;
end;
procedure TDEVCFG_DEVCFG2.setUPLLEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00008000
  else
    pTDefRegMap(@Self)^.&set := $00008000;
end;
function  TDEVCFG_DEVCFG2.getUPLLEN : TBits_1; inline;
begin
  getUPLLEN := (pTDefRegMap(@Self)^.val and $00008000) shr 15;
end;
procedure TDEVCFG_DEVCFG2.setFPLLODIV(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFF8FFFF or ( thebits shl 16 );
end;
function  TDEVCFG_DEVCFG2.getFPLLODIV : TBits_3; inline;
begin
  getFPLLODIV := (pTDefRegMap(@Self)^.val and $00070000) shr 16;
end;
procedure TDEVCFG_DEVCFG2.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDEVCFG_DEVCFG2.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG1.setFNOSC(thebits : TBits_3); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFF8 or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG1.getFNOSC : TBits_3; inline;
begin
  getFNOSC := (pTDefRegMap(@Self)^.val and $00000007) shr 0;
end;
procedure TDEVCFG_DEVCFG1.setFSOSCEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000020;
end;
procedure TDEVCFG_DEVCFG1.clearFSOSCEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000020;
end;
procedure TDEVCFG_DEVCFG1.setFSOSCEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000020
  else
    pTDefRegMap(@Self)^.&set := $00000020;
end;
function  TDEVCFG_DEVCFG1.getFSOSCEN : TBits_1; inline;
begin
  getFSOSCEN := (pTDefRegMap(@Self)^.val and $00000020) shr 5;
end;
procedure TDEVCFG_DEVCFG1.setIESO; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000080;
end;
procedure TDEVCFG_DEVCFG1.clearIESO; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000080;
end;
procedure TDEVCFG_DEVCFG1.setIESO(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000080
  else
    pTDefRegMap(@Self)^.&set := $00000080;
end;
function  TDEVCFG_DEVCFG1.getIESO : TBits_1; inline;
begin
  getIESO := (pTDefRegMap(@Self)^.val and $00000080) shr 7;
end;
procedure TDEVCFG_DEVCFG1.setPOSCMOD(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFCFF or ( thebits shl 8 );
end;
function  TDEVCFG_DEVCFG1.getPOSCMOD : TBits_2; inline;
begin
  getPOSCMOD := (pTDefRegMap(@Self)^.val and $00000300) shr 8;
end;
procedure TDEVCFG_DEVCFG1.setOSCIOFNC; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000400;
end;
procedure TDEVCFG_DEVCFG1.clearOSCIOFNC; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000400;
end;
procedure TDEVCFG_DEVCFG1.setOSCIOFNC(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000400
  else
    pTDefRegMap(@Self)^.&set := $00000400;
end;
function  TDEVCFG_DEVCFG1.getOSCIOFNC : TBits_1; inline;
begin
  getOSCIOFNC := (pTDefRegMap(@Self)^.val and $00000400) shr 10;
end;
procedure TDEVCFG_DEVCFG1.setFPBDIV(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFCFFF or ( thebits shl 12 );
end;
function  TDEVCFG_DEVCFG1.getFPBDIV : TBits_2; inline;
begin
  getFPBDIV := (pTDefRegMap(@Self)^.val and $00003000) shr 12;
end;
procedure TDEVCFG_DEVCFG1.setFCKSM(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF3FFF or ( thebits shl 14 );
end;
function  TDEVCFG_DEVCFG1.getFCKSM : TBits_2; inline;
begin
  getFCKSM := (pTDefRegMap(@Self)^.val and $0000C000) shr 14;
end;
procedure TDEVCFG_DEVCFG1.setWDTPS(thebits : TBits_5); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFE0FFFF or ( thebits shl 16 );
end;
function  TDEVCFG_DEVCFG1.getWDTPS : TBits_5; inline;
begin
  getWDTPS := (pTDefRegMap(@Self)^.val and $001F0000) shr 16;
end;
procedure TDEVCFG_DEVCFG1.setWINDIS; inline;
begin
  pTDefRegMap(@Self)^.&set := $00400000;
end;
procedure TDEVCFG_DEVCFG1.clearWINDIS; inline;
begin
  pTDefRegMap(@Self)^.clr := $00400000;
end;
procedure TDEVCFG_DEVCFG1.setWINDIS(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00400000
  else
    pTDefRegMap(@Self)^.&set := $00400000;
end;
function  TDEVCFG_DEVCFG1.getWINDIS : TBits_1; inline;
begin
  getWINDIS := (pTDefRegMap(@Self)^.val and $00400000) shr 22;
end;
procedure TDEVCFG_DEVCFG1.setFWDTEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00800000;
end;
procedure TDEVCFG_DEVCFG1.clearFWDTEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00800000;
end;
procedure TDEVCFG_DEVCFG1.setFWDTEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00800000
  else
    pTDefRegMap(@Self)^.&set := $00800000;
end;
function  TDEVCFG_DEVCFG1.getFWDTEN : TBits_1; inline;
begin
  getFWDTEN := (pTDefRegMap(@Self)^.val and $00800000) shr 23;
end;
procedure TDEVCFG_DEVCFG1.setFWDTWINSZ(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FCFFFFFF or ( thebits shl 24 );
end;
function  TDEVCFG_DEVCFG1.getFWDTWINSZ : TBits_2; inline;
begin
  getFWDTWINSZ := (pTDefRegMap(@Self)^.val and $03000000) shr 24;
end;
procedure TDEVCFG_DEVCFG1.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDEVCFG_DEVCFG1.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
procedure TDEVCFG_DEVCFG0.setDEBUG(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG0.getDEBUG : TBits_2; inline;
begin
  getDEBUG := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDEVCFG_DEVCFG0.setJTAGEN; inline;
begin
  pTDefRegMap(@Self)^.&set := $00000004;
end;
procedure TDEVCFG_DEVCFG0.clearJTAGEN; inline;
begin
  pTDefRegMap(@Self)^.clr := $00000004;
end;
procedure TDEVCFG_DEVCFG0.setJTAGEN(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $00000004
  else
    pTDefRegMap(@Self)^.&set := $00000004;
end;
function  TDEVCFG_DEVCFG0.getJTAGEN : TBits_1; inline;
begin
  getJTAGEN := (pTDefRegMap(@Self)^.val and $00000004) shr 2;
end;
procedure TDEVCFG_DEVCFG0.setICESEL(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFE7 or ( thebits shl 3 );
end;
function  TDEVCFG_DEVCFG0.getICESEL : TBits_2; inline;
begin
  getICESEL := (pTDefRegMap(@Self)^.val and $00000018) shr 3;
end;
procedure TDEVCFG_DEVCFG0.setPWP(thebits : TBits_6); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFF03FF or ( thebits shl 10 );
end;
function  TDEVCFG_DEVCFG0.getPWP : TBits_6; inline;
begin
  getPWP := (pTDefRegMap(@Self)^.val and $0000FC00) shr 10;
end;
procedure TDEVCFG_DEVCFG0.setBWP; inline;
begin
  pTDefRegMap(@Self)^.&set := $01000000;
end;
procedure TDEVCFG_DEVCFG0.clearBWP; inline;
begin
  pTDefRegMap(@Self)^.clr := $01000000;
end;
procedure TDEVCFG_DEVCFG0.setBWP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $01000000
  else
    pTDefRegMap(@Self)^.&set := $01000000;
end;
function  TDEVCFG_DEVCFG0.getBWP : TBits_1; inline;
begin
  getBWP := (pTDefRegMap(@Self)^.val and $01000000) shr 24;
end;
procedure TDEVCFG_DEVCFG0.setCP; inline;
begin
  pTDefRegMap(@Self)^.&set := $10000000;
end;
procedure TDEVCFG_DEVCFG0.clearCP; inline;
begin
  pTDefRegMap(@Self)^.clr := $10000000;
end;
procedure TDEVCFG_DEVCFG0.setCP(thebits : TBits_1); inline;
begin
  if thebits = 0 then
    pTDefRegMap(@Self)^.clr := $10000000
  else
    pTDefRegMap(@Self)^.&set := $10000000;
end;
function  TDEVCFG_DEVCFG0.getCP : TBits_1; inline;
begin
  getCP := (pTDefRegMap(@Self)^.val and $10000000) shr 28;
end;
procedure TDEVCFG_DEVCFG0.setFDEBUG(thebits : TBits_2); inline;
begin
  pTDefRegMap(@Self)^.val := pTDefRegMap(@Self)^.val and $FFFFFFFC or ( thebits shl 0 );
end;
function  TDEVCFG_DEVCFG0.getFDEBUG : TBits_2; inline;
begin
  getFDEBUG := (pTDefRegMap(@Self)^.val and $00000003) shr 0;
end;
procedure TDEVCFG_DEVCFG0.setw(thebits : TBits_32); inline;
begin
    pTDefRegMap(@Self)^.val := thebits;
end;
function  TDEVCFG_DEVCFG0.getw : TBits_32; inline;
begin
  getw := (pTDefRegMap(@Self)^.val and $FFFFFFFF) shr 0;
end;
  procedure _CORE_TIMER_VECTOR_interrupt; external name '_CORE_TIMER_VECTOR_interrupt';
  procedure _CORE_SOFTWARE_0_VECTOR_interrupt; external name '_CORE_SOFTWARE_0_VECTOR_interrupt';
  procedure _CORE_SOFTWARE_1_VECTOR_interrupt; external name '_CORE_SOFTWARE_1_VECTOR_interrupt';
  procedure _EXTERNAL_0_VECTOR_interrupt; external name '_EXTERNAL_0_VECTOR_interrupt';
  procedure _TIMER_1_VECTOR_interrupt; external name '_TIMER_1_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_1_VECTOR_interrupt; external name '_INPUT_CAPTURE_1_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_1_VECTOR_interrupt; external name '_OUTPUT_COMPARE_1_VECTOR_interrupt';
  procedure _EXTERNAL_1_VECTOR_interrupt; external name '_EXTERNAL_1_VECTOR_interrupt';
  procedure _TIMER_2_VECTOR_interrupt; external name '_TIMER_2_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_2_VECTOR_interrupt; external name '_INPUT_CAPTURE_2_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_2_VECTOR_interrupt; external name '_OUTPUT_COMPARE_2_VECTOR_interrupt';
  procedure _EXTERNAL_2_VECTOR_interrupt; external name '_EXTERNAL_2_VECTOR_interrupt';
  procedure _TIMER_3_VECTOR_interrupt; external name '_TIMER_3_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_3_VECTOR_interrupt; external name '_INPUT_CAPTURE_3_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_3_VECTOR_interrupt; external name '_OUTPUT_COMPARE_3_VECTOR_interrupt';
  procedure _EXTERNAL_3_VECTOR_interrupt; external name '_EXTERNAL_3_VECTOR_interrupt';
  procedure _TIMER_4_VECTOR_interrupt; external name '_TIMER_4_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_4_VECTOR_interrupt; external name '_INPUT_CAPTURE_4_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_4_VECTOR_interrupt; external name '_OUTPUT_COMPARE_4_VECTOR_interrupt';
  procedure _EXTERNAL_4_VECTOR_interrupt; external name '_EXTERNAL_4_VECTOR_interrupt';
  procedure _TIMER_5_VECTOR_interrupt; external name '_TIMER_5_VECTOR_interrupt';
  procedure _INPUT_CAPTURE_5_VECTOR_interrupt; external name '_INPUT_CAPTURE_5_VECTOR_interrupt';
  procedure _OUTPUT_COMPARE_5_VECTOR_interrupt; external name '_OUTPUT_COMPARE_5_VECTOR_interrupt';
  procedure _ADC_VECTOR_interrupt; external name '_ADC_VECTOR_interrupt';
  procedure _FAIL_SAFE_MONITOR_VECTOR_interrupt; external name '_FAIL_SAFE_MONITOR_VECTOR_interrupt';
  procedure _RTCC_VECTOR_interrupt; external name '_RTCC_VECTOR_interrupt';
  procedure _FCE_VECTOR_interrupt; external name '_FCE_VECTOR_interrupt';
  procedure _COMPARATOR_1_VECTOR_interrupt; external name '_COMPARATOR_1_VECTOR_interrupt';
  procedure _COMPARATOR_2_VECTOR_interrupt; external name '_COMPARATOR_2_VECTOR_interrupt';
  procedure _COMPARATOR_3_VECTOR_interrupt; external name '_COMPARATOR_3_VECTOR_interrupt';
  procedure _USB_1_VECTOR_interrupt; external name '_USB_1_VECTOR_interrupt';
  procedure _SPI_1_VECTOR_interrupt; external name '_SPI_1_VECTOR_interrupt';
  procedure _UART_1_VECTOR_interrupt; external name '_UART_1_VECTOR_interrupt';
  procedure _I2C_1_VECTOR_interrupt; external name '_I2C_1_VECTOR_interrupt';
  procedure _CHANGE_NOTICE_VECTOR_interrupt; external name '_CHANGE_NOTICE_VECTOR_interrupt';
  procedure _PMP_VECTOR_interrupt; external name '_PMP_VECTOR_interrupt';
  procedure _SPI_2_VECTOR_interrupt; external name '_SPI_2_VECTOR_interrupt';
  procedure _UART_2_VECTOR_interrupt; external name '_UART_2_VECTOR_interrupt';
  procedure _I2C_2_VECTOR_interrupt; external name '_I2C_2_VECTOR_interrupt';
  procedure _CTMU_VECTOR_interrupt; external name '_CTMU_VECTOR_interrupt';
  procedure _DMA_0_VECTOR_interrupt; external name '_DMA_0_VECTOR_interrupt';
  procedure _DMA_1_VECTOR_interrupt; external name '_DMA_1_VECTOR_interrupt';
  procedure _DMA_2_VECTOR_interrupt; external name '_DMA_2_VECTOR_interrupt';
  procedure _DMA_3_VECTOR_interrupt; external name '_DMA_3_VECTOR_interrupt';

  procedure Vectors; assembler; nostackframe;
  label interrupt_vectors;
  asm
    .section ".init.interrupt_vectors,\"ax\",@progbits"
  interrupt_vectors:

    j _CORE_TIMER_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _CORE_SOFTWARE_0_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _CORE_SOFTWARE_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_0_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_4_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_4_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_4_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _EXTERNAL_4_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _TIMER_5_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _INPUT_CAPTURE_5_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _OUTPUT_COMPARE_5_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _ADC_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _FAIL_SAFE_MONITOR_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _RTCC_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _FCE_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _COMPARATOR_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _COMPARATOR_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _COMPARATOR_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _USB_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _SPI_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _UART_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _I2C_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _CHANGE_NOTICE_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _PMP_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _SPI_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _UART_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _I2C_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _CTMU_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _DMA_0_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _DMA_1_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _DMA_2_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    j _DMA_3_VECTOR_interrupt
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    .weak _CORE_TIMER_VECTOR_interrupt
    .weak _CORE_SOFTWARE_0_VECTOR_interrupt
    .weak _CORE_SOFTWARE_1_VECTOR_interrupt
    .weak _EXTERNAL_0_VECTOR_interrupt
    .weak _TIMER_1_VECTOR_interrupt
    .weak _INPUT_CAPTURE_1_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_1_VECTOR_interrupt
    .weak _EXTERNAL_1_VECTOR_interrupt
    .weak _TIMER_2_VECTOR_interrupt
    .weak _INPUT_CAPTURE_2_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_2_VECTOR_interrupt
    .weak _EXTERNAL_2_VECTOR_interrupt
    .weak _TIMER_3_VECTOR_interrupt
    .weak _INPUT_CAPTURE_3_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_3_VECTOR_interrupt
    .weak _EXTERNAL_3_VECTOR_interrupt
    .weak _TIMER_4_VECTOR_interrupt
    .weak _INPUT_CAPTURE_4_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_4_VECTOR_interrupt
    .weak _EXTERNAL_4_VECTOR_interrupt
    .weak _TIMER_5_VECTOR_interrupt
    .weak _INPUT_CAPTURE_5_VECTOR_interrupt
    .weak _OUTPUT_COMPARE_5_VECTOR_interrupt
    .weak _ADC_VECTOR_interrupt
    .weak _FAIL_SAFE_MONITOR_VECTOR_interrupt
    .weak _RTCC_VECTOR_interrupt
    .weak _FCE_VECTOR_interrupt
    .weak _COMPARATOR_1_VECTOR_interrupt
    .weak _COMPARATOR_2_VECTOR_interrupt
    .weak _COMPARATOR_3_VECTOR_interrupt
    .weak _USB_1_VECTOR_interrupt
    .weak _SPI_1_VECTOR_interrupt
    .weak _UART_1_VECTOR_interrupt
    .weak _I2C_1_VECTOR_interrupt
    .weak _CHANGE_NOTICE_VECTOR_interrupt
    .weak _PMP_VECTOR_interrupt
    .weak _SPI_2_VECTOR_interrupt
    .weak _UART_2_VECTOR_interrupt
    .weak _I2C_2_VECTOR_interrupt
    .weak _CTMU_VECTOR_interrupt
    .weak _DMA_0_VECTOR_interrupt
    .weak _DMA_1_VECTOR_interrupt
    .weak _DMA_2_VECTOR_interrupt
    .weak _DMA_3_VECTOR_interrupt

    .text
  end;
end.
