{
    This file is part of the Free Pascal run time library.
    Copyright (c) 2002-2011 by Tomas Hajny,
    member of the Free Pascal development team.

    OS/2 threading support implementation

    See the file COPYING.FPC, included in this distribution,
    for details about the copyright.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

 **********************************************************************}

{*****************************************************************************
                           Local Api imports
*****************************************************************************}

const
 pag_Read = 1;
 pag_Write = 2;
 pag_Execute = 4;
 pag_Guard = 8;
 pag_Commit = $10;
 obj_Tile = $40;
 sem_Indefinite_Wait = cardinal (-1);
 dtSuspended = 1;
 dtStack_Commited = 2;
 deThread = 0; {DosExit - exit thread only}
 dcWW_Wait = 0;
 dcWW_NoWait = 1;
 dpThread = 2;
 dpSameClass = 0;


{ import the necessary stuff from the OS }
function DosAllocThreadLocalMemory (Count: cardinal; var P: pointer): cardinal;
                                          cdecl; external 'DOSCALLS' index 454;

function DosFreeThreadLocalMemory (P: pointer): cardinal; cdecl;
                                                 external 'DOSCALLS' index 455;

function DosCreateThread (var TID: cardinal; Address: pointer;
(* TThreadFunc *)
     aParam: pointer; Flags: cardinal; StackSize: cardinal): cardinal; cdecl;
                                                 external 'DOSCALLS' index 311;

function DosCreateMutExSem (Name: PChar; var Handle: THandle; Attr: cardinal;
               State: boolean): cardinal; cdecl; external 'DOSCALLS' index 331;

function DosCloseMutExSem (Handle: THandle): cardinal; cdecl;
                                                 external 'DOSCALLS' index 333;

function DosRequestMutExSem (Handle: THandle; Timeout: cardinal): cardinal;
                                          cdecl; external 'DOSCALLS' index 334;

function DosReleaseMutExSem (Handle: THandle): cardinal; cdecl;
                                                 external 'DOSCALLS' index 335;

function DosSuspendThread (TID:cardinal): cardinal; cdecl;
                                                 external 'DOSCALLS' index 238;

function DosResumeThread (TID: cardinal): cardinal; cdecl;
                                                 external 'DOSCALLS' index 237;

function DosKillThread (TID: cardinal): cardinal; cdecl;
                                                 external 'DOSCALLS' index 111;

function DosWaitThread (var TID: cardinal; Option: cardinal): cardinal; cdecl;
                                                 external 'DOSCALLS' index 349;

procedure DosSleep (MSec: cardinal); cdecl; external 'DOSCALLS' index 229;

{
procedure DosExit (Action, Result: cardinal); cdecl;
                                                 external 'DOSCALLS' index 234;

Already declared in the main part of system.pas...
}

function DosSetPriority (Scope, TrClass: cardinal; Delta: longint;
                                           PortID: cardinal): cardinal; cdecl;
                                                 external 'DOSCALLS' index 236;


{*****************************************************************************
                             Threadvar support
*****************************************************************************}

const
 ThreadVarBlockSize: dword = 0;


const
(* Pointer to an allocated dword space within the local thread *)
(* memory area. Pointer to the real memory block allocated for *)
(* thread vars in this block is then stored in this dword.     *)
 DataIndex: PPointer = nil;


procedure SysInitThreadvar (var Offset: dword; Size: dword);
begin
 Offset := ThreadVarBlockSize;
 Inc (ThreadVarBlockSize, Size);
end;


procedure SysAllocateThreadVars;
begin
 { we've to allocate the memory from the OS }
 { because the FPC heap management uses     }
 { exceptions which use threadvars but      }
 { these aren't allocated yet ...           }
 { allocate room on the heap for the thread vars }
 if DosAllocMem (DataIndex^, ThreadVarBlockSize, pag_Read or pag_Write
                                                       or pag_Commit) <> 0 then
  HandleError (8);
{ The Windows API apparently provides a way to fill the allocated memory with }
{ zeros; we probably need to do it ourselves for compatibility. }
 FillChar (DataIndex^^, 0, ThreadVarBlockSize);
end;


function SysRelocateThreadVar (Offset: dword): pointer;
begin
{ DataIndex itself not checked for not being nil - expected that this should }
{ not be necessary because the equivalent check (i.e. TlsKey not being set)  }
{ is note performed by the Windows implementation.                           }
  if DataIndex^ = nil then
   begin
    SysAllocateThreadVars;
    InitThread ($1000000);
   end;
  SysRelocateThreadVar := DataIndex^ + Offset;
end;


procedure SysInitMultithreading;
begin
  { do not check IsMultiThread, as program could have altered it, out of Delphi habit }

  { the thread attach/detach code uses locks to avoid multiple calls of this }
  if DataIndex = nil then
   begin
    { We're still running in single thread mode, setup the TLS }
    if DosAllocThreadLocalMemory (1, DataIndex) <> 0 then RunError (8);
    InitThreadVars (@SysRelocateThreadvar);
    IsMultiThread := true;
   end;
end;


procedure SysFiniMultithreading;
begin
  if IsMultiThread then
   begin
    if DosFreeThreadLocalMemory (DataIndex) <> 0 then
     begin
{??? What to do if releasing fails?}
     end;
    DataIndex := nil;
   end;
end;


procedure SysReleaseThreadVars;
begin
  DosFreeMem (DataIndex^);
  DataIndex^ := nil;
end;


(*    procedure InitThreadVars;
      begin
        { allocate one ThreadVar entry from the OS, we use this entry }
        { for a pointer to our threadvars                             }
        if DosAllocThreadLocalMemory (1, DataIndex) <> 0 then HandleError (8);
        { initialize threadvars }
        init_all_unit_threadvars;
        { allocate mem for main thread threadvars }
        SysAllocateThreadVars;
        { copy main thread threadvars }
        copy_all_unit_threadvars;
        { install threadvar handler }
        fpc_threadvar_relocate_proc := @SysRelocateThreadvar;
      end;
*)


{*****************************************************************************
                            Thread starting
*****************************************************************************}

    type
      pthreadinfo = ^tthreadinfo;
      tthreadinfo = record
        f : tthreadfunc;
        p : pointer;
        stklen : cardinal;
      end;

(*    procedure InitThread(stklen:cardinal);
      begin
        SysResetFPU;
        SysInitFPU;
        { ExceptAddrStack and ExceptObjectStack are threadvars       }
        { so every thread has its on exception handling capabilities }
        SysInitExceptions;
        { Open all stdio fds again }
        SysInitStdio;
        InOutRes:=0;
        // ErrNo:=0;
        { Stack checking }
        StackLength:=stklen;
        StackBottom:=Sptr - StackLength;
      end;
*)


    function ThreadMain(param : pointer) : pointer;cdecl;
      var
        ti : tthreadinfo;
      begin
        { Allocate local thread vars, this must be the first thing,
          because the exception management and io depends on threadvars }
        SysAllocateThreadVars;
        { Copy parameter to local data }
{$ifdef DEBUG_MT}
        writeln('New thread started, initialising ...');
{$endif DEBUG_MT}
        ti:=pthreadinfo(param)^;
        dispose(pthreadinfo(param));
        { Initialize thread }
        InitThread(ti.stklen);
        { Start thread function }
{$ifdef DEBUG_MT}
        writeln('Jumping to thread function');
{$endif DEBUG_MT}
        ThreadMain:=pointer(ti.f(ti.p));
      end;


function SysBeginThread (SA: pointer; StackSize : PtrUInt;
                         ThreadFunction: TThreadFunc; P: pointer;
                         CreationFlags: cardinal; var ThreadId: TThreadID): DWord;
var
  TI: PThreadInfo;
begin
{ WriteLn is not a good idea before thread initialization...
  $ifdef DEBUG_MT
  WriteLn ('Creating new thread');
 $endif DEBUG_MT}
{ Initialize multithreading if not done }
  SysInitMultithreading;
{ the only way to pass data to the newly created thread
  in a MT safe way, is to use the heap }
  New (TI);
  TI^.F := ThreadFunction;
  TI^.P := P;
  TI^.StkLen := StackSize;
  ThreadID := 0;
{$ifdef DEBUG_MT}
  WriteLn ('Starting new thread');
{$endif DEBUG_MT}
  if DosCreateThread (cardinal (ThreadID), @ThreadMain, TI,
                                             CreationFlags, StackSize) = 0 then
   SysBeginThread := ThreadID
  else
   begin
    SysBeginThread := 0;
{$IFDEF DEBUG_MT}
    WriteLn ('Thread creation failed');
{$ENDIF DEBUG_MT}
    Dispose (TI);
   end;
end;


procedure SysEndThread (ExitCode: cardinal);
begin
  DoneThread;
  DosExit (0, ExitCode);
end;


procedure SysThreadSwitch;
begin
  DosSleep (0);
end;


function SysSuspendThread (ThreadHandle: dword): dword;
begin
{$WARNING Check expected return value}
  SysSuspendThread := DosSuspendThread (ThreadHandle);
end;


function SysResumeThread (ThreadHandle: dword): dword;
begin
{$WARNING Check expected return value}
  SysResumeThread := DosResumeThread (ThreadHandle);
end;


function SysKillThread (ThreadHandle: dword): dword;
begin
  SysKillThread := DosKillThread (ThreadHandle);
end;

function SysCloseThread (ThreadHandle: TThreadID): dword;
begin
{ Probably not relevant under OS/2? }
//      SysCloseThread:=CloseHandle(threadHandle);
end;

function SysWaitForThreadTerminate (ThreadHandle: dword;
                                                    TimeoutMs: longint): dword;
var
  RC: cardinal;
const
{ Wait at most 100 ms before next check for thread termination }
  WaitTime = 100;
begin
  if TimeoutMs = 0 then
   RC := DosWaitThread (ThreadHandle, dcWW_Wait)
  else
   repeat
    RC := DosWaitThread (ThreadHandle, dcWW_NoWait);
    if RC = 294 then
     begin
      if TimeoutMs > WaitTime then
       DosSleep (WaitTime)
      else
       begin
        DosSleep (TimeoutMs);
        DosWaitThread (ThreadHandle, dcWW_NoWait);
       end;
      Dec (TimeoutMs, WaitTime);
     end;
   until (RC <> 294) or (TimeoutMs <= 0);
  SysWaitForThreadTerminate := RC;
end;


function GetOS2ThreadPriority (ThreadHandle: dword): longint;
begin
{$WARNING TODO!}
{
  DosQuerySysState
}
end;


function SysThreadSetPriority (ThreadHandle: dword; Prio: longint): boolean;
{-15..+15, 0=normal}
var
  Delta: longint;
begin
{$WARNING TODO!}
{
      SysThreadSetPriority:=WinThreadSetPriority(threadHandle,Prio);

Find out current priority first using GetOS2ThreadPriority defined above, then
calculate delta (translate the input scale -15..+15 based on MSDN docs to
-31..+31 used by OS/2).

  SysThreadSetPriority := DosSetPriority (dpThread, dpSameClass, Delta,
                                                                 ThreadHandle);
}
end;


function SysThreadGetPriority (ThreadHandle: dword): longint;
begin
{$WARNING TODO!}
{
      SysThreadGetPriority:=WinThreadGetPriority(threadHandle);

  Use GetOS2ThreadPriority defined above and translate the OS/2 value 0..31
  to -15..+15 based on MSDN docs.
}
end;


function SysGetCurrentThreadID: dword;
var
  TIB: PThreadInfoBlock;
begin
  DosGetInfoBlocks (@TIB, nil);
  SysGetCurrentThreadID := TIB^.TIB2^.TID;
end;



{*****************************************************************************
                          Delphi/Win32 compatibility
*****************************************************************************}

procedure SysInitCriticalSection (var CS);
begin
  if DosCreateMutExSem (nil, THandle (CS), 0, false) <> 0 then
   FPC_ThreadError;
end;

procedure SysDoneCriticalSection (var CS);
begin
(* Trying to release first since this might apparently be the expected  *)
(* behaviour in Delphi according to comment in the Unix implementation. *)
  repeat
  until DosReleaseMutExSem (THandle (CS)) <> 0;
  if DosCloseMutExSem (THandle (CS)) <> 0 then
   FPC_ThreadError;
end;

procedure SysEnterCriticalSection (var CS);
begin
  if DosRequestMutExSem (THandle (CS), cardinal (-1)) <> 0 then
   FPC_ThreadError;
end;

function SysTryEnterCriticalSection (var CS): longint;
begin
  if DosRequestMutExSem (THandle (CS), 0) = 0 then
   Result := 1
  else
   Result := 0;
end;

procedure SysLeaveCriticalSection (var CS);
begin
  if DosReleaseMutExSem (THandle (CS)) <> 0 then
   FPC_ThreadError;
end;



type
  TBasicEventState = record
                      FHandle: THandle;
                      FLastError: longint;
                     end;
  PLocalEventRec = ^TBasicEventState;


function IntBasicEventCreate (EventAttributes: Pointer;
     AManualReset, InitialState: Boolean; const Name: ansistring): PEventState;
begin
  New (PLocalEventRec (Result));
{$WARNING TODO!}
{
  PLocalEventrec (Result)^.FHandle :=
         CreateEvent (EventAttributes, AManualReset, InitialState,PChar(Name));
}
end;


procedure IntBasicEventDestroy (State: PEventState);
begin
{$WARNING TODO!}
{
  closehandle(plocaleventrec(state)^.fhandle);
}
  Dispose (PLocalEventRec (State));
end;


procedure IntBasicEventResetEvent (State: PEventState);
begin
{$WARNING TODO!}
{
  ResetEvent(plocaleventrec(state)^.FHandle)
}
end;


procedure IntBasicEventSetEvent (State: PEventState);
begin
{$WARNING TODO!}
{
  SetEvent(plocaleventrec(state)^.FHandle);
}
end;


function IntBasicEventWaitFor (Timeout: Cardinal; State: PEventState): longint;
begin
{$WARNING TODO!}
{
  case WaitForSingleObject(plocaleventrec(state)^.fHandle, Timeout) of
    WAIT_ABANDONED: Result := wrAbandoned;
    WAIT_OBJECT_0: Result := wrSignaled;
    WAIT_TIMEOUT: Result := wrTimeout;
    WAIT_FAILED:
        begin
        Result := wrError;
        plocaleventrec(state)^.FLastError := GetLastError;
       end;
  else
    Result := wrError;
  end;
}
end;


function IntRTLEventCreate: PRTLEvent;
begin
{$WARNING TODO!}
{
  Result := PRTLEVENT(CreateEvent(nil, false, false, nil));
}
end;


procedure IntRTLEventDestroy (AEvent: PRTLEvent);
begin
{$WARNING TODO!}
{
  CloseHandle(THANDLE(AEvent));
}
end;


procedure IntRTLEventSetEvent (AEvent: PRTLEvent);
begin
{$WARNING TODO!}
{
  SetEvent(THANDLE(AEvent));
}
end;


procedure IntRTLEventWaitFor (AEvent: PRTLEvent);
CONST INFINITE=-1;
begin
{$WARNING TODO!}
{
  WaitForSingleObject(THANDLE(AEvent), INFINITE);
}
end;


procedure IntRTLEventWaitForTimeout (AEvent: PRTLEvent; Timeout: longint);
begin
{$WARNING TODO!}
{
  WaitForSingleObject(THANDLE(AEvent), Timeout);
}
end;


procedure intRTLEventResetEvent (AEvent: PRTLEvent);
begin
{$WARNING TODO!}
{
  ResetEvent(THANDLE(AEvent));
}
end;



var
  OS2ThreadManager: TThreadManager;


procedure InitSystemThreads;
begin
  with OS2ThreadManager do
    begin
    InitManager            :=Nil;
    DoneManager            :=Nil;
    BeginThread            :=@SysBeginThread;
    EndThread              :=@SysEndThread;
    SuspendThread          :=@SysSuspendThread;
    ResumeThread           :=@SysResumeThread;
    KillThread             :=@SysKillThread;
    CloseThread		   :=@SysCloseThread;
    ThreadSwitch           :=@SysThreadSwitch;
    WaitForThreadTerminate :=@SysWaitForThreadTerminate;
    ThreadSetPriority      :=@SysThreadSetPriority;
    ThreadGetPriority      :=@SysThreadGetPriority;
    GetCurrentThreadId     :=@SysGetCurrentThreadId;
    InitCriticalSection    :=@SysInitCriticalSection;
    DoneCriticalSection    :=@SysDoneCriticalSection;
    EnterCriticalSection   :=@SysEnterCriticalSection;
    TryEnterCriticalSection:=@SysTryEnterCriticalSection;
    LeaveCriticalSection   :=@SysLeaveCriticalSection;
    InitThreadVar          :=@SysInitThreadVar;
    RelocateThreadVar      :=@SysRelocateThreadVar;
    AllocateThreadVars     :=@SysAllocateThreadVars;
    ReleaseThreadVars      :=@SysReleaseThreadVars;
    BasicEventCreate       :=@IntBasicEventCreate;
    BasicEventDestroy      :=@IntBasicEventDestroy;
    BasicEventSetEvent     :=@IntBasicEventSetEvent;
    BasicEventResetEvent   :=@IntBasicEventResetEvent;
    BasiceventWaitFor      :=@IntBasiceventWaitFor;
    RTLEventCreate         :=@IntRTLEventCreate;
    RTLEventDestroy        :=@IntRTLEventDestroy;
    RTLEventSetEvent       :=@IntRTLEventSetEvent;
    RTLEventResetEvent     :=@intRTLEventResetEvent;
    RTLEventWaitFor        :=@IntRTLEventWaitFor;
    RTLEventWaitForTimeout :=@intRTLEventWaitForTimeout;
    end;
  SetThreadManager (OS2ThreadManager);
end;

