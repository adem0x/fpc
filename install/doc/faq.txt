
    1. [1]What is Free Pascal (FPC)?
    2. [2]Which versions exist, and which one should I use?
    3. [3]Free Pascal and GNU Pascal - a comparison
    4. [4]Where can I get the compiler ?
    5. [5]What are the considerations in porting
    6. [6]I tried to compile my Delphi code with the Free Pascal
    7. [7]I have to write a program for homework. Can you help?
    8. [8]How can I build a unit?
    9. [9]Will Free Pascal support TV (Turbo Vision) in the future?
   10. [10]How can I compile the system unit?
   11. [11]I get an internal error 9999 or 10?
   12. [12]How does function overloading work?
   13. [13]How can I call C functions?
   14. [14]How can I use the graph unit with Free Pascal?
   15. [15]Why do I get wrong colors when using the graph unit?
   16. [16]Integrated Assembler syntax
   17. [17]How can I access DOS memory / How can I do graphics
       programming?
   18. [18]How can I run Free Pascal without a math coprocessor?
   19. [19]How do I reserve more than 2 megabytes of RAM?
   20. [20]How can I access I/O ports?
   21. [21]I'm using the Dos compiler under Windows 95
   22. [22]I'm using OS/2
   23. [23]INSTALL.EXE of Dos version 0.99.10 reports "Load error: no
       DPMI"
   24. [24]INSTALL.EXE of version 1.0 for Dos returns an error (-2) in
       Windows NT 4.0
   25. [25]INSTALL.EXE of version 1.0.6 or below returns an unknown error (-1)
       under OS/2
       or
       [25]INSTALL.EXE of version 1.0.6 or above complains about missing
       TZ variable under OS/2
   26. [26]I want a new version NOW
   27. [27]Where can I find a text mode IDE?
   28. [28]How do I configure the Dos IDE?
   29. [29]Why are the generated binaries so big?
   30. [30]Unit system, syslinux, sysos2 or syswin32 not found errors
   31. [31]Known bugs
   32. [32]How can I find where an error occurred using the addresses a
       crashed program prints?
       
    1. What is Free Pascal (FPC)?
       Originally named FPK-Pascal, the Free Pascal compiler is a 32 bit
       Turbo Pascal compatible Pascal compiler for DOS, Linux, Win32,
       OS/2 and (based on an older version) the AmigaOS. More operating
       systems (BeOS and FreeBSD/ELF are in advanced stages of
       development) are in the works.
       The compiler is written in Pascal and is able to compile its own
       sources. The source files are included.
       Free Pascal is modest regarding its minimal system requirements
       (386-25 Mhz for the Intel version and ideally a 68020 processor
       for the Motorola version). At least 2 megabytes of RAM are
       required. To remake the compiler more than 16MB is recommended.
       Short history:
          + 6/1993: project start
          + 10/1993: first little programs work
          + 3/1995: the compiler compiles the own sources
          + 3/1996: released to the internet
          + 7/2000: 1.0 version
    2. Which versions exist, and which one should I use?
       FPC's version numbering changed a few times over the years.
       Versions before 0.99.5 are considered archaic. After the release
       of 0.99.5 a system in version numbering was introduced, and that
       system was changed slightly changed after the 1.0 release.
       Versioning for versions 0.99.5 - 1.0
       Compilers with an even last number are release versions(e.g.
       0.99.8, 0.99.10, 0.99.12, 0.99.14 1.0.0)
       Compilers and packages with an odd last number are development
       versions (e.g. 0.99.9, 0.99.11, 0.99.13, 0.99.15)
       0.99.5 is an exception to this rule, since 0.99.5 IS a release (a
       release prior to the introduction of this odd/even system).
       Letters behind the version number (0.99.12b, 0.99.5d) indicate
       release versions with some bugs and problems in the original
       release (respectively 0.99.12 and 0.99.5) fixed.
       Versioning after 1.0
       Together with the release of 1.0 the version numbering has been
       slightly changed, and a system in versioning resembling the Linux
       kernel's has been introduced. The main difference is that the
       difference between a release version is now in the second number
       (1.0.x vs 1.1.x) instead of the third number (0.99.14 vs 0.99.15),
       and the third number now becomes the patch level, replacing the
       postfixed letter in the old system.
          + Releases that only fix bugs in version 1.0 will be numbered
            1.0.x
          + New development (the so called snapshots) have version number
            1.1.x. The meaning of the third version number x in the new
            development branch is not defined yet, it could be used for
            test releases or to signal major changes.
          + Eventually the 1.1.x versions, when stabilized will be
            released as version 1.2. Fixes on the 1.2 release will be
            numbered 1.2.x
          + The new development after the 1.2 release will be numbered
            1.3.x and so on
          + When really big changes are implemented, the version will be
            updated in the major number. This could be case with e.g. a
            codegenerator rewrite with support for other processors
       Normally you would want to use a release. Releases are considered
       stable, and easier to support (the bugs, quirks and unintended
       "features" are well known after a period of time, and workarounds
       exist).
       Development snapshots (which are generated daily) reflect the
       current status of the compiler. Development versions probably have
       new features and larger bugs fixed since the last release, but
       might have some temporary stability drawbacks (which are usually
       fixed by the next day).
       Most support for development snapshots are basically the advise to
       upgrade to newer snapshot in which the bugs are hopefully fixed.
       Since version 0.99.8 the stability of the compiler steadily
       increased and development snapshots are often quite useful for
       certain categories of users. Ask in the maillists if it is worth
       the trouble in your case if you're not sure.
       The current release version is 1.00 for the OS/2, Linux, Windows
       and Dos (Go32V2) targets and 0.99.5d for the 680x0 based systems
       (Amiga and Atari ST). The development versions (snapshots) are
       numbered 1.1.x at the moment
       We advise all users to upgrade to the newest version for their
       target. (1.0 for intel processors, and 0.99.5d for Motorola)
    3. Free Pascal and GNU Pascal - a comparison
       
        Aim:
                Free Pascal tries to implement a Borland compatible
                pascal compiler on as many platforms as possible. GNU
                Pascal tries to implement a portable pascal compiler
                based on POSIX.
                
        Version:
                Currently, Free Pascal is at version 1.00 for the Intel
                version and version 0.99.5d for the Motorola/Intel
                version. Version 0.99.5d differs from version 0.99.5 in
                that all run time library fixes have been applied, as
                well as all known code generation bugs. Version 1.00
                differs from version 0.99.5d in that all parser bugfixes
                have also been applied and also a lot of Delphi 2 and
                Delphi 3 extensions have been implemented. GNU Pascal is
                at version 2.8.1 (but this numbering is not really an
                indication, it follows the GNU C numbering, since it is a
                derivation of it)
                
        Operating systems:
                Free pascal runs on a limited number of systems : DOS,
                Win32, Linux, OS/2 and AmigaOS and is for the moment
                limited to the Intel and Motorola architectures. GNU
                Pascal runs basically on any system that can run GNU C.
                
        Sources:
                Free Pascal is entirely written in Pascal (about 6 Mb of
                source code), while GNU Pascal is written in C (it's an
                adaptation of the GNU C compiler: 2.8 Mb code + 8 MB of
                GNU C code)
                
        Language:
                Free Pascal supports the Borland Pascal dialect Borland,
                and implements the Delphi Object Pascal language. GNU
                Pascal supports ISO 7185, ISO 10206, (most of) Borland
                Pascal 7.0
                
        Extensions:
                Free Pascal implements method, function and operator
                overloading. GNU Pascal implements operator overloading.
                
        License:
                Both compilers come under the GNU GPL.
                
        Author:
                Free Pascal was started by Florian Klaempfl, Germany
                (Florian.Klaempfl@gmx.de), GNU Pascal was started by
                Jukka Virtanen, Finland (jtv@hut.fi).
                
    4. Where can I get the compiler ?
       Free Pascal is available for download from all [33]official
       mirrors
    5. What are the considerations in porting code to other processors?
       Because the compiler now supports processors other than the Intel,
       it is important to take a few precautions so that your code will
       execute correctly on all processors.
          + Limit your use of asm statements unless it is time critical
            code
          + Don't use the packed directive unless you know exactly what
            you are doing. Most processors require alignment of data, and
            using packed on objects,classes and records may break this
            requirement. If this is the case your code will simply crash
            on the target processors.
          + Clean up at the end of your program, i.e. close all files on
            exit, as some operating systems don't like it when some files
            are left opened.
          + Try not to rely on the endian of the specific machines when
            doing arithmetic operations. Furthermore, reading and writing
            of binary data to/from files will probably require byte swaps
            across different endian machines (swap is your friend in this
            case). This is even more important if you write binary data
            to files.
          + Try limiting your local variables in subroutines to 32K, as
            this is the limit of some processors, use dynamic allocation
            instead.
          + Try limiting the size of parameters passed to subroutines to
            32K, as this is the limit of some processors, use const or
            var parameters instead.
    6. I tried to compile my Delphi code with the Free Pascal Compiler,
       but it seems that it doesn't recognize Delphi style OOP.
       The compiler supports the Delphi OOP. Make sure you use the -S2 or
       -Sd switches (see the manuals for the meaning of these switches).
       For a list of Delphi incompabilities also check the manual.
    7. I have to write a program for homework. Can you help?
       No. Please, don't send us mail about homework, we are no teachers.
       The Free Pascal development team tries to give good support for
       the Free Pascal compiler and are trying to always reply to emails.
       If we get emails like this, this becomes harder and harder.
    8. How can I build a unit?
       It works like in Turbo Pascal. The first keyword in the file must
       be UNIT (not case sensitive). The compiler will generate two
       files: XXX.PPU and XXX.O. The PPU file contains the interface
       information for the compiler and the O-file the machine code (an
       object file, whose precise structure depends on the assembler you
       used). To use this unit in another unit or program, you must
       include its name in the USES clause of your program.
    9. Will Free Pascal support TV (Turbo Vision) in the future?
       A Turbo Vision port, called Free Vision, has progressed nicely
       lately. It's already very usable, we are even writing an IDE in
       it. Due to copyrights problem the FreeVision source code is not
       available at the moment. You can download the IDE from the
       [34]development page. and get an idea of the look and feel though.
   10. How can I compile the system unit?
       To recompile the system unit, it is recommended to have GNU make
       installed. typing 'make' in the rtl source directory will then
       recompile all RTL units including the system unit. You may choose
       to descend into the directory of your OS (e.g. rtl/go32v2) and do
       a 'make' there.
       It is possible to do all this manually, but you need more detailed
       knowledge of the RTL tree structure for that.
   11. I get an internal error 9999 or 10?
       The latest versions of the Free Pascal Compiler come with an error
       handling routine which catches the segmentation fault and lets the
       compiler to exit gracefully. This is reported as an internal error
       9999. Please try to reproduce the error and send [35]us a bug
       report.
       (For the curious, IE 9999 is not a specific bug. It is a safety
       measure which terminates if during compiling a certain condition
       is not met, which can be caused by several bugs. So if you report
       the bug, and get IE 9999 later in a different piece or part of
       sourcecode, it could be a completely different bug. IE 10 is
       something similar. It is a safety measure that is triggered when
       the estimated number of registers needed to evaluate an expression
       proves wrong. Just like IE 9999, two IE 10 problems are often
       independant of eachother.)
   12. How does function overloading work?
       function overloading is implemented, like in C++:
procedure a(i : integer);
begin
end;
procedure a(s : string);
begin
end;
begin
a('asdfdasf');
a(1234);
end.
       You must be careful. If one of your overloaded functions is in the
       interface part of your unit, then all overloaded functions must be
       in the interface part. If you leave one out, the compiler will
       complain with a 'This overloaded function can't be local' message.
       Overloaded functions must differ in their parameters, it's not
       enough if their return types are different.
   13. How can I call C functions?
       C calling convention is implemented as follows: The compiler
       pushes the parameters from right to left, but the procedure has to
       clear the stack. For calling the C function strcmp declare the
       following:
function strcmp(s1 : pchar;s2 : pchar) : integer;cdecl;external;
Since 0.99.5, the older [C]; won't work!
   14. How can I use the graph unit with Free Pascal?
       Since 0.99.12, the graph unit is available both for Dos and Linux.
       Under Dos, it only supported VESA modes though. Since version
       0.99.14, a new more system independant graph unit is included
       (although the only extra supported OS is Win32 and this is only
       rudimentary support) which also supports standard VGA.
       Since version 1.0, we also have a completely platform independent
       way of selecting resolutions and bitdepths. You are strongly
       encouraged to use it, because other ways will probably fail on one
       or other platform. See the documentation of the graph unit for
       more information.
   15. Why do I get wrong colors when using the graph unit?
       If you use detect as graphdriver, you will end up with the highest
       supported bitdepth. Since the graph unit currently only supports
       up to 16 bits per pixel modes and since this bitdepth is supported
       by all graphics cards made in at least the last 5 years, you will
       most likely get a 16 bit mode.
       The main problem is that in 16 (and 15, 24, 32, ...) bit modes,
       the colors aren't set anymore using an index in a palette (the
       palettized way is called "indexed color"). In these modes, the
       color number itself determines what color you get on screen and
       you can't change this color. The color is encoded as follows (for
       most graphics cards on PC's at least):
          + 15 bit color: lower 5 bits are blue intensity, next come 5
            bits of green and then 5 bits of red. The highest bit of the
            word is ignored.
          + 16 bit color: lower 5 bits are blue intensite, next come *6*
            bits of green and then 5 bits of red.
       This means that either you have to rewrite your program so it can
       work with this so-called "direct color" scheme, or that you have
       to use D8BIT as graphdriver and DetectMode as graphmode. This will
       ensure that you end up with a 256 (indexed) color mode. If there
       are no 256 color modes supported, then graphresult will contain
       the value GrNotDetected after you called InitGraph and you can
       retry with graphdriver D4BIT. Make sure you use the constant names
       (D8BIT, D4BIT, ...) and not their actual numeric values, because
       those values can change with the next release! That the very
       reason why such symbolic constants exist.
   16. Integrated Assembler syntax
       The default assembler syntax (AT&T style) is different from the
       one in Borland Pascal (Intel style).
       However, as of version 0.99.0, the compiler supports Intel style
       assembly syntax. See the documentation for more info on how to use
       different assembler styles.
       A description of the AT&T syntax can be found in the DJGPP FAQ
       [36]http://www.delorie.com/djgpp/v2faq/faq102.html#Syntax or in
       Brennan's Guide to Inline Assembly
       [37]http://www.rt66.com/%7Ebrennan/djgpp/djgpp asm.html. The
       documentation also contains a chapter where the difference between
       the Intel and AT&T style assembly is explained.
       Or you can use the convertor program at
       [38]http://rcs.urz.tu-dresden.de/schoenfu/zip/asmtrans.zip .
   17. How can I access DOS memory / How can I do graphics programming?
       You can do like in TP, via absolute or mem[]. For larger memory
       blocks use the dosmemput/dosmemget routines in Go32 unit.
   18. How can I run Free Pascal without a math coprocessor?
       On the Intel version the emulator is automatically loaded by the
       compiler if you add the following commands to your autoexec.bat:
SET 387=N
SET EMU386=C:\PP\BIN\GO32V2\WEMU387.DXE
       (don't forget to replace the C:\PP with the directory where you
       installed FPC)
   19. How do I reserve more than 2 megabytes of RAM?
       By default Free Pascal allocates only 2MB of RAM for your
       application. If it just allocated all it could get, people running
       Windows would have problems as Windows would increase the swap
       file size to give the program more memory on and on, until the
       swap file drive would be full.
       You can specify the size of the heap with -Chxxxx. The default
       value is -Ch4000000. Try -Ch10000000, provided you got enough swap
       space.
       However, the heap size doesn't really matter anymore, since the
       Heap is able to grow: if you've used all the available heap space,
       the program will try to get more memory from the OS, so the heap
       is limited to the maximum amount of free memory provided by the
       OS.
       It is only handy if you know you will need at least a certain
       amount of memory. You can then specify this value using the -Ch
       parameter, so your program will allocate it at once on startup.
       This is slightly faster than growing the heap a number of times.
   20. How can I access I/O ports?
       With versions before 0.99.10: if you're under DOS you can use the
       outport* and inport* procedures of the go32 unit.
       Since version 0.99.8, the Port array is supported like in TP, as
       long as you use the ports unit in your program (not available
       under Win32).
       I/O port access is possible under Linux, but that requires root
       privileges. Check the manuals for the IOPerm, ReadPort and
       WritePort procedures. (Unit Linux)
   21. I'm using the Dos compiler under Windows 95
       There is a problem with the Dos compiler and Win 95 on computers
       with less than 16 MB. First set in the properties of the DOS box
       the DPMI memory size to max value. Now try to start a demo program
       in the DOS box, e.g. HELLO (starting takes some time). If this
       works you will be able to get the compiler to work by recompiling
       it with a smaller heap size, perhaps 2 or 4 MB (option -Chxxxx).
   22. I'm using OS/2
       Problems have been reported that the GO32v2 compiler does not run
       on some OS/2 installations. You can use the native OS/2 compiler
       (strongly preferred solution) or maybe compile a GO32v1 compiler
       yourself. However, the GO32v2 version should generally work under
       OS/2 as well.
   23. INSTALL.EXE of Dos version 0.99.10 reports "Load error: no DPMI"
       The file cwsdpmi.exe is missing in the main directory of the zip
       archive. The above message pops up if no other DPMI services are
       available. Such services are for example available in a Dos window
       of Windows. You can either extract that file from basego32.zip or
       download it from
       [39]http://www.brain.uni-freiburg.de/%7Eklaus/cwsdpmi.exe. Put it
       into the same directory as install.exe and run install again.
   24. INSTALL.EXE of version 1.0 for Dos returns an error (-2) in
       Windows NT 4.0
       This is caused by long file names in some of the .ZIPs of the
       dosversion. A new installer will be generated that ignores the
       packages with long file names in it. Currently it is still being
       tested. Alternatively, one could use the installer from the Win32
       1.0 version under NT. This has the additional benefit that the
       archives with long filenames can be selected and installed too.
       The exact cause of this problem is that a NT 4.0 dosbox doesn't
       support long file names for dos programs. Windows 95,98 and 2000
       don't exhibit this problem.
          + The current ZIPs on ftp have been updated with the new
            installer.
          + Dosw32100.zip, has now default the win32 installer, and the
            go32v2 installer packaged as installd.exe.
          + If you already downloaded one of the large Dos zips, repeated
            downloading is not necessary, just download a new installer:
               o [40]Plain dos installer. For dos without a 32-bit
                 windows loaded or OS/2
               o [41]Win32 installer, for all win32 targets (win 95,98,NT
                 en 2000) including their dosboxes
          + If you downloaded an OS/2 version, and experience problems,
            you can try to download the new dos installer
   25. INSTALL.EXE of version 1.0.6 or below fails with an unknown
       error (-1) under OS/2
       or
       INSTALL.EXE of version 1.0.6 or above complains about missing
       TZ variable under OS/2
       You are most probably using an older version of OS/2 (like
       OS/2 Warp 3.0) and don't have TZ variable in your environment.
       The easiest solution is to add "SET TZ=..."
       (e.g. "SET TZ=CET-1CEST,3,-1,0,7200,10,-1,0,10800,3600" for most
       of western and central Europe) line to your CONFIG.SYS, and restart
       OS/2. The proper setting for you can be found e.g. using the TZCALC
       tool from [51]TIME868 package.
   26. I want a new version NOW
       In the time between the release of new official versions, you can
       have a look at and test developer versions (so-called
       "snapshots"). Be warned though: this is work under progress, so in
       addition to old bugs fixed and new features added, this may also
       contain new bugs.
       Snapshots are generated automatically each night from the current
       source at that moment. Sometimes this may fail due to bigger
       changes not yet fully implemented. If your version doesn't work,
       try again one or two days later. You're advised not to download
       the GO32v1 version for Dos, since it's not supported any more.
       The latest snapshot can always be downloaded from the
       [42]development web page.
       To install a snapshot, extract the zip archive into the existing
       program directory of the last official version of Free Pascal
       (after making a backup of the original of course). You can also
       extract it into an empty directory and then move the files to the
       program directory, overwriting existing files. Make sure that you
       extract the ZIP archive such that the included directory structure
       remains intact. For example if you use PKUNZIP, use "pkunzip -d"
       instead of just "pkunzip". Note that snpashots also contain a new
       RTL which most likely can't be used with the previous release
       version, so backup your old RTL as well.
   27. Where can I find a text mode IDE?
       The development of the IDE (integrated development environment) is
       not yet finished. However a working test version of the IDE is
       available as snapshot. It requires the latest compiler snapshot be
       installed on top of the current official version for your
       particular platform (1.00 for GO32v2 or Win32). So if you have not
       already done that, first install the latest official version (e.g.
       file dos100.zip or dos100full.zip, you find these in the
       [43]download section).
       Then get and extract the latest snapshot for your platform (e.g.
       snapshot.zip) into the directory containing the official version.
       Next, do the same with one of the IDE snapshots. For more details
       on where to find and how to install a snapshot, please see the
       previous FAQ item. For additional instructions for required IDE
       configuration please also read the next FAQ item.
   28. How do I configure the Dos IDE?
       Once you have installed the IDE (see the previous FAQ item), it
       requires two configuration changes before it can compile. This is
       due to the fact that the IDE includes its own compiler; it does
       not use ppc386.exe and thus it also does not use the configuration
       in the file ppc386.cfg.
       Start fp.exe, select Target from the Compile menu and then check
       GO32v2. Next, choose Directories in the Otions menu and in the
       line "Unit directories" enter the path to your copy of the rtl
       directory, usually c:\pp\rtl\go32v2. If you have done everything
       correct and it still doesn't work, you may have grabbed a snapshot
       that has a bug; in this case try again one or two days later or
       ask for help on one of the [44]mailing lists.
   29. Why are the generated binaries so big?
       There are several reasons and remedies for this:
         1. If you are using 0.99.12: Due to some problems with the
            binary writer, 0.99.12 wasn't released with smartlinkable
            RTLs. Smartlinking causes only actually used procedures,
            functions and constants to be linked in.
            You can remedy this by using a development version and
            creating a smartlinking RTL. See the [45]make cycle faq or
            use a later release if available (0.99.14 and later do
            include a smartlinkable RTL). To turn on the generation of
            smartlinkable units, use the -Cx command line option when
            compiling your units. To turn on the linking of previously
            generated smarlinkable units, use the -XX (-XS in 0.99.12 and
            earlier) command line option when compiling a program.
         2. Normally, all symbol information is included in the resulting
            program (for easier debugging). You can remove this by using
            the -Xs command line option when compiling your program (it
            won't do anything when compiling units)
         3. You can use UPX to pack the .EXEs (just like e.g. pklite) for
            Dos (GO32v2) and Windows targets. Look [46]here for more
            info.
         4. You can use LXLITE for packing EMX binaries, but you won't be
            able to run them under DOS (with extender) any more then. It
            might even not be possible to use them on lower OS/2 versions
            (like 2.x) depending on chosen type of compression. LXLITE
            can be found e.g. on [47]Hobbes, search for LXLITE.
         5. Turn on optimalisations, both for supplied packages (RTL,
            API, FV, FCL) and for your own code, this will also decrease
            the code size.
   30. Unit system, syslinux, sysos2 or syswin32 not found errors
       System (syslinux, sysos2 or syswin32, depending on platform) is
       Pascal's base unit which is implicitely used in all programs. This
       unit defines several standard procedures and structures, and must
       be found to be able to compile any pascal program by FPC.
       The location of the system.ppu and syslinux.o files are determined
       by the -Fu switch which can be specified commandline, but is
       usually in the ppc386.cfg configuration file.
       If the compiler can't find this unit there are three possible
       causes:
         1. The ppc386.cfg isn't in the same path as the compiler
            executable (go32v2, win32 and OS/2) or can't be found as
            "/etc/ppc386.cfg" or ".ppc386.cfg" in your homedirectory
            (Linux).
         2. The ppc386.cfg doesn't contain the -Fu line, or a wrong one.
            See the [48]make cycle faq, especially the chapters about the
            ppc386.cfg and the directory structure.
         3. The files ARE found but the wrong version or platform.
            Correct ppc386.cfg to point to the right versions or
            reinstall the right versions (this can happen if you try to
            use a [49]snapshot compiler while the -Fu statemnt in the
            used ppc386.cfg still points to the RTL that came with the
            official release compiler).
       A handy trick can be executing "ppc386 programname -vt", this
       shows where the compiler is currently looking for the system
       unit's files. You might want to pipe this through more (Dos, OS/2,
       Windows) or less (Linux), since it can generate more than one
       screen information:
Dos, OS/2, Windows:
ppc386 programname -vt |more

Linux:
ppc386 programname -vt |less

   31. Known bugs
       Go to the [50]bugs page
   32. How can I find where an error occurred using the addresses a
       crashed program prints?
         1. Starting with version 1.00, the easiest possibility is to
            recompile your program with -gl debugging option. This way
            unit LineInfo is automatically linked in, and the printout
            after a program crash then contains source line numbers in
            addition to addresses. To see RTL functions in the backtrace
            with their real name, you have to recompile the RTL with -gl
            too.
         2. For older versions, or more comprehensive checking, compile
            the program with debugging information (use the -g command
            line option)
         3. Load the program in the debugger (gdb(w) for 0.99.12b and
            earlier, gdbpas(w) for 0.99.14 and later) using
gdb(pas)(w) --directory=&LT;src dirs&GT; myprog.exe
            Notes:
               o Under Linux/Unix, don't add the ".exe" after myprog
               o "src dirs" is a list of directories containing the
                 source code files of myprog and the units it uses
                 seperated by semi-colons (";"). The current directory is
                 automatically included.
         4. Once inside the debugger, you can (optionally) set the
            command line options that will be passed to your program
            using the command "set args &LT;option1 option2 ...&GT;"
         5. To start the program, type "run" and press enter
         6. After the program has crashed, the address of the instruction
            where the crash occurred will be shown. The debugger will try
            to display the source code line corresponding with this
            address. Note that this can be inside a procedure of the RTL,
            so the source may not always be available and most likely the
            RTL wasn't compiled with debugging information.
         7. If you then type "bt" (BackTrace), the addreses in the call
            stack will be shown (the addresses of the procedures which
            were called before the program got to the current address).
            You can see which source code lines these present using the
            command
info line *&LT;address&GT;
            For example:
info line *0x05bd8

References

   1. http://www.freepascal.org/faq.htm#WhatIsFP
   2. http://www.freepascal.org/faq.htm#versions
   3. http://www.freepascal.org/faq.htm#FPandGNUPascal
   4. http://www.freepascal.org/faq.htm#WhereToGetFP
   5. http://www.freepascal.org/faq.htm#PortabilityTips
   6. http://www.freepascal.org/faq.htm#OOP
   7. http://www.freepascal.org/faq.htm#HOMEWORK
   8. http://www.freepascal.org/faq.htm#HowcanIbuildaunit
   9. http://www.freepascal.org/faq.htm#TurboVision
  10. http://www.freepascal.org/faq.htm#CompileSystemUnit
  11. http://www.freepascal.org/faq.htm#Internalerror9999
  12. http://www.freepascal.org/faq.htm#Howdoesfunctionoverloadingwork
  13. http://www.freepascal.org/faq.htm#HowToCallCFuncuntions
  14. http://www.freepascal.org/faq.htm#HowToUseGraph
  15. http://www.freepascal.org/faq.htm#WrongColors
  16. http://www.freepascal.org/faq.htm#IntegratedAssemblerSyntax
  17. http://www.freepascal.org/faq.htm#HowToAccessDosMemory
  18. http://www.freepascal.org/faq.htm#FPwithoutfpu
  19. http://www.freepascal.org/faq.htm#AccessingMoreThan4MB
  20. http://www.freepascal.org/faq.htm#accessioports
  21. http://www.freepascal.org/faq.htm#ImusingWin95
  22. http://www.freepascal.org/faq.htm#ImusingOS2
  23. http://www.freepascal.org/faq.htm#dpmi
  24. http://www.freepascal.org/faq.htm#instal10NT
  25. http://www.freepascal.org/faq.htm#instal106os2
  26. http://www.freepascal.org/faq.htm#snapshot
  27. http://www.freepascal.org/faq.htm#ideinst
  28. http://www.freepascal.org/faq.htm#ideconfig
  29. http://www.freepascal.org/faq.htm#binariesbig
  30. http://www.freepascal.org/faq.htm#systemnotfound
  31. http://www.freepascal.org/faq.htm#KnownBugs
  32. http://www.freepascal.org/faq.htm#ErrorPos
  33. http://www.freepascal.org/download.html
  34. http://www.freepascal.org/develop.html#snapshot
  35. http://www.freepascal.org/bugs.html
  36. http://www.delorie.com/djgpp/v2faq/faq102.html#Syntax
  37. http://www.rt66.com/%7Ebrennan/djgpp/djgpp%A0asm.html
  38. http://rcs.urz.tu-dresden.de/schoenfu/zip/asmtrans.zip
  39. http://www.brain.uni-freiburg.de/%7Eklaus/cwsdpmi.exe
  40. ftp://ftp.freepascal.org/pub/fpc/dist/dos-1.00/separate/install.exe
  41. ftp://ftp.freepascal.org/pub/fpc/dist/win32-1.00/separate/install.exe
  42. http://www.freepascal.org/develop.html#snapshot
  43. http://www.freepascal.org/download.html
  44. http://www.freepascal.org/maillist.html
  45. http://www.freepascal.org/makecyc.html
  46. http://wildsau.idv.uni-linz.ac.at/mfx/upx.html
  47. http://hobbes.nmsu.edu/
  48. http://www.freepascal.org/makecyc.html
  49. http://www.freepascal.org/faq.htm#snapshot
  50. http://www.freepascal.org/bugs.html
  51. http://hobbes.nmsu.edu/pub/os2/apps/internet/time/time868f.zip
